{
  "id": "node-fundamentals-lesson-18",
  "moduleSlug": "node-fundamentals",
  "title": "Advanced DevOps and CI/CD Practices",
  "order": 18,
  "objectives": [
    "Implement comprehensive CI/CD pipelines with GitHub Actions",
    "Utilize container orchestration with Docker and Kubernetes",
    "Implement blue-green deployments and rollback strategies",
    "Configure monitoring, logging, and alerting systems"
  ],
  "intro": "Advanced DevOps and CI/CD practices are essential for modern software development teams that need to deliver high-quality applications rapidly and reliably. This comprehensive lesson explores sophisticated deployment strategies, infrastructure automation, and monitoring practices that enable continuous delivery at scale.\n\nYou'll learn to implement robust CI/CD pipelines using GitHub Actions that automate testing, building, and deployment processes while maintaining security and reliability. We'll explore containerization strategies with Docker that ensure consistent environments across development, testing, and production, and orchestration with Kubernetes for scalable application deployment.\n\nDeployment strategies covered include blue-green deployments, canary releases, and automated rollback mechanisms that minimize downtime and reduce deployment risks. You'll also learn to implement comprehensive monitoring, logging, and alerting systems that provide visibility into application health and performance in production environments.\n\nBy mastering advanced DevOps and CI/CD practices, you'll be able to streamline development workflows, reduce deployment risks, and maintain high-quality applications that can scale to meet growing user demands. This knowledge is crucial for DevOps engineers and senior developers responsible for application deployment and infrastructure management.",
  "code": {
    "example": "// GitHub Actions CI/CD Pipeline\n/*\nname: Node.js CI/CD\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    strategy:\n      matrix:\n        node-version: [16.x, 18.x]\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node-version }}\n        cache: 'npm'\n    \n    - name: Install dependencies\n      run: npm ci\n    \n    - name: Run linting\n      run: npm run lint\n    \n    - name: Run unit tests\n      run: npm run test:unit\n    \n    - name: Run integration tests\n      run: npm run test:integration\n    \n    - name: Run security audit\n      run: npm audit --audit-level=high\n    \n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n\n  build-and-deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    \n    # Only run on main branch\n    if: github.ref == 'refs/heads/main'\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Set up Docker Buildx\n      uses: docker/setup-buildx-action@v2\n    \n    - name: Login to DockerHub\n      uses: docker/login-action@v2\n      with:\n        username: ${{ secrets.DOCKERHUB_USERNAME }}\n        password: ${{ secrets.DOCKERHUB_TOKEN }}\n    \n    - name: Extract metadata (tags, labels) for Docker\n      id: meta\n      uses: docker/metadata-action@v4\n      with:\n        images: myorg/myapp\n        tags: |\n          type=ref,event=branch\n          type=ref,event=pr\n          type=semver,pattern={{version}}\n          type=semver,pattern={{major}}.{{minor}}\n    \n    - name: Build and push Docker image\n      uses: docker/build-push-action@v4\n      with:\n        context: .\n        push: true\n        tags: ${{ steps.meta.outputs.tags }}\n        labels: ${{ steps.meta.outputs.labels }}\n    \n    - name: Deploy to Kubernetes\n      uses: actions-hub/kubectl@master\n      env:\n        KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}\n      with:\n        args: set image deployment/myapp myapp=${{ steps.meta.outputs.tags }}\n\n  performance-test:\n    needs: build-and-deploy\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Run performance tests\n      run: npm run test:performance\n    \n    - name: Check performance thresholds\n      run: node scripts/check-performance-thresholds.js\n*/\n\n// Dockerfile for Production\n/*\nFROM node:18-alpine AS builder\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\n\n# Install dependencies\nRUN npm ci --only=production && npm cache clean --force\n\n# Copy application code\nCOPY . .\n\n# Run tests in builder stage\nRUN npm test\n\nFROM node:18-alpine AS runtime\n\nWORKDIR /app\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs\nRUN adduser -S nodejs -u 1001\n\n# Copy dependencies from builder stage\nCOPY --from=builder /app/node_modules ./node_modules\nCOPY --from=builder /app/package*.json ./\n\n# Copy application code\nCOPY --chown=nodejs:nodejs . .\n\n# Change to non-root user\nUSER nodejs\n\n# Expose port\nEXPOSE 3000\n\n# Health check\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD node healthcheck.js\n\n# Start application\nCMD [\"node\", \"server.js\"]\n*/\n\n// Kubernetes Deployment Configuration\n/*\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: myapp\n  labels:\n    app: myapp\nspec:\n  replicas: 3\n  strategy:\n    type: RollingUpdate\n    rollingUpdate:\n      maxSurge: 1\n      maxUnavailable: 0\n  selector:\n    matchLabels:\n      app: myapp\n  template:\n    metadata:\n      labels:\n        app: myapp\n    spec:\n      containers:\n      - name: myapp\n        image: myorg/myapp:latest\n        ports:\n        - containerPort: 3000\n        env:\n        - name: NODE_ENV\n          value: \"production\"\n        - name: DATABASE_URL\n          valueFrom:\n            secretKeyRef:\n              name: myapp-secrets\n              key: database-url\n        resources:\n          requests:\n            memory: \"128Mi\"\n            cpu: \"100m\"\n          limits:\n            memory: \"256Mi\"\n            cpu: \"200m\"\n        livenessProbe:\n          httpGet:\n            path: /health\n            port: 3000\n          initialDelaySeconds: 30\n          periodSeconds: 10\n        readinessProbe:\n          httpGet:\n            path: /ready\n            port: 3000\n          initialDelaySeconds: 5\n          periodSeconds: 5\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: myapp\nspec:\n  selector:\n    app: myapp\n  ports:\n    - protocol: TCP\n      port: 80\n      targetPort: 3000\n  type: LoadBalancer\n*/\n\n// Blue-Green Deployment Script\n/*\n#!/bin/bash\n\n# Blue-Green Deployment Script\n\n# Get current color\nCURRENT_COLOR=$(kubectl get service myapp -o jsonpath='{.spec.selector.color}')\n\nif [ \"$CURRENT_COLOR\" = \"blue\" ]; then\n  NEW_COLOR=\"green\"\nelse\n  NEW_COLOR=\"blue\"\nfi\n\n# Deploy new version to inactive environment\necho \"Deploying new version to $NEW_COLOR environment...\"\nkubectl set image deployment/myapp-$NEW_COLOR myapp=myorg/myapp:$NEW_VERSION\n\n# Wait for deployment to be ready\nkubectl rollout status deployment/myapp-$NEW_COLOR\n\n# Test new environment\necho \"Testing $NEW_COLOR environment...\"\nNEW_ENV_URL=$(kubectl get service myapp-$NEW_COLOR -o jsonpath='{.status.loadBalancer.ingress[0].ip}')\ncurl -f http://$NEW_ENV_URL/health\n\nif [ $? -eq 0 ]; then\n  echo \"Tests passed, switching traffic to $NEW_COLOR...\"\n  # Switch traffic to new environment\n  kubectl patch service myapp -p '{\"spec\":{\"selector\":{\"color\":\"'$NEW_COLOR'\"}}}'\n  \n  # Scale down old environment\n  kubectl scale deployment/myapp-$CURRENT_COLOR --replicas=0\n  \n  echo \"Deployment successful!\"\nelse\n  echo \"Tests failed, rolling back...\"\n  # Keep old environment and scale down new one\n  kubectl scale deployment/myapp-$NEW_COLOR --replicas=0\n  \n  echo \"Rollback completed.\"\n  exit 1\nfi\n*/\n\n// Monitoring and Alerting Configuration\n/*\n// Prometheus metrics endpoint\nconst promClient = require('prom-client');\n\n// Create custom metrics\nconst httpRequestDuration = new promClient.Histogram({\n  name: 'http_request_duration_seconds',\n  help: 'Duration of HTTP requests in seconds',\n  labelNames: ['method', 'route', 'status_code']\n});\n\nconst httpRequestTotal = new promClient.Counter({\n  name: 'http_requests_total',\n  help: 'Total number of HTTP requests',\n  labelNames: ['method', 'route', 'status_code']\n});\n\nconst activeUsers = new promClient.Gauge({\n  name: 'active_users',\n  help: 'Number of active users'\n});\n\n// Middleware to collect metrics\napp.use((req, res, next) => {\n  const start = Date.now();\n  \n  res.on('finish', () => {\n    const duration = (Date.now() - start) / 1000;\n    const route = req.route ? req.route.path : req.path;\n    \n    httpRequestDuration\n      .labels(req.method, route, res.statusCode)\n      .observe(duration);\n    \n    httpRequestTotal\n      .labels(req.method, route, res.statusCode)\n      .inc();\n  });\n  \n  next();\n});\n\n// Metrics endpoint\napp.get('/metrics', async (req, res) => {\n  res.set('Content-Type', promClient.register.contentType);\n  res.end(await promClient.register.metrics());\n});\n\n// Error tracking and alerting\nconst Sentry = require('@sentry/node');\n\nSentry.init({\n  dsn: process.env.SENTRY_DSN,\n  tracesSampleRate: 1.0,\n  environment: process.env.NODE_ENV\n});\n\n// Error handling middleware\napp.use((error, req, res, next) => {\n  // Capture error in Sentry\n  Sentry.captureException(error);\n  \n  // Log error\n  console.error('Unhandled error:', error);\n  \n  // Send error response\n  res.status(500).json({\n    error: 'Internal server error',\n    requestId: req.id\n  });\n});\n*/",
    "explanation": "This example demonstrates comprehensive DevOps and CI/CD practices including multi-stage GitHub Actions pipelines with testing, security scanning, and deployment, production-ready Dockerfiles with security best practices, Kubernetes deployment configurations with health checks and resource limits, blue-green deployment scripts for zero-downtime releases, and monitoring with Prometheus metrics and error tracking with Sentry. These practices enable robust, automated deployment workflows with comprehensive observability.",
    "language": "yaml"
  },
  "pitfalls": [
    {
      "mistake": "Not implementing proper health checks and readiness probes in containerized applications",
      "solution": "Configure comprehensive health checks and readiness probes in Docker and Kubernetes configurations to ensure reliable deployments and automatic failover",
      "severity": "high"
    },
    {
      "mistake": "Lacking automated rollback mechanisms for failed deployments",
      "solution": "Implement blue-green deployments or canary releases with automated health checking and rollback capabilities to minimize downtime",
      "severity": "high"
    },
    {
      "mistake": "Insufficient monitoring and alerting in production environments",
      "solution": "Implement comprehensive metrics collection, error tracking, and alerting systems to provide visibility into application health and performance",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Implement a Complete CI/CD Pipeline with Kubernetes Deployment",
      "description": "Create a GitHub Actions CI/CD pipeline with multi-stage testing, build Docker images with security best practices, configure Kubernetes deployments with health checks and resource limits, implement blue-green deployment scripts, and set up monitoring with Prometheus metrics and error tracking",
      "checkpoints": [
        "Configure GitHub Actions pipeline with testing, security scanning, and deployment stages",
        "Create production-ready Dockerfile with multi-stage build and security configurations",
        "Set up Kubernetes deployment with health checks, resource limits, and service configuration",
        "Implement blue-green deployment script with automated health checking and rollback",
        "Configure monitoring with Prometheus metrics and error tracking with alerting"
      ]
    }
  ],
  "next": [],
  "estimatedMinutes": 60,
  "difficulty": "Advanced",
  "tags": [
    "DevOps",
    "CI/CD",
    "Docker",
    "Kubernetes",
    "Deployment",
    "Monitoring",
    "Node.js"
  ],
  "lastUpdated": "2025-10-03T00:00:00.000Z",
  "version": "1.0.0"
}