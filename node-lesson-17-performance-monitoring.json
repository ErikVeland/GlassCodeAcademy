{
  "id": "node-fundamentals-lesson-17",
  "moduleSlug": "node-fundamentals",
  "title": "Advanced Performance Monitoring and Optimization",
  "order": 17,
  "objectives": [
    "Implement comprehensive performance monitoring with APM tools",
    "Utilize Node.js profiling and debugging techniques",
    "Optimize memory usage and prevent memory leaks",
    "Implement caching strategies and database query optimization"
  ],
  "intro": "Performance monitoring and optimization are critical for maintaining high-quality user experiences and efficient resource utilization in Node.js applications. This comprehensive lesson explores advanced techniques for measuring, analyzing, and improving application performance across multiple dimensions including response times, memory usage, and database efficiency.\n\nYou'll learn to implement Application Performance Monitoring (APM) solutions that provide real-time insights into your application's behavior in production environments. We'll explore profiling techniques using built-in Node.js tools and third-party solutions to identify performance bottlenecks and memory leaks that can degrade application performance over time.\n\nDatabase optimization is a crucial aspect of performance improvement, so we'll cover query optimization strategies, connection pooling, and caching mechanisms that can dramatically improve response times. You'll also learn to implement distributed tracing for microservices architectures to identify performance issues across service boundaries.\n\nBy mastering advanced performance monitoring and optimization techniques, you'll be able to maintain responsive applications that scale effectively under load while minimizing infrastructure costs. This knowledge is essential for senior Node.js developers responsible for production systems with demanding performance requirements.",
  "code": {
    "example": "// Performance Monitoring with APM (Application Performance Monitoring)\nconst apm = require('elastic-apm-node').start({\n  serviceName: 'my-node-app',\n  serverUrl: 'http://localhost:8200',\n  secretToken: 'your-secret-token',\n  logLevel: 'info'\n});\n\nconst express = require('express');\nconst app = express();\n\n// Custom transaction tracing\napp.get('/api/users/:id', async (req, res) => {\n  const transaction = apm.startTransaction('GET /api/users/:id', 'request');\n  \n  try {\n    // Start a span for database operation\n    const dbSpan = apm.startSpan('Database Query', 'db.mysql.query');\n    \n    const user = await getUserFromDatabase(req.params.id);\n    \n    dbSpan.end();\n    \n    // Start a span for external API call\n    const apiSpan = apm.startSpan('External API Call', 'external.http');\n    \n    const userDetails = await fetchUserDetailsFromExternalAPI(user.id);\n    \n    apiSpan.end();\n    \n    res.json({\n      ...user,\n      ...userDetails\n    });\n    \n    transaction.result = 'success';\n  } catch (error) {\n    apm.captureError(error);\n    transaction.result = 'error';\n    res.status(500).json({ error: 'Internal server error' });\n  } finally {\n    transaction.end();\n  }\n});\n\n// Memory leak detection and prevention\nconst leaks = new Set();\n\nclass UserManager {\n  constructor() {\n    this.users = new Map();\n    // Prevent memory leaks by using WeakMap for temporary data\n    this.temporaryData = new WeakMap();\n  }\n  \n  addUser(user) {\n    this.users.set(user.id, user);\n    \n    // Schedule cleanup of temporary data\n    setTimeout(() => {\n      if (this.users.has(user.id)) {\n        this.cleanupUserData(user.id);\n      }\n    }, 30 * 60 * 1000); // 30 minutes\n  }\n  \n  cleanupUserData(userId) {\n    this.temporaryData.delete(userId);\n    // Additional cleanup logic\n  }\n  \n  // Proper cleanup method\n  destroy() {\n    this.users.clear();\n    this.temporaryData = null;\n  }\n}\n\n// Memory usage monitoring\nconst os = require('os');\n\nfunction logMemoryUsage() {\n  const usage = process.memoryUsage();\n  const freeMemory = os.freemem();\n  const totalMemory = os.totalmem();\n  \n  console.log({\n    rss: `${Math.round(usage.rss / 1024 / 1024)} MB`,\n    heapTotal: `${Math.round(usage.heapTotal / 1024 / 1024)} MB`,\n    heapUsed: `${Math.round(usage.heapUsed / 1024 / 1024)} MB`,\n    external: `${Math.round(usage.external / 1024 / 1024)} MB`,\n    freeMemory: `${Math.round(freeMemory / 1024 / 1024)} MB`,\n    totalMemory: `${Math.round(totalMemory / 1024 / 1024)} MB`,\n    memoryUsagePercentage: `${Math.round((usage.heapUsed / totalMemory) * 100)}%`\n  });\n}\n\n// Log memory usage periodically\nsetInterval(logMemoryUsage, 30000);\n\n// CPU profiling\nconst v8Profiler = require('v8-profiler-next');\n\nfunction startProfiling(duration = 30000) {\n  v8Profiler.startProfiling('CPU Profile', true);\n  \n  setTimeout(() => {\n    const profile = v8Profiler.stopProfiling('CPU Profile');\n    profile.export((error, result) => {\n      if (error) {\n        console.error('Profiling error:', error);\n        return;\n      }\n      \n      // Save profile to file for analysis\n      require('fs').writeFileSync('./cpu-profile.cpuprofile', result);\n      profile.delete();\n      console.log('CPU profile saved to cpu-profile.cpuprofile');\n    });\n  }, duration);\n}\n\n// Start profiling on high CPU usage\nconst si = require('systeminformation');\n\nasync function monitorCPU() {\n  const cpuData = await si.currentLoad();\n  if (cpuData.currentLoad > 80) {\n    console.log('High CPU usage detected, starting profiler...');\n    startProfiling(60000); // Profile for 60 seconds\n  }\n}\n\nsetInterval(monitorCPU, 5000);\n\n// Database query optimization\nconst { Pool } = require('pg');\n\nconst pool = new Pool({\n  connectionString: process.env.DATABASE_URL,\n  // Connection pooling for better performance\n  max: 20,\n  min: 5,\n  idleTimeoutMillis: 30000,\n  connectionTimeoutMillis: 2000,\n});\n\n// Optimized query with proper indexing and caching\nasync function getOptimizedUserPosts(userId, page = 1, limit = 10) {\n  const offset = (page - 1) * limit;\n  \n  // Use prepared statements for better performance\n  const query = {\n    name: 'fetch-user-posts',\n    text: `\n      SELECT p.id, p.title, p.content, p.created_at,\n             u.name as author_name,\n             COUNT(c.id) as comment_count\n      FROM posts p\n      JOIN users u ON p.user_id = u.id\n      LEFT JOIN comments c ON p.id = c.post_id\n      WHERE p.user_id = $1\n      GROUP BY p.id, u.name\n      ORDER BY p.created_at DESC\n      LIMIT $2 OFFSET $3\n    `,\n    values: [userId, limit, offset]\n  };\n  \n  const result = await pool.query(query);\n  return result.rows;\n}\n\n// Response time monitoring middleware\napp.use((req, res, next) => {\n  const start = Date.now();\n  \n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    \n    // Log slow requests\n    if (duration > 1000) {\n      console.warn(`Slow request: ${req.method} ${req.url} took ${duration}ms`);\n      apm.captureError(new Error(`Slow request: ${duration}ms`));\n    }\n    \n    // Send metrics to monitoring system\n    apm.setMetric('response_time', duration);\n  });\n  \n  next();\n});",
    "explanation": "This example demonstrates comprehensive performance monitoring and optimization techniques including APM integration with custom transaction tracing, memory leak prevention with proper cleanup patterns, CPU profiling for bottleneck identification, database query optimization with connection pooling and prepared statements, and response time monitoring middleware. These techniques provide end-to-end performance visibility and optimization capabilities.",
    "language": "javascript"
  },
  "pitfalls": [
    {
      "mistake": "Not monitoring performance in production environments",
      "solution": "Implement APM solutions and custom metrics collection in production to identify real-world performance issues",
      "severity": "high"
    },
    {
      "mistake": "Ignoring memory leaks that accumulate over time",
      "solution": "Use proper cleanup patterns, WeakMaps for temporary data, and regular memory monitoring to prevent leaks",
      "severity": "high"
    },
    {
      "mistake": "Using inefficient database queries without proper indexing",
      "solution": "Implement query optimization with prepared statements, connection pooling, and proper database indexing strategies",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Implement Comprehensive Performance Monitoring for a Blogging Platform",
      "description": "Set up APM monitoring with custom transaction tracing, implement memory leak detection and prevention, optimize database queries with connection pooling, add response time monitoring middleware, and create CPU profiling triggers for performance analysis",
      "checkpoints": [
        "Configure APM with custom transaction and span tracing",
        "Implement memory leak prevention patterns and monitoring",
        "Optimize database queries with connection pooling and prepared statements",
        "Add response time monitoring middleware with slow request detection",
        "Set up CPU profiling triggers for performance bottleneck analysis"
      ]
    }
  ],
  "next": [],
  "estimatedMinutes": 55,
  "difficulty": "Advanced",
  "tags": [
    "Performance",
    "Monitoring",
    "APM",
    "Profiling",
    "Optimization",
    "Node.js"
  ],
  "lastUpdated": "2025-10-03T00:00:00.000Z",
  "version": "1.0.0"
}