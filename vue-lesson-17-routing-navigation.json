{
  "id": "vue-lesson-17-routing-navigation",
  "moduleSlug": "vue-advanced",
  "title": "Advanced Routing and Navigation Patterns",
  "order": 17,
  "objectives": [
    "Master advanced Vue Router patterns for complex applications",
    "Implement sophisticated route guards and navigation controls",
    "Create dynamic route configurations with nested routes",
    "Optimize routing performance and handle route transitions"
  ],
  "intro": "Advanced routing and navigation patterns in Vue Router enable developers to create sophisticated single-page applications with complex navigation flows and precise route control. This comprehensive lesson explores advanced techniques for managing route transitions, implementing sophisticated authentication flows, and optimizing routing performance.\n\nYou'll learn to implement complex route guard patterns that handle authentication, authorization, and data loading requirements, create dynamic route configurations with nested routes and route metadata, and optimize routing performance through lazy loading and route splitting. We'll explore advanced patterns for handling route transitions, managing scroll behavior, and creating accessible navigation experiences.\n\nThe lesson covers practical implementation strategies for organizing large route hierarchies, implementing proper error handling for routing failures, and creating routes that integrate seamlessly with state management systems. You'll discover how to balance client-side routing with server-side requirements, implement proper route testing strategies, and optimize routes for performance and SEO.\n\nBy mastering advanced routing and navigation patterns, you'll be able to create Vue applications with sophisticated navigation flows that provide excellent user experience and maintain clean, organized code.",
  "code": {
    "example": "// Advanced Vue Router Patterns\n\n// Router configuration with advanced features\n// router/index.js\nimport { createRouter, createWebHistory } from 'vue-router'\nimport { useAuthStore } from '@/stores/auth'\nimport { useLayoutStore } from '@/stores/layout'\n\n// Dynamic route imports for code splitting\nconst HomeView = () => import('@/views/HomeView.vue')\nconst DashboardView = () => import('@/views/DashboardView.vue')\nconst ProfileView = () => import('@/views/ProfileView.vue')\nconst SettingsView = () => import('@/views/SettingsView.vue')\nconst AdminView = () => import('@/views/AdminView.vue')\nconst NotFoundView = () => import('@/views/NotFoundView.vue')\nconst LoginView = () => import('@/views/LoginView.vue')\n\n// Route metadata for advanced control\nconst routes = [\n  {\n    path: '/',\n    name: 'Home',\n    component: HomeView,\n    meta: {\n      title: 'Home',\n      layout: 'default',\n      requiresAuth: false,\n      transition: 'fade'\n    }\n  },\n  {\n    path: '/dashboard',\n    name: 'Dashboard',\n    component: DashboardView,\n    meta: {\n      title: 'Dashboard',\n      layout: 'dashboard',\n      requiresAuth: true,\n      roles: ['user', 'admin'],\n      transition: 'slide-left',\n      breadcrumb: 'Dashboard'\n    },\n    children: [\n      {\n        path: 'profile',\n        name: 'Profile',\n        component: ProfileView,\n        meta: {\n          title: 'Profile',\n          layout: 'dashboard',\n          requiresAuth: true,\n          roles: ['user', 'admin'],\n          transition: 'slide-up',\n          breadcrumb: 'Profile'\n        }\n      },\n      {\n        path: 'settings',\n        name: 'Settings',\n        component: SettingsView,\n        meta: {\n          title: 'Settings',\n          layout: 'dashboard',\n          requiresAuth: true,\n          roles: ['user', 'admin'],\n          transition: 'slide-up',\n          breadcrumb: 'Settings'\n        }\n      }\n    ]\n  },\n  {\n    path: '/admin',\n    name: 'Admin',\n    component: AdminView,\n    meta: {\n      title: 'Admin Panel',\n      layout: 'admin',\n      requiresAuth: true,\n      roles: ['admin'],\n      transition: 'slide-left',\n      breadcrumb: 'Admin'\n    },\n    beforeEnter: (to, from, next) => {\n      // Route-specific guard\n      const authStore = useAuthStore()\n      if (authStore.user?.role === 'admin') {\n        next()\n      } else {\n        next({ name: 'Home' })\n      }\n    }\n  },\n  {\n    path: '/login',\n    name: 'Login',\n    component: LoginView,\n    meta: {\n      title: 'Login',\n      layout: 'auth',\n      requiresAuth: false,\n      guestOnly: true,\n      transition: 'fade'\n    },\n    beforeEnter: (to, from, next) => {\n      // Redirect if already logged in\n      const authStore = useAuthStore()\n      if (authStore.isAuthenticated) {\n        const redirect = from.query.redirect || '/dashboard'\n        next(redirect)\n      } else {\n        next()\n      }\n    }\n  },\n  {\n    path: '/:pathMatch(.*)*',\n    name: 'NotFound',\n    component: NotFoundView,\n    meta: {\n      title: 'Page Not Found',\n      layout: 'default',\n      requiresAuth: false,\n      transition: 'fade'\n    }\n  }\n]\n\nconst router = createRouter({\n  history: createWebHistory(import.meta.env.BASE_URL),\n  routes,\n  scrollBehavior(to, from, savedPosition) {\n    // Handle scroll behavior\n    if (savedPosition) {\n      return savedPosition\n    } else if (to.hash) {\n      return {\n        el: to.hash,\n        behavior: 'smooth'\n      }\n    } else {\n      return { top: 0 }\n    }\n  }\n})\n\n// Global before guard\nrouter.beforeEach(async (to, from, next) => {\n  // Update loading state\n  const layoutStore = useLayoutStore()\n  layoutStore.setLoading(true)\n  \n  try {\n    // Check authentication requirements\n    const authStore = useAuthStore()\n    \n    // Redirect logged-in users away from guest-only pages\n    if (to.meta.guestOnly && authStore.isAuthenticated) {\n      next({ name: 'Dashboard' })\n      return\n    }\n    \n    // Check authentication for protected routes\n    if (to.meta.requiresAuth && !authStore.isAuthenticated) {\n      next({\n        name: 'Login',\n        query: { redirect: to.fullPath }\n      })\n      return\n    }\n    \n    // Check role-based access\n    if (to.meta.roles && authStore.user) {\n      const userRole = authStore.user.role\n      if (!to.meta.roles.includes(userRole)) {\n        next({ name: 'Home' })\n        return\n      }\n    }\n    \n    // Load required data\n    if (to.meta.loadData) {\n      await to.meta.loadData(to, from)\n    }\n    \n    next()\n  } catch (error) {\n    console.error('Navigation guard error:', error)\n    next({ name: 'Home' })\n  }\n})\n\n// Global after guard\nrouter.afterEach((to, from) => {\n  // Update page title\n  document.title = to.meta.title ? `${to.meta.title} - MyApp` : 'MyApp'\n  \n  // Update loading state\n  const layoutStore = useLayoutStore()\n  layoutStore.setLoading(false)\n  \n  // Track page view\n  if (import.meta.env.PROD) {\n    // Analytics tracking\n    // analytics.trackPageView(to.path, to.meta.title)\n  }\n  \n  // Update layout\n  const layoutStore = useLayoutStore()\n  layoutStore.setLayout(to.meta.layout || 'default')\n})\n\n// Global error handler\nrouter.onError((error) => {\n  console.error('Router error:', error)\n  \n  // Handle chunk loading errors (useful for hot reloading)\n  if (error.name === 'ChunkLoadError') {\n    window.location.reload()\n  }\n})\n\nexport default router\n\n// Composable for route management\n// composables/useRouteManager.js\nimport { useRouter, useRoute } from 'vue-router'\nimport { computed, ref } from 'vue'\n\nexport function useRouteManager() {\n  const router = useRouter()\n  const route = useRoute()\n  \n  // Breadcrumb navigation\n  const breadcrumbs = computed(() => {\n    const breadcrumbs = []\n    let matched = route.matched\n    \n    for (let i = 0; i < matched.length; i++) {\n      const record = matched[i]\n      if (record.meta.breadcrumb) {\n        breadcrumbs.push({\n          title: record.meta.breadcrumb,\n          path: record.path,\n          active: i === matched.length - 1\n        })\n      }\n    }\n    \n    return breadcrumbs\n  })\n  \n  // Navigation history\n  const navigationHistory = ref([])\n  \n  const navigateTo = async (location, options = {}) {\n    try {\n      // Add to history\n      navigationHistory.value.push({\n        path: route.path,\n        timestamp: Date.now()\n      })\n      \n      // Navigate\n      await router.push(location)\n      \n      // Limit history size\n      if (navigationHistory.value.length > 50) {\n        navigationHistory.value.shift()\n      }\n    } catch (error) {\n      console.error('Navigation failed:', error)\n      throw error\n    }\n  }\n  \n  const goBack = () => {\n    if (navigationHistory.value.length > 0) {\n      const lastRoute = navigationHistory.value.pop()\n      router.push(lastRoute.path)\n    } else {\n      router.back()\n    }\n  }\n  \n  const canGoBack = computed(() => navigationHistory.value.length > 0)\n  \n  return {\n    breadcrumbs: readonly(breadcrumbs),\n    navigationHistory: readonly(navigationHistory),\n    navigateTo,\n    goBack,\n    canGoBack\n  }\n}\n\n// Usage examples:\n// In a component\n// import { useRouteManager } from '@/composables'\n// \n// const { breadcrumbs, navigateTo, goBack, canGoBack } = useRouteManager()\n// \n// const handleNavigation = async (path) => {\n//   try {\n//     await navigateTo(path)\n//   } catch (error) {\n//     console.error('Navigation failed:', error)\n//   }\n// }\n// \n// // In template\n// // <nav>\n// //   <ol class=\"breadcrumb\">\n// //     <li v-for=\"crumb in breadcrumbs\" :key=\"crumb.path\">\n// //       <router-link v-if=\"!crumb.active\" :to=\"crumb.path\">\n// //         {{ crumb.title }}\n// //       </router-link>\n// //       <span v-else>{{ crumb.title }}</span>\n// //     </li>\n// //   </ol>\n// // </nav>",
    "explanation": "This example demonstrates advanced Vue Router patterns including:\n\n1. Dynamic route imports for code splitting and lazy loading\n2. Comprehensive route metadata for advanced control\n3. Nested routes with proper hierarchy\n4. Global and route-specific navigation guards\n5. Scroll behavior management\n6. Route error handling\n7. Breadcrumb navigation composable\n8. Navigation history management\n\nThese patterns enable developers to create sophisticated routing solutions that provide excellent user experience while maintaining clean, organized code.",
    "language": "javascript"
  },
  "pitfalls": [
    {
      "mistake": "Creating overly complex route configurations that are hard to maintain",
      "solution": "Organize routes logically, use route metadata for control, and implement proper documentation",
      "severity": "medium"
    },
    {
      "mistake": "Not handling navigation failures gracefully",
      "solution": "Implement proper error handling in navigation guards and provide user feedback",
      "severity": "high"
    },
    {
      "mistake": "Ignoring SEO and accessibility considerations in routing",
      "solution": "Implement proper page titles, meta tags, and accessible navigation patterns",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Implement Advanced Routing Patterns",
      "description": "Create a comprehensive routing system with advanced features and proper error handling",
      "checkpoints": [
        "Implement dynamic route imports and code splitting",
        "Create nested routes with proper metadata",
        "Build sophisticated navigation guards",
        "Add breadcrumb navigation and history management",
        "Implement proper error handling and SEO optimization"
      ]
    }
  ],
  "next": ["vue-lesson-18-testing-strategies"],
  "estimatedMinutes": 55,
  "difficulty": "Advanced",
  "tags": [
    "Vue Router",
    "Routing",
    "Navigation",
    "Guards",
    "Performance",
    "Vue 3"
  ],
  "lastUpdated": "2025-10-03T10:00:00Z",
  "version": "1.0.0"
}