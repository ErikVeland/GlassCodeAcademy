{
  "id": "vue-lesson-18-testing-strategies",
  "moduleSlug": "vue-advanced",
  "title": "Advanced Testing Strategies",
  "order": 18,
  "objectives": [
    "Master advanced testing patterns for Vue components and composables",
    "Implement comprehensive test coverage with Vitest and Vue Test Utils",
    "Create effective mocking strategies for complex dependencies",
    "Optimize test performance and maintainability"
  ],
  "intro": "Advanced testing strategies in Vue applications go beyond basic component testing to encompass comprehensive coverage of complex application logic, state management, and integration scenarios. This comprehensive lesson explores sophisticated testing techniques that ensure application reliability and maintainability at scale.\n\nYou'll learn to implement advanced testing patterns for Vue components, composables, and stores, create effective mocking strategies for complex dependencies like APIs and third-party libraries, and optimize test performance and maintainability through proper organization and tooling. We'll explore advanced patterns for testing asynchronous operations, handling complex state transitions, and ensuring proper integration between application layers.\n\nThe lesson covers practical implementation strategies for organizing large test suites, implementing proper test data management, and creating tests that provide meaningful coverage while remaining maintainable. You'll discover how to balance test coverage with development velocity, implement proper continuous integration testing, and optimize tests for performance.\n\nBy mastering advanced testing strategies, you'll be able to create Vue applications with high confidence in their correctness and reliability, enabling faster development cycles and reduced bug rates.",
  "code": {
    "example": "// Advanced Testing Strategies for Vue Applications\n\n// Comprehensive component testing with complex interactions\n// tests/components/UserProfile.test.js\nimport { mount, flushPromises } from '@vue/test-utils'\nimport { createTestingPinia } from '@pinia/testing'\nimport { useUserStore } from '@/stores/user'\nimport UserProfile from '@/components/UserProfile.vue'\n\ndescribe('UserProfile', () => {\n  let wrapper\n  let userStore\n  \n  // Setup testing environment\n  beforeEach(() => {\n    wrapper = mount(UserProfile, {\n      global: {\n        plugins: [\n          createTestingPinia({\n            initialState: {\n              user: {\n                currentUser: {\n                  id: 1,\n                  name: 'John Doe',\n                  email: 'john@example.com',\n                  role: 'user'\n                }\n              }\n            },\n            stubActions: false // Allow actions to be called\n          })\n        ]\n      },\n      props: {\n        userId: 1\n      }\n    })\n    \n    userStore = useUserStore()\n  })\n  \n  afterEach(() => {\n    wrapper.unmount()\n    vi.restoreAllMocks()\n  })\n  \n  it('renders user profile correctly', () => {\n    expect(wrapper.find('[data-testid=\"user-name\"]').text()).toBe('John Doe')\n    expect(wrapper.find('[data-testid=\"user-email\"]').text()).toBe('john@example.com')\n  })\n  \n  it('handles user update correctly', async () => {\n    // Mock API call\n    const updateUserSpy = vi.spyOn(userStore, 'updateUser').mockResolvedValue({\n      id: 1,\n      name: 'Jane Doe',\n      email: 'jane@example.com',\n      role: 'user'\n    })\n    \n    // Simulate user input\n    await wrapper.find('[data-testid=\"name-input\"]').setValue('Jane Doe')\n    await wrapper.find('[data-testid=\"email-input\"]').setValue('jane@example.com')\n    \n    // Trigger form submission\n    await wrapper.find('[data-testid=\"save-button\"]').trigger('click')\n    \n    // Wait for async operations\n    await flushPromises()\n    \n    // Assert API call was made\n    expect(updateUserSpy).toHaveBeenCalledWith(1, {\n      name: 'Jane Doe',\n      email: 'jane@example.com'\n    })\n    \n    // Assert UI updates\n    expect(wrapper.find('[data-testid=\"user-name\"]').text()).toBe('Jane Doe')\n  })\n  \n  it('handles API errors gracefully', async () => {\n    // Mock API error\n    vi.spyOn(userStore, 'updateUser').mockRejectedValue(new Error('Network error'))\n    \n    // Trigger form submission\n    await wrapper.find('[data-testid=\"save-button\"]').trigger('click')\n    await flushPromises()\n    \n    // Assert error message is displayed\n    expect(wrapper.find('[data-testid=\"error-message\"]').exists()).toBe(true)\n    expect(wrapper.find('[data-testid=\"error-message\"]').text()).toContain('Network error')\n  })\n  \n  it('disables save button when form is invalid', async () => {\n    // Clear required field\n    await wrapper.find('[data-testid=\"name-input\"]').setValue('')\n    \n    // Assert button is disabled\n    expect(wrapper.find('[data-testid=\"save-button\"]').attributes('disabled')).toBeDefined()\n  })\n})\n\n// Advanced composable testing\n// tests/composables/useAsyncOperation.test.js\nimport { ref } from 'vue'\nimport { useAsyncOperation } from '@/composables/useAsyncOperation'\n\ndescribe('useAsyncOperation', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n  })\n  \n  afterEach(() => {\n    vi.useRealTimers()\n    vi.restoreAllMocks()\n  })\n  \n  it('executes operation successfully', async () => {\n    const mockOperation = vi.fn().mockResolvedValue('success')\n    const { data, loading, error, execute } = useAsyncOperation(mockOperation)\n    \n    const promise = execute('param1', 'param2')\n    \n    // Assert loading state\n    expect(loading.value).toBe(true)\n    expect(error.value).toBeNull()\n    \n    await promise\n    \n    // Assert final state\n    expect(loading.value).toBe(false)\n    expect(data.value).toBe('success')\n    expect(error.value).toBeNull()\n    expect(mockOperation).toHaveBeenCalledWith('param1', 'param2', expect.any(Object))\n  })\n  \n  it('handles operation errors', async () => {\n    const mockError = new Error('Operation failed')\n    const mockOperation = vi.fn().mockRejectedValue(mockError)\n    const { data, loading, error, execute } = useAsyncOperation(mockOperation)\n    \n    try {\n      await execute()\n    } catch (e) {\n      // Expected error\n    }\n    \n    // Assert final state\n    expect(loading.value).toBe(false)\n    expect(data.value).toBeNull()\n    expect(error.value).toBe(mockError)\n  })\n  \n  it('supports operation abortion', async () => {\n    let abortSignal\n    const mockOperation = vi.fn((param, options) => {\n      abortSignal = options.signal\n      return new Promise((resolve) => {\n        setTimeout(() => resolve('success'), 100)\n      })\n    })\n    \n    const { loading, execute, cleanup } = useAsyncOperation(mockOperation)\n    \n    const promise = execute()\n    \n    // Abort operation\n    cleanup()\n    \n    await expect(promise).rejects.toThrow('AbortError')\n    expect(abortSignal.aborted).toBe(true)\n    expect(loading.value).toBe(false)\n  })\n})\n\n// Store testing with complex state management\n// tests/stores/userStore.test.js\nimport { createPinia, setActivePinia } from 'pinia'\nimport { useUserStore } from '@/stores/user'\n\ndescribe('User Store', () => {\n  let userStore\n  \n  beforeEach(() => {\n    // Create new pinia instance for each test\n    setActivePinia(createPinia())\n    userStore = useUserStore()\n  })\n  \n  describe('fetchUsers', () => {\n    it('fetches users successfully', async () => {\n      // Mock API response\n      global.fetch = vi.fn().mockResolvedValue({\n        json: () => Promise.resolve([\n          { id: 1, name: 'John Doe', email: 'john@example.com' },\n          { id: 2, name: 'Jane Smith', email: 'jane@example.com' }\n        ])\n      })\n      \n      await userStore.fetchUsers()\n      \n      expect(userStore.users).toHaveLength(2)\n      expect(userStore.users[0].name).toBe('John Doe')\n      expect(userStore.loading.fetch).toBe(false)\n      expect(userStore.error).toBeNull()\n    })\n    \n    it('handles fetch errors', async () => {\n      global.fetch = vi.fn().mockRejectedValue(new Error('Network error'))\n      \n      await userStore.fetchUsers()\n      \n      expect(userStore.users).toHaveLength(0)\n      expect(userStore.loading.fetch).toBe(false)\n      expect(userStore.error).toBe('Network error')\n    })\n  })\n  \n  describe('CRUD operations', () => {\n    const testUser = { id: 1, name: 'John Doe', email: 'john@example.com' }\n    \n    beforeEach(() => {\n      userStore.users = [testUser]\n      userStore.currentUser = testUser\n    })\n    \n    it('creates user successfully', async () => {\n      const newUser = { name: 'Jane Smith', email: 'jane@example.com' }\n      const createdUser = { id: 2, ...newUser }\n      \n      global.fetch = vi.fn().mockResolvedValue({\n        json: () => Promise.resolve(createdUser)\n      })\n      \n      await userStore.createUser(newUser)\n      \n      expect(userStore.users).toHaveLength(2)\n      expect(userStore.users[1]).toEqual(createdUser)\n    })\n    \n    it('updates user successfully', async () => {\n      const updatedUser = { ...testUser, name: 'John Smith' }\n      \n      global.fetch = vi.fn().mockResolvedValue({\n        json: () => Promise.resolve(updatedUser)\n      })\n      \n      await userStore.updateUser(1, { name: 'John Smith' })\n      \n      expect(userStore.users[0].name).toBe('John Smith')\n      expect(userStore.currentUser.name).toBe('John Smith')\n    })\n    \n    it('deletes user successfully', async () => {\n      global.fetch = vi.fn().mockResolvedValue({})\n      \n      await userStore.deleteUser(1)\n      \n      expect(userStore.users).toHaveLength(0)\n      expect(userStore.currentUser).toBeNull()\n    })\n  })\n})\n\n// Integration test for complex workflows\n// tests/integration/userManagement.test.js\nimport { mount } from '@vue/test-utils'\nimport { createTestingPinia } from '@pinia/testing'\nimport { useUserStore } from '@/stores/user'\nimport UserManagement from '@/views/UserManagement.vue'\n\ndescribe('User Management Integration', () => {\n  let wrapper\n  let userStore\n  \n  beforeEach(() => {\n    wrapper = mount(UserManagement, {\n      global: {\n        plugins: [\n          createTestingPinia({\n            stubActions: false\n          })\n        ]\n      }\n    })\n    \n    userStore = useUserStore()\n  })\n  \n  it('completes full user management workflow', async () => {\n    // Mock initial data fetch\n    vi.spyOn(userStore, 'fetchUsers').mockResolvedValue([\n      { id: 1, name: 'John Doe', email: 'john@example.com' }\n    ])\n    \n    // Mock create operation\n    vi.spyOn(userStore, 'createUser').mockResolvedValue({\n      id: 2, name: 'Jane Smith', email: 'jane@example.com'\n    })\n    \n    // Load initial data\n    await wrapper.vm.loadUsers()\n    \n    // Add new user\n    await wrapper.vm.addUser({\n      name: 'Jane Smith',\n      email: 'jane@example.com'\n    })\n    \n    // Assert final state\n    expect(userStore.users).toHaveLength(2)\n    expect(userStore.users[1].name).toBe('Jane Smith')\n  })\n})",
    "explanation": "This example demonstrates advanced testing strategies including:\n\n1. Comprehensive component testing with complex interactions\n2. Advanced composable testing with async operations and abortion\n3. Store testing with complex state management scenarios\n4. Integration testing for complex workflows\n5. Proper mocking strategies for APIs and dependencies\n6. Test organization and setup patterns\n7. Error handling and edge case testing\n\nThese patterns enable developers to create comprehensive test suites that provide high confidence in application correctness while remaining maintainable and performant.",
    "language": "javascript"
  },
  "pitfalls": [
    {
      "mistake": "Creating tests that are too brittle and break with minor changes",
      "solution": "Use data-testid attributes, test behavior over implementation, and focus on user-facing functionality",
      "severity": "medium"
    },
    {
      "mistake": "Not testing edge cases and error conditions",
      "solution": "Test error states, boundary conditions, and unexpected inputs thoroughly",
      "severity": "high"
    },
    {
      "mistake": "Ignoring test performance which slows down development",
      "solution": "Use proper mocking, avoid unnecessary async operations, and organize tests efficiently",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Implement Comprehensive Testing Strategies",
      "description": "Create a complete testing suite with advanced patterns for components, composables, and stores",
      "checkpoints": [
        "Implement component tests with complex interactions",
        "Create composable tests with async operations",
        "Build store tests with complex state management",
        "Add integration tests for workflows",
        "Implement proper mocking and error handling tests"
      ]
    }
  ],
  "next": [],
  "estimatedMinutes": 60,
  "difficulty": "Advanced",
  "tags": [
    "Testing",
    "Vitest",
    "Vue Test Utils",
    "Pinia",
    "Mocking",
    "Vue 3"
  ],
  "lastUpdated": "2025-10-03T10:00:00Z",
  "version": "1.0.0"
}