{
  "id": "laravel-lesson-22-caching-strategies",
  "moduleSlug": "laravel-fundamentals",
  "title": "Caching Strategies and Optimization",
  "order": 22,
  "objectives": [
    "Master Laravel's caching system with multiple drivers and strategies",
    "Implement efficient cache invalidation and expiration patterns",
    "Create scalable caching architectures for high-performance applications",
    "Optimize cache usage for different data access patterns"
  ],
  "intro": "Caching strategies and optimization in Laravel provide essential tools for creating high-performance applications that can efficiently serve content while minimizing database load and response times. This comprehensive lesson explores advanced techniques for implementing robust caching systems that can handle complex data access patterns while maintaining data consistency and optimal performance.\n\nYou'll learn to implement sophisticated caching patterns that efficiently store and retrieve frequently accessed data, create cache invalidation strategies that maintain data consistency, and optimize cache usage for different types of data and access patterns. We'll explore advanced patterns for cache tagging, cache warming, and distributed caching that enable scalable, high-performance applications.\n\nThe lesson covers practical implementation strategies for monitoring cache performance, handling cache failures gracefully, and designing caching architectures that scale with application growth. You'll discover how to balance cache hit rates with memory usage, implement proper cache key naming conventions, and optimize caching for different storage drivers.\n\nBy mastering caching strategies and optimization, you'll be able to create Laravel applications that deliver exceptional performance and can handle high traffic loads while maintaining excellent user experience.",
  "code": {
    "example": "<?php\n// Advanced Caching Strategies and Optimization\n\n// Repository Pattern with Caching\n// app/Repositories/UserRepository.php\n\nnamespace App\\Repositories;\n\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass UserRepository\n{\n    protected const CACHE_TTL = 3600; // 1 hour\n    protected const TAG_PREFIX = 'users';\n    \n    public function findById(int $id)\n    {\n        $key = \"user:{$id}\";\n        \n        return Cache::tags([self::TAG_PREFIX])->remember($key, self::CACHE_TTL, function () use ($id) {\n            Log::info('Cache miss: User ' . $id);\n            return User::find($id);\n        });\n    }\n    \n    public function findByEmail(string $email)\n    {\n        $key = \"user:email:{$email}\";\n        \n        return Cache::tags([self::TAG_PREFIX, 'user_emails'])->remember($key, self::CACHE_TTL, function () use ($email) {\n            return User::where('email', $email)->first();\n        });\n    }\n    \n    public function getActiveUsers(int $limit = 50)\n    {\n        $key = \"users:active:limit:{$limit}\";\n        \n        return Cache::tags([self::TAG_PREFIX, 'user_lists'])->remember($key, 1800, function () use ($limit) {\n            return User::where('status', 'active')\n                      ->orderBy('last_login_at', 'desc')\n                      ->limit($limit)\n                      ->get();\n        });\n    }\n    \n    public function getUserStats(int $userId)\n    {\n        $key = \"user:{$userId}:stats\";\n        \n        return Cache::tags([self::TAG_PREFIX, 'user_stats'])->remember($key, 300, function () use ($userId) {\n            return [\n                'total_posts' => DB::table('posts')->where('user_id', $userId)->count(),\n                'total_comments' => DB::table('comments')->where('user_id', $userId)->count(),\n                'total_likes' => DB::table('likes')->where('user_id', $userId)->count(),\n                'last_activity' => DB::table('activities')\n                                    ->where('user_id', $userId)\n                                    ->latest('created_at')\n                                    ->value('created_at'),\n            ];\n        });\n    }\n    \n    public function searchUsers(array $filters = [])\n    {\n        // Create cache key from filters\n        $key = 'users:search:' . md5(serialize($filters));\n        \n        return Cache::tags([self::TAG_PREFIX, 'user_searches'])->remember($key, 600, function () use ($filters) {\n            $query = User::query();\n            \n            if (!empty($filters['name'])) {\n                $query->where('name', 'like', \"%{$filters['name']}%\");\n            }\n            \n            if (!empty($filters['status'])) {\n                $query->where('status', $filters['status']);\n            }\n            \n            if (!empty($filters['role'])) {\n                $query->where('role', $filters['role']);\n            }\n            \n            return $query->paginate($filters['per_page'] ?? 15);\n        });\n    }\n    \n    public function createUser(array $data)\n    {\n        $user = User::create($data);\n        \n        // Clear relevant caches\n        Cache::tags([self::TAG_PREFIX, 'user_lists'])->flush();\n        \n        return $user;\n    }\n    \n    public function updateUser(int $id, array $data)\n    {\n        $user = User::findOrFail($id);\n        $user->update($data);\n        \n        // Clear user-specific cache\n        Cache::tags([self::TAG_PREFIX])->forget(\"user:{$id}\");\n        Cache::tags([self::TAG_PREFIX])->forget(\"user:email:{$user->email}\");\n        \n        // Clear related caches\n        Cache::tags([self::TAG_PREFIX, 'user_stats'])->flush();\n        Cache::tags([self::TAG_PREFIX, 'user_lists'])->flush();\n        \n        return $user;\n    }\n    \n    public function deleteUser(int $id)\n    {\n        $user = User::findOrFail($id);\n        $user->delete();\n        \n        // Clear all user-related caches\n        Cache::tags([self::TAG_PREFIX])->flush();\n        \n        return true;\n    }\n    \n    public function clearUserCache(int $userId)\n    {\n        Cache::tags([self::TAG_PREFIX])->forget(\"user:{$userId}\");\n        Cache::tags([self::TAG_PREFIX, 'user_stats'])->forget(\"user:{$userId}:stats\");\n    }\n}\n\n// Advanced Cache Management Service\n// app/Services/CacheManager.php\n\nnamespace App\\Services;\n\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\Redis;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass CacheManager\n{\n    public function warmCache()\n    {\n        // Warm frequently accessed caches\n        $this->warmUserStats();\n        $this->warmActiveUsers();\n        $this->warmSystemSettings();\n        \n        Log::info('Cache warming completed');\n    }\n    \n    protected function warmUserStats()\n    {\n        $activeUsers = \\App\\Models\\User::where('status', 'active')\n                                      ->limit(1000)\n                                      ->pluck('id');\n        \n        foreach ($activeUsers as $userId) {\n            // Preload user stats\n            app('App\\Repositories\\UserRepository')->getUserStats($userId);\n        }\n    }\n    \n    protected function warmActiveUsers()\n    {\n        // Preload active users list\n        app('App\\Repositories\\UserRepository')->getActiveUsers(100);\n    }\n    \n    protected function warmSystemSettings()\n    {\n        // Preload system settings\n        \\App\\Models\\Setting::all()->keyBy('key');\n    }\n    \n    public function getCacheStats()\n    {\n        $driver = config('cache.default');\n        \n        switch ($driver) {\n            case 'redis':\n                return $this->getRedisStats();\n            case 'memcached':\n                return $this->getMemcachedStats();\n            default:\n                return [\n                    'driver' => $driver,\n                    'info' => 'Detailed stats not available for this driver'\n                ];\n        }\n    }\n    \n    protected function getRedisStats()\n    {\n        try {\n            $info = Redis::info();\n            $stats = [\n                'driver' => 'redis',\n                'used_memory' => $info['used_memory_human'] ?? 'N/A',\n                'connected_clients' => $info['connected_clients'] ?? 'N/A',\n                'total_commands_processed' => $info['total_commands_processed'] ?? 'N/A',\n                'keyspace_hits' => $info['keyspace_hits'] ?? 'N/A',\n                'keyspace_misses' => $info['keyspace_misses'] ?? 'N/A',\n                'hit_rate' => $this->calculateHitRate(\n                    $info['keyspace_hits'] ?? 0,\n                    $info['keyspace_misses'] ?? 0\n                )\n            ];\n            \n            return $stats;\n        } catch (\\Exception $e) {\n            Log::error('Failed to get Redis stats: ' . $e->getMessage());\n            return ['error' => 'Failed to retrieve Redis stats'];\n        }\n    }\n    \n    protected function calculateHitRate($hits, $misses)\n    {\n        $total = $hits + $misses;\n        return $total > 0 ? round(($hits / $total) * 100, 2) . '%' : '0%';\n    }\n    \n    public function clearTag($tag)\n    {\n        try {\n            Cache::tags([$tag])->flush();\n            Log::info(\"Cache tag '{$tag}' cleared\");\n            return true;\n        } catch (\\Exception $e) {\n            Log::error(\"Failed to clear cache tag '{$tag}': \" . $e->getMessage());\n            return false;\n        }\n    }\n    \n    public function clearPattern($pattern)\n    {\n        // Implementation depends on cache driver\n        // For Redis, you might use KEYS pattern and DEL\n        if (config('cache.default') === 'redis') {\n            $keys = Redis::keys($pattern);\n            if (!empty($keys)) {\n                Redis::del($keys);\n            }\n        }\n    }\n}\n\n// Model with Caching\n// app/Models/User.php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\DB;\n\nclass User extends Authenticatable\n{\n    use HasFactory;\n    \n    protected $fillable = [\n        'name', 'email', 'password', 'status', 'role'\n    ];\n    \n    protected $hidden = [\n        'password', 'remember_token',\n    ];\n    \n    protected $casts = [\n        'email_verified_at' => 'datetime',\n        'last_login_at' => 'datetime',\n    ];\n    \n    // Cached relationships\n    public function posts()\n    {\n        return $this->hasMany(Post::class);\n    }\n    \n    public function getPostCountAttribute()\n    {\n        return Cache::remember(\"user:{$this->id}:post_count\", 3600, function () {\n            return $this->posts()->count();\n        });\n    }\n    \n    // Cached computed properties\n    public function getFullNameAttribute()\n    {\n        return Cache::remember(\"user:{$this->id}:full_name\", 86400, function () {\n            return trim($this->first_name . ' ' . $this->last_name);\n        });\n    }\n    \n    // Cache invalidation on model events\n    protected static function booted()\n    {\n        static::saved(function ($user) {\n            // Clear user-specific caches\n            Cache::forget(\"user:{$user->id}\");\n            Cache::forget(\"user:{$user->id}:full_name\");\n            Cache::forget(\"user:{$user->id}:post_count\");\n            \n            // Clear user lists if status changed\n            if ($user->wasChanged('status')) {\n                Cache::tags(['users', 'user_lists'])->flush();\n            }\n        });\n        \n        static::deleted(function ($user) {\n            // Clear all user-related caches\n            Cache::tags(['users'])->flush();\n        });\n    }\n}\n\n// Controller with Cache Optimization\n// app/Http/Controllers/DashboardController.php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Repositories\\UserRepository;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\DB;\n\nclass DashboardController extends Controller\n{\n    protected $userRepository;\n    \n    public function __construct(UserRepository $userRepository)\n    {\n        $this->userRepository = $userRepository;\n    }\n    \n    public function index()\n    {\n        // Use cache tags for easy invalidation\n        $dashboardData = Cache::tags(['dashboard', 'analytics'])->remember('dashboard:data', 300, function () {\n            return [\n                'total_users' => $this->userRepository->getActiveUsers()->count(),\n                'recent_users' => $this->userRepository->getActiveUsers(10),\n                'system_stats' => $this->getSystemStats(),\n                'cache_stats' => app('App\\Services\\CacheManager')->getCacheStats(),\n            ];\n        });\n        \n        return response()->json($dashboardData);\n    }\n    \n    protected function getSystemStats()\n    {\n        return Cache::remember('system:stats', 600, function () {\n            return [\n                'database_size' => DB::select('SELECT pg_size_pretty(pg_database_size(current_database())) as size')[0]->size ?? 'N/A',\n                'active_sessions' => DB::table('sessions')->count(),\n                'server_load' => sys_getloadavg()[0] ?? 0,\n            ];\n        });\n    }\n    \n    public function clearCache(Request $request)\n    {\n        $tag = $request->get('tag', 'dashboard');\n        \n        $success = app('App\\Services\\CacheManager')->clearTag($tag);\n        \n        return response()->json([\n            'message' => $success ? 'Cache cleared successfully' : 'Failed to clear cache',\n            'tag' => $tag\n        ]);\n    }\n}\n\n// Cache Configuration\n// config/cache.php\n\nreturn [\n    'default' => env('CACHE_DRIVER', 'redis'),\n    \n    'stores' => [\n        'redis' => [\n            'driver' => 'redis',\n            'connection' => 'cache',\n            'lock_connection' => 'default',\n            'options' => [\n                'compression' => true, // Enable compression for large values\n                'serializer' => 'igbinary', // Use igbinary for better performance\n            ],\n        ],\n        \n        'memcached' => [\n            'driver' => 'memcached',\n            'persistent_id' => env('MEMCACHED_PERSISTENT_ID'),\n            'sasl' => [\n                env('MEMCACHED_USERNAME'),\n                env('MEMCACHED_PASSWORD'),\n            ],\n            'options' => [\n                // Memcached::OPT_CONNECT_TIMEOUT => 2000,\n            ],\n            'servers' => [\n                [\n                    'host' => env('MEMCACHED_HOST', '127.0.0.1'),\n                    'port' => env('MEMCACHED_PORT', 11211),\n                    'weight' => 100,\n                ],\n            ],\n        ],\n    ],\n    \n    'prefix' => env('CACHE_PREFIX', 'laravel'),\n    \n    // Cache warming configuration\n    'warm_on_deploy' => env('CACHE_WARM_ON_DEPLOY', true),\n    \n    // Cache monitoring\n    'monitor_hits' => env('CACHE_MONITOR_HITS', false),\n];",
    "explanation": "This example demonstrates advanced Laravel caching strategies including:\n\n1. Repository pattern with comprehensive caching\n2. Cache tagging for organized invalidation\n3. Advanced cache management service\n4. Model-level caching with automatic invalidation\n5. Cache warming strategies for improved performance\n6. Cache statistics and monitoring\n7. Multiple cache driver configuration\n8. Proper cache key naming conventions\n\nThese patterns enable developers to create robust, scalable caching systems that significantly improve application performance while maintaining data consistency.",
    "language": "php"
  },
  "pitfalls": [
    {
      "mistake": "Caching data that changes frequently without proper invalidation",
      "solution": "Implement proper cache invalidation strategies, use appropriate TTL values, and leverage cache tags for organized clearing",
      "severity": "high"
    },
    {
      "mistake": "Creating cache keys that are too generic or collide",
      "solution": "Use consistent naming conventions, include relevant identifiers, and consider using cache key hashing for complex keys",
      "severity": "medium"
    },
    {
      "mistake": "Not monitoring cache performance and hit rates",
      "solution": "Implement cache statistics tracking, monitor hit rates, and regularly review cache effectiveness",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Implement Comprehensive Caching System",
      "description": "Create a complete caching system with proper invalidation, monitoring, and optimization",
      "checkpoints": [
        "Implement repository pattern with caching",
        "Create cache tagging for organized invalidation",
        "Build cache warming strategies",
        "Add cache monitoring and statistics",
        "Implement proper cache key naming conventions"
      ]
    }
  ],
  "next": ["laravel-lesson-23-deployment-practices"],
  "estimatedMinutes": 55,
  "difficulty": "Advanced",
  "tags": [
    "Caching",
    "Optimization",
    "Redis",
    "Performance",
    "Laravel"
  ],
  "lastUpdated": "2025-10-03T10:00:00Z",
  "version": "1.0.0"
}