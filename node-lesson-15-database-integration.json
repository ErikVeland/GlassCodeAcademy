{
  "id": "node-fundamentals-lesson-15",
  "moduleSlug": "node-fundamentals",
  "title": "Database Integration and ORM Patterns",
  "order": 15,
  "objectives": [
    "Implement robust database connections with connection pooling and error handling",
    "Design efficient database queries with proper indexing and optimization strategies",
    "Create data access layers with ORM patterns for maintainable database interactions",
    "Implement database migrations and seeding for consistent data management"
  ],
  "intro": "Database integration and ORM patterns are essential for building data-driven Node.js applications that can efficiently store, retrieve, and manipulate information while maintaining data integrity and performance. This comprehensive lesson explores advanced techniques for connecting to various database systems, implementing efficient querying strategies, and creating maintainable data access layers that abstract database complexity.\n\nYou'll learn to implement robust database connections with proper connection pooling, error handling, and retry mechanisms that ensure application reliability even when database systems experience temporary issues. We'll explore different database paradigms including relational databases like PostgreSQL and MySQL, as well as NoSQL databases like MongoDB, understanding when to use each approach for specific application requirements.\n\nORM (Object-Relational Mapping) patterns provide abstraction layers that simplify database interactions by mapping database records to application objects. We'll explore popular Node.js ORMs like Sequelize and TypeORM, learning to implement efficient querying patterns, relationship handling, and transaction management that maintain data consistency across complex operations.\n\nDatabase migrations and seeding are crucial for maintaining consistent database schemas across different environments and development teams. We'll cover best practices for creating reversible migrations, implementing data seeding strategies, and establishing database version control that enables reliable deployment and rollback procedures. By mastering database integration and ORM patterns, you'll be able to build applications that efficiently manage data while maintaining scalability and reliability.",
  "code": {
    "example": "// Database Integration and ORM Patterns Implementation\n\n// Connection Pooling with PostgreSQL\nconst { Pool } = require('pg');\nconst dotenv = require('dotenv');\n\ndotenv.config();\n\n// Create connection pool\nconst pool = new Pool({\n  user: process.env.DB_USER,\n  host: process.env.DB_HOST,\n  database: process.env.DB_NAME,\n  password: process.env.DB_PASSWORD,\n  port: process.env.DB_PORT,\n  max: 20, // Maximum number of clients in the pool\n  idleTimeoutMillis: 30000, // Close idle clients after 30 seconds\n  connectionTimeoutMillis: 2000, // Return an error after 2 seconds if connection could not be established\n});\n\n// Database service with connection management\nclass DatabaseService {\n  constructor(pool) {\n    this.pool = pool;\n  }\n  \n  // Execute query with error handling and retry logic\n  async query(text, params, retries = 3) {\n    for (let i = 0; i <= retries; i++) {\n      try {\n        const start = Date.now();\n        const res = await this.pool.query(text, params);\n        const duration = Date.now() - start;\n        console.log('Executed query', { text, duration, rows: res.rowCount });\n        return res;\n      } catch (error) {\n        if (i === retries) {\n          console.error('Database query failed after retries:', error);\n          throw error;\n        }\n        \n        // Wait before retry with exponential backoff\n        await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));\n      }\n    }\n  }\n  \n  // Transaction management\n  async transaction(callback) {\n    const client = await this.pool.connect();\n    try {\n      await client.query('BEGIN');\n      const result = await callback(client);\n      await client.query('COMMIT');\n      return result;\n    } catch (error) {\n      await client.query('ROLLBACK');\n      throw error;\n    } finally {\n      client.release();\n    }\n  }\n  \n  // Connection health check\n  async healthCheck() {\n    try {\n      const result = await this.query('SELECT NOW()');\n      return {\n        status: 'healthy',\n        timestamp: result.rows[0].now\n      };\n    } catch (error) {\n      return {\n        status: 'unhealthy',\n        error: error.message\n      };\n    }\n  }\n}\n\n// Initialize database service\nconst db = new DatabaseService(pool);\n\n// Express route with database integration\nconst express = require('express');\nconst app = express();\n\napp.use(express.json());\n\n// Get users with pagination and filtering\napp.get('/api/users', async (req, res) => {\n  try {\n    const { page = 1, limit = 10, search } = req.query;\n    const offset = (page - 1) * limit;\n    \n    let query = 'SELECT id, name, email, created_at FROM users';\n    const params = [];\n    \n    if (search) {\n      query += ' WHERE name ILIKE $1 OR email ILIKE $1';\n      params.push(`%${search}%`);\n    }\n    \n    query += ' ORDER BY created_at DESC LIMIT $' + (params.length + 1) + ' OFFSET $' + (params.length + 2);\n    params.push(limit, offset);\n    \n    const result = await db.query(query, params);\n    \n    // Get total count for pagination\n    let countQuery = 'SELECT COUNT(*) FROM users';\n    if (search) {\n      countQuery += ' WHERE name ILIKE $1 OR email ILIKE $1';\n    }\n    const countResult = await db.query(countQuery, search ? [`%${search}%`] : []);\n    const total = parseInt(countResult.rows[0].count);\n    \n    res.json({\n      data: result.rows,\n      pagination: {\n        page: parseInt(page),\n        limit: parseInt(limit),\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    });\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Create user with transaction\napp.post('/api/users', async (req, res) => {\n  const { name, email, profile } = req.body;\n  \n  try {\n    const result = await db.transaction(async (client) => {\n      // Insert user\n      const userResult = await client.query(\n        'INSERT INTO users (name, email) VALUES ($1, $2) RETURNING id, name, email',\n        [name, email]\n      );\n      \n      const userId = userResult.rows[0].id;\n      \n      // Insert profile if provided\n      if (profile) {\n        await client.query(\n          'INSERT INTO user_profiles (user_id, bio, avatar_url) VALUES ($1, $2, $3)',\n          [userId, profile.bio, profile.avatar_url]\n        );\n      }\n      \n      return userResult.rows[0];\n    });\n    \n    res.status(201).json(result);\n  } catch (error) {\n    console.error('Error creating user:', error);\n    res.status(500).json({ error: 'Failed to create user' });\n  }\n});\n\n// ORM Pattern Implementation with Sequelize\nconst { Sequelize, DataTypes, Model } = require('sequelize');\n\n// Initialize Sequelize\nconst sequelize = new Sequelize(process.env.DATABASE_URL, {\n  logging: false,\n  pool: {\n    max: 20,\n    min: 5,\n    acquire: 30000,\n    idle: 10000\n  }\n});\n\n// User model\nclass User extends Model {}\nUser.init({\n  id: {\n    type: DataTypes.INTEGER,\n    primaryKey: true,\n    autoIncrement: true\n  },\n  name: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    validate: {\n      notEmpty: true,\n      len: [1, 100]\n    }\n  },\n  email: {\n    type: DataTypes.STRING,\n    allowNull: false,\n    unique: true,\n    validate: {\n      isEmail: true\n    }\n  },\n  status: {\n    type: DataTypes.ENUM('active', 'inactive', 'suspended'),\n    defaultValue: 'active'\n  }\n}, {\n  sequelize,\n  modelName: 'User',\n  tableName: 'users',\n  timestamps: true,\n  indexes: [\n    {\n      unique: true,\n      fields: ['email']\n    },\n    {\n      fields: ['status']\n    }\n  ]\n});\n\n// Profile model\nclass Profile extends Model {}\nProfile.init({\n  bio: {\n    type: DataTypes.TEXT\n  },\n  avatar_url: {\n    type: DataTypes.STRING,\n    validate: {\n      isUrl: true\n    }\n  }\n}, {\n  sequelize,\n  modelName: 'Profile',\n  tableName: 'user_profiles',\n  timestamps: true\n});\n\n// Define relationships\nUser.hasOne(Profile, { foreignKey: 'user_id' });\nProfile.belongsTo(User, { foreignKey: 'user_id' });\n\n// Repository pattern for data access\nclass UserRepository {\n  async findAll({ page = 1, limit = 10, search, status }) {\n    const options = {\n      limit,\n      offset: (page - 1) * limit,\n      order: [['createdAt', 'DESC']],\n      where: {}\n    };\n    \n    if (search) {\n      options.where[Sequelize.Op.or] = [\n        { name: { [Sequelize.Op.iLike]: `%${search}%` } },\n        { email: { [Sequelize.Op.iLike]: `%${search}%` } }\n      ];\n    }\n    \n    if (status) {\n      options.where.status = status;\n    }\n    \n    return await User.findAndCountAll(options);\n  }\n  \n  async findById(id) {\n    return await User.findByPk(id, {\n      include: [{\n        model: Profile,\n        attributes: ['bio', 'avatar_url']\n      }]\n    });\n  }\n  \n  async create(userData) {\n    const { profile, ...userFields } = userData;\n    \n    return await sequelize.transaction(async (transaction) => {\n      const user = await User.create(userFields, { transaction });\n      \n      if (profile) {\n        await Profile.create({\n          ...profile,\n          userId: user.id\n        }, { transaction });\n      }\n      \n      return await this.findById(user.id);\n    });\n  }\n  \n  async update(id, userData) {\n    const user = await this.findById(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    \n    const { profile, ...userFields } = userData;\n    \n    return await sequelize.transaction(async (transaction) => {\n      await user.update(userFields, { transaction });\n      \n      if (profile) {\n        const [userProfile] = await Profile.findOrCreate({\n          where: { userId: id },\n          defaults: { userId: id },\n          transaction\n        });\n        \n        await userProfile.update(profile, { transaction });\n      }\n      \n      return await this.findById(id);\n    });\n  }\n  \n  async delete(id) {\n    const user = await this.findById(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    \n    return await user.destroy();\n  }\n}\n\n// Express routes with ORM\nconst userRepo = new UserRepository();\n\napp.get('/api/v2/users', async (req, res) => {\n  try {\n    const { page, limit, search, status } = req.query;\n    const result = await userRepo.findAll({ page, limit, search, status });\n    \n    res.json({\n      data: result.rows,\n      pagination: {\n        page: parseInt(page) || 1,\n        limit: parseInt(limit) || 10,\n        total: result.count,\n        pages: Math.ceil(result.count / (parseInt(limit) || 10))\n      }\n    });\n  } catch (error) {\n    console.error('Error fetching users:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/api/v2/users/:id', async (req, res) => {\n  try {\n    const user = await userRepo.findById(req.params.id);\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json(user);\n  } catch (error) {\n    console.error('Error fetching user:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Database migration example\n// migrations/20251003000000-create-users-table.js\n\nmodule.exports = {\n  up: async (queryInterface, Sequelize) => {\n    await queryInterface.createTable('users', {\n      id: {\n        type: Sequelize.INTEGER,\n        primaryKey: true,\n        autoIncrement: true\n      },\n      name: {\n        type: Sequelize.STRING,\n        allowNull: false\n      },\n      email: {\n        type: Sequelize.STRING,\n        allowNull: false,\n        unique: true\n      },\n      status: {\n        type: Sequelize.ENUM('active', 'inactive', 'suspended'),\n        defaultValue: 'active'\n      },\n      created_at: {\n        type: Sequelize.DATE,\n        allowNull: false,\n        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')\n      },\n      updated_at: {\n        type: Sequelize.DATE,\n        allowNull: false,\n        defaultValue: Sequelize.literal('CURRENT_TIMESTAMP')\n      }\n    });\n    \n    await queryInterface.addIndex('users', ['email'], {\n      unique: true\n    });\n    \n    await queryInterface.addIndex('users', ['status']);\n  },\n  \n  down: async (queryInterface, Sequelize) => {\n    await queryInterface.dropTable('users');\n  }\n};\n\n// Seed data example\n// seeders/20251003000001-demo-users.js\n\nmodule.exports = {\n  up: async (queryInterface, Sequelize) => {\n    await queryInterface.bulkInsert('users', [{\n      name: 'John Doe',\n      email: 'john@example.com',\n      status: 'active',\n      created_at: new Date(),\n      updated_at: new Date()\n    }, {\n      name: 'Jane Smith',\n      email: 'jane@example.com',\n      status: 'active',\n      created_at: new Date(),\n      updated_at: new Date()\n    }], {});\n  },\n  \n  down: async (queryInterface, Sequelize) => {\n    await queryInterface.bulkDelete('users', null, {});\n  }\n};",
    "explanation": "This example demonstrates comprehensive database integration patterns including:\n\n1. Connection pooling with PostgreSQL for efficient resource management\n2. Robust error handling with retry mechanisms for database operations\n3. Transaction management for data consistency\n4. Database health checks for monitoring\n5. ORM implementation with Sequelize for abstracting database complexity\n6. Repository pattern for clean data access layer\n7. Database migrations and seeding for schema management\n\nThese patterns work together to create a robust, maintainable database integration layer that can handle complex operations while maintaining performance and reliability.",
    "language": "javascript"
  },
  "pitfalls": [
    {
      "mistake": "Creating database connections without proper pooling, leading to resource exhaustion",
      "solution": "Implement connection pooling with appropriate sizing and timeout configurations to efficiently manage database connections",
      "severity": "high"
    },
    {
      "mistake": "Not handling database errors properly, causing application crashes",
      "solution": "Implement comprehensive error handling with retry logic and graceful degradation when database operations fail",
      "severity": "high"
    },
    {
      "mistake": "Writing inefficient queries without proper indexing, causing performance bottlenecks",
      "solution": "Use query analysis tools, implement proper indexing strategies, and optimize queries for common access patterns",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Implement Database Integration with ORM Patterns",
      "description": "Create a complete database integration system with connection pooling, ORM patterns, transactions, and migration management",
      "checkpoints": [
        "Implement connection pooling with error handling and retry logic",
        "Create ORM models with proper relationships and validations",
        "Build repository pattern for data access abstraction",
        "Implement transaction management for data consistency",
        "Create database migrations and seed data"
      ]
    }
  ],
  "next": ["node-fundamentals-lesson-16"],
  "estimatedMinutes": 60,
  "difficulty": "Advanced",
  "tags": [
    "Database",
    "ORM",
    "Sequelize",
    "PostgreSQL",
    "Node.js"
  ],
  "lastUpdated": "2025-10-03T00:00:00.000Z",
  "version": "1.0.0"
}