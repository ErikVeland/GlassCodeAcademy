{
  "id": "laravel-lesson-21-event-broadcasting",
  "moduleSlug": "laravel-fundamentals",
  "title": "Event Broadcasting and Real-Time Features",
  "order": 21,
  "objectives": [
    "Master Laravel's event broadcasting system for real-time applications",
    "Implement WebSocket connections with Laravel Echo and Pusher",
    "Create efficient event handling with proper serialization",
    "Design scalable real-time architectures for high-concurrency applications"
  ],
  "intro": "Event broadcasting and real-time features in Laravel provide powerful tools for creating dynamic, interactive applications that can instantly respond to server-side events and deliver real-time updates to users. This comprehensive lesson explores advanced techniques for implementing robust real-time systems that can handle high concurrency while maintaining excellent performance and reliability.\n\nYou'll learn to implement sophisticated event broadcasting patterns that efficiently deliver real-time updates to connected clients, create WebSocket connections with proper authentication and channel management, and optimize event handling for performance and resource utilization. We'll explore advanced patterns for presence channels, private channels, and event broadcasting to specific users or groups.\n\nThe lesson covers practical implementation strategies for monitoring real-time performance, handling connection failures gracefully, and designing event architectures that scale with application growth. You'll discover how to balance real-time functionality with system resources, implement proper logging and debugging, and optimize events for different use cases.\n\nBy mastering event broadcasting and real-time features, you'll be able to create Laravel applications that provide engaging, interactive user experiences with instant updates and real-time collaboration capabilities.",
  "code": {
    "example": "<?php\n// Advanced Event Broadcasting and Real-Time Features\n\n// Event Implementation with Broadcasting\n// app/Events/UserStatusChanged.php\n\nnamespace App\\Events;\n\nuse App\\Models\\User;\nuse Illuminate\\Broadcasting\\Channel;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Broadcasting\\PresenceChannel;\nuse Illuminate\\Broadcasting\\PrivateChannel;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass UserStatusChanged implements ShouldBroadcast\n{\n    use Dispatchable, InteractsWithSockets, SerializesModels;\n    \n    public $user;\n    public $status;\n    public $timestamp;\n    \n    public function __construct(User $user, string $status)\n    {\n        $this->user = $user;\n        $this->status = $status;\n        $this->timestamp = now();\n        \n        // Broadcast immediately without queueing\n        $this->connection = 'redis';\n        $this->queue = 'broadcasts';\n    }\n    \n    public function broadcastOn()\n    {\n        return new PrivateChannel('user.' . $this->user->id);\n    }\n    \n    public function broadcastWith()\n    {\n        return [\n            'user' => [\n                'id' => $this->user->id,\n                'name' => $this->user->name,\n                'avatar' => $this->user->avatar_url,\n            ],\n            'status' => $this->status,\n            'timestamp' => $this->timestamp->toIso8601String(),\n        ];\n    }\n    \n    public function broadcastAs()\n    {\n        return 'user.status.changed';\n    }\n}\n\n// Real-time Notification Event\n// app/Events/NotificationCreated.php\n\nnamespace App\\Events;\n\nuse App\\Models\\Notification;\nuse App\\Models\\User;\nuse Illuminate\\Broadcasting\\Channel;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Broadcasting\\PrivateChannel;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass NotificationCreated implements ShouldBroadcast\n{\n    use Dispatchable, InteractsWithSockets, SerializesModels;\n    \n    public $notification;\n    public $user;\n    \n    public function __construct(Notification $notification, User $user)\n    {\n        $this->notification = $notification;\n        $this->user = $user;\n    }\n    \n    public function broadcastOn()\n    {\n        return new PrivateChannel('App.Models.User.' . $this->user->id);\n    }\n    \n    public function broadcastWith()\n    {\n        return [\n            'id' => $this->notification->id,\n            'type' => $this->notification->type,\n            'data' => $this->notification->data,\n            'read_at' => $this->notification->read_at,\n            'created_at' => $this->notification->created_at->toIso8601String(),\n        ];\n    }\n    \n    public function broadcastAs()\n    {\n        return 'notification.created';\n    }\n}\n\n// Presence Channel Event\n// app/Events/UserJoinedRoom.php\n\nnamespace App\\Events;\n\nuse App\\Models\\User;\nuse App\\Models\\ChatRoom;\nuse Illuminate\\Broadcasting\\Channel;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Broadcasting\\PresenceChannel;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass UserJoinedRoom implements ShouldBroadcast\n{\n    use Dispatchable, InteractsWithSockets, SerializesModels;\n    \n    public $user;\n    public $room;\n    \n    public function __construct(User $user, ChatRoom $room)\n    {\n        $this->user = $user;\n        $this->room = $room;\n    }\n    \n    public function broadcastOn()\n    {\n        return new PresenceChannel('chat.room.' . $this->room->id);\n    }\n    \n    public function broadcastWith()\n    {\n        return [\n            'user' => [\n                'id' => $this->user->id,\n                'name' => $this->user->name,\n                'avatar' => $this->user->avatar_url,\n            ]\n        ];\n    }\n    \n    public function broadcastAs()\n    {\n        return 'user.joined';\n    }\n}\n\n// Event Listener with Real-Time Processing\n// app/Listeners/SendRealTimeNotification.php\n\nnamespace App\\Listeners;\n\nuse App\\Events\\OrderShipped;\nuse App\\Events\\NotificationCreated;\nuse App\\Models\\User;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Queue\\InteractsWithQueue;\n\nclass SendRealTimeNotification implements ShouldQueue\n{\n    use InteractsWithQueue;\n    \n    public $connection = 'redis';\n    public $queue = 'listeners';\n    public $delay = 0;\n    \n    public function handle(OrderShipped $event)\n    {\n        $user = $event->order->user;\n        \n        // Create database notification\n        $notification = $user->notifications()->create([\n            'type' => 'order_shipped',\n            'data' => [\n                'order_id' => $event->order->id,\n                'tracking_number' => $event->trackingNumber,\n            ],\n        ]);\n        \n        // Broadcast real-time notification\n        broadcast(new NotificationCreated($notification, $user));\n        \n        // Send push notification (if configured)\n        if ($user->push_notifications_enabled) {\n            // Send push notification via external service\n        }\n    }\n}\n\n// Controller for Real-Time Features\n// app/Http/Controllers/RealTimeController.php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Events\\UserStatusChanged;\nuse App\\Models\\User;\nuse Illuminate\\Http\\Request;\n\nclass RealTimeController extends Controller\n{\n    public function updateStatus(Request $request)\n    {\n        $request->validate([\n            'status' => 'required|string|in:online,away,busy,offline'\n        ]);\n        \n        $user = $request->user();\n        $user->update(['status' => $request->status]);\n        \n        // Broadcast status change\n        broadcast(new UserStatusChanged($user, $request->status));\n        \n        return response()->json([\n            'message' => 'Status updated',\n            'status' => $request->status\n        ]);\n    }\n    \n    public function joinRoom(Request $request, $roomId)\n    {\n        $user = $request->user();\n        $room = \\App\\Models\\ChatRoom::findOrFail($roomId);\n        \n        // Add user to room\n        $room->users()->attach($user->id, [\n            'joined_at' => now()\n        ]);\n        \n        // Broadcast user joined\n        broadcast(new \\App\\Events\\UserJoinedRoom($user, $room));\n        \n        return response()->json([\n            'message' => 'Joined room successfully',\n            'room' => $room\n        ]);\n    }\n}\n\n// Frontend JavaScript with Laravel Echo\n// resources/js/echo.js\n\nimport Echo from 'laravel-echo';\nimport Pusher from 'pusher-js';\n\nwindow.Pusher = Pusher;\n\nconst echo = new Echo({\n    broadcaster: 'pusher',\n    key: process.env.MIX_PUSHER_APP_KEY,\n    cluster: process.env.MIX_PUSHER_APP_CLUSTER,\n    forceTLS: true,\n    auth: {\n        headers: {\n            'Authorization': `Bearer ${localStorage.getItem('authToken')}`,\n            'X-CSRF-TOKEN': document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content')\n        }\n    }\n});\n\n// Listen for user status changes\necho.private(`user.${userId}`)\n    .listen('UserStatusChanged', (e) => {\n        console.log('User status changed:', e.status);\n        // Update UI with new status\n        document.getElementById('user-status').textContent = e.status;\n    });\n\n// Listen for notifications\necho.private(`App.Models.User.${userId}`)\n    .listen('NotificationCreated', (e) => {\n        console.log('New notification:', e);\n        // Show notification in UI\n        showNotification(e.data.title, e.data.message);\n        \n        // Update notification count\n        const countElement = document.getElementById('notification-count');\n        countElement.textContent = parseInt(countElement.textContent) + 1;\n    });\n\n// Presence channel for chat rooms\necho.join(`chat.room.${roomId}`)\n    .here((users) => {\n        // Initial list of users in room\n        console.log('Users in room:', users);\n        updateOnlineUsersList(users);\n    })\n    .joining((user) => {\n        // User joined room\n        console.log('User joined:', user);\n        addUserToList(user);\n        showSystemMessage(`${user.name} joined the room`);\n    })\n    .leaving((user) => {\n        // User left room\n        console.log('User left:', user);\n        removeUserFromList(user);\n        showSystemMessage(`${user.name} left the room`);\n    })\n    .listen('MessageSent', (e) => {\n        // New message in room\n        console.log('New message:', e.message);\n        displayMessage(e.message);\n    });\n\n// Real-time dashboard updates\necho.channel('dashboard')\n    .listen('MetricsUpdated', (e) => {\n        console.log('Dashboard metrics updated:', e.metrics);\n        updateDashboardMetrics(e.metrics);\n    });\n\n// Error handling\necho.connector.pusher.connection.bind('error', (error) => {\n    console.error('Pusher connection error:', error);\n    // Handle connection error\n    showConnectionError();\n});\n\n// Reconnection handling\necho.connector.pusher.connection.bind('state_change', (states) => {\n    console.log('Connection state changed:', states);\n    if (states.current === 'connected') {\n        hideConnectionError();\n    }\n});\n\n// Broadcasting from server-side\n// In a service class or controller\n\\App\\Events\\UserStatusChanged::dispatch($user, 'online');\n\n// Broadcasting to specific channels\nbroadcast(new \\App\\Events\\NotificationCreated($notification, $user));\n\n// Broadcasting to presence channels\nbroadcast(new \\App\\Events\\UserJoinedRoom($user, $room));",
    "explanation": "This example demonstrates advanced Laravel event broadcasting patterns including:\n\n1. Event implementation with proper broadcasting configuration\n2. Private and presence channel usage for secure real-time communication\n3. Event serialization and custom payload formatting\n4. Event listeners with queue integration\n5. Frontend JavaScript with Laravel Echo for real-time updates\n6. Presence channels for user presence tracking\n7. Authentication and security for real-time connections\n8. Error handling and reconnection management\n\nThese patterns enable developers to create robust, scalable real-time applications that provide engaging user experiences with instant updates and interactive features.",
    "language": "php"
  },
  "pitfalls": [
    {
      "mistake": "Broadcasting sensitive data in events without proper authorization",
      "solution": "Implement proper channel authorization, sanitize event data, and use private channels for sensitive information",
      "severity": "high"
    },
    {
      "mistake": "Creating events that are too large or broadcast too frequently",
      "solution": "Optimize event payload size, implement rate limiting, and batch updates when appropriate",
      "severity": "medium"
    },
    {
      "mistake": "Not handling connection failures and reconnection scenarios",
      "solution": "Implement proper error handling, reconnection logic, and user feedback for connection issues",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Implement Comprehensive Real-Time Features",
      "description": "Create a complete real-time system with private channels, presence channels, and proper error handling",
      "checkpoints": [
        "Implement events with proper broadcasting configuration",
        "Create private and presence channels for secure communication",
        "Build frontend integration with Laravel Echo",
        "Add proper authentication and authorization",
        "Implement error handling and reconnection management"
      ]
    }
  ],
  "next": ["laravel-lesson-22-caching-strategies"],
  "estimatedMinutes": 55,
  "difficulty": "Advanced",
  "tags": [
    "Event Broadcasting",
    "Real-Time",
    "WebSocket",
    "Laravel Echo",
    "Pusher",
    "Laravel"
  ],
  "lastUpdated": "2025-10-03T10:00:00Z",
  "version": "1.0.0"
}