{
  "id": "node-fundamentals-lesson-14",
  "moduleSlug": "node-fundamentals",
  "title": "Security Best Practices and Vulnerability Management",
  "order": 14,
  "objectives": [
    "Implement comprehensive authentication and authorization strategies",
    "Protect against common web vulnerabilities including XSS, CSRF, and injection attacks",
    "Create secure API designs with proper input validation and sanitization",
    "Establish robust security monitoring and incident response procedures"
  ],
  "intro": "Security best practices and vulnerability management are critical aspects of modern Node.js application development that protect both user data and system integrity from malicious attacks. This comprehensive lesson explores advanced security techniques that address the OWASP Top 10 vulnerabilities and implement defense-in-depth strategies to secure applications at multiple layers.\n\nYou'll learn to implement robust authentication and authorization systems using industry-standard protocols like OAuth 2.0 and JWT, creating secure session management that prevents session hijacking and fixation attacks. We'll explore advanced authorization patterns including role-based access control (RBAC) and attribute-based access control (ABAC) that provide fine-grained permissions for complex application requirements.\n\nInput validation and sanitization are fundamental defenses against injection attacks, cross-site scripting (XSS), and other common vulnerabilities. We'll cover comprehensive validation strategies for different data types, secure file upload handling, and protection against cross-site request forgery (CSRF) attacks that exploit user sessions.\n\nSecurity monitoring and incident response capabilities enable rapid detection and mitigation of security threats. We'll explore logging strategies that balance security requirements with privacy concerns, implement security headers and content security policies, and establish procedures for vulnerability assessment and remediation. By mastering security best practices, you'll be able to build applications that protect user data and maintain trust in an increasingly threat-filled digital landscape.",
  "code": {
    "example": "// Security Best Practices Implementation\n\n// Authentication with JWT and OAuth 2.0\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcrypt');\nconst rateLimit = require('express-rate-limit');\nconst helmet = require('helmet');\n\n// User authentication service\nclass AuthenticationService {\n  constructor(jwtSecret, saltRounds = 12) {\n    this.jwtSecret = jwtSecret;\n    this.saltRounds = saltRounds;\n  }\n  \n  async hashPassword(password) {\n    return await bcrypt.hash(password, this.saltRounds);\n  }\n  \n  async verifyPassword(password, hash) {\n    return await bcrypt.compare(password, hash);\n  }\n  \n  generateToken(user, expiresIn = '24h') {\n    const payload = {\n      sub: user.id,\n      email: user.email,\n      roles: user.roles || [],\n      permissions: user.permissions || []\n    };\n    \n    return jwt.sign(payload, this.jwtSecret, { expiresIn });\n  }\n  \n  verifyToken(token) {\n    try {\n      return jwt.verify(token, this.jwtSecret);\n    } catch (error) {\n      throw new Error('Invalid token');\n    }\n  }\n  \n  async login(email, password, userRepository) {\n    // Rate limiting should be implemented at the route level\n    \n    // Find user\n    const user = await userRepository.findByEmail(email);\n    if (!user) {\n      throw new Error('Invalid credentials');\n    }\n    \n    // Verify password\n    const isValid = await this.verifyPassword(password, user.passwordHash);\n    if (!isValid) {\n      throw new Error('Invalid credentials');\n    }\n    \n    // Update last login\n    await userRepository.updateLastLogin(user.id);\n    \n    // Generate token\n    const token = this.generateToken(user);\n    \n    return {\n      token,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    };\n  }\n}\n\n// Express app with security middleware\nconst express = require('express');\nconst app = express();\n\n// Security headers with Helmet\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"],\n      connectSrc: [\"'self'\"],\n      fontSrc: [\"'self'\", \"https:\"],\n      objectSrc: [\"'none'\"],\n      mediaSrc: [\"'self'\"],\n      frameSrc: [\"'none'\"],\n    },\n  },\n  hsts: {\n    maxAge: 31536000, // 1 year\n    includeSubDomains: true,\n    preload: true\n  }\n}));\n\n// Rate limiting\nconst loginLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 5, // limit each IP to 5 requests per windowMs\n  message: 'Too many login attempts, please try again later',\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\nconst generalLimiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: 'Too many requests from this IP, please try again later',\n  standardHeaders: true,\n  legacyHeaders: false,\n});\n\napp.use('/api/', generalLimiter);\napp.use('/api/auth/login', loginLimiter);\n\n// Input validation and sanitization\nconst { body, validationResult } = require('express-validator');\n\n// User registration validation\nconst registerValidation = [\n  body('email')\n    .isEmail()\n    .normalizeEmail()\n    .withMessage('Must be a valid email'),\n  body('password')\n    .isLength({ min: 8 })\n    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/)\n    .withMessage('Password must be at least 8 characters with uppercase, lowercase, number, and special character'),\n  body('name')\n    .trim()\n    .isLength({ min: 1, max: 50 })\n    .escape() // Sanitize input\n    .withMessage('Name is required and must be less than 50 characters')\n];\n\n// Authorization middleware\nconst authorizationService = {\n  // Check if user has required role\n  requireRole(requiredRole) {\n    return (req, res, next) => {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Authentication required' });\n      }\n      \n      if (!req.user.roles.includes(requiredRole)) {\n        return res.status(403).json({ error: 'Insufficient permissions' });\n      }\n      \n      next();\n    };\n  },\n  \n  // Check if user has required permission\n  requirePermission(requiredPermission) {\n    return (req, res, next) => {\n      if (!req.user) {\n        return res.status(401).json({ error: 'Authentication required' });\n      }\n      \n      if (!req.user.permissions.includes(requiredPermission)) {\n        return res.status(403).json({ error: 'Insufficient permissions' });\n      }\n      \n      next();\n    };\n  }\n};\n\n// Secure route implementation\napp.post('/api/auth/register', registerValidation, async (req, res) => {\n  // Check for validation errors\n  const errors = validationResult(req);\n  if (!errors.isEmpty()) {\n    return res.status(400).json({ errors: errors.array() });\n  }\n  \n  try {\n    const { email, password, name } = req.body;\n    \n    // Check if user already exists\n    const existingUser = await userRepository.findByEmail(email);\n    if (existingUser) {\n      return res.status(409).json({ error: 'User already exists' });\n    }\n    \n    // Hash password\n    const authService = new AuthenticationService(process.env.JWT_SECRET);\n    const passwordHash = await authService.hashPassword(password);\n    \n    // Create user\n    const user = await userRepository.create({\n      email,\n      passwordHash,\n      name,\n      roles: ['user'],\n      permissions: ['read:profile']\n    });\n    \n    // Generate token\n    const token = authService.generateToken(user);\n    \n    res.status(201).json({\n      token,\n      user: {\n        id: user.id,\n        email: user.email,\n        name: user.name\n      }\n    });\n  } catch (error) {\n    console.error('Registration error:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Protected route with authorization\napp.get('/api/admin/users', \n  authorizationService.requireRole('admin'),\n  async (req, res) => {\n    try {\n      const users = await userRepository.findAll();\n      res.json(users);\n    } catch (error) {\n      console.error('Error fetching users:', error);\n      res.status(500).json({ error: 'Internal server error' });\n    }\n  }\n);\n\n// Protection against NoSQL injection\napp.get('/api/users/:id', async (req, res) => {\n  try {\n    // Validate ID format to prevent NoSQL injection\n    if (!/^[a-fA-F0-9]{24}$/.test(req.params.id)) {\n      return res.status(400).json({ error: 'Invalid user ID format' });\n    }\n    \n    const user = await userRepository.findById(req.params.id);\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json({\n      id: user.id,\n      email: user.email,\n      name: user.name\n    });\n  } catch (error) {\n    console.error('Error fetching user:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\n// Secure file upload\nconst multer = require('multer');\nconst path = require('path');\nconst crypto = require('crypto');\n\n// Configure multer with security restrictions\nconst upload = multer({\n  dest: 'uploads/',\n  limits: {\n    fileSize: 5 * 1024 * 1024, // 5MB limit\n  },\n  fileFilter: (req, file, cb) => {\n    // Allow only specific file types\n    const allowedTypes = /jpeg|jpg|png|gif|pdf/;\n    const extname = allowedTypes.test(path.extname(file.originalname).toLowerCase());\n    const mimetype = allowedTypes.test(file.mimetype);\n    \n    if (mimetype && extname) {\n      return cb(null, true);\n    } else {\n      cb(new Error('Only images and PDFs are allowed'));\n    }\n  }\n});\n\n// Secure file upload endpoint\napp.post('/api/upload', upload.single('file'), (req, res) => {\n  if (!req.file) {\n    return res.status(400).json({ error: 'No file uploaded' });\n  }\n  \n  // Generate secure filename\n  const filename = crypto.randomBytes(16).toString('hex') + path.extname(req.file.originalname);\n  \n  // Move file to secure location\n  const fs = require('fs');\n  const newPath = path.join('secure_uploads/', filename);\n  fs.renameSync(req.file.path, newPath);\n  \n  res.json({\n    message: 'File uploaded successfully',\n    filename: filename\n  });\n});\n\n// Error handling middleware for security\napp.use((error, req, res, next) => {\n  // Don't expose internal errors to client\n  if (error instanceof multer.MulterError) {\n    if (error.code === 'LIMIT_FILE_SIZE') {\n      return res.status(400).json({ error: 'File too large' });\n    }\n  }\n  \n  // Log error for debugging (without sensitive data)\n  console.error('Error:', error.message);\n  \n  // Send generic error response\n  res.status(500).json({ error: 'Internal server error' });\n});\n\n// Security monitoring and logging\nconst winston = require('winston');\n\nconst logger = winston.createLogger({\n  level: 'info',\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  defaultMeta: { service: 'node-app' },\n  transports: [\n    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'logs/security.log', level: 'warn' }),\n    new winston.transports.File({ filename: 'logs/combined.log' })\n  ]\n});\n\n// Security event logging\napp.use((req, res, next) => {\n  // Log security-relevant events\n  if (req.path.includes('/auth/') || req.method !== 'GET') {\n    logger.warn('Security event', {\n      method: req.method,\n      url: req.url,\n      ip: req.ip,\n      userAgent: req.get('user-agent'),\n      timestamp: new Date().toISOString()\n    });\n  }\n  \n  next();\n});\n\napp.listen(3000, () => {\n  console.log('Secure Node.js app listening on port 3000');\n});",
    "explanation": "This example demonstrates comprehensive security best practices including:\n\n1. JWT-based authentication with secure password handling\n2. Security headers with Helmet middleware\n3. Rate limiting to prevent brute force attacks\n4. Input validation and sanitization with express-validator\n5. Role-based and permission-based authorization\n6. Protection against injection attacks (SQL/NoSQL)\n7. Secure file upload handling\n8. Security-focused error handling and logging\n\nThese security measures work together to create a defense-in-depth approach that protects against common web vulnerabilities while maintaining usability.",
    "language": "javascript"
  },
  "pitfalls": [
    {
      "mistake": "Storing passwords or secrets in plain text or using weak hashing algorithms",
      "solution": "Always use strong, salted hashing algorithms like bcrypt for passwords and store secrets in environment variables or secure vaults",
      "severity": "critical"
    },
    {
      "mistake": "Not validating and sanitizing user input, leading to injection vulnerabilities",
      "solution": "Implement comprehensive input validation at the boundaries of your application and sanitize all user-provided data before processing",
      "severity": "critical"
    },
    {
      "mistake": "Exposing internal errors and stack traces to clients",
      "solution": "Implement proper error handling that logs detailed errors server-side while returning generic error messages to clients",
      "severity": "high"
    }
  ],
  "exercises": [
    {
      "title": "Implement Comprehensive Security for a Node.js Application",
      "description": "Create a secure Node.js application with authentication, authorization, input validation, and security monitoring",
      "checkpoints": [
        "Implement JWT-based authentication with secure password handling",
        "Add security headers and rate limiting",
        "Create input validation and sanitization for all endpoints",
        "Build role-based and permission-based authorization",
        "Implement secure file upload handling",
        "Add security logging and monitoring"
      ]
    }
  ],
  "next": ["node-fundamentals-lesson-15"],
  "estimatedMinutes": 65,
  "difficulty": "Advanced",
  "tags": [
    "Security",
    "Authentication",
    "Authorization",
    "Vulnerability Management",
    "Node.js"
  ],
  "lastUpdated": "2025-10-03T00:00:00.000Z",
  "version": "1.0.0"
}