[
  {
    "id": 1,
    "topic": "Web Security",
    "title": "Web Security Fundamentals",
    "description": "Learn about common web security vulnerabilities and threats, authentication and authorization best practices, and secure coding practices to prevent attacks.",
    "codeExample": "function validateInput(input) {\n  // Simple input validation\n  return input.replace(/[<>]/g, '');\n}",
    "output": "Basic input validation function that removes potentially harmful characters."
  },
  {
    "id": 2,
    "topic": "OWASP Top 10",
    "title": "OWASP Top 10 Security Risks",
    "description": "Dive deep into each of the OWASP Top 10 security risks, learning how they occur, what damage they can cause, and most importantly, how to prevent them.",
    "codeExample": "// OWASP Top 10 Security Risk Prevention Examples\n\n// 1. Injection Prevention (SQL Injection Example)\n// Vulnerable code - NEVER do this:\n// const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n\n// Secure approach using parameterized queries:\nclass SecureUserRepository {\n  static async authenticateUser(username, password) {\n    // Parameterized query prevents SQL injection\n    const query = 'SELECT * FROM users WHERE username = ? AND active = 1';\n    const [users] = await db.execute(query, [username]);\n    \n    if (users.length === 0) return null;\n    \n    const user = users[0];\n    const isValidPassword = await bcrypt.compare(password, user.password_hash);\n    \n    return isValidPassword ? user : null;\n  }\n  \n  // Command injection prevention\n  static async getUserFiles(userId) {\n    // Validate input to prevent command injection\n    if (!Number.isInteger(userId) || userId <= 0) {\n      throw new Error('Invalid user ID');\n    }\n    \n    // Use path.join and validate paths to prevent directory traversal\n    const userDir = path.join('/user_files', userId.toString());\n    \n    // Additional validation to ensure path is within allowed directory\n    if (!userDir.startsWith('/user_files/')) {\n      throw new Error('Access denied');\n    }\n    \n    return fs.readdirSync(userDir);\n  }\n}\n\n// 2. Broken Authentication Prevention\nconst crypto = require('crypto');\n\nclass SecureAuthService {\n  // Implement account lockout after failed attempts\n  static async loginWithLockout(username, password, maxAttempts = 5, lockoutTime = 900000) { // 15 minutes\n    const user = await UserRepository.findByUsername(username);\n    \n    if (!user) return null;\n    \n    // Check if account is locked\n    if (user.locked_until && new Date(user.locked_until) > new Date()) {\n      throw new Error('Account temporarily locked due to multiple failed attempts');\n    }\n    \n    const isValid = await bcrypt.compare(password, user.password_hash);\n    \n    if (isValid) {\n      // Reset failed attempts on successful login\n      await UserRepository.resetFailedAttempts(user.id);\n      return this.generateToken(user);\n    } else {\n      // Increment failed attempts\n      const updatedUser = await UserRepository.incrementFailedAttempts(user.id);\n      \n      // Lock account if max attempts exceeded\n      if (updatedUser.failed_attempts >= maxAttempts) {\n        await UserRepository.lockAccount(user.id, new Date(Date.now() + lockoutTime));\n        throw new Error('Account locked due to multiple failed attempts');\n      }\n      \n      return null;\n    }\n  }\n  \n  // Secure password reset with time-limited tokens\n  static async generatePasswordResetToken(email) {\n    const user = await UserRepository.findByEmail(email);\n    if (!user) return;\n    \n    // Generate secure random token\n    const token = crypto.randomBytes(32).toString('hex');\n    const expiresAt = new Date(Date.now() + 3600000); // 1 hour\n    \n    await UserRepository.savePasswordResetToken(user.id, token, expiresAt);\n    \n    // Send email with reset link (implementation not shown)\n    await emailService.sendPasswordReset(email, token);\n  }\n  \n  static async resetPassword(token, newPassword) {\n    const user = await UserRepository.findByPasswordResetToken(token);\n    \n    if (!user || new Date(user.reset_token_expires) < new Date()) {\n      throw new Error('Invalid or expired reset token');\n    }\n    \n    // Validate password strength\n    if (newPassword.length < 12) {\n      throw new Error('Password must be at least 12 characters long');\n    }\n    \n    const hashedPassword = await bcrypt.hash(newPassword, 12);\n    await UserRepository.updatePassword(user.id, hashedPassword);\n    await UserRepository.clearPasswordResetToken(user.id);\n  }\n}\n\n// 3. Sensitive Data Exposure Prevention\nconst crypto = require('crypto');\n\nclass DataProtectionService {\n  // Encrypt sensitive data\n  static encryptData(data, key) {\n    const algorithm = 'aes-256-gcm';\n    const iv = crypto.randomBytes(16);\n    \n    const cipher = crypto.createCipher(algorithm, key);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return {\n      encryptedData: encrypted,\n      iv: iv.toString('hex'),\n      authTag: authTag.toString('hex')\n    };\n  }\n  \n  // Decrypt sensitive data\n  static decryptData(encryptedObj, key) {\n    const { encryptedData, iv, authTag } = encryptedObj;\n    const algorithm = 'aes-256-gcm';\n    \n    const decipher = crypto.createDecipher(algorithm, key);\n    decipher.setAuthTag(Buffer.from(authTag, 'hex'));\n    \n    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  }\n  \n  // Hash sensitive data that doesn't need to be decrypted\n  static hashData(data) {\n    return crypto.createHash('sha256').update(data).digest('hex');\n  }\n  \n  // Securely store passwords\n  static async hashPassword(password) {\n    const salt = crypto.randomBytes(32).toString('hex');\n    const hashed = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n    return `${salt}:${hashed}`;\n  }\n  \n  static async verifyPassword(password, hashedPassword) {\n    const [salt, hash] = hashedPassword.split(':');\n    const hashed = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n    return hashed === hash;\n  }\n}\n\n// 4. XML External Entities (XXE) Prevention\nconst { XMLParser } = require('fast-xml-parser');\n\nclass SecureXMLProcessor {\n  static parseXML(xmlString) {\n    // Disable external entities to prevent XXE attacks\n    const options = {\n      ignoreAttributes: false,\n      allowBooleanAttributes: true,\n      parseAttributeValue: true,\n      // Critical: Disable external entities\n      ignoreDeclaration: true,\n      ignorePiTags: true,\n      // Prevent billion laughs attack\n      maxFileSize: 5 * 1024 * 1024, // 5MB limit\n      // Disable DTD processing\n      allowDTD: false\n    };\n    \n    const parser = new XMLParser(options);\n    return parser.parse(xmlString);\n  }\n}\n\n// 5. Broken Access Control Prevention\nfunction requirePermission(requiredPermission) {\n  return async (req, res, next) => {\n    try {\n      const user = req.user;\n      \n      // Check if user has the required permission\n      const hasPermission = await UserRepository.hasPermission(user.id, requiredPermission);\n      \n      if (!hasPermission) {\n        return res.status(403).json({ error: 'Insufficient permissions' });\n      }\n      \n      next();\n    } catch (error) {\n      return res.status(500).json({ error: 'Permission check failed' });\n    }\n  };\n}\n\n// Example usage in routes\napp.get('/api/users/:id', authenticateToken, async (req, res) => {\n  try {\n    const userId = parseInt(req.params.id);\n    \n    // Check if user can access this resource\n    if (req.user.id !== userId && req.user.role !== 'admin') {\n      return res.status(403).json({ error: 'Access denied' });\n    }\n    \n    const user = await UserRepository.findById(userId);\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json(user);\n  } catch (error) {\n    res.status(500).json({ error: 'Server error' });\n  }\n});\n\n// 6. Security Misconfiguration Prevention\n// Environment-specific configuration\nconst config = {\n  development: {\n    logging: true,\n    debug: true\n  },\n  production: {\n    logging: false,\n    debug: false,\n    // Security headers\n    securityHeaders: {\n      'X-Content-Type-Options': 'nosniff',\n      'X-Frame-Options': 'DENY',\n      'X-XSS-Protection': '1; mode=block',\n      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',\n      'Content-Security-Policy': \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';\"\n    }\n  }\n};\n\n// Apply security headers in production\nif (process.env.NODE_ENV === 'production') {\n  app.use((req, res, next) => {\n    Object.entries(config.production.securityHeaders).forEach(([header, value]) => {\n      res.setHeader(header, value);\n    });\n    next();\n  });\n}",
    "output": "Comprehensive security implementation covering injection prevention, secure authentication with account lockout, data encryption, XXE prevention, access control, and security misconfiguration handling."
  },
  {
    "id": 3,
    "topic": "Input Validation",
    "title": "Input Validation and Data Sanitization",
    "description": "Learn the principles of secure input validation including whitelist and blacklist validation approaches, data type validation, range checking, and format validation.",
    "codeExample": "// Comprehensive Input Validation and Data Sanitization Implementation\n\n// 1. Input Validation Utilities\nconst validator = require('validator');\n\nclass InputValidator {\n  // Email validation with multiple checks\n  static validateEmail(email) {\n    // Basic format check\n    if (!validator.isEmail(email)) {\n      throw new Error('Invalid email format');\n    }\n    \n    // Length check\n    if (email.length > 254) {\n      throw new Error('Email too long');\n    }\n    \n    // Domain validation\n    const domain = email.split('@')[1];\n    if (!validator.isFQDN(domain)) {\n      throw new Error('Invalid domain in email');\n    }\n    \n    return email.toLowerCase().trim();\n  }\n  \n  // Username validation\n  static validateUsername(username) {\n    // Length check\n    if (username.length < 3 || username.length > 30) {\n      throw new Error('Username must be between 3 and 30 characters');\n    }\n    \n    // Character validation (alphanumeric, underscore, hyphen only)\n    if (!/^[a-zA-Z0-9_-]+$/.test(username)) {\n      throw new Error('Username can only contain letters, numbers, underscores, and hyphens');\n    }\n    \n    // No consecutive special characters\n    if (/[-_]{2,}/.test(username)) {\n      throw new Error('Username cannot contain consecutive special characters');\n    }\n    \n    // Cannot start or end with special characters\n    if (/^[-_]|[-_]$/.test(username)) {\n      throw new Error('Username cannot start or end with special characters');\n    }\n    \n    return username;\n  }\n  \n  // Password validation\n  static validatePassword(password) {\n    // Length check\n    if (password.length < 12) {\n      throw new Error('Password must be at least 12 characters long');\n    }\n    \n    // Complexity checks\n    if (!/(?=.*[a-z])/.test(password)) {\n      throw new Error('Password must contain at least one lowercase letter');\n    }\n    \n    if (!/(?=.*[A-Z])/.test(password)) {\n      throw new Error('Password must contain at least one uppercase letter');\n    }\n    \n    if (!/(?=.*\\d)/.test(password)) {\n      throw new Error('Password must contain at least one digit');\n    }\n    \n    if (!/(?=.*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?])/.test(password)) {\n      throw new Error('Password must contain at least one special character');\n    }\n    \n    // No common patterns\n    const commonPasswords = ['password', '12345678', 'qwerty'];\n    if (commonPasswords.some(common => password.toLowerCase().includes(common))) {\n      throw new Error('Password contains common patterns');\n    }\n    \n    return password;\n  }\n  \n  // Phone number validation\n  static validatePhoneNumber(phone) {\n    // Remove all non-digit characters\n    const digitsOnly = phone.replace(/\\D/g, '');\n    \n    // Check length (assuming US format)\n    if (digitsOnly.length !== 10 && digitsOnly.length !== 11) {\n      throw new Error('Invalid phone number format');\n    }\n    \n    // Format consistently\n    if (digitsOnly.length === 11 && digitsOnly[0] !== '1') {\n      throw new Error('Invalid country code');\n    }\n    \n    return digitsOnly;\n  }\n  \n  // URL validation\n  static validateURL(url) {\n    if (!validator.isURL(url, {\n      protocols: ['http', 'https'],\n      require_tld: true,\n      require_protocol: true,\n      allow_underscores: false,\n      host_whitelist: [],\n      host_blacklist: ['localhost', '127.0.0.1'],\n      allow_trailing_dot: false,\n      allow_protocol_relative_urls: false,\n      disallow_auth: true\n    })) {\n      throw new Error('Invalid URL');\n    }\n    \n    // Additional checks\n    const parsedUrl = new URL(url);\n    if (parsedUrl.hostname.length > 253) {\n      throw new Error('URL hostname too long');\n    }\n    \n    return url;\n  }\n}\n\n// 2. Data Sanitization Functions\nconst xss = require('xss');\n\nclass DataSanitizer {\n  // HTML sanitization to prevent XSS\n  static sanitizeHTML(input) {\n    if (typeof input !== 'string') return input;\n    \n    // Use a whitelist approach\n    const options = {\n      whiteList: {\n        a: ['href', 'title'],\n        b: [],\n        i: [],\n        strong: [],\n        em: [],\n        p: [],\n        br: [],\n        ul: [],\n        ol: [],\n        li: []\n      },\n      stripIgnoreTag: true, // Strip all tags not in whitelist\n      stripIgnoreTagBody: ['script'] // Remove script tag content\n    };\n    \n    return xss(input, options);\n  }\n  \n  // JavaScript string escaping\n  static escapeJS(input) {\n    if (typeof input !== 'string') return input;\n    \n    return input\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/'/g, '\\\\\\'')\n      .replace(/\\\"/g, '\\\\\\\"')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/</g, '\\\\u003c')\n      .replace(/>/g, '\\\\u003e');\n  }\n  \n  // CSS escaping\n  static escapeCSS(input) {\n    if (typeof input !== 'string') return input;\n    \n    return input.replace(/[\\\"'();\\\\]/g, '\\\\$&');\n  }\n  \n  // URL parameter encoding\n  static encodeURLParam(param) {\n    return encodeURIComponent(param);\n  }\n  \n  // SQL value escaping (for cases where parameterized queries aren't possible)\n  static escapeSQLValue(value) {\n    if (typeof value !== 'string') return value;\n    \n    return value\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/'/g, \"''\") // Escape single quotes\n      .replace(/\\\"/g, '\\\\\\\"') // Escape double quotes\n      .replace(/\\x00/g, '\\\\0') // Null byte\n      .replace(/\\n/g, '\\\\n') // Newline\n      .replace(/\\r/g, '\\\\r') // Carriage return\n      .replace(/\\x1a/g, '\\\\Z'); // Substitute character\n  }\n}\n\n// 3. File Upload Security\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs').promises;\nconst { exec } = require('child_process');\nconst util = require('util');\n\nconst execPromise = util.promisify(exec);\n\n// Configure multer with security restrictions\nconst upload = multer({\n  storage: multer.diskStorage({\n    destination: async (req, file, cb) => {\n      // Create user-specific directory\n      const uploadDir = path.join(__dirname, 'uploads', req.user.id.toString());\n      \n      try {\n        await fs.mkdir(uploadDir, { recursive: true });\n        cb(null, uploadDir);\n      } catch (error) {\n        cb(new Error('Failed to create upload directory'), null);\n      }\n    },\n    filename: (req, file, cb) => {\n      // Generate safe filename\n      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n      const ext = path.extname(file.originalname).toLowerCase();\n      const basename = path.basename(file.originalname, ext);\n      \n      // Sanitize filename\n      const safeBasename = basename.replace(/[^a-zA-Z0-9_-]/g, '_');\n      \n      cb(null, `${safeBasename}-${uniqueSuffix}${ext}`);\n    }\n  }),\n  limits: {\n    fileSize: 5 * 1024 * 1024, // 5MB limit\n    files: 1 // Single file upload\n  },\n  fileFilter: (req, file, cb) => {\n    // Whitelist allowed file types\n    const allowedTypes = [\n      'image/jpeg',\n      'image/png',\n      'image/gif',\n      'application/pdf',\n      'text/plain'\n    ];\n    \n    if (allowedTypes.includes(file.mimetype)) {\n      cb(null, true);\n    } else {\n      cb(new Error('Invalid file type'), false);\n    }\n  }\n});\n\n// File validation service\nclass FileValidationService {\n  static async validateFile(filePath, mimeType) {\n    try {\n      // Check file size\n      const stats = await fs.stat(filePath);\n      if (stats.size > 5 * 1024 * 1024) { // 5MB\n        throw new Error('File too large');\n      }\n      \n      // Validate file extension matches content\n      const ext = path.extname(filePath).toLowerCase();\n      const validExtensions = {\n        'image/jpeg': ['.jpg', '.jpeg'],\n        'image/png': ['.png'],\n        'image/gif': ['.gif'],\n        'application/pdf': ['.pdf'],\n        'text/plain': ['.txt']\n      };\n      \n      if (!validExtensions[mimeType] || !validExtensions[mimeType].includes(ext)) {\n        throw new Error('File extension does not match content type');\n      }\n      \n      // For images, validate with ImageMagick or similar tool\n      if (mimeType.startsWith('image/')) {\n        await this.validateImage(filePath);\n      }\n      \n      // For PDFs, validate with pdfinfo or similar\n      if (mimeType === 'application/pdf') {\n        await this.validatePDF(filePath);\n      }\n      \n      return true;\n    } catch (error) {\n      throw new Error(`File validation failed: ${error.message}`);\n    }\n  }\n  \n  static async validateImage(filePath) {\n    try {\n      // Use ImageMagick to validate image\n      const { stdout } = await execPromise(`identify -format '%m' '${filePath}'`);\n      if (!stdout) {\n        throw new Error('Invalid image file');\n      }\n    } catch (error) {\n      throw new Error('Image validation failed');\n    }\n  }\n  \n  static async validatePDF(filePath) {\n    try {\n      // Use pdfinfo to validate PDF\n      const { stdout } = await execPromise(`pdfinfo '${filePath}'`);\n      if (!stdout.includes('Pages:')) {\n        throw new Error('Invalid PDF file');\n      }\n    } catch (error) {\n      throw new Error('PDF validation failed');\n    }\n  }\n  \n  // Scan file for malware (integration with ClamAV or similar)\n  static async scanForMalware(filePath) {\n    try {\n      const { stdout } = await execPromise(`clamdscan --no-summary '${filePath}'`);\n      if (stdout.includes('FOUND')) {\n        throw new Error('Malware detected in file');\n      }\n      return true;\n    } catch (error) {\n      throw new Error('Malware scan failed');\n    }\n  }\n}\n\n// Express route with secure file upload\napp.post('/api/upload', authenticateToken, upload.single('file'), async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ error: 'No file uploaded' });\n    }\n    \n    // Validate file\n    await FileValidationService.validateFile(req.file.path, req.file.mimetype);\n    \n    // Scan for malware\n    await FileValidationService.scanForMalware(req.file.path);\n    \n    // Store file reference in database\n    const fileRecord = await FileRepository.create({\n      userId: req.user.id,\n      filename: req.file.filename,\n      originalName: req.file.originalname,\n      mimeType: req.file.mimetype,\n      size: req.file.size,\n      path: req.file.path\n    });\n    \n    res.json({\n      message: 'File uploaded successfully',\n      fileId: fileRecord.id\n    });\n  } catch (error) {\n    // Clean up uploaded file on error\n    if (req.file && req.file.path) {\n      try {\n        await fs.unlink(req.file.path);\n      } catch (unlinkError) {\n        console.error('Failed to clean up file:', unlinkError);\n      }\n    }\n    \n    res.status(400).json({ error: error.message });\n  }\n});\n\n// 4. Validation Middleware\nfunction validateRequest(schema) {\n  return (req, res, next) => {\n    try {\n      // Validate request body\n      if (schema.body) {\n        Object.keys(schema.body).forEach(field => {\n          const validatorFunc = schema.body[field];\n          if (req.body[field] !== undefined) {\n            req.body[field] = validatorFunc(req.body[field]);\n          }\n        });\n      }\n      \n      // Validate query parameters\n      if (schema.query) {\n        Object.keys(schema.query).forEach(field => {\n          const validatorFunc = schema.query[field];\n          if (req.query[field] !== undefined) {\n            req.query[field] = validatorFunc(req.query[field]);\n          }\n        });\n      }\n      \n      // Validate route parameters\n      if (schema.params) {\n        Object.keys(schema.params).forEach(field => {\n          const validatorFunc = schema.params[field];\n          if (req.params[field] !== undefined) {\n            req.params[field] = validatorFunc(req.params[field]);\n          }\n        });\n      }\n      \n      next();\n    } catch (error) {\n      res.status(400).json({ error: error.message });\n    }\n  };\n}\n\n// Usage example\nconst userSchema = {\n  body: {\n    email: InputValidator.validateEmail,\n    username: InputValidator.validateUsername,\n    password: InputValidator.validatePassword\n  }\n};\n\napp.post('/api/users', validateRequest(userSchema), async (req, res) => {\n  try {\n    // At this point, req.body is validated and safe to use\n    const user = await UserService.create(req.body);\n    res.status(201).json(user);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to create user' });\n  }\n});",
    "output": "Comprehensive input validation and data sanitization implementation including email, username, and password validation; HTML, JavaScript, and CSS sanitization; secure file upload handling with validation and malware scanning; and reusable validation middleware for Express applications."
  },
  {
    "id": 4,
    "topic": "Performance Testing",
    "title": "Security Performance Testing and Optimization",
    "description": "Learn how to conduct performance testing specifically for security features, including authentication systems, encryption processes, access controls, and logging mechanisms.",
    "codeExample": "// Security Performance Testing and Optimization Implementation\\n\\n// 1. Secure Authentication Performance Testing\\nconst bcrypt = require('bcrypt');\\nconst crypto = require('crypto');\\n\\n// Benchmark different bcrypt cost factors\\nasync function benchmarkBcryptCost(password, minCost = 10, maxCost = 14) {\\n  const results = [];\\n  \\n  for (let cost = minCost; cost <= maxCost; cost++) {\\n    const startTime = process.hrtime.bigint();\\n    await bcrypt.hash(password, cost);\\n    const endTime = process.hrtime.bigint();\\n    \\n    const durationMs = Number(endTime - startTime) / 1000000;\\n    results.push({\\n      cost,\\n      durationMs,\\n      recommendation: durationMs < 100 ? 'Acceptable' : \\n                     durationMs < 250 ? 'Consider optimization' : 'Too slow for interactive use'\\n    });\\n  }\\n  \\n  return results;\\n}\\n\\n// Optimized session management with caching\\nclass OptimizedSessionManager {\\n  constructor(redisClient, cacheTtl = 3600) {\\n    this.redis = redisClient;\\n    this.cacheTtl = cacheTtl;\\n  }\\n  \\n  async createSession(userId, permissions) {\\n    const sessionId = crypto.randomBytes(32).toString('hex');\\n    const sessionData = {\\n      userId,\\n      permissions,\\n      createdAt: Date.now(),\\n      lastAccessed: Date.now()\\n    };\\n    \\n    // Store in Redis with expiration\\n    await this.redis.setex(\\`session:${sessionId}\\`, \\n      this.cacheTtl, \\n      JSON.stringify(sessionData)\\n    );\\n    \\n    return sessionId;\\n  }\\n  \\n  async validateSession(sessionId) {\\n    // First check if session exists\\n    const sessionStr = await this.redis.get(\\`session:${sessionId}\\`);\\n    if (!sessionStr) return null;\\n    \\n    const session = JSON.parse(sessionStr);\\n    \\n    // Update last accessed time\\n    session.lastAccessed = Date.now();\\n    await this.redis.setex(\\`session:${sessionId}\\`, \\n      this.cacheTtl, \\n      JSON.stringify(session)\\n    );\\n    \\n    return session;\\n  }\\n  \\n  async destroySession(sessionId) {\\n    await this.redis.del(\\`session:${sessionId}\\`);\\n  }\\n}\\n\\n// 2. Rate Limiting with Performance Considerations\\nclass PerformanceOptimizedRateLimiter {\\n  constructor(redisClient) {\\n    this.redis = redisClient;\\n  }\\n  \\n  async isAllowed(identifier, maxRequests = 100, windowSeconds = 60) {\\n    const key = \\`rate_limit:${identifier}\\`;\\n    const now = Math.floor(Date.now() / 1000);\\n    const windowStart = now - windowSeconds;\\n    \\n    // Use Redis pipeline for atomic operations\\n    const pipeline = this.redis.multi();\\n    \\n    // Remove expired entries\\n    pipeline.zremrangebyscore(key, 0, windowStart);\\n    \\n    // Add current request\\n    pipeline.zadd(key, now, \\`\\${now}-\\${Math.random()}\\`);\\n    \\n    // Set expiration\\n    pipeline.expire(key, windowSeconds);\\n    \\n    // Get count\\n    pipeline.zcard(key);\\n    \\n    const results = await pipeline.exec();\\n    const requestCount = results[3][1]; // Result of zcard\\n    \\n    return {\\n      allowed: requestCount <= maxRequests,\\n      count: requestCount,\\n      remaining: Math.max(0, maxRequests - requestCount)\\n    };\\n  }\\n}\\n\\n// 3. Efficient Access Control with Caching\\nclass CachedAccessControl {\\n  constructor(redisClient, db) {\\n    this.redis = redisClient;\\n    this.db = db;\\n    this.cacheTtl = 300; // 5 minutes\\n  }\\n  \\n  async hasPermission(userId, resource, action) {\\n    const cacheKey = \\`permission:${userId}:${resource}:${action}\\`;\\n    \\n    // Try cache first\\n    const cachedResult = await this.redis.get(cacheKey);\\n    if (cachedResult !== null) {\\n      return cachedResult === 'true';\\n    }\\n    \\n    // Check database if not in cache\\n    const hasPermission = await this.db.checkPermission(userId, resource, action);\\n    \\n    // Cache result\\n    await this.redis.setex(\\n      cacheKey, \\n      this.cacheTtl, \\n      hasPermission ? 'true' : 'false'\\n    );\\n    \\n    return hasPermission;\\n  }\\n  \\n  // Invalidate cache when permissions change\\n  async invalidateUserPermissions(userId) {\\n    const pattern = \\`permission:${userId}:*\\`;\\n    const keys = await this.redis.keys(pattern);\\n    if (keys.length > 0) {\\n      await this.redis.del(...keys);\\n    }\\n  }\\n}\\n\\n// 4. Cryptographic Operation Optimization\\nconst crypto = require('crypto');\\n\\n// Use streaming for large data encryption\\nfunction encryptLargeFile(inputStream, outputStream, key) {\\n  const algorithm = 'aes-256-gcm';\\n  const iv = crypto.randomBytes(16);\\n  \\n  const cipher = crypto.createCipher(algorithm, key);\\n  \\n  // Write IV to output stream\\n  outputStream.write(iv);\\n  \\n  // Stream encryption\\n  inputStream.pipe(cipher).pipe(outputStream);\\n  \\n  return new Promise((resolve, reject) => {\\n    cipher.on('end', resolve);\\n    cipher.on('error', reject);\\n  });\\n}\\n\\n// Batch processing for multiple small operations\\nasync function batchHashPasswords(passwords, saltRounds = 12) {\\n  const results = [];\\n  \\n  // Process in smaller batches to avoid blocking the event loop\\n  const batchSize = 10;\\n  \\n  for (let i = 0; i < passwords.length; i += batchSize) {\\n    const batch = passwords.slice(i, i + batchSize);\\n    const batchResults = await Promise.all(\\n      batch.map(password => bcrypt.hash(password, saltRounds))\\n    );\\n    results.push(...batchResults);\\n    \\n    // Allow event loop to process other tasks\\n    await new Promise(resolve => setImmediate(resolve));\\n  }\\n  \\n  return results;\\n}\\n\\n// 5. Security Performance Testing Utilities\\nconst autocannon = require('autocannon');\\n\\nasync function securityPerformanceTest(url, requests, connections) {\\n  const result = await autocannon({\\n    url,\\n    requests,\\n    connections,\\n    duration: 30, // 30 seconds\\n    pipelining: 1,\\n    setupClient: (client) => {\\n      // Add authentication token for security testing\\n      client.on('headers', {\\n        authorization: 'Bearer test-token'\\n      });\\n    }\\n  });\\n  \\n  return {\\n    requestsPerSecond: result.requests.average,\\n    latency: result.latency.average,\\n    throughput: result.throughput.average,\\n    errors: result.errors,\\n    timeouts: result.timeouts\\n  };\\n}\\n\\n// Example usage\\napp.post('/api/login', async (req, res) => {\\n  try {\\n    const { email, password } = req.body;\\n    \\n    // Simulate optimized authentication\\n    const user = await UserRepository.findByEmail(email);\\n    if (!user) {\\n      return res.status(401).json({ error: 'Invalid credentials' });\\n    }\\n    \\n    const isValid = await bcrypt.compare(password, user.password_hash);\\n    if (!isValid) {\\n      return res.status(401).json({ error: 'Invalid credentials' });\\n    }\\n    \\n    // Create optimized session\\n    const sessionId = await sessionManager.createSession(user.id, user.permissions);\\n    \\n    res.json({ \\n      token: sessionId,\\n      user: { id: user.id, email: user.email }\\n    });\\n  } catch (error) {\\n    res.status(500).json({ error: 'Authentication failed' });\\n  }\\n});",
    "output": "Security performance optimization implementation including bcrypt cost factor benchmarking, optimized session management with Redis caching, performance-optimized rate limiting using Redis pipelines, cached access control to reduce database queries, streaming encryption for large files, batch processing for cryptographic operations, and security-focused performance testing utilities."
  },
  {
    "id": 5,
    "topic": "Buffer Overflow",
    "title": "Memory Safety and Buffer Overflow Prevention",
    "description": "Understand classic buffer overflows and modern mitigations: bounds checking, safer libraries, stack canaries, ASLR, and DEP.",
    "codeExample": "#include <stdio.h>\n#include <string.h>\n\nvoid unsafe_copy(char *dest, const char *src) {\n  strcpy(dest, src);\n}\n\nvoid safe_copy(char *dest, size_t dest_size, const char *src) {\n  strncpy(dest, src, dest_size - 1);\n  dest[dest_size - 1] = '\\0';\n}\n\nint main() {\n  char dest[16];\n  const char *input = \"AAAAAAAAAAAAAAAAAAAAAAAAAAAA\";\n  safe_copy(dest, sizeof(dest), input);\n  printf(\"%s\", dest);\n  return 0;\n}",
    "output": "Demonstrates safe bounded copy to prevent stack-based buffer overflow."
  },
  {
    "id": 6,
    "topic": "Account Lockout",
    "title": "Brute-force Mitigation with Account Lockout",
    "description": "Implement rate limiting and lockout thresholds to counter credential stuffing and brute-force attacks.",
    "codeExample": "class AuthThrottle {\n  constructor(store, maxAttempts = 5, lockoutMs = 900000) {\n    this.store = store;\n    this.maxAttempts = maxAttempts;\n    this.lockoutMs = lockoutMs;\n  }\n  async recordAttempt(userId, success) {\n    const key = 'auth:' + userId;\n    const rec = (await this.store.get(key)) || { attempts: 0, lockedUntil: 0 };\n    const now = Date.now();\n    if (rec.lockedUntil && rec.lockedUntil > now) {\n      return { locked: true, until: rec.lockedUntil };\n    }\n    if (success) {\n      await this.store.set(key, { attempts: 0, lockedUntil: 0 });\n      return { locked: false };\n    }\n    rec.attempts += 1;\n    if (rec.attempts >= this.maxAttempts) {\n      rec.lockedUntil = now + this.lockoutMs;\n    }\n    await this.store.set(key, rec);\n    return { locked: !!rec.lockedUntil, until: rec.lockedUntil };\n  }\n}",
    "output": "Shows time-bound account lockout after repeated failed authentication attempts."
  },
  {
    "id": 7,
    "topic": "CSP",
    "title": "Content Security Policy for XSS Mitigation",
    "description": "Author effective CSPs: directives for script-src, style-src, frame-ancestors, object-src, and reporting; use nonce/hash policies.",
    "codeExample": "// Express middleware setting CSP\napp.use((req, res, next) => {\n  const csp = \"default-src 'self'; script-src 'self' 'nonce-abc123'; style-src 'self' 'nonce-abc123'; img-src 'self' data:; frame-ancestors 'none'; object-src 'none'; base-uri 'self';\";\n  res.setHeader('Content-Security-Policy', csp);\n  next();\n});",
    "output": "Applies strict CSP with nonces to reduce script injection risk and clickjacking."
  },
  {
    "id": 8,
    "topic": "Social Engineering",
    "title": "Defenses Against Social Engineering",
    "description": "Phishing, pretexting, baiting, tailgating; layered defenses: MFA, training, just-in-time warnings, anomalous behavior detection.",
    "codeExample": "function detectPhishing(email) {\n  const suspiciousDomains = [/\\\\.ru$/, /\\\\.cn$/];\n  const indicators = [/urgent/i, /verify your account/i, /password expires/i];\n  const domainMatch = suspiciousDomains.some(rx => rx.test(email.from));\n  const contentMatch = indicators.some(rx => rx.test(email.body));\n  return domainMatch || contentMatch;\n}",
    "output": "Simple heuristic detection of potentially malicious messages to complement training and controls."
  },
  {
    "id": 9,
    "topic": "Security Audit",
    "title": "Planning and Executing Security Audits",
    "description": "Risk-based scoping, control testing, evidence collection, reporting, and remediation tracking aligned with ISO/IEC 27001.",
    "codeExample": "class AuditPlan {\n  constructor(scope, controls) {\n    this.scope = scope;\n    this.controls = controls;\n    this.evidence = [];\n  }\n  addEvidence(controlId, artifact) {\n    this.evidence.push({ controlId: controlId, artifact: artifact, timestamp: new Date().toISOString() });\n  }\n  summarize() {\n    const tested = new Set(this.evidence.map(e => e.controlId));\n    const remaining = this.controls.filter(c => !tested.has(c.id));\n    return { tested: tested.size, remaining: remaining.length };\n  }\n}",
    "output": "Provides an audit planning scaffold linking controls to evidence for defensible reporting."
  },
  {
    "id": 10,
    "topic": "Zero-day",
    "title": "Zero-day Vulnerabilities and Coordinated Disclosure",
    "description": "Discovery paths, exploit economics, and coordinated vulnerability disclosure (CVD): timelines, CVE assignment, patching, and communication.",
    "codeExample": "class DisclosureWorkflow {\n  constructor() {\n    this.state = 'identified';\n    this.timeline = [];\n  }\n  advance(step, note) {\n    this.timeline.push({ step: step, note: note, at: new Date().toISOString() });\n    this.state = step;\n  }\n}",
    "output": "Outlines CVD lifecycle tracking states and artifacts, grounding responsible disclosure practice."
  },
  {
    "id": 11,
    "topic": "Password Policy",
    "title": "Modern Password Policies and MFA Integration",
    "description": "Align with NIST SP 800-63B: prohibit common passwords, allow long passphrases, throttle guesses, pair with phishing-resistant MFA.",
    "codeExample": "async function validatePassword(pw, breachedSet) {\n  if (pw.length < 12) return false;\n  if (/\\s/.test(pw)) return false;\n  if (breachedSet.has(pw.toLowerCase())) return false;\n  return true;\n}",
    "output": "Checks include breached-password screening; complements MFA for strong assurance."
  },
  {
    "id": 12,
    "topic": "Secure Headers",
    "title": "HTTP Security Headers in Practice",
    "description": "Apply HSTS, X-Content-Type-Options, X-Frame-Options, Referrer-Policy, and robust CSP; discuss preload lists and subdomain coverage.",
    "codeExample": "app.use((req, res, next) => {\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains; preload');\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('Referrer-Policy', 'no-referrer');\n  res.setHeader('Content-Security-Policy', \"default-src 'self'\");\n  next();\n});",
    "output": "Configures core headers to reduce common web attack surfaces and enforce HTTPS."
  },
  {
    "id": 13,
    "topic": "Secure SDLC",
    "title": "Integrating Security into the SDLC",
    "description": "Embed threat modeling, secure code review, dependency scanning, SAST/DAST, and continuous security testing into agile workflows.",
    "codeExample": "const pipeline = {\n  stages: ['lint', 'test', 'sast', 'build', 'dast'],\n  gates: {\n    sast: { failOn: ['critical', 'high'] },\n    dast: { failOn: ['critical'] }\n  }\n};",
    "output": "Shows a simplified pipeline with security gates to prevent risky deployments."
  }
]
