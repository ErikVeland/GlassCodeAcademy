[
  {
    "id": 1,
    "topic": "Variables",
    "type": "multiple-choice",
    "question": "Which variable declaration is most appropriate for storing a user's age that might change over time?",
    "choices": [
      "let age = 25;",
      "const age = 25;",
      "var age = 25;",
      "age = 25;"
    ],
    "correctAnswer": 0,
    "explanation": "'let' is the correct choice because the user's age might change (when they have a birthday), so we need a variable that can be reassigned. 'const' is for constants that never change, 'var' has scope issues and should be avoided in modern JavaScript, and declaring without a keyword creates a global variable which is dangerous."
  },
  {
    "id": 2,
    "topic": "Control Structures",
    "type": "multiple-choice",
    "question": "What will this code output?\n\nlet x = 5;\nif (x > 3) {\n    console.log('A');\n} else if (x > 7) {\n    console.log('B');\n} else {\n    console.log('C');\n}",
    "choices": [
      "A",
      "B",
      "C",
      "Nothing (no output)"
    ],
    "correctAnswer": 0,
    "explanation": "The code will output 'A'. Since x = 5 and 5 > 3 is true, the first condition is met and 'A' is logged. The else if condition (x > 7) is never checked because the first condition was already true. In if-else chains, only the first true condition executes."
  },
  {
    "id": 3,
    "topic": "Functions",
    "type": "multiple-choice",
    "question": "Which function definition follows best practices for a function that calculates the total price including tax?",
    "choices": [
      "function calculateTotalPrice(price, taxRate) { return price + (price * taxRate); }",
      "function calc(p, t) { return p + p * t; }",
      "function calculatePrice() { return price + tax; }",
      "const calculate = () => { console.log(price * 1.08); }"
    ],
    "correctAnswer": 0,
    "explanation": "Option A follows best practices with a descriptive function name, clear parameter names, and returns a value instead of just logging. Option B uses unclear abbreviations, Option C relies on global variables which is bad practice, and Option D doesn't return a value and hardcodes the tax rate."
  },
  {
    "id": 4,
    "topic": "Control Structures",
    "type": "multiple-choice",
    "question": "What is wrong with this loop and how would you fix it?\n\nlet i = 0;\nwhile (i < 10) {\n    console.log(i);\n    // Missing something here\n}",
    "choices": [
      "Missing i++ or i = i + 1 to increment the counter",
      "Should use for loop instead of while loop",
      "The condition should be i <= 10",
      "Need to declare i inside the loop"
    ],
    "correctAnswer": 0,
    "explanation": "The loop is missing the increment statement (i++ or i = i + 1). Without incrementing i, the condition i < 10 will always be true, creating an infinite loop that will crash the program. The counter variable must be updated inside the loop body."
  },
  {
    "id": 5,
    "topic": "Data Types",
    "type": "multiple-choice",
    "question": "Which data type should you use to store whether a user is currently logged in?",
    "choices": [
      "boolean",
      "string",
      "number",
      "array"
    ],
    "correctAnswer": 0,
    "explanation": "Boolean is the correct data type for true/false values like login status. A boolean can only be true or false, making it perfect for yes/no, on/off, or logged-in/logged-out states. Strings and numbers could work but waste memory and allow invalid values."
  },
  {
    "id": 6,
    "topic": "Functions",
    "type": "multiple-choice",
    "question": "What will happen when this function is called with calculateDiscount(100)?\n\nfunction calculateDiscount(price, discountRate = 0.1) {\n    return price * discountRate;\n}",
    "choices": [
      "Returns 10 (using default discount rate of 0.1)",
      "Returns an error because discountRate is missing",
      "Returns 0 because discountRate is undefined",
      "Returns 100 because no discount is applied"
    ],
    "correctAnswer": 0,
    "explanation": "The function will return 10. When discountRate is not provided, it uses the default value of 0.1. So 100 * 0.1 = 10. Default parameters allow functions to work even when some arguments are omitted, making them more flexible and user-friendly."
  },
  {
    "id": 7,
    "topic": "Best Practices",
    "type": "multiple-choice",
    "question": "What are the key principles of writing clean, maintainable code?",
    "choices": [
      "Use meaningful variable names, keep functions small and focused, and add comments where necessary",
      "Write code as quickly as possible to meet deadlines",
      "Use single-letter variable names to keep code concise",
      "Put all code in one large function to reduce file count"
    ],
    "correctAnswer": 0,
    "explanation": "Clean code principles include using descriptive variable and function names that clearly express intent, keeping functions small and focused on a single responsibility, and adding comments to explain complex logic or business rules. These practices make code easier to read, understand, and maintain by other developers."
  },
  {
    "id": 8,
    "topic": "Data Structures",
    "type": "multiple-choice",
    "question": "Which data structure is most appropriate for implementing a function call stack?",
    "choices": [
      "Stack (LIFO - Last In, First Out)",
      "Queue (FIFO - First In, First Out)",
      "Array with random access",
      "Linked List"
    ],
    "correctAnswer": 0,
    "explanation": "A stack data structure is perfect for implementing a function call stack because of its LIFO (Last In, First Out) behavior. When functions are called, they are pushed onto the stack, and when they return, they are popped off the stack. This ensures that the most recently called function is the first to return, which is exactly how function calls work."
  },
  {
    "id": 9,
    "topic": "Functions",
    "type": "multiple-choice",
    "question": "What is the primary benefit of using functions in programming?",
    "choices": [
      "Code reusability and modularity",
      "Making code run faster",
      "Reducing the need for variables",
      "Eliminating the need for comments"
    ],
    "correctAnswer": 0,
    "explanation": "The primary benefits of functions are code reusability and modularity. Functions allow you to write code once and use it multiple times, reducing duplication. They also break complex problems into smaller, manageable pieces, making code easier to understand, test, and maintain."
  },
  {
    "id": 10,
    "topic": "Algorithms",
    "type": "multiple-choice",
    "question": "What is the time complexity of accessing an element in an array by index?",
    "choices": [
      "O(1) - Constant time",
      "O(n) - Linear time",
      "O(log n) - Logarithmic time",
      "O(nÂ²) - Quadratic time"
    ],
    "correctAnswer": 0,
    "explanation": "Accessing an element in an array by index is O(1) or constant time complexity. This is because arrays store elements in contiguous memory locations, so the memory address of any element can be calculated directly using the base address + (index * element_size) without needing to traverse through other elements."
  },
  {
    "id": 11,
    "topic": "Variables",
    "type": "multiple-choice",
    "question": "Which of the following is NOT a valid way to declare a variable in modern JavaScript?",
    "choices": [
      "var variableName = value;",
      "let variableName = value;",
      "const variableName = value;",
      "variableName = value;"
    ],
    "correctAnswer": 3,
    "explanation": "Declaring a variable without var, let, or const (like 'variableName = value;') creates a global variable, which is generally considered bad practice. Modern JavaScript should use 'let' for variables that can change and 'const' for constants. The 'var' keyword is older and has scope issues, but it's still valid."
  },
  {
    "id": 12,
    "topic": "Control Structures",
    "type": "multiple-choice",
    "question": "What is the output of this code snippet?\n\nlet result = 0;\nfor (let i = 1; i <= 5; i++) {\n  result += i;\n}\nconsole.log(result);",
    "choices": [
      "15",
      "10",
      "5",
      "0"
    ],
    "correctAnswer": 0,
    "explanation": "The loop iterates from 1 to 5, adding each value to result: 0 + 1 + 2 + 3 + 4 + 5 = 15. This is a common pattern for calculating the sum of a series of numbers."
  },
  {
    "id": 13,
    "topic": "OOP",
    "type": "multiple-choice",
    "question": "What is the main advantage of using object-oriented programming (OOP)?",
    "choices": [
      "Encapsulation, inheritance, and polymorphism for better code organization",
      "Making code run faster",
      "Reducing the total number of lines of code",
      "Eliminating the need for functions"
    ],
    "correctAnswer": 0,
    "explanation": "OOP's main advantages are its core principles: encapsulation (bundling data and methods together while controlling access), inheritance (creating specialized versions of classes), and polymorphism (objects taking multiple forms). These principles help organize code, promote reusability, and make complex systems more manageable."
  },
  {
    "id": 14,
    "topic": "Error Handling",
    "type": "multiple-choice",
    "question": "Which error handling approach is most appropriate for handling unexpected runtime errors?",
    "choices": [
      "try-catch blocks with specific error types",
      "Ignoring errors and hoping they don't occur",
      "Using console.log() to print error messages",
      "Wrapping entire programs in a single try-catch block"
    ],
    "correctAnswer": 0,
    "explanation": "try-catch blocks with specific error types provide structured error handling that allows programs to gracefully handle unexpected situations. By catching specific error types, you can implement appropriate recovery strategies for different error conditions, making applications more robust and user-friendly."
  }
]