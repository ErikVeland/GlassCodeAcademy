[
  {
    "Id": 1,
    "Topic": "Variables & Data Types",
    "Title": "Variables and Data Types",
    "Description": "Variables are fundamental building blocks in programming that store and manage data in your applications. Understanding data types is crucial for writing efficient and bug-free code.\n\nIn this lesson, you'll learn about primitive data types including numbers, strings, and booleans. We'll explore how different programming languages handle these types and when to use each one effectively.\n\nVariables act as containers that hold values which can change during program execution. Proper variable management is essential for memory efficiency and code readability. You'll discover naming conventions that make your code self-documenting and easier to maintain.\n\nBy the end of this lesson, you'll confidently declare variables, choose appropriate data types, and follow industry-standard naming practices. These skills form the foundation for all programming concepts you'll learn throughout your development journey.\n\nWe'll cover practical examples showing how variables store different types of information, from user input to calculation results. Understanding these fundamentals will prepare you for more complex topics like functions, arrays, and object-oriented programming.",
    "CodeExample": "// Variable declarations with different data types\n\n// Numbers (integers and floating-point)\nlet age = 25;\nlet price = 19.99;\nlet temperature = -5;\n\n// Strings (text data)\nlet firstName = \"John\";\nlet lastName = \"Doe\";\nlet message = `Hello, ${firstName} ${lastName}!`;\n\n// Booleans (true/false values)\nlet isLoggedIn = true;\nlet hasPermission = false;\nlet isValidEmail = email.includes('@');\n\n// Constants (values that don't change)\nconst PI = 3.14159;\nconst MAX_USERS = 100;\n\n// Variable naming conventions\nlet userName = \"camelCase for variables\";\nconst API_URL = \"UPPER_CASE for constants\";\nlet is_valid = false; // avoid snake_case in JavaScript\n\nconsole.log(`Age: ${age}, Price: $${price}, User: ${firstName}`);",
    "Output": "This example demonstrates proper variable declaration, different data types, and naming conventions. Notice how we use 'let' for variables that can change, 'const' for constants, and template literals for string interpolation."
  },
  {
    "Id": 2,
    "Topic": "Control Structures",
    "Title": "Control Structures: Conditionals",
    "Description": "Control structures are the decision-making components of programming that allow your code to execute different paths based on conditions. Conditionals are essential for creating dynamic applications that respond to user input, data changes, and varying states.\n\nIn this lesson, you'll learn how to implement if/else statements, which form the backbone of conditional logic in most programming languages. We'll explore comparison operators (==, ===, !=, !==, <, >, <=, >=) and logical operators (&&, ||, !) that enable complex decision-making.\n\nYou'll also discover alternative control structures like switch statements for handling multiple conditions and ternary operators for concise conditional assignments. These tools help you write cleaner, more readable code while maintaining functionality.\n\nBy the end of this lesson, you'll be able to create sophisticated conditional logic that handles various scenarios in your applications. You'll understand when to use each control structure and how to avoid common pitfalls that lead to bugs and maintenance issues.\n\nWe'll work through practical examples showing how conditionals control program flow in real-world applications, from user authentication to data validation and feature toggles.",
    "CodeExample": "// If/else statements\nconst userAge = 20;\n\nif (userAge >= 18) {\n  console.log(\"You are eligible to vote\");\n} else if (userAge >= 16) {\n  console.log(\"You can get a driver's license\");\n} else {\n  console.log(\"You're still young\");\n}\n\n// Logical operators\nconst isLoggedIn = true;\nconst hasPermission = false;\n\nif (isLoggedIn && hasPermission) {\n  console.log(\"Access granted\");\n} else if (isLoggedIn || hasPermission) {\n  console.log(\"Partial access\");\n} else {\n  console.log(\"Access denied\");\n}\n\n// Switch statement\nconst day = \"Monday\";\nswitch (day) {\n  case \"Monday\":\n    console.log(\"Start of the work week\");\n    break;\n  case \"Friday\":\n    console.log(\"End of the work week\");\n    break;\n  default:\n    console.log(\"Mid-week day\");\n}\n\n// Ternary operator\nconst isStudent = true;\nconst discount = isStudent ? 0.1 : 0;\nconsole.log(`Discount: ${discount * 100}%`);",
    "Output": "This example shows various conditional structures. Notice how if/else chains handle multiple conditions, logical operators combine boolean values, switch statements efficiently handle multiple discrete values, and ternary operators provide concise conditional assignments."
  },
  {
    "Id": 3,
    "Topic": "Control Structures",
    "Title": "Control Structures: Loops",
    "Description": "Loops are repetitive control structures that allow you to execute code multiple times without writing the same statements repeatedly. They're essential for processing collections of data, implementing algorithms, and automating repetitive tasks.\n\nIn this lesson, you'll learn about different loop types: for loops for counting iterations, while loops for condition-based repetition, and do-while loops for guaranteed execution. Each has specific use cases and advantages depending on your programming needs.\n\nYou'll also explore loop control statements like break (to exit loops early) and continue (to skip to the next iteration). These tools give you fine-grained control over loop execution and help you handle special cases efficiently.\n\nBy the end of this lesson, you'll be able to choose the appropriate loop type for different scenarios and implement complex iteration patterns. You'll understand how to avoid infinite loops and optimize loop performance for better application efficiency.\n\nWe'll work through practical examples showing how loops process arrays, implement algorithms like searching and sorting, and handle real-world data processing tasks.",
    "CodeExample": "// For loop\nfor (let i = 0; i < 5; i++) {\n  console.log(`Count: ${i}`);\n}\n\n// While loop\nlet count = 0;\nwhile (count < 5) {\n  console.log(`While count: ${count}`);\n  count++;\n}\n\n// Do-while loop\nlet attempts = 0;\ndo {\n  console.log(`Attempt: ${attempts}`);\n  attempts++;\n} while (attempts < 3);\n\n// Loop control statements\nfor (let i = 0; i < 10; i++) {\n  if (i === 3) continue; // Skip iteration when i is 3\n  if (i === 7) break;    // Exit loop when i is 7\n  console.log(`Number: ${i}`);\n}\n\n// Iterating over arrays\nconst fruits = [\"apple\", \"banana\", \"orange\"];\nfor (let i = 0; i < fruits.length; i++) {\n  console.log(`Fruit ${i}: ${fruits[i]}`);\n}\n\n// For...of loop (modern approach)\nfor (const fruit of fruits) {\n  console.log(`Delicious: ${fruit}`);\n}",
    "Output": "This example demonstrates various loop types and control statements. Notice how for loops are ideal for counting, while loops continue based on conditions, do-while loops guarantee at least one execution, and control statements provide flexibility in loop execution."
  },
  {
    "Id": 4,
    "Topic": "Functions & Scope",
    "Title": "Functions and Scope",
    "Description": "Functions are reusable blocks of code that perform specific tasks and help organize your programs into logical units. They're fundamental to writing maintainable, modular code and implementing the DRY (Don't Repeat Yourself) principle.\n\nIn this lesson, you'll learn how to define functions with parameters, return values, and proper naming conventions. We'll explore different function syntaxes including traditional function declarations, arrow functions, and anonymous functions.\n\nYou'll also dive deep into variable scope, understanding the difference between global and local scope, and how closures work to maintain access to outer function variables. These concepts are crucial for avoiding naming conflicts and managing data flow in your applications.\n\nBy the end of this lesson, you'll be able to create well-structured functions that encapsulate logic, accept input parameters, and return meaningful results. You'll understand how scope affects variable accessibility and how to use closures effectively.\n\nWe'll work through practical examples showing how functions modularize code, enable code reuse, and create clean interfaces between different parts of your applications.",
    "CodeExample": "// Function declaration\nfunction greetUser(name) {\n  return `Hello, ${name}!`;\n}\n\n// Function expression\nconst calculateArea = function(width, height) {\n  return width * height;\n};\n\n// Arrow function\nconst isEven = (number) => number % 2 === 0;\n\n// Function with default parameters\nfunction createUser(name, role = \"user\", isActive = true) {\n  return {\n    name,\n    role,\n    isActive,\n    createdAt: new Date()\n  };\n}\n\n// Scope example\nconst globalVar = \"I'm global\";\n\nfunction scopeDemo() {\n  const localVar = \"I'm local\";\n  console.log(globalVar); // Accessible\n  console.log(localVar);  // Accessible\n  \n  if (true) {\n    const blockVar = \"I'm block-scoped\";\n    console.log(blockVar); // Accessible\n  }\n  // console.log(blockVar); // Error: not accessible outside block\n}\n\n// Closure example\nfunction createCounter() {\n  let count = 0;\n  return function() {\n    count++;\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2",
    "Output": "This example shows different function syntaxes, parameter handling, and scope concepts. Notice how functions encapsulate logic, arrow functions provide concise syntax, default parameters handle missing values, and closures maintain access to outer variables."
  },
  {
    "Id": 5,
    "Topic": "Data Structures",
    "Title": "Arrays and Array Methods",
    "Description": "Arrays are ordered collections that store multiple values in a single variable. They're essential data structures for managing lists of related data and implementing algorithms that process collections efficiently.\n\nIn this lesson, you'll learn how to create arrays, access elements by index, and modify array contents. We'll explore essential array methods like push, pop, shift, unshift for adding and removing elements, and slice, splice for manipulating array segments.\n\nYou'll dive deep into transformation methods like map (for creating new arrays), filter (for selecting elements), and reduce (for aggregating values). These powerful methods enable functional programming patterns that lead to cleaner, more expressive code.\n\nBy the end of this lesson, you'll be able to manipulate arrays effectively, transform data using functional methods, and choose appropriate techniques for different array operations. You'll understand how to avoid common array-related bugs and optimize array processing for performance.\n\nWe'll work through practical examples showing how arrays manage user data, process API responses, implement shopping carts, and handle real-world collection-based tasks.",
    "CodeExample": "// Creating arrays\nconst fruits = [\"apple\", \"banana\", \"orange\"];\nconst numbers = new Array(1, 2, 3, 4, 5);\nconst mixed = [1, \"hello\", true, {name: \"John\"}];\n\n// Accessing and modifying elements\nconsole.log(fruits[0]); // \"apple\"\nfruits[1] = \"grape\";   // Change element\nfruits.push(\"mango\");   // Add to end\nfruits.unshift(\"kiwi\"); // Add to beginning\n\n// Essential array methods\nconst colors = [\"red\", \"green\", \"blue\", \"yellow\"];\n\n// Adding/removing\ncolors.push(\"purple\");     // Add to end\ncolors.pop();              // Remove from end\ncolors.unshift(\"orange\");  // Add to beginning\ncolors.shift();            // Remove from beginning\n\n// Transformation methods\nconst nums = [1, 2, 3, 4, 5];\n\n// Map - transform each element\nconst doubled = nums.map(n => n * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\n\n// Filter - select elements that match condition\nconst evens = nums.filter(n => n % 2 === 0);\nconsole.log(evens); // [2, 4]\n\n// Reduce - aggregate values\nconst sum = nums.reduce((acc, n) => acc + n, 0);\nconsole.log(sum); // 15\n\n// Chaining methods\nconst result = nums\n  .filter(n => n > 2)      // [3, 4, 5]\n  .map(n => n * 2)         // [6, 8, 10]\n  .reduce((a, b) => a + b, 0); // 24\nconsole.log(result);",
    "Output": "This example demonstrates array creation, element access, and essential methods. Notice how push/pop modify the end, unshift/shift modify the beginning, map transforms elements, filter selects elements, and reduce aggregates values."
  },
  {
    "Id": 6,
    "Topic": "Data Structures",
    "Title": "Objects and Object Methods",
    "Description": "Objects are collections of key-value pairs that represent entities with properties and behaviors. They're fundamental to organizing complex data and implementing object-oriented programming principles in modern applications.\n\nIn this lesson, you'll learn how to create objects using literals, constructors, and classes. We'll explore property access using dot notation and bracket notation, and how to add, modify, and delete object properties dynamically.\n\nYou'll dive into object methods, understanding how functions can be attached to objects to define behaviors. We'll cover the 'this' keyword and how it refers to the object context when methods are called.\n\nBy the end of this lesson, you'll be able to model real-world entities using objects, organize related data and functions together, and implement basic object-oriented programming patterns. You'll understand how objects enable code organization and data encapsulation.\n\nWe'll work through practical examples showing how objects represent users, products, and application state, and how methods define the behaviors of these entities.",
    "CodeExample": "// Object literal\nconst user = {\n  name: \"John Doe\",\n  age: 30,\n  email: \"john@example.com\",\n  isActive: true,\n  \n  // Method\n  greet() {\n    return `Hello, I'm ${this.name}`;\n  },\n  \n  // Method with parameters\n  updateEmail(newEmail) {\n    this.email = newEmail;\n    return `Email updated to ${newEmail}`;\n  }\n};\n\n// Accessing properties\nconsole.log(user.name);        // \"John Doe\"\nconsole.log(user[\"email\"]);   // \"john@example.com\"\n\n// Adding properties\nuser.location = \"New York\";\nuser[\"phoneNumber\"] = \"123-456-7890\";\n\n// Object methods\nconsole.log(user.greet());     // \"Hello, I'm John Doe\"\nconsole.log(user.updateEmail(\"newemail@example.com\"));\n\n// Object constructor\nfunction Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n  this.start = function() {\n    return `${this.make} ${this.model} is starting`;\n  };\n}\n\nconst myCar = new Car(\"Toyota\", \"Camry\", 2022);\nconsole.log(myCar.start());\n\n// Modern class syntax\nclass Product {\n  constructor(name, price, category) {\n    this.name = name;\n    this.price = price;\n    this.category = category;\n  }\n  \n  getInfo() {\n    return `${this.name} - $${this.price} (${this.category})`;\n  }\n  \n  applyDiscount(percent) {\n    this.price = this.price * (1 - percent / 100);\n    return `Discount applied. New price: $${this.price.toFixed(2)}`;\n  }\n}\n\nconst laptop = new Product(\"Laptop\", 999.99, \"Electronics\");\nconsole.log(laptop.getInfo());\nconsole.log(laptop.applyDiscount(10));",
    "Output": "This example shows object creation with literals, constructors, and classes. Notice how properties store data, methods define behaviors, and the 'this' keyword refers to the object instance."
  },
  {
    "Id": 7,
    "Topic": "Debugging & Error Handling",
    "Title": "Error Handling and Debugging",
    "Description": "Error handling is crucial for creating robust applications that gracefully handle unexpected situations. Debugging skills help you identify, understand, and fix issues in your code efficiently.\n\nIn this lesson, you'll learn about different error types like syntax errors, runtime errors, and logical errors. We'll explore try/catch blocks for handling exceptions and finally blocks for cleanup operations.\n\nYou'll master debugging techniques using console methods, breakpoints, and browser developer tools. We'll cover strategies for effective logging, error tracking, and preventive coding practices.\n\nBy the end of this lesson, you'll be able to write defensive code that handles errors gracefully, debug complex issues systematically, and implement logging for better application monitoring. You'll understand how to create user-friendly error messages while maintaining security.\n\nWe'll work through practical examples showing how to handle network failures, invalid user input, and other common error scenarios in real applications.",
    "CodeExample": "// Try/catch for error handling\ntry {\n  const result = riskyOperation();\n  console.log(\"Success:\", result);\n} catch (error) {\n  console.error(\"Error occurred:\", error.message);\n  // Handle error appropriately\n} finally {\n  // Cleanup operations\n  console.log(\"Cleanup completed\");\n}\n\n// Throwing custom errors\nfunction validateAge(age) {\n  if (age < 0) {\n    throw new Error(\"Age cannot be negative\");\n  }\n  if (age > 150) {\n    throw new Error(\"Age seems unrealistic\");\n  }\n  return true;\n}\n\ntry {\n  validateAge(-5);\n} catch (error) {\n  console.error(\"Validation failed:\", error.message);\n}\n\n// Different error types\ntry {\n  // ReferenceError\n  console.log(undefinedVariable);\n  \n  // TypeError\n  null.someMethod();\n  \n  // SyntaxError\n  eval(\"invalid javascript code\");\n  \n} catch (error) {\n  if (error instanceof ReferenceError) {\n    console.error(\"Reference error:\", error.message);\n  } else if (error instanceof TypeError) {\n    console.error(\"Type error:\", error.message);\n  } else {\n    console.error(\"Other error:\", error.message);\n  }\n}\n\n// Debugging with console methods\nconst data = {name: \"John\", age: 30, hobbies: [\"reading\", \"coding\"]};\nconsole.log(\"Basic log:\", data);\nconsole.table(data.hobbies);\nconsole.warn(\"This is a warning\");\nconsole.error(\"This is an error\");\n\n// Conditional debugging\nconst debug = true;\nif (debug) {\n  console.log(\"Debug info:\", data);\n}",
    "Output": "This example demonstrates error handling with try/catch, custom error throwing, error type checking, and various console debugging methods. Notice how different error types are caught and handled appropriately."
  },
  {
    "Id": 8,
    "Topic": "Algorithms & Problem Solving",
    "Title": "Basic Algorithms and Problem Solving",
    "Description": "Algorithms are step-by-step procedures for solving problems or completing tasks. Developing algorithmic thinking is essential for writing efficient code and tackling complex programming challenges.\n\nIn this lesson, you'll learn fundamental algorithms like linear search, binary search, bubble sort, and selection sort. We'll explore problem-solving strategies including breaking down complex problems, identifying patterns, and choosing appropriate data structures.\n\nYou'll understand basic algorithm complexity using Big O notation to analyze time and space efficiency. This knowledge helps you make informed decisions about which algorithms and data structures to use in different situations.\n\nBy the end of this lesson, you'll be able to approach programming problems systematically, implement basic algorithms correctly, and evaluate the efficiency of your solutions. You'll develop the analytical skills needed for more advanced algorithmic challenges.\n\nWe'll work through practical examples showing how algorithms solve real-world problems like searching contact lists, sorting product catalogs, and optimizing data processing tasks.",
    "CodeExample": "// Linear search\nfunction linearSearch(arr, target) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === target) {\n      return i; // Return index if found\n    }\n  }\n  return -1; // Return -1 if not found\n}\n\n// Binary search (for sorted arrays)\nfunction binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return -1;\n}\n\n// Bubble sort\nfunction bubbleSort(arr) {\n  const sorted = [...arr]; // Create copy to avoid mutating original\n  \n  for (let i = 0; i < sorted.length - 1; i++) {\n    for (let j = 0; j < sorted.length - i - 1; j++) {\n      if (sorted[j] > sorted[j + 1]) {\n        // Swap elements\n        [sorted[j], sorted[j + 1]] = [sorted[j + 1], sorted[j]];\n      }\n    }\n  }\n  \n  return sorted;\n}\n\n// Selection sort\nfunction selectionSort(arr) {\n  const sorted = [...arr];\n  \n  for (let i = 0; i < sorted.length - 1; i++) {\n    let minIndex = i;\n    \n    // Find minimum element in remaining array\n    for (let j = i + 1; j < sorted.length; j++) {\n      if (sorted[j] < sorted[minIndex]) {\n        minIndex = j;\n      }\n    }\n    \n    // Swap minimum element with first element\n    if (minIndex !== i) {\n      [sorted[i], sorted[minIndex]] = [sorted[minIndex], sorted[i]];\n    }\n  }\n  \n  return sorted;\n}\n\n// Example usage\nconst numbers = [64, 34, 25, 12, 22, 11, 90];\nconsole.log(\"Original:\", numbers);\nconsole.log(\"Linear search for 25:\", linearSearch(numbers, 25));\nconsole.log(\"Sorted (bubble):\", bubbleSort(numbers));\nconsole.log(\"Sorted (selection):\", selectionSort(numbers));\nconst sortedNumbers = selectionSort(numbers);\nconsole.log(\"Binary search for 25:\", binarySearch(sortedNumbers, 25));",
    "Output": "This example shows fundamental algorithms: linear search for unsorted data, binary search for sorted data, and two sorting algorithms. Notice the time complexity differences and when to use each approach."
  },
  {
    "Id": 9,
    "Topic": "String Manipulation",
    "Title": "Strings and String Manipulation",
    "Description": "Strings are sequences of characters used to represent text in programming. Effective string manipulation is essential for processing user input, generating output, and working with textual data in applications.\n\nIn this lesson, you'll learn essential string methods for searching, replacing, and transforming text. We'll explore string concatenation, template literals, and formatting techniques for creating dynamic content.\n\nYou'll dive into regular expressions for powerful pattern matching and text processing. We'll cover regex syntax, common patterns, and practical applications like input validation and data extraction.\n\nBy the end of this lesson, you'll be able to manipulate strings effectively, validate and format text input, and use regular expressions for complex pattern matching tasks. You'll understand how to handle string encoding and avoid common string-related issues.\n\nWe'll work through practical examples showing how string manipulation processes user names, formats addresses, validates email addresses, and extracts data from text sources.",
    "CodeExample": "// String basics\nconst greeting = \"Hello, World!\";\nconsole.log(greeting.length);        // 13\nconsole.log(greeting.charAt(0));     // \"H\"\nconsole.log(greeting.indexOf(\"World\")); // 7\nconsole.log(greeting.substring(0, 5)); // \"Hello\"\n\n// String methods\nconst text = \"  JavaScript is awesome!  \";\nconsole.log(text.trim());           // \"JavaScript is awesome!\"\nconsole.log(text.toUpperCase());    // \"  JAVASCRIPT IS AWESOME!  \"\nconsole.log(text.toLowerCase());    // \"  javascript is awesome!  \"\n\n// String searching\nconst sentence = \"The quick brown fox jumps over the lazy dog\";\nconsole.log(sentence.includes(\"fox\"));     // true\nconsole.log(sentence.startsWith(\"The\"));   // true\nconsole.log(sentence.endsWith(\"dog\"));     // true\n\n// String replacement\nconst message = \"Hello, NAME. Welcome to PLACE.\";\nconst personalized = message.replace(\"NAME\", \"John\").replace(\"PLACE\", \"our website\");\nconsole.log(personalized); // \"Hello, John. Welcome to our website.\"\n\n// Template literals\nconst name = \"Alice\";\nconst age = 25;\nconst info = `User: ${name}, Age: ${age}, Next year: ${age + 1}`;\nconsole.log(info); // \"User: Alice, Age: 25, Next year: 26\"\n\n// Regular expressions\nconst emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\nconst validEmail = \"user@example.com\";\nconst invalidEmail = \"invalid.email\";\n\nconsole.log(emailPattern.test(validEmail));   // true\nconsole.log(emailPattern.test(invalidEmail)); // false\n\n// String extraction with regex\nconst phoneText = \"Call me at 123-456-7890 or 987-654-3210\";\nconst phonePattern = /\\d{3}-\\d{3}-\\d{4}/g;\nconst phones = phoneText.match(phonePattern);\nconsole.log(phones); // [\"123-456-7890\", \"987-654-3210\"]\n\n// String splitting\nconst csvData = \"name,age,city\";\nconst columns = csvData.split(\",\");\nconsole.log(columns); // [\"name\", \"age\", \"city\"]",
    "Output": "This example demonstrates string operations including length checking, character access, searching, replacement, template literals, and regular expressions for pattern matching."
  },
  {
    "Id": 10,
    "Topic": "Numbers & Math",
    "Title": "Numbers and Mathematical Operations",
    "Description": "Numbers are fundamental data types used for mathematical calculations, counting, and representing quantitative values in programming. Understanding number handling is crucial for financial calculations, scientific computations, and general arithmetic operations.\n\nIn this lesson, you'll learn about different number types including integers, floating-point numbers, and special values like Infinity and NaN. We'll explore arithmetic operators, assignment operators, and operator precedence rules.\n\nYou'll dive into the Math object, which provides powerful mathematical functions and constants. We'll cover rounding methods, random number generation, and trigonometric functions for more advanced calculations.\n\nBy the end of this lesson, you'll be able to perform precise mathematical operations, handle number formatting and precision issues, and use mathematical functions effectively. You'll understand common pitfalls with floating-point arithmetic and how to avoid them.\n\nWe'll work through practical examples showing how number handling processes financial data, generates random values for games, and performs scientific calculations.",
    "CodeExample": "// Number basics\nconst integer = 42;\nconst float = 3.14159;\nconst scientific = 1.23e5; // 123000\n\nconsole.log(integer + float);    // 45.14159\nconsole.log(integer * float);    // 131.94678\nconsole.log(integer / float);    // 13.369000000000001\n\n// Number methods\nconst num = 123.456;\nconsole.log(num.toFixed(2));     // \"123.46\"\nconsole.log(num.toPrecision(5)); // \"123.46\"\nconsole.log(num.toString());     // \"123.456\"\n\n// Math object\nconsole.log(Math.PI);            // 3.141592653589793\nconsole.log(Math.E);             // 2.718281828459045\n\n// Rounding methods\nconst value = 4.7;\nconsole.log(Math.round(value));  // 5\nconsole.log(Math.floor(value));  // 4\nconsole.log(Math.ceil(value));   // 5\nconsole.log(Math.trunc(value));  // 4\n\n// Random numbers\nconst randomInt = Math.floor(Math.random() * 100) + 1; // 1-100\nconsole.log(\"Random number:\", randomInt);\n\n// Power and roots\nconsole.log(Math.pow(2, 3));     // 8\nconsole.log(Math.sqrt(16));      // 4\nconsole.log(Math.cbrt(27));      // 3\n\n// Trigonometric functions\nconst angle = Math.PI / 4; // 45 degrees in radians\nconsole.log(Math.sin(angle));    // 0.7071067811865476\nconsole.log(Math.cos(angle));    // 0.7071067811865476\nconsole.log(Math.tan(angle));    // 0.9999999999999999\n\n// Absolute value and signs\nconsole.log(Math.abs(-5));       // 5\nconsole.log(Math.sign(-5));      // -1\nconsole.log(Math.sign(5));       // 1\nconsole.log(Math.sign(0));       // 0\n\n// Max and min\nconsole.log(Math.max(1, 5, 3, 9, 2)); // 9\nconsole.log(Math.min(1, 5, 3, 9, 2)); // 1\n\n// Handling precision issues\nconst result = 0.1 + 0.2;\nconsole.log(result);             // 0.30000000000000004\nconsole.log(result.toFixed(2));  // \"0.30\"\nconsole.log(Math.round(result * 100) / 100); // 0.3",
    "Output": "This example demonstrates number operations, Math object methods, rounding techniques, random number generation, and handling floating-point precision issues."
  },
  {
    "Id": 11,
    "Topic": "Date & Time Handling",
    "Title": "Dates and Time Handling",
    "Description": "Date and time handling is essential for applications that need to track events, schedule tasks, or display time-based information. Proper date manipulation ensures accurate time calculations and user-friendly date displays.\n\nIn this lesson, you'll learn to create and manipulate Date objects, understanding the various constructor options and methods for getting and setting date components. We'll explore date arithmetic for calculating time differences and scheduling future events.\n\nYou'll dive into date formatting techniques, including internationalization options for displaying dates in different locales. We'll cover common challenges with time zones and how to handle them in web applications.\n\nBy the end of this lesson, you'll be able to work with dates and times effectively, format them for different audiences, and handle time zone complexities. You'll understand how to perform date calculations and avoid common pitfalls with date manipulation.\n\nWe'll work through practical examples showing how date handling manages user registrations, calculates deadlines, schedules notifications, and displays time-sensitive information.",
    "CodeExample": "// Creating Date objects\nconst now = new Date();\nconst specificDate = new Date(\"2025-12-25\");\nconst components = new Date(2025, 11, 25, 14, 30, 0); // Year, Month, Day, Hour, Minute, Second\n\nconsole.log(now.toString());\nconsole.log(specificDate.toDateString());\nconsole.log(components.toLocaleString());\n\n// Getting date components\nconst date = new Date();\nconsole.log(date.getFullYear());    // 2025\nconsole.log(date.getMonth());       // 0-11 (January is 0)\nconsole.log(date.getDate());        // 1-31\nconsole.log(date.getDay());         // 0-6 (Sunday is 0)\nconsole.log(date.getHours());       // 0-23\nconsole.log(date.getMinutes());     // 0-59\nconsole.log(date.getSeconds());     // 0-59\n\n// Setting date components\nconst myDate = new Date();\nmyDate.setFullYear(2026);\nmyDate.setMonth(5);        // June (0-based)\nmyDate.setDate(15);\nconsole.log(myDate.toDateString());\n\n// Date arithmetic\nconst start = new Date(\"2025-01-01\");\nconst end = new Date(\"2025-12-31\");\nconst diffMs = end - start; // Difference in milliseconds\nconst diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\nconsole.log(`Days in 2025: ${diffDays}`);\n\n// Adding days\nfunction addDays(date, days) {\n  const result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result;\n}\n\nconst today = new Date();\nconst nextWeek = addDays(today, 7);\nconsole.log(`Today: ${today.toDateString()}`);\nconsole.log(`Next week: ${nextWeek.toDateString()}`);\n\n// Date formatting\nconst eventDate = new Date(\"2025-07-04T19:30:00\");\n\n// Different formatting options\nconsole.log(eventDate.toDateString());           // \"Jul 4 2025\"\nconsole.log(eventDate.toLocaleDateString());     // Locale-specific date\nconsole.log(eventDate.toLocaleTimeString());     // Locale-specific time\nconsole.log(eventDate.toLocaleString());         // Locale-specific date and time\n\n// Custom formatting\nconst options = {\n  weekday: 'long',\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n  hour: '2-digit',\n  minute: '2-digit'\n};\n\nconsole.log(eventDate.toLocaleDateString('en-US', options));\n// \"Friday, July 4, 2025, 07:30 PM\"\n\n// Time zone handling\nconst utcDate = new Date();\nconsole.log(utcDate.toUTCString());\nconsole.log(utcDate.getTimezoneOffset()); // Minutes offset from UTC",
    "Output": "This example demonstrates creating Date objects, accessing and modifying date components, performing date arithmetic, and formatting dates for display in different locales."
  },
  {
    "Id": 12,
    "Topic": "File I/O & Persistence",
    "Title": "File I/O and Data Persistence",
    "Description": "Data persistence is crucial for applications that need to store and retrieve information beyond the current session. Understanding file operations and storage mechanisms enables you to build applications that maintain state and user data.\n\nIn this lesson, you'll learn file input/output operations in Node.js, including reading from and writing to files. We'll explore different file formats and the importance of proper error handling in file operations.\n\nYou'll dive into JSON (JavaScript Object Notation) for data serialization and exchange. We'll cover parsing JSON data, generating JSON from objects, and handling JSON-related errors safely.\n\nBy the end of this lesson, you'll be able to work with files effectively, handle JSON data properly, and implement basic data persistence in both server-side and client-side applications. You'll understand the differences between various storage options and when to use each.\n\nWe'll work through practical examples showing how file operations manage configuration data, how JSON handles API responses, and how localStorage persists user preferences.",
    "CodeExample": "// Node.js file operations (require 'fs' module)\nconst fs = require('fs');\n\n// Reading a file\ntry {\n  const data = fs.readFileSync('example.txt', 'utf8');\n  console.log('File contents:', data);\n} catch (error) {\n  console.error('Error reading file:', error.message);\n}\n\n// Writing to a file\nconst content = 'Hello, File System!\\nThis is a new line.';\ntry {\n  fs.writeFileSync('output.txt', content);\n  console.log('File written successfully');\n} catch (error) {\n  console.error('Error writing file:', error.message);\n}\n\n// JSON handling\nconst userData = {\n  name: \"John Doe\",\n  age: 30,\n  preferences: {\n    theme: \"dark\",\n    notifications: true\n  }\n};\n\n// Converting object to JSON string\nconst jsonString = JSON.stringify(userData, null, 2);\nconsole.log('JSON string:', jsonString);\n\n// Parsing JSON string to object\ntry {\n  const parsedData = JSON.parse(jsonString);\n  console.log('Parsed object:', parsedData);\n} catch (error) {\n  console.error('Error parsing JSON:', error.message);\n}\n\n// Client-side localStorage (browser environment)\n// Storing data\nlocalStorage.setItem('username', 'johndoe');\nlocalStorage.setItem('userPreferences', JSON.stringify(userData));\n\n// Retrieving data\nconst username = localStorage.getItem('username');\nconsole.log('Username:', username);\n\nconst storedPreferences = localStorage.getItem('userPreferences');\nif (storedPreferences) {\n  try {\n    const preferences = JSON.parse(storedPreferences);\n    console.log('User preferences:', preferences);\n  } catch (error) {\n    console.error('Error parsing stored preferences:', error.message);\n  }\n}\n\n// Removing data\n// localStorage.removeItem('username');\n// localStorage.clear(); // Remove all items\n\n// Checking localStorage availability\nfunction isStorageAvailable() {\n  try {\n    const test = '__storage_test__';\n    localStorage.setItem(test, test);\n    localStorage.removeItem(test);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nif (isStorageAvailable()) {\n  console.log('localStorage is available');\n} else {\n  console.log('localStorage is not available');\n}",
    "Output": "This example demonstrates file operations in Node.js, JSON serialization and parsing, and client-side data persistence with localStorage. Notice the error handling around file and JSON operations."
  }
]