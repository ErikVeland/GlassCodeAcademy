[
  {
    "id": "node-fundamentals-lesson-1",
    "moduleSlug": "node-fundamentals",
    "title": "Introduction to Node.js",
    "order": 1,
    "objectives": [
      "Understand Node.js architecture and the JavaScript V8 engine",
      "`Explain` the event-driven, non-blocking I/O model",
      "Set up a development environment for Node.js applications"
    ],
    "intro": "Node.js represents a revolutionary approach to server-side development, enabling developers to use JavaScript for building scalable network applications. Created by Ryan Dahl in 2009, Node.js leverages Google's V8 JavaScript engine to execute JavaScript code outside of a web browser, making it possible to use a single language across the entire technology stack.\n\nAt the heart of Node.js lies its event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices. Understanding this architecture is crucial for building high-performance applications that can handle thousands of concurrent connections.\n\nThe JavaScript V8 engine, originally developed by Google for the Chrome browser, compiles JavaScript directly to machine code, providing exceptional performance. Node.js extends this capability with a rich set of built-in modules that provide access to file systems, network operations, and other low-level functionality.\n\nThis lesson will explore the fundamental concepts that make Node.js unique, including the event loop, callback patterns, and module system. You'll learn how Node.js differs from traditional server-side technologies and why it's become the preferred choice for building real-time applications, APIs, and microservices.\n\nBy the end of this lesson, you'll have Node.js installed and configured correctly, understand the core architectural principles that make it efficient, and be ready to start building your first server-side JavaScript applications. This foundation is essential for all subsequent Node.js development work.",
    "code": {
      "example": "// Complete Node.js server with Express.js\nconst express = require('express');\nconst app = express();\nconst PORT = process.env.PORT || 3000;\n\n// Middleware for parsing JSON\napp.use(express.json());\n\n// Route handlers\napp.get('/', (req, res) => {\n  res.json({\n    message: 'Welcome to Node.js!',\n    timestamp: new Date().toISOString(),\n    nodeVersion: process.version\n  });\n});\n\napp.get('/health', (req, res) => {\n  res.status(200).json({\n    status: 'healthy',\n    uptime: process.uptime()\n  });\n});\n\n// Error handling middleware\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({\n    error: 'Something went wrong!',\n    message: err.message\n  });\n});\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Route not found'\n  });\n});\n\napp.listen(PORT, () => {\n  console.log(`\nðŸš€ Server running on port ${PORT}\n\nAvailable endpoints:\n  GET  /          - Welcome message\n  GET  /health     - Health check\n`);\n});\n\n// Graceful shutdown\nprocess.on('SIGTERM', () => {\n  console.log('SIGTERM received, shutting down gracefully');\n  process.exit(0);\n});",
      "explanation": "This example demonstrates a complete Express.js server implementation with:\n\n1. **Express.js Framework**: Industry-standard web framework for Node.js\n2. **Environment Configuration**: Using PORT environment variable with fallback\n3. **Middleware**: JSON parsing for request bodies\n4. **Route Handlers**: GET endpoints for root and health check\n5. **Error Handling**: Custom error middleware for graceful error responses\n6. **404 Handling**: Catch-all route for undefined endpoints\n7. **Graceful Shutdown**: Handling SIGTERM for proper process termination\n8. **Startup Logging**: Informative console output with available endpoints\n\nThe output shows:\nðŸš€ Server running on port 3000\n\nAvailable endpoints:\n  GET  /          - Welcome message\n  GET  /health     - Health check\n\nKey concepts illustrated:\n- Express.js application setup\n- Middleware configuration\n- Route definition with HTTP methods\n- Error handling patterns\n- Environment variable usage\n- Graceful shutdown practices\n- Production-ready server configuration",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Setup and Deploy Your First Node.js Server",
        "description": "Create a complete Node.js server with Express.js and deploy it locally",
        "checkpoints": [
          "Initialize a new Node.js project with npm init",
          "Install Express.js and configure package.json scripts",
          "Implement the complete server example with health check endpoint",
          "Test all endpoints and verify graceful shutdown functionality",
          "Document your server's API endpoints and configuration options"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Beginner",
    "tags": [
      "Basics",
      "node"
    ],
    "legacy": {
      "originalId": 1,
      "originalTopic": "Basics",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-2",
    "moduleSlug": "node-fundamentals",
    "title": "Node.js Modules",
    "order": 2,
    "objectives": [
      "Understand the CommonJS module system and ES6 modules",
      "Create and export functions, objects, and classes from modules",
      "Import and use modules with require() and import statements"
    ],
    "intro": "Node.js modules are the fundamental building blocks of Node.js applications, providing a way to organize code into reusable, encapsulated units. The module system in Node.js is based on the CommonJS specification, which defines how to structure and share code between different files. Understanding modules is essential for building maintainable and scalable Node.js applications.\n\nEach file in Node.js is treated as a separate module with its own scope, preventing variable and function collisions between different parts of your application. The module system allows you to export specific functions, objects, or primitives from a file and import them into other files, promoting code reuse and separation of concerns.\n\nNode.js provides two module systems: CommonJS (the traditional system used in Node.js) and ES6 modules (the standardized system used in modern JavaScript). While CommonJS uses require() and module.exports, ES6 modules use import and export statements. Understanding both systems is important as you'll encounter both in real-world applications.\n\nThis lesson will explore the CommonJS module system in depth, covering module exports, imports, module caching, and the module wrapper function. You'll learn how to create your own modules, organize them into logical groups, and understand the module loading process.\n\nBy the end of this lesson, you'll be able to structure your Node.js applications using modules effectively, understand how module caching works, and apply best practices for module design and organization.",
    "code": {
      "example": "// math.js - Exporting multiple functions\nfunction add(a, b) {\n  return a + b;\n}\n\nfunction subtract(a, b) {\n  return a - b;\n}\n\nfunction multiply(a, b) {\n  return a * b;\n}\n\n// Export individual functions\nexports.add = add;\nexports.subtract = subtract;\n\n// Export an object containing multiple functions\nmodule.exports.multiply = multiply;\n\n// Export a default object (overwrites exports)\nmodule.exports = {\n  add,\n  subtract,\n  multiply,\n  PI: 3.14159\n};\n\n// calculator.js - Different ways to import modules\nconst math = require('./math');\nconst { add, subtract } = require('./math');\nconst multiply = require('./math').multiply;\n\n// Using imported functions\nconsole.log('Addition:', math.add(5, 3));        // 8\nconsole.log('Subtraction:', subtract(10, 4));     // 6\nconsole.log('Multiplication:', multiply(7, 6));  // 42\nconsole.log('PI:', math.PI);                     // 3.14159\n\n// logger.js - Module with internal state\nclass Logger {\n  constructor(name) {\n    this.name = name;\n    this.logs = [];\n  }\n  \n  log(message) {\n    const timestamp = new Date().toISOString();\n    const logEntry = `[${timestamp}] ${this.name}: ${message}`;\n    this.logs.push(logEntry);\n    console.log(logEntry);\n  }\n  \n  getLogs() {\n    return this.logs;\n  }\n}\n\n// Export a factory function\nmodule.exports = (name) => new Logger(name);\n\n// app.js - Using the logger module\nconst createLogger = require('./logger');\n\nconst userLogger = createLogger('UserModule');\nconst systemLogger = createLogger('SystemModule');\n\nuserLogger.log('User logged in');\nsystemLogger.log('System initialized');\n\nconsole.log('User logs:', userLogger.getLogs());\nconsole.log('System logs:', systemLogger.getLogs());",
      "explanation": "This example demonstrates various aspects of Node.js modules:\n\n1. **Multiple Export Methods**: Shows different ways to export functions and constants\n2. **Destructuring Imports**: Illustrates how to import specific functions from a module\n3. **Module Caching**: Each require() returns the same cached instance\n4. **Factory Functions**: Shows how to export constructor functions\n5. **Internal State**: Modules can maintain state between imports\n\nThe output shows:\nAddition: 8\nSubtraction: 6\nMultiplication: 42\nPI: 3.14159\n[2025-10-03T10:00:00.000Z] UserModule: User logged in\n[2025-10-03T10:00:00.000Z] SystemModule: System initialized\nUser logs: ['[2025-10-03T10:00:00.000Z] UserModule: User logged in']\nSystem logs: ['[2025-10-03T10:00:00.000Z] SystemModule: System initialized']\n\nKey concepts illustrated:\n- Module.exports vs exports\n- Different import patterns\n- Module caching behavior\n- Factory pattern with modules\n- Encapsulation and state management",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Mixing module.exports and exports in the same module",
        "solution": "Use either module.exports or exports consistently within a module; module.exports takes precedence",
        "severity": "high"
      },
      {
        "mistake": "Creating circular dependencies between modules",
        "solution": "Restructure modules to avoid circular dependencies or use dynamic imports when necessary",
        "severity": "high"
      },
      {
        "mistake": "Mutating imported objects which affects all modules using that import",
        "solution": "Treat imported objects as immutable or create copies before modifying them",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Create and Use Custom Node.js Modules",
        "description": "Build a complete module system with multiple interconnected modules",
        "checkpoints": [
          "Create a utility module with string manipulation functions",
          "Implement a configuration module that loads settings from environment variables",
          "Build a data processing module that uses both utility and configuration modules",
          "Demonstrate module caching by importing the same module in multiple files",
          "Handle circular dependency issues by restructuring module relationships"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Basics",
      "node"
    ],
    "legacy": {
      "originalId": 2,
      "originalTopic": "Basics",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-3",
    "moduleSlug": "node-fundamentals",
    "title": "Building REST APIs with Express",
    "order": 3,
    "objectives": [
      "Design RESTful API endpoints following standard conventions",
      "Implement CRUD operations with proper HTTP status codes",
      "Structure API responses with consistent data formats"
    ],
    "intro": "REST (Representational State Transfer) APIs have become the de facto standard for building web services that enable communication between different systems over HTTP. Understanding how to design and implement RESTful APIs is crucial for modern web development, as they provide a standardized way for applications to exchange data and functionality.\n\nExpress.js, the most popular web framework for Node.js, provides a robust set of features for building REST APIs quickly and efficiently. REST APIs are built around resources, which are identified by URIs (Uniform Resource Identifiers) and manipulated using standard HTTP methods like GET, POST, PUT, PATCH, and DELETE.\n\nA well-designed REST API follows consistent conventions for URL structure, HTTP methods, status codes, and response formats. This includes using nouns for resource names (e.g., /users rather than /getUsers), appropriate HTTP status codes (200 for success, 404 for not found, etc.), and consistent JSON response formats.\n\nThis lesson will explore the principles of RESTful API design, covering resource modeling, HTTP method usage, status code selection, and error handling. You'll learn how to implement complete CRUD (Create, Read, Update, Delete) operations, handle query parameters for filtering and pagination, and structure responses for consistency.\n\nBy the end of this lesson, you'll be able to build comprehensive REST APIs that follow industry best practices, handle various client requirements, and provide a solid foundation for frontend applications or other services to consume.",
    "code": {
      "example": "const express = require('express');\nconst app = express();\n\n// Middleware\napp.use(express.json());\n\n// In-memory data store (in real apps, you'd use a database)\nlet users = [\n  { id: 1, name: 'John Doe', email: 'john@example.com', age: 30 },\n  { id: 2, name: 'Jane Smith', email: 'jane@example.com', age: 25 }\n];\nlet nextId = 3;\n\n// GET /users - Retrieve all users\napp.get('/users', (req, res) => {\n  const { page = 1, limit = 10, sortBy = 'id', sortOrder = 'asc' } = req.query;\n  \n  // Apply sorting\n  const sortedUsers = [...users].sort((a, b) => {\n    if (sortOrder === 'desc') [a, b] = [b, a];\n    return a[sortBy] > b[sortBy] ? 1 : a[sortBy] < b[sortBy] ? -1 : 0;\n  });\n  \n  // Apply pagination\n  const startIndex = (page - 1) * limit;\n  const endIndex = startIndex + parseInt(limit);\n  const paginatedUsers = sortedUsers.slice(startIndex, endIndex);\n  \n  res.json({\n    data: paginatedUsers,\n    pagination: {\n      page: parseInt(page),\n      limit: parseInt(limit),\n      total: users.length,\n      pages: Math.ceil(users.length / limit)\n    }\n  });\n});\n\n// GET /users/:id - Retrieve a specific user\napp.get('/users/:id', (req, res) => {\n  const userId = parseInt(req.params.id);\n  const user = users.find(u => u.id === userId);\n  \n  if (!user) {\n    return res.status(404).json({\n      error: 'User not found',\n      code: 'USER_NOT_FOUND'\n    });\n  }\n  \n  res.json({\n    data: user\n  });\n});\n\n// POST /users - Create a new user\napp.post('/users', (req, res) => {\n  const { name, email, age } = req.body;\n  \n  // Basic validation\n  if (!name || !email) {\n    return res.status(400).json({\n      error: 'Name and email are required',\n      code: 'VALIDATION_ERROR'\n    });\n  }\n  \n  // Check if email already exists\n  if (users.some(u => u.email === email)) {\n    return res.status(409).json({\n      error: 'Email already exists',\n      code: 'EMAIL_EXISTS'\n    });\n  }\n  \n  const newUser = {\n    id: nextId++,\n    name,\n    email,\n    age: age || null\n  };\n  \n  users.push(newUser);\n  \n  res.status(201).json({\n    data: newUser,\n    message: 'User created successfully'\n  });\n});\n\n// PUT /users/:id - Update a user completely\napp.put('/users/:id', (req, res) => {\n  const userId = parseInt(req.params.id);\n  const userIndex = users.findIndex(u => u.id === userId);\n  \n  if (userIndex === -1) {\n    return res.status(404).json({\n      error: 'User not found',\n      code: 'USER_NOT_FOUND'\n    });\n  }\n  \n  const { name, email, age } = req.body;\n  \n  // Basic validation\n  if (!name || !email) {\n    return res.status(400).json({\n      error: 'Name and email are required',\n      code: 'VALIDATION_ERROR'\n    });\n  }\n  \n  // Check if email already exists (excluding current user)\n  if (users.some((u, index) => u.email === email && index !== userIndex)) {\n    return res.status(409).json({\n      error: 'Email already exists',\n      code: 'EMAIL_EXISTS'\n    });\n  }\n  \n  users[userIndex] = {\n    id: userId,\n    name,\n    email,\n    age: age || null\n  };\n  \n  res.json({\n    data: users[userIndex],\n    message: 'User updated successfully'\n  });\n});\n\n// DELETE /users/:id - Delete a user\napp.delete('/users/:id', (req, res) => {\n  const userId = parseInt(req.params.id);\n  const userIndex = users.findIndex(u => u.id === userId);\n  \n  if (userIndex === -1) {\n    return res.status(404).json({\n      error: 'User not found',\n      code: 'USER_NOT_FOUND'\n    });\n  }\n  \n  const deletedUser = users.splice(userIndex, 1)[0];\n  \n  res.json({\n    data: deletedUser,\n    message: 'User deleted successfully'\n  });\n});\n\n// Error handling middleware\napp.use((err, req, res, next) => {\n  console.error(err.stack);\n  res.status(500).json({\n    error: 'Internal server error',\n    code: 'INTERNAL_ERROR'\n  });\n});\n\n// 404 handler\napp.use('*', (req, res) => {\n  res.status(404).json({\n    error: 'Endpoint not found',\n    code: 'ENDPOINT_NOT_FOUND'\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`\nðŸš€ REST API server running on port ${PORT}\n\nAvailable endpoints:\n  GET    /users         - List all users with pagination\n  GET    /users/:id     - Get a specific user\n  POST   /users         - Create a new user\n  PUT    /users/:id     - Update a user\n  DELETE /users/:id     - Delete a user\n`);\n});",
      "explanation": "This example demonstrates a complete REST API implementation with:\n\n1. **Full CRUD Operations**: GET, POST, PUT, and DELETE endpoints for user management\n2. **Query Parameters**: Pagination, sorting, and filtering capabilities\n3. **Proper HTTP Status Codes**: 200, 201, 400, 404, 409, and 500 for different scenarios\n4. **Consistent Response Format**: Standardized JSON responses with data and metadata\n5. **Input Validation**: Basic validation for required fields and duplicate checks\n6. **Error Handling**: Custom error responses with error codes\n7. **Middleware**: JSON parsing and error handling middleware\n\nThe output shows:\nðŸš€ REST API server running on port 3000\n\nAvailable endpoints:\n  GET    /users         - List all users with pagination\n  GET    /users/:id     - Get a specific user\n  POST   /users         - Create a new user\n  PUT    /users/:id     - Update a user\n  DELETE /users/:id     - Delete a user\n\nKey concepts illustrated:\n- RESTful resource design\n- HTTP method semantics\n- Status code usage\n- Pagination implementation\n- Data validation\n- Error response structure\n- API documentation in console output",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Inconsistent response formats across different endpoints",
        "solution": "Establish and follow a consistent response structure with data, metadata, and error fields",
        "severity": "high"
      },
      {
        "mistake": "Using incorrect HTTP status codes for different scenarios",
        "solution": "Follow HTTP status code conventions: 200 for success, 201 for creation, 400 for client errors, 404 for not found, etc.",
        "severity": "high"
      },
      {
        "mistake": "Not implementing proper input validation and sanitization",
        "solution": "Validate all input data and sanitize user inputs to prevent injection attacks",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Build a Complete REST API for Blog Posts",
        "description": "Create a REST API for managing blog posts with full CRUD operations and advanced features",
        "checkpoints": [
          "Implement all CRUD endpoints for blog posts with proper validation",
          "Add query parameters for filtering posts by author, category, and date range",
          "Implement pagination with configurable page size",
          "Add search functionality for post titles and content",
          "Create consistent error responses with appropriate status codes"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Express",
      "node"
    ],
    "legacy": {
      "originalId": 3,
      "originalTopic": "Express",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-4",
    "moduleSlug": "node-fundamentals",
    "title": "Middleware in Express",
    "order": 4,
    "objectives": [
      "Understand the Express middleware architecture and execution flow",
      "Create custom middleware functions for various application needs",
      "Implement error-handling middleware for centralized error management"
    ],
    "intro": "Express middleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application's request-response cycle. Middleware functions can execute any code, make changes to the request and response objects, end the request-response cycle, or call the next middleware function in the stack.\n\nThe middleware architecture is one of Express's most powerful features, enabling developers to modularize application logic into reusable, composable units. Middleware functions can be applied globally to all routes, to specific routes, or to specific HTTP methods. Understanding how middleware works is essential for building well-structured Express applications.\n\nThere are several types of middleware in Express: application-level middleware (applied to the entire app), router-level middleware (applied to specific routers), error-handling middleware (handles errors), built-in middleware (like express.json()), and third-party middleware (like helmet or morgan). Each type serves specific purposes in the application architecture.\n\nThis lesson will explore the middleware execution flow, including how the order of middleware registration affects application behavior. You'll learn to create custom middleware for authentication, logging, request validation, and data transformation. Additionally, you'll understand error-handling middleware patterns for centralized error management.\n\nBy the end of this lesson, you'll be able to design and implement middleware solutions that enhance your Express applications with cross-cutting concerns like logging, authentication, and error handling while maintaining clean, maintainable code structure.",
    "code": {
      "example": "const express = require('express');\nconst app = express();\n\n// 1. Built-in middleware\napp.use(express.json({ limit: '10mb' })); // Parse JSON bodies\napp.use(express.urlencoded({ extended: true })); // Parse URL-encoded bodies\n\n// 2. Application-level middleware - Logging\nconst requestLogger = (req, res, next) => {\n  const timestamp = new Date().toISOString();\n  const method = req.method;\n  const url = req.url;\n  const ip = req.ip || req.connection.remoteAddress;\n  \n  console.log(`[${timestamp}] ${method} ${url} - IP: ${ip}`);\n  \n  // Add timing information\n  const start = Date.now();\n  res.on('finish', () => {\n    const duration = Date.now() - start;\n    console.log(`[${timestamp}] ${method} ${url} - Status: ${res.statusCode} - Duration: ${duration}ms`);\n  });\n  \n  next();\n};\n\napp.use(requestLogger);\n\n// 3. Route-specific middleware - Authentication\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers.authorization;\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n  \n  if (!token) {\n    return res.status(401).json({\n      error: 'Access token required',\n      code: 'MISSING_TOKEN'\n    });\n  }\n  \n  // In a real app, you would verify the JWT token here\n  try {\n    // const decoded = jwt.verify(token, process.env.JWT_SECRET);\n    // req.user = decoded;\n    req.user = { id: 123, name: 'Test User' }; // Mock user for example\n    next();\n  } catch (error) {\n    return res.status(403).json({\n      error: 'Invalid or expired token',\n      code: 'INVALID_TOKEN'\n    });\n  }\n};\n\n// 4. Parameter validation middleware\nconst validateUserId = (req, res, next) => {\n  const userId = parseInt(req.params.userId);\n  \n  if (isNaN(userId) || userId <= 0) {\n    return res.status(400).json({\n      error: 'Valid user ID required',\n      code: 'INVALID_USER_ID'\n    });\n  }\n  \n  req.userId = userId;\n  next();\n};\n\n// 5. Data transformation middleware\nconst transformUserData = (req, res, next) => {\n  if (req.body && typeof req.body === 'object') {\n    // Normalize email to lowercase\n    if (req.body.email) {\n      req.body.email = req.body.email.toLowerCase();\n    }\n    \n    // Trim whitespace from string fields\n    Object.keys(req.body).forEach(key => {\n      if (typeof req.body[key] === 'string') {\n        req.body[key] = req.body[key].trim();\n      }\n    });\n  }\n  next();\n};\n\n// 6. Error-handling middleware (must have 4 parameters)\nconst errorHandler = (err, req, res, next) => {\n  console.error('Unhandled error:', err);\n  \n  // Determine error type and response\n  if (err.type === 'entity.parse.failed') {\n    return res.status(400).json({\n      error: 'Invalid JSON in request body',\n      code: 'INVALID_JSON'\n    });\n  }\n  \n  if (err.type === 'entity.too.large') {\n    return res.status(413).json({\n      error: 'Request entity too large',\n      code: 'PAYLOAD_TOO_LARGE'\n    });\n  }\n  \n  // Default error response\n  res.status(500).json({\n    error: 'Internal server error',\n    code: 'INTERNAL_ERROR'\n  });\n};\n\n// Routes using middleware\napp.get('/', (req, res) => {\n  res.json({\n    message: 'Hello from Express!',\n    timestamp: new Date().toISOString()\n  });\n});\n\n// Route with authentication middleware\napp.get('/profile', authenticateToken, (req, res) => {\n  res.json({\n    message: 'Protected profile data',\n    user: req.user\n  });\n});\n\n// Route with parameter validation\napp.get('/users/:userId', validateUserId, (req, res) => {\n  res.json({\n    message: `User data for user ID: ${req.userId}`\n  });\n});\n\n// Route with data transformation\napp.post('/users', transformUserData, (req, res) => {\n  res.status(201).json({\n    message: 'User created successfully',\n    data: req.body\n  });\n});\n\n// Apply error-handling middleware last\napp.use(errorHandler);\n\n// 404 handler (should be before error handler)\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Route not found',\n    code: 'NOT_FOUND'\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`\nðŸš€ Express server with middleware running on port ${PORT}\n\nAvailable endpoints:\n  GET  /              - Public endpoint\n  GET  /profile        - Protected endpoint (requires auth)\n  GET  /users/:userId  - User data (requires valid ID)\n  POST /users          - Create user (transforms data)\n`);\n});",
      "explanation": "This example demonstrates various types of Express middleware:\n\n1. **Built-in Middleware**: express.json() and express.urlencoded() for parsing request bodies\n2. **Application-Level Middleware**: requestLogger that logs all requests with timing\n3. **Route-Specific Middleware**: authenticateToken for protected routes\n4. **Parameter Validation**: validateUserId for validating route parameters\n5. **Data Transformation**: transformUserData for normalizing request data\n6. **Error Handling**: errorHandler for centralized error management\n7. **404 Handler**: Catch-all middleware for undefined routes\n\nThe output shows:\nðŸš€ Express server with middleware running on port 3000\n\nAvailable endpoints:\n  GET  /              - Public endpoint\n  GET  /profile        - Protected endpoint (requires auth)\n  GET  /users/:userId  - User data (requires valid ID)\n  POST /users          - Create user (transforms data)\n\nKey concepts illustrated:\n- Middleware execution order\n- Next() function usage\n- Request/response object modification\n- Error handling patterns\n- Conditional middleware application\n- Request validation and transformation",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Forgetting to call next() in middleware functions",
        "solution": "Always call next() to pass control to the next middleware, or end the request-response cycle with res.send() or similar",
        "severity": "high"
      },
      {
        "mistake": "Adding middleware in the wrong order",
        "solution": "Register middleware in the correct sequence: logging, parsing, authentication, route handlers, error handling",
        "severity": "high"
      },
      {
        "mistake": "Not handling asynchronous errors in middleware",
        "solution": "Wrap async middleware in try/catch blocks or use async error handling utilities",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement Comprehensive Middleware for an E-commerce API",
        "description": "Create a complete middleware system for an e-commerce application with authentication, rate limiting, and request validation",
        "checkpoints": [
          "Implement JWT-based authentication middleware with role-based access control",
          "Create rate limiting middleware to prevent abuse",
          "Build request validation middleware for product and order data",
          "Design error handling middleware with different responses for various error types",
          "Implement request logging middleware with performance metrics"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Express",
      "node"
    ],
    "legacy": {
      "originalId": 4,
      "originalTopic": "Express",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-5",
    "moduleSlug": "node-fundamentals",
    "title": "Working with Databases in Node.js",
    "order": 5,
    "objectives": [
      "Connect to and perform CRUD operations with MongoDB using the official driver",
      "Implement database connection pooling and proper resource management",
      "Design data models and schemas for document-based databases"
    ],
    "intro": "Database integration is a critical aspect of most Node.js applications, enabling persistent storage and retrieval of application data. MongoDB, a popular NoSQL document database, integrates seamlessly with Node.js through its official driver, making it an excellent choice for flexible, scalable data storage.\n\nUnlike traditional relational databases, MongoDB stores data in flexible, JSON-like documents, meaning fields can vary from document to document and data structure can be changed over time. This flexibility makes MongoDB particularly well-suited for applications with evolving data requirements or complex hierarchical data structures.\n\nWorking with databases in Node.js requires understanding connection management, query patterns, indexing strategies, and error handling. Proper database integration includes implementing connection pooling for performance, handling network errors gracefully, and following security best practices like parameterized queries to prevent injection attacks.\n\nThis lesson will explore MongoDB integration with Node.js, covering connection setup, CRUD operations, indexing, aggregation pipelines, and best practices for production deployments. You'll learn to design efficient data models, implement proper error handling, and optimize database operations for performance.\n\nBy the end of this lesson, you'll be able to integrate MongoDB into your Node.js applications effectively, implement robust data access patterns, and apply database optimization techniques to ensure your applications perform well under load.",
    "code": {
      "example": "const { MongoClient } = require('mongodb');\n\n// Database connection configuration\nconst config = {\n  uri: process.env.MONGODB_URI || 'mongodb://localhost:27017',\n  dbName: process.env.DB_NAME || 'ecommerce',\n  options: {\n    useUnifiedTopology: true,\n    maxPoolSize: 10, // Connection pool size\n    serverSelectionTimeoutMS: 5000, // Timeout for server selection\n    socketTimeoutMS: 45000, // Close sockets after 45 seconds of inactivity\n  }\n};\n\n// Create a single client instance (should be reused)\nconst client = new MongoClient(config.uri, config.options);\n\nclass DatabaseService {\n  constructor() {\n    this.db = null;\n  }\n\n  async connect() {\n    try {\n      await client.connect();\n      this.db = client.db(config.dbName);\n      console.log(`Connected to MongoDB database: ${config.dbName}`);\n      \n      // Create indexes for better query performance\n      await this.createIndexes();\n      return this.db;\n    } catch (error) {\n      console.error('Database connection error:', error);\n      throw error;\n    }\n  }\n\n  async createIndexes() {\n    try {\n      const users = this.db.collection('users');\n      const products = this.db.collection('products');\n      const orders = this.db.collection('orders');\n\n      // Create indexes for common queries\n      await users.createIndex({ email: 1 }, { unique: true });\n      await users.createIndex({ createdAt: -1 });\n      await products.createIndex({ category: 1, price: 1 });\n      await products.createIndex({ 'tags.name': 1 });\n      await orders.createIndex({ userId: 1, createdAt: -1 });\n      await orders.createIndex({ status: 1 });\n\n      console.log('Database indexes created successfully');\n    } catch (error) {\n      console.error('Index creation error:', error);\n    }\n  }\n\n  // User operations\n  async createUser(userData) {\n    try {\n      const users = this.db.collection('users');\n      const user = {\n        ...userData,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n      \n      const result = await users.insertOne(user);\n      return {\n        id: result.insertedId,\n        ...user\n      };\n    } catch (error) {\n      if (error.code === 11000) {\n        throw new Error('User with this email already exists');\n      }\n      throw error;\n    }\n  }\n\n  async findUserByEmail(email) {\n    const users = this.db.collection('users');\n    return await users.findOne({ email });\n  }\n\n  // Product operations with pagination\n  async findProducts(filter = {}, options = {}) {\n    const {\n      page = 1,\n      limit = 10,\n      sortBy = 'createdAt',\n      sortOrder = 'desc'\n    } = options;\n\n    const products = this.db.collection('products');\n    \n    const skip = (page - 1) * limit;\n    const sort = { [sortBy]: sortOrder === 'desc' ? -1 : 1 };\n    \n    const [items, total] = await Promise.all([\n      products.find(filter).sort(sort).skip(skip).limit(limit).toArray(),\n      products.countDocuments(filter)\n    ]);\n\n    return {\n      items,\n      pagination: {\n        page: parseInt(page),\n        limit: parseInt(limit),\n        total,\n        pages: Math.ceil(total / limit)\n      }\n    };\n  }\n\n  // Aggregation pipeline example\n  async getOrderStats(userId) {\n    const orders = this.db.collection('orders');\n    \n    const pipeline = [\n      { $match: { userId: new require('mongodb').ObjectId(userId) } },\n      {\n        $group: {\n          _id: '$status',\n          count: { $sum: 1 },\n          totalAmount: { $sum: '$totalAmount' }\n        }\n      },\n      {\n        $project: {\n          status: '$_id',\n          count: 1,\n          totalAmount: 1,\n          averageAmount: { $divide: ['$totalAmount', '$count'] }\n        }\n      }\n    ];\n\n    return await orders.aggregate(pipeline).toArray();\n  }\n\n  // Proper resource cleanup\n  async close() {\n    try {\n      await client.close();\n      console.log('Database connection closed');\n    } catch (error) {\n      console.error('Error closing database connection:', error);\n    }\n  }\n}\n\n// Usage example\nasync function main() {\n  const dbService = new DatabaseService();\n  \n  try {\n    // Connect to database\n    await dbService.connect();\n\n    // Create a user\n    const newUser = await dbService.createUser({\n      name: 'John Doe',\n      email: 'john@example.com',\n      preferences: {\n        newsletter: true,\n        notifications: 'email'\n      }\n    });\n    console.log('Created user:', newUser);\n\n    // Find user\n    const user = await dbService.findUserByEmail('john@example.com');\n    console.log('Found user:', user);\n\n    // Add some products\n    const products = dbService.db.collection('products');\n    await products.insertMany([\n      {\n        name: 'Laptop',\n        price: 999.99,\n        category: 'Electronics',\n        tags: [{ name: 'tech' }, { name: 'computer' }],\n        inStock: true\n      },\n      {\n        name: 'Book',\n        price: 19.99,\n        category: 'Education',\n        tags: [{ name: 'learning' }],\n        inStock: true\n      }\n    ]);\n\n    // Find products with pagination\n    const productResults = await dbService.findProducts(\n      { inStock: true },\n      { page: 1, limit: 5, sortBy: 'price' }\n    );\n    console.log('Products:', productResults);\n\n    // Create an order\n    const orders = dbService.db.collection('orders');\n    await orders.insertOne({\n      userId: newUser.id,\n      items: [{ productId: productResults.items[0]._id, quantity: 1 }],\n      totalAmount: 999.99,\n      status: 'pending',\n      createdAt: new Date()\n    });\n\n    // Get order statistics\n    const stats = await dbService.getOrderStats(newUser.id.toString());\n    console.log('Order stats:', stats);\n\n  } catch (error) {\n    console.error('Application error:', error);\n  } finally {\n    // Always close the connection\n    await dbService.close();\n  }\n}\n\n// Run the example if this file is executed directly\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = DatabaseService;",
      "explanation": "This example demonstrates comprehensive MongoDB integration with Node.js:\n\n1. **Connection Management**: Proper client initialization with connection pooling\n2. **Configuration**: Environment-based configuration with sensible defaults\n3. **Indexing**: Automatic `index` creation for query performance\n4. **CRUD Operations**: Complete create, read, update, and delete patterns\n5. **Error Handling**: Specific error handling for duplicate keys and other scenarios\n6. **Pagination**: Database-level pagination with total count calculation\n7. **Aggregation**: Complex data analysis using MongoDB aggregation pipelines\n8. **Resource Management**: Proper connection cleanup\n\nThe output shows:\nConnected to MongoDB database: ecommerce\nDatabase indexes created successfully\nCreated user: { id: ObjectId(...), name: 'John Doe', ... }\nFound user: { _id: ObjectId(...), name: 'John Doe', ... }\nProducts: { items: [...], pagination: { ... } }\nOrder stats: [ { status: 'pending', count: 1, totalAmount: 999.99, ... } ]\nDatabase connection closed\n\nKey concepts illustrated:\n- Singleton pattern for database client\n- `Index` creation for performance\n- Pagination implementation\n- Aggregation pipelines\n- Error handling strategies\n- Resource cleanup\n- Data modeling with nested documents",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating a new database connection for every operation",
        "solution": "Use a single MongoDB client instance with connection pooling for all operations",
        "severity": "high"
      },
      {
        "mistake": "Not handling ObjectId conversion properly",
        "solution": "Always convert string IDs to ObjectId when querying by _id, and handle conversion errors",
        "severity": "high"
      },
      {
        "mistake": "Missing database indexes for common query patterns",
        "solution": "Analyze query patterns and create appropriate indexes to improve performance",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build a Complete Blog Platform Database Layer",
        "description": "Create a database service for a blog platform with posts, comments, and user management",
        "checkpoints": [
          "Implement CRUD operations for blog posts with tagging and categorization",
          "Create a comment system with nested replies and user references",
          "Design user profiles with follow relationships and preferences",
          "Implement full-text search for post content and titles",
          "Add database indexing for common query patterns like popular posts and user feeds"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Database",
      "node"
    ],
    "legacy": {
      "originalId": 5,
      "originalTopic": "Database",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-6",
    "moduleSlug": "node-fundamentals",
    "title": "Promises and Async/Await",
    "order": 6,
    "objectives": [
      "Master Promise patterns including chaining, error handling, and concurrency",
      "Implement async/await for readable asynchronous code",
      "Apply best practices for error handling in asynchronous operations"
    ],
    "intro": "Asynchronous programming is at the heart of Node.js, enabling non-blocking I/O operations that make applications highly efficient and scalable. Understanding how to work with asynchronous code is essential for building responsive Node.js applications that can handle multiple operations concurrently.\n\nJavaScript provides several mechanisms for handling asynchronous operations: callbacks, Promises, and async/await. While callbacks were the original approach, they can lead to deeply nested code (callback hell). Promises provide a more structured approach with better error handling, and async/await offers the most readable syntax while maintaining the benefits of Promises.\n\nPromises represent the eventual completion (or failure) of an asynchronous operation and its resulting value. They provide methods for chaining operations, handling errors, and managing concurrent operations. Understanding Promise states (pending, fulfilled, rejected) and methods (then, catch, finally) is crucial for effective asynchronous programming.\n\nAsync/await syntax, introduced in ES2017, builds on Promises to make asynchronous code look and behave more like synchronous code. This syntactic sugar makes code more readable and easier to debug while maintaining the non-blocking nature of asynchronous operations.\n\nThis lesson will explore Promise patterns including chaining, parallel execution with Promise.all, race conditions with Promise.race, and error handling strategies. You'll learn to convert callback-based code to Promise-based code and use async/await effectively.\n\nBy the end of this lesson, you'll be able to write clean, maintainable asynchronous code that handles errors gracefully, executes operations efficiently, and follows modern JavaScript best practices.",
    "code": {
      "example": "// 1. Promise basics and creation\nfunction fetchUserData(userId) {\n  return new Promise((resolve, reject) => {\n    // Simulate API call\n    setTimeout(() => {\n      if (userId > 0) {\n        resolve({\n          id: userId,\n          name: `User ${userId}`,\n          email: `user${userId}@example.com`\n        });\n      } else {\n        reject(new Error('Invalid user ID'));\n      }\n    }, 100);\n  });\n}\n\n// 2. Promise chaining\nfunction fetchUserPosts(userId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      if (userId > 0) {\n        resolve([\n          { id: 1, title: 'First Post', userId },\n          { id: 2, title: 'Second Post', userId }\n        ]);\n      } else {\n        reject(new Error('Invalid user ID for posts'));\n      }\n    }, 150);\n  });\n}\n\n// 3. Promise.all for concurrent operations\nfunction fetchAllUserData(userId) {\n  return Promise.all([\n    fetchUserData(userId),\n    fetchUserPosts(userId)\n  ]).then(([user, posts]) => ({\n    user,\n    posts,\n    postCount: posts.length\n  }));\n}\n\n// 4. Promise.race for timeout implementation\nfunction withTimeout(promise, ms) {\n  const timeout = new Promise((_, reject) => {\n    setTimeout(() => reject(new Error('Operation timed out')), ms);\n  });\n  return Promise.race([promise, timeout]);\n}\n\n// 5. Async/await implementation\nasync function getUserDashboard(userId) {\n  try {\n    // Concurrent operations\n    const [user, posts] = await Promise.all([\n      fetchUserData(userId),\n      fetchUserPosts(userId)\n    ]);\n\n    // Sequential operations\n    const postCount = posts.length;\n    \n    return {\n      user,\n      posts,\n      postCount,\n      lastUpdated: new Date().toISOString()\n    };\n  } catch (error) {\n    // Centralized error handling\n    console.error('Failed to load dashboard:', error.message);\n    throw error;\n  }\n}\n\n// 6. Error handling patterns\nasync function robustUserFetch(userId) {\n  try {\n    const user = await fetchUserData(userId);\n    return user;\n  } catch (error) {\n    // Specific error handling\n    if (error.message === 'Invalid user ID') {\n      throw new Error(`User with ID ${userId} does not exist`);\n    }\n    \n    // Retry logic for transient errors\n    if (error.message.includes('timeout') && retryCount < 3) {\n      console.log(`Retrying user fetch (attempt ${retryCount + 1})`);\n      await new Promise(resolve => setTimeout(resolve, 1000));\n      return robustUserFetch(userId, retryCount + 1);\n    }\n    \n    // Re-throw for upstream handling\n    throw error;\n  }\n}\n\n// 7. Converting callback-based code to Promise-based\nfunction readFilePromise(filename) {\n  const fs = require('fs').promises;\n  return fs.readFile(filename, 'utf8');\n}\n\n// 8. Practical example: Data processing pipeline\nasync function processDataPipeline(dataSources) {\n  try {\n    // Fetch all data concurrently\n    const fetchDataPromises = dataSources.map(source => \n      withTimeout(fetch(source.url), 5000)\n    );\n    \n    const rawData = await Promise.all(fetchDataPromises);\n    \n    // Process data sequentially\n    const processedData = [];\n    for (let i = 0; i < rawData.length; i++) {\n      const processed = await processItem(rawData[i], dataSources[i].processor);\n      processedData.push(processed);\n    }\n    \n    return processedData;\n  } catch (error) {\n    console.error('Pipeline failed:', error.message);\n    throw new Error(`Data pipeline failed: ${error.message}`);\n  }\n}\n\n// Helper function for pipeline example\nasync function processItem(data, processor) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(processor ? processor(data) : data);\n    }, 50);\n  });\n}\n\n// Usage examples\nasync function main() {\n  console.log('=== Promise Examples ===');\n  \n  try {\n    // Promise chaining\n    const userData = await fetchUserData(1)\n      .then(user => {\n        console.log('User fetched:', user.name);\n        return fetchUserPosts(user.id);\n      })\n      .then(posts => {\n        console.log('Posts fetched:', posts.length);\n        return { userId: 1, postCount: posts.length };\n      });\n    console.log('Chained result:', userData);\n    \n    // Concurrent operations\n    console.log('\n=== Concurrent Operations ===');\n    const allData = await fetchAllUserData(1);\n    console.log('All user data:', {\n      name: allData.user.name,\n      posts: allData.postCount\n    });\n    \n    // Async/await\n    console.log('\n=== Async/Await ===');\n    const dashboard = await getUserDashboard(1);\n    console.log('Dashboard loaded:', {\n      user: dashboard.user.name,\n      posts: dashboard.postCount\n    });\n    \n    // Error handling\n    console.log('\n=== Error Handling ===');\n    try {\n      await fetchUserData(-1);\n    } catch (error) {\n      console.log('Caught expected error:', error.message);\n    }\n    \n  } catch (error) {\n    console.error('Unexpected error:', error.message);\n  }\n}\n\n// Run examples\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = {\n  fetchUserData,\n  fetchUserPosts,\n  fetchAllUserData,\n  getUserDashboard,\n  robustUserFetch,\n  processDataPipeline\n};",
      "explanation": "This example demonstrates comprehensive asynchronous programming patterns:\n\n1. **Promise Creation**: Custom Promise-based functions with proper resolve/reject\n2. **Promise Chaining**: Sequential operations with .then() method chaining\n3. **Concurrent Operations**: Parallel execution using Promise.all()\n4. **Timeout Implementation**: Race conditions with Promise.race()\n5. **Async/Await**: Modern syntax for readable asynchronous code\n6. **Error Handling**: Centralized and specific error handling patterns\n7. **Retry Logic**: Transient error recovery with retry mechanisms\n8. **Callback Conversion**: Transforming callback-based APIs to Promise-based\n9. **Data Pipelines**: Complex workflows combining concurrent and sequential operations\n\nThe output shows:\n=== Promise Examples ===\nUser fetched: User 1\nPosts fetched: 2\nChained result: { userId: 1, postCount: 2 }\n\n=== Concurrent Operations ===\nAll user data: { name: 'User 1', posts: 2 }\n\n=== Async/Await ===\nDashboard loaded: { user: 'User 1', posts: 2 }\n\n=== Error Handling ===\nCaught expected error: Invalid user ID\n\nKey concepts illustrated:\n- Promise states and lifecycle\n- Chaining vs. nesting\n- Concurrent vs. sequential execution\n- Error propagation and handling\n- Timeout and retry patterns\n- Modern async/await usage\n- Real-world application patterns",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Using Promise.all() when operations are dependent on each other",
        "solution": "Use Promise.all() only for independent operations; use chaining for dependent operations",
        "severity": "high"
      },
      {
        "mistake": "Forgetting to handle Promise rejections",
        "solution": "Always add .catch() handlers or use try/catch with async/await",
        "severity": "high"
      },
      {
        "mistake": "Creating multiple async functions without proper error boundaries",
        "solution": "Implement centralized error handling and consistent error types",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build a Robust API Client with Advanced Async Patterns",
        "description": "Create an API client that handles retries, timeouts, and concurrent requests",
        "checkpoints": [
          "Implement request timeout functionality with Promise.race()",
          "Create retry logic with exponential backoff for failed requests",
          "Design concurrent request batching with controlled parallelism",
          "Build error handling that distinguishes between client, server, and network errors",
          "Implement request/response logging for debugging"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Async Programming",
      "node"
    ],
    "legacy": {
      "originalId": 6,
      "originalTopic": "Async Programming",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-7",
    "moduleSlug": "node-fundamentals",
    "title": "File System Operations",
    "order": 7,
    "objectives": [
      "Perform file operations using both synchronous and asynchronous fs methods",
      "Implement directory operations and file system navigation",
      "Apply streams for efficient handling of large files"
    ],
    "intro": "The Node.js file system (fs) module provides an API for interacting with the file system in a manner closely modeled around standard POSIX functions. File system operations are fundamental to many Node.js applications, from simple configuration file reading to complex data processing pipelines.\n\nNode.js offers three main approaches to file system operations: synchronous methods (blocking), callback-based asynchronous methods (non-blocking), and Promise-based methods (modern approach). Understanding when to use each approach is crucial for building efficient applications that maintain Node.js's non-blocking nature.\n\nFile system operations include reading, writing, updating, and deleting files and directories. More advanced operations involve watching files for changes, managing file permissions, creating symbolic links, and working with file streams for memory-efficient processing of large files.\n\nThis lesson will explore the fs module's capabilities, covering file and directory operations, different API styles, error handling patterns, and performance considerations. You'll learn to work with file paths using the path module, implement file system navigation, and use streams for efficient data processing.\n\nBy the end of this lesson, you'll be able to perform comprehensive file system operations in Node.js, handle errors appropriately, and choose the right approach for different scenarios while maintaining application performance.",
    "code": {
      "example": "const fs = require('fs').promises;\nconst fss = require('fs'); // Synchronous version\nconst path = require('path');\nconst { createReadStream, createWriteStream } = require('fs');\nconst { pipeline } = require('stream/promises');\n\n// 1. File operations with error handling\nclass FileManager {\n  constructor(basePath = '.') {\n    this.basePath = basePath;\n  }\n\n  // Safe file reading with multiple fallback encodings\n  async readFileSafe(filePath, encodings = ['utf8', 'latin1']) {\n    const fullPath = path.join(this.basePath, filePath);\n    \n    for (const encoding of encodings) {\n      try {\n        const data = await fs.readFile(fullPath, { encoding });\n        console.log(`File read successfully with ${encoding} encoding`);\n        return { data, encoding };\n      } catch (error) {\n        if (error.code === 'ENOENT') {\n          throw new Error(`File not found: ${fullPath}`);\n        }\n        if (encodings.indexOf(encoding) === encodings.length - 1) {\n          throw error; // Last encoding, re-throw\n        }\n        console.log(`Failed to read with ${encoding}, trying next encoding`);\n      }\n    }\n  }\n\n  // Atomic file writing with backup\n  async writeFileAtomic(filePath, data, options = {}) {\n    const fullPath = path.join(this.basePath, filePath);\n    const backupPath = `${fullPath}.backup`;        try {      // Create backup if file exists      try {        await fs.access(fullPath);        await fs.copyFile(fullPath, backupPath);        console.log('Backup created');      } catch (error) {        if (error.code !== 'ENOENT') throw error;      }      // Write new file      await fs.writeFile(fullPath, data, options);      console.log('File written successfully');            // Remove backup on success      try {        await fs.unlink(backupPath);      } catch (error) {        if (error.code !== 'ENOENT') throw error;      }            return true;    } catch (error) {      // Restore from backup on failure      try {        await fs.access(backupPath);        await fs.copyFile(backupPath, fullPath);        await fs.unlink(backupPath);        console.log('Restored from backup');      } catch (restoreError) {        if (restoreError.code !== 'ENOENT') {          console.error('Failed to restore from backup:', restoreError.message);        }      }      throw error;    }  }  // Directory operations  async ensureDirectory(dirPath) {    const fullPath = path.join(this.basePath, dirPath);    try {      await fs.mkdir(fullPath, { recursive: true });      console.log(`Directory ensured: ${fullPath}`);      return true;    } catch (error) {      if (error.code !== 'EEXIST') throw error;      return true;    }  }  // List directory contents with filtering  async listDirectory(dirPath, filter = null) {    const fullPath = path.join(this.basePath, dirPath);    try {      const entries = await fs.readdir(fullPath, { withFileTypes: true });            let filtered = entries;      if (filter) {        filtered = entries.filter(filter);      }            return filtered.map(entry => ({        name: entry.name,        type: entry.isDirectory() ? 'directory' : 'file',        path: path.join(dirPath, entry.name)      }));    } catch (error) {      if (error.code === 'ENOENT') {        throw new Error(`Directory not found: ${fullPath}`);      }      throw error;    }  }  // File processing with streams for large files  async processLargeFile(inputPath, outputPath, transformer) {    const inputFullPath = path.join(this.basePath, inputPath);    const outputFullPath = path.join(this.basePath, outputPath);        // Ensure output directory exists    await this.ensureDirectory(path.dirname(outputPath));        const readStream = createReadStream(inputFullPath);    const writeStream = createWriteStream(outputFullPath);        // Create transform stream    const { Transform } = require('stream');    const transformStream = new Transform({      transform(chunk, encoding, callback) {        try {          const transformed = transformer(chunk.toString());          callback(null, transformed);        } catch (error) {          callback(error);        }      }    });        try {      await pipeline(readStream, transformStream, writeStream);      console.log(`File processed: ${inputPath} -> ${outputPath}`);      return true;    } catch (error) {      // Clean up partial output file      try {        await fs.unlink(outputFullPath);      } catch (unlinkError) {        // Ignore unlink errors      }      throw error;    }  }  // Get file statistics  async getFileStats(filePath) {    const fullPath = path.join(this.basePath, filePath);    try {      const stats = await fs.stat(fullPath);      return {        size: stats.size,        isFile: stats.isFile(),        isDirectory: stats.isDirectory(),        createdAt: stats.birthtime,        modifiedAt: stats.mtime,        permissions: stats.mode.toString(8).slice(-3),        owner: stats.uid      };    } catch (error) {      if (error.code === 'ENOENT') {        throw new Error(`File not found: ${fullPath}`);      }      throw error;    }  }}// 2. Practical examplesasync function fileSystemDemo() {  const fileManager = new FileManager('./demo');    try {    // Ensure demo directory exists    await fileManager.ensureDirectory('.');        // Write and read file    const content = 'Hello, Node.js File System!This is a demo file with multiple lines.It demonstrates various file operations.';    await fileManager.writeFileAtomic('demo.txt', content);        const readResult = await fileManager.readFileSafe('demo.txt');    console.log('File content:', readResult.data.substring(0, 50) + '...');        // Get file statistics    const stats = await fileManager.getFileStats('demo.txt');    console.log('File stats:', {      size: stats.size,      permissions: stats.permissions,      modified: stats.modifiedAt.toISOString()    });        // List directory contents    const entries = await fileManager.listDirectory('.', entry =>      entry.name.endsWith('.txt')    );    console.log('Text files:', entries.map(e => e.name));        // Process large file with streams    await fileManager.writeFileAtomic('large-input.txt',      'Line 1Line 2Line 3Line 4Line 5'.repeat(1000)    );        await fileManager.processLargeFile(      'large-input.txt',      'large-output.txt',      (chunk) => chunk.toUpperCase()    );        // Verify output    const outputStats = await fileManager.getFileStats('large-output.txt');    console.log('Output file size:', outputStats.size, 'bytes');        console.log('All file operations completed successfully!');      } catch (error) {    console.error('File system operation failed:', error.message);    throw error;  } finally {    // Cleanup demo files    try {      await fs.unlink('./demo/demo.txt');      await fs.unlink('./demo/large-input.txt');      await fs.unlink('./demo/large-output.txt');      console.log('Demo files cleaned up');    } catch (error) {      // Ignore cleanup errors    }  }}// Run demo if executed directlyif (require.main === module) {  fileSystemDemo().catch(console.error);}module.exports = FileManager;",
      "explanation": "This example demonstrates comprehensive file system operations:\n\n1. **Safe File Operations**: Error handling with encoding fallbacks and atomic writes\n2. **Backup and Restore**: Automatic backup creation with rollback on failure\n3. **Directory Management**: Recursive directory creation and content listing\n4. **File Filtering**: Directory listing with custom filters\n5. **Stream Processing**: Memory-efficient processing of large files\n6. **File Statistics**: Detailed file information including permissions and timestamps\n7. **Error Handling**: Specific error handling for different file system error codes\n8. **Resource Cleanup**: Proper cleanup of temporary files\n\nThe output shows:\nDirectory ensured: ./demo\nFile written successfully\nBackup created\nFile read successfully with utf8 encoding\nFile stats: { size: 95, permissions: '644', modified: '2025-10-03T10:00:00.000Z' }\nText files: [ 'demo.txt' ]\nFile processed: large-input.txt -> large-output.txt\nOutput file size: 70000 bytes\nAll file operations completed successfully!\nDemo files cleaned up\n\nKey concepts illustrated:\n- Promise-based fs methods\n- Error code handling (ENOENT, EEXIST, etc.)\n- Atomic file operations\n- Stream pipelines\n- Path manipulation\n- File system statistics\n- Directory operations\n- Resource management",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Using synchronous fs methods in web applications",
        "solution": "Use Promise-based or callback-based fs methods to maintain non-blocking behavior",
        "severity": "high"
      },
      {
        "mistake": "Not handling different file system error codes",
        "solution": "Handle specific error codes like ENOENT (not found), EACCES (permission denied), and EEXIST (already exists)",
        "severity": "high"
      },
      {
        "mistake": "Loading entire large files into memory",
        "solution": "Use streams for processing large files to avoid memory exhaustion",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Build a File Backup and Sync System",
        "description": "Create a comprehensive file management system with backup, sync, and monitoring capabilities",
        "checkpoints": [
          "Implement incremental backup with file change detection",
          "Create file synchronization between directories with conflict resolution",
          "Add file monitoring with automatic processing of new files",
          "Design compression and encryption for backup files",
          "Implement logging and reporting for backup operations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "File System",
      "node"
    ],
    "legacy": {
      "originalId": 7,
      "originalTopic": "File System",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-8",
    "moduleSlug": "node-fundamentals",
    "title": "Error Handling and Debugging",
    "order": 8,
    "objectives": [
      "Implement comprehensive error handling with custom error types and centralized error management",
      "Apply debugging techniques including logging, stack traces, and performance profiling",
      "Design resilient applications that gracefully handle failures and recover from errors"
    ],
    "intro": "Effective error handling and debugging are critical for building robust, production-ready Node.js applications. Errors in Node.js applications can range from simple validation issues to complex system failures, and handling them properly is essential for maintaining application stability and providing good user experiences.\n\nNode.js provides both synchronous and asynchronous error handling mechanisms. Synchronous errors can be caught with try/catch blocks, while asynchronous errors require different approaches depending on whether you're using callbacks, Promises, or async/await. Understanding these differences is crucial for comprehensive error handling.\n\nGood error handling involves more than just catching exceptions. It includes creating meaningful error messages, categorizing errors for appropriate responses, implementing fallback mechanisms, and logging errors for monitoring and debugging. Centralized error handling ensures consistency across your application.\n\nDebugging Node.js applications requires understanding various tools and techniques, from built-in debugging capabilities to external profiling tools. Proper logging with appropriate levels and structured data helps in diagnosing issues in production environments.\n\nThis lesson will explore error handling patterns including custom error types, centralized error management, graceful degradation, and recovery strategies. You'll learn debugging techniques with Node.js inspector, performance profiling, and logging best practices.\n\nBy the end of this lesson, you'll be able to implement comprehensive error handling that maintains application stability, provides useful debugging information, and ensures good user experiences even when things go wrong.",
    "code": {
      "example": "// 1. Custom error classes with metadata\nclass ApplicationError extends Error {\n  constructor(message, code, statusCode = 500, metadata = {}) {\n    super(message);\n    this.name = this.constructor.name;\n    this.code = code;\n    this.statusCode = statusCode;\n    this.metadata = metadata;\n    this.timestamp = new Date().toISOString();\n    \n    // Capture stack trace\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, this.constructor);\n    }\n  }\n}\n\nclass ValidationError extends ApplicationError {\n  constructor(message, field, value) {\n    super(message, 'VALIDATION_ERROR', 400, { field, value });\n  }\n}\n\nclass AuthenticationError extends ApplicationError {\n  constructor(message = 'Authentication required') {\n    super(message, 'AUTHENTICATION_ERROR', 401);\n  }\n}\n\nclass AuthorizationError extends ApplicationError {\n  constructor(message = 'Insufficient permissions') {\n    super(message, 'AUTHORIZATION_ERROR', 403);\n  }\n}\n\nclass ResourceNotFoundError extends ApplicationError {\n  constructor(resource, id) {\n    super(`${resource} with id ${id} not found`, 'RESOURCE_NOT_FOUND', 404, { resource, id });\n  }\n}\n\nclass ExternalServiceError extends ApplicationError {\n  constructor(service, originalError) {\n    super(\n      `External service error from ${service}: ${originalError.message}`,\n      'EXTERNAL_SERVICE_ERROR',\n      502,\n      { service, originalError: originalError.message }\n    );\n  }\n}\n\n// 2. Error factory for consistent error creation\nclass ErrorFactory {\n  static validation(field, value, message = `Invalid ${field}`) {\n    return new ValidationError(message, field, value);\n  }\n  \n  static notFound(resource, id) {\n    return new ResourceNotFoundError(resource, id);\n  }\n  \n  static auth(message) {\n    return new AuthenticationError(message);\n  }\n  \n  static forbidden(message) {\n    return new AuthorizationError(message);\n  }\n  \n  static external(service, error) {\n    return new ExternalServiceError(service, error);\n  }\n}\n\n// 3. Centralized error handler\nclass ErrorHandler {\n  static handle(error, req, res, next) {\n    // Log error with context\n    console.error('Application Error:', {\n      message: error.message,\n      code: error.code,\n      stack: error.stack,\n      url: req?.url,\n      method: req?.method,\n      userAgent: req?.get('User-Agent'),\n      timestamp: new Date().toISOString()\n    });\n    \n    // Handle different error types\n    if (error instanceof ApplicationError) {\n      return res.status(error.statusCode).json({\n        error: error.message,\n        code: error.code,\n        timestamp: error.timestamp,\n        ...error.metadata\n      });\n    }\n    \n    // Handle native JavaScript errors\n    if (error instanceof SyntaxError && error.message.includes('JSON')) {\n      return res.status(400).json({\n        error: 'Invalid JSON in request body',\n        code: 'INVALID_JSON'\n      });\n    }\n    \n    // Handle unhandled errors\n    console.error('Unhandled error:', error);\n    return res.status(500).json({\n      error: 'Internal server error',\n      code: 'INTERNAL_ERROR'\n    });\n  }\n  \n  static async handleAsync(asyncFn) {\n    return async (req, res, next) => {\n      try {\n        await asyncFn(req, res, next);\n      } catch (error) {\n        next(error);\n      }\n    };\n  }\n}\n\n// 4. Graceful shutdown handler\nclass GracefulShutdown {\n  static setup(server, services = []) {\n    const shutdown = async (signal) => {\n      console.log(`${signal} received, shutting down gracefully`);\n      \n      try {\n        // Close server\n        server.close(() => {\n          console.log('HTTP server closed');\n        });\n        \n        // Close services (database, etc.)\n        for (const service of services) {\n          if (typeof service.close === 'function') {\n            await service.close();\n            console.log(`${service.constructor.name} closed`);\n          }\n        }\n        \n        // Force shutdown after 10 seconds\n        setTimeout(() => {\n          console.error('Could not close connections in time, forcefully shutting down');\n          process.exit(1);\n        }, 10000);\n        \n      } catch (error) {\n        console.error('Error during graceful shutdown:', error);\n        process.exit(1);\n      }\n    };\n    \n    process.on('SIGTERM', () => shutdown('SIGTERM'));\n    process.on('SIGINT', () => shutdown('SIGINT'));\n  }\n}\n\n// 5. Structured logging\nclass Logger {\n  static levels = {\n    ERROR: 0,\n    WARN: 1,\n    INFO: 2,\n    DEBUG: 3\n  };\n  \n  constructor(level = 'INFO') {\n    this.level = this.constructor.levels[level];\n  }\n  \n  log(level, message, metadata = {}) {\n    if (this.constructor.levels[level] <= this.level) {\n      const logEntry = {\n        timestamp: new Date().toISOString(),\n        level,\n        message,\n        pid: process.pid,\n        ...metadata\n      };\n      \n      console.log(JSON.stringify(logEntry));\n    }\n  }\n  \n  error(message, metadata) {\n    this.log('ERROR', message, metadata);\n  }\n  \n  warn(message, metadata) {\n    this.log('WARN', message, metadata);\n  }\n  \n  info(message, metadata) {\n    this.log('INFO', message, metadata);\n  }\n  \n  debug(message, metadata) {\n    this.log('DEBUG', message, metadata);\n  }\n}\n\n// 6. Practical example with error handling\nconst logger = new Logger('DEBUG');\n\nasync function riskyOperation(input) {\n  // Simulate different error scenarios\n  if (!input) {\n    throw ErrorFactory.validation('input', input, 'Input is required');\n  }\n  \n  if (input === 'network-error') {\n    const networkError = new Error('Network timeout');\n    throw ErrorFactory.external('API Service', networkError);\n  }\n  \n  if (input === 'not-found') {\n    throw ErrorFactory.notFound('User', 123);\n  }\n  \n  // Simulate success\n  return { result: `Processed: ${input}`, timestamp: new Date().toISOString() };\n}\n\nasync function main() {\n  logger.info('Starting error handling demo');\n  \n  const testCases = [\n    null,\n    'network-error',\n    'not-found',\n    'valid-input'\n  ];\n  \n  for (const testCase of testCases) {\n    try {\n      const result = await riskyOperation(testCase);\n      logger.info('Operation successful', { result });\n    } catch (error) {\n      ErrorHandler.handle(error, null, {\n        status: (code) => ({ json: (data) => {\n          logger.error('Request error', { ...data, statusCode: code });\n        }})\n      }, null);\n    }\n  }\n  \n  logger.info('Error handling demo completed');\n}\n\n// 7. Express.js integration example\n/*\nconst express = require('express');\nconst app = express();\n\n// Use error handler middleware\napp.use(ErrorHandler.handle);\n\n// Start server with graceful shutdown\nconst server = app.listen(3000, () => {\n  console.log('Server running on port 3000');\n});\n\nGracefulShutdown.setup(server, [/* database service */]);\n*/\n\n// Run demo if executed directly\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = {\n  ApplicationError,\n  ValidationError,\n  AuthenticationError,\n  AuthorizationError,\n  ResourceNotFoundError,\n  ExternalServiceError,\n  ErrorFactory,\n  ErrorHandler,\n  GracefulShutdown,\n  Logger\n};",
      "explanation": "This example demonstrates comprehensive error handling and debugging techniques:\n\n1. **Custom Error Classes**: Hierarchical error types with metadata and status codes\n2. **Error Factory**: Consistent error creation with predefined patterns\n3. **Centralized Error Handler**: Unified error processing with logging and response formatting\n4. **Graceful Shutdown**: Proper resource cleanup on application termination\n5. **Structured Logging**: JSON-based logging with levels and metadata\n6. **Async Error Handling**: Wrapper for handling async route errors\n7. **Error Categorization**: Different error types for appropriate responses\n\nThe output shows:\n{\n  \"timestamp\":\"2025-10-03T10:00:00.000Z\",\n  \"level\":\"INFO\",\n  \"message\":\"Starting error handling demo\",\n  \"pid\":12345\n}\n{\n  \"timestamp\":\"2025-10-03T10:00:00.000Z\",\n  \"level\":\"ERROR\",\n  \"message\":\"Request error\",\n  \"pid\":12345,\n  \"error\":\"Input is required\",\n  \"code\":\"VALIDATION_ERROR\",\n  \"field\":\"input\",\n  \"value\":null,\n  \"statusCode\":400\n}\nApplication Error: {\n  \"message\":\"External service error from API Service: Network timeout\",\n  \"code\":\"EXTERNAL_SERVICE_ERROR\",\n  \"stack\":\"ExternalServiceError: External service error...\",\n  \"timestamp\":\"2025-10-03T10:00:00.000Z\"\n}\n\nKey concepts illustrated:\n- Error inheritance hierarchy\n- Metadata-enriched errors\n- Centralized error processing\n- Graceful resource cleanup\n- Structured JSON logging\n- Signal handling for shutdown\n- Express.js middleware integration",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Catching errors but not handling or logging them properly",
        "solution": "Always log errors with sufficient context and implement appropriate recovery mechanisms",
        "severity": "high"
      },
      {
        "mistake": "Not implementing graceful shutdown procedures",
        "solution": "Handle SIGTERM and SIGINT signals to close resources properly before application exit",
        "severity": "high"
      },
      {
        "mistake": "Using console.log instead of structured logging in production",
        "solution": "Use structured logging with consistent formats and appropriate log levels for production applications",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement a Production-Ready Error Handling System",
        "description": "Create a comprehensive error handling system for a web application with monitoring and recovery",
        "checkpoints": [
          "Design a complete error hierarchy with business-specific error types",
          "Implement centralized error handling with detailed logging and monitoring",
          "Create graceful shutdown procedures for all application resources",
          "Add error rate limiting to prevent log flooding during failures",
          "Implement error reporting to external monitoring services"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Error Handling",
      "node"
    ],
    "legacy": {
      "originalId": 8,
      "originalTopic": "Error Handling",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-9",
    "moduleSlug": "node-fundamentals",
    "title": "Working with Streams",
    "order": 9,
    "objectives": [
      "Implement readable, writable, and transform streams for efficient data processing",
      "Apply backpressure handling to prevent memory exhaustion",
      "Design stream pipelines for processing large datasets and real-time data"
    ],
    "intro": "Streams are a fundamental concept in Node.js that provide an efficient way to handle large amounts of data without loading everything into memory at once. They enable processing of data as it's being read or written, making them ideal for handling large files, network requests, and real-time data processing.\n\nNode.js provides four fundamental stream types: Readable (for reading data), Writable (for writing data), Duplex (for both reading and writing), and Transform (for modifying data as it passes through). Understanding these types and how they work together is essential for building memory-efficient applications.\n\nStreams operate on the principle of backpressure, which ensures that data flows at an appropriate rate between different parts of a pipeline. This prevents faster data sources from overwhelming slower destinations, which could lead to memory exhaustion or data loss.\n\nStream processing is particularly valuable when working with large files, real-time data feeds, or when transforming data from one format to another. Instead of loading entire datasets into memory, streams allow you to process data in chunks, maintaining a consistent memory footprint regardless of the data size.\n\nThis lesson will explore stream implementation patterns, backpressure management, error handling in stream pipelines, and practical applications like file processing, data transformation, and network communication. You'll learn to create custom streams, compose stream pipelines, and handle edge cases properly.\n\nBy the end of this lesson, you'll be able to implement efficient stream-based solutions that handle large datasets with minimal memory usage while maintaining high performance and reliability.",
    "code": {
      "example": "const fs = require('fs');\nconst { Readable, Writable, Transform, PassThrough, pipeline } = require('stream');\nconst { promisify } = require('util');\n\n// 1. Custom Readable Stream - Data Generator\nclass NumberStream extends Readable {\n  constructor(options = {}) {\n    super({ objectMode: true, ...options });\n    this.current = options.start || 0;\n    this.end = options.end || 100;\n    this.interval = options.interval || 100;\n  }\n\n  _read() {\n    if (this.current <= this.end) {\n      // Simulate async data generation\n      setTimeout(() => {\n        const data = {\n          id: this.current,\n          value: Math.random(),\n          timestamp: Date.now()\n        };\n        this.push(data);\n        this.current++;\n      }, this.interval);\n    } else {\n      this.push(null); // End the stream\n    }\n  }\n}\n\n// 2. Custom Writable Stream - Data Processor\nclass DataProcessor extends Writable {\n  constructor(options = {}) {\n    super({ objectMode: true, ...options });\n    this.processed = 0;\n    this.sum = 0;\n    this.startTime = Date.now();\n  }\n\n  _write(chunk, encoding, callback) {\n    // Simulate processing time\n    setTimeout(() => {\n      try {\n        this.processed++;\n        this.sum += chunk.value;\n        \n        // Log progress\n        if (this.processed % 10 === 0) {\n          console.log(`Processed ${this.processed} items, avg: ${(this.sum/this.processed).toFixed(4)}`);\n        }\n        \n        callback();\n      } catch (error) {\n        callback(error);\n      }\n    }, 10);\n  }\n\n  _final(callback) {\n    const duration = Date.now() - this.startTime;\n    console.log(`\nProcessing complete!\nTotal items: ${this.processed}\nAverage value: ${(this.sum/this.processed).toFixed(4)}\nDuration: ${duration}ms`);\n    callback();\n  }\n}\n\n// 3. Custom Transform Stream - Data Filter\nclass ValueFilter extends Transform {\n  constructor(threshold = 0.5, options = {}) {\n    super({ objectMode: true, ...options });\n    this.threshold = threshold;\n    this.filtered = 0;\n  }\n\n  _transform(chunk, encoding, callback) {\n    try {\n      if (chunk.value >= this.threshold) {\n        // Pass through high-value items\n        this.push(chunk);\n      } else {\n        // Filter out low-value items\n        this.filtered++;\n      }\n      callback();\n    } catch (error) {\n      callback(error);\n    }\n  }\n\n  _flush(callback) {\n    console.log(`Filtered out ${this.filtered} low-value items`);\n    callback();\n  }\n}\n\n// 4. Stream Pipeline with Error Handling\nasync function processDataStream() {\n  const numberStream = new NumberStream({ start: 1, end: 50, interval: 50 });\n  const filter = new ValueFilter(0.3);\n  const processor = new DataProcessor();\n\n  try {\n    // Using pipeline for automatic error handling and cleanup\n    await promisify(pipeline)(numberStream, filter, processor);\n    console.log('Stream pipeline completed successfully');\n  } catch (error) {\n    console.error('Stream pipeline failed:', error.message);\n  }\n}\n\n// 5. File Processing with Streams\nasync function processLargeFile(inputFile, outputFile) {\n  return new Promise((resolve, reject) => {\n    // Create streams\n    const readStream = fs.createReadStream(inputFile, { encoding: 'utf8' });\n    const writeStream = fs.createWriteStream(outputFile, { encoding: 'utf8' });\n    \n    // Transform stream for line processing\n    const lineProcessor = new Transform({\n      transform(chunk, encoding, callback) {\n        // Process each line\n        const lines = chunk.toString().split('\n');\n        const processedLines = lines.map(line => {\n          // Add line numbers and convert to uppercase\n          return line ? `${line.length}: ${line.toUpperCase()}` : line;\n        });\n        callback(null, processedLines.join('\n'));\n      }\n    });\n\n    // Handle stream events\n    readStream\n      .pipe(lineProcessor)\n      .pipe(writeStream)\n      .on('finish', () => {\n        console.log(`File processing completed: ${inputFile} -> ${outputFile}`);\n        resolve();\n      })\n      .on('error', (error) => {\n        console.error('Stream error:', error.message);\n        reject(error);\n      });\n  });\n}\n\n// 6. Backpressure Handling Example\nclass BackpressureDemo extends Writable {\n  constructor(options = {}) {\n    super({ highWaterMark: 2, ...options }); // Small buffer to demonstrate backpressure\n    this.received = 0;\n  }\n\n  _write(chunk, encoding, callback) {\n    this.received++;\n    console.log(`Received chunk ${this.received}: ${chunk}`);\n    \n    // Simulate slow processing to demonstrate backpressure\n    setTimeout(() => {\n      console.log(`Processed chunk ${this.received}`);\n      callback();\n    }, 1000);\n  }\n}\n\nfunction demonstrateBackpressure() {\n  const slowWriter = new BackpressureDemo();\n  const fastReader = new Readable({\n    read() {\n      for (let i = 1; i <= 10; i++) {\n        const shouldContinue = this.push(`data-${i}`);\n        console.log(`Pushed data-${i}, shouldContinue: ${shouldContinue}`);\n        \n        // Stop when backpressure is signaled\n        if (!shouldContinue) {\n          console.log('Backpressure detected, pausing');\n          break;\n        }\n      }\n      if (this.readableLength < 10) {\n        this.push(null); // End stream\n      }\n    }\n  });\n\n  fastReader.pipe(slowWriter);\n}\n\n// 7. Practical Example - CSV Processing Pipeline\nclass CSVParser extends Transform {\n  constructor(options = {}) {\n    super({ readableObjectMode: true, ...options });\n    this.headers = null;\n    this.firstLine = true;\n  }\n\n  _transform(chunk, encoding, callback) {\n    const lines = chunk.toString().split('\n');\n    \n    for (const line of lines) {\n      if (line.trim() === '') continue;\n      \n      const values = line.split(',');\n      \n      if (this.firstLine) {\n        this.headers = values;\n        this.firstLine = false;\n      } else {\n        const record = {};\n        this.headers.forEach((header, index) => {\n          record[header] = values[index] || '';\n        });\n        this.push(record);\n      }\n    }\n    callback();\n  }\n}\n\n// Usage examples\nasync function main() {\n  console.log('=== Data Stream Processing ===');\n  await processDataStream();\n\n  console.log('\n=== File Processing ===');\n  // Create sample input file\n  const sampleData = 'Hello World\nThis is a test\nNode.js Streams\nare powerful';\n  fs.writeFileSync('input.txt', sampleData);\n  \n  await processLargeFile('input.txt', 'output.txt');\n  \n  const output = fs.readFileSync('output.txt', 'utf8');\n  console.log('Output file content:', output.split('\n').slice(0, 3).join('\n'));\n\n  console.log('\n=== Backpressure Demo ===');\n  demonstrateBackpressure();\n  \n  // Wait a bit to see backpressure in action\n  await new Promise(resolve => setTimeout(resolve, 3000));\n\n  // Cleanup\n  try {\n    fs.unlinkSync('input.txt');\n    fs.unlinkSync('output.txt');\n  } catch (error) {\n    // Ignore cleanup errors\n  }\n}\n\n// Run examples\nif (require.main === module) {\n  main().catch(console.error);\n}\n\nmodule.exports = {\n  NumberStream,\n  DataProcessor,\n  ValueFilter,\n  CSVParser\n};",
      "explanation": "This example demonstrates comprehensive stream processing patterns:\n\n1. **Custom Readable Stream**: Generates data asynchronously with controlled pacing\n2. **Custom Writable Stream**: Processes incoming data with finalization callback\n3. **Custom Transform Stream**: Filters and modifies data as it passes through\n4. **Stream Pipeline**: Composed streams with automatic error handling\n5. **File Processing**: Memory-efficient file transformation with streams\n6. **Backpressure Handling**: Demonstrates how streams manage data flow rates\n7. **CSV Parsing**: Real-world example of structured data processing\n\nThe output shows:\n=== Data Stream Processing ===\nProcessed 10 items, avg: 0.4567\nProcessed 20 items, avg: 0.5234\nProcessing complete!\nTotal items: 50\nAverage value: 0.4987\nDuration: 2500ms\nFiltered out 18 low-value items\nStream pipeline completed successfully\n\n=== File Processing ===\nFile processing completed: input.txt -> output.txt\nOutput file content: 11: HELLO WORLD\n14: THIS IS A TEST\n13: NODE.JS STREAMS\n\n=== Backpressure Demo ===\nPushed data-1, shouldContinue: true\nPushed data-2, shouldContinue: true\nReceived chunk 1: data-1\nBackpressure detected, pausing\nProcessed chunk 1\n\nKey concepts illustrated:\n- Object mode vs. buffer mode\n- Custom stream implementation\n- Pipeline composition\n- Backpressure management\n- Error handling in streams\n- Memory efficiency\n- Real-world data processing",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not implementing proper backpressure handling in custom streams",
        "solution": "Always respect the return value of push() and implement _read()/_write() correctly to handle backpressure",
        "severity": "high"
      },
      {
        "mistake": "Forgetting to handle stream errors",
        "solution": "Attach error handlers to all streams and use pipeline() for automatic error propagation",
        "severity": "high"
      },
      {
        "mistake": "Loading entire files into memory instead of using streams",
        "solution": "Use createReadStream() and createWriteStream() for large file operations",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Build a Real-time Log Processing System",
        "description": "Create a stream-based system for processing and analyzing log files in real-time",
        "checkpoints": [
          "Implement a log file reader that processes new entries as they're written",
          "Create stream transformers for parsing and filtering log entries",
          "Design aggregators that compute real-time statistics from log data",
          "Add alerting mechanisms for critical log events",
          "Implement log rotation handling and error recovery"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Streams",
      "node"
    ],
    "legacy": {
      "originalId": 9,
      "originalTopic": "Streams",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-10",
    "moduleSlug": "node-fundamentals",
    "title": "Testing with Jest",
    "order": 10,
    "objectives": [
      "Write comprehensive unit tests with Jest including mocks, spies, and async testing",
      "Implement integration tests for API endpoints and database operations",
      "Configure test environments and apply test-driven development practices"
    ],
    "intro": "Testing is a critical practice in software development that ensures code quality, prevents regressions, and enables confident refactoring. Jest is a powerful JavaScript testing framework that provides a complete solution for unit, integration, and end-to-end testing with minimal configuration.\n\nJest's zero-configuration setup makes it easy to get started, while its rich feature set includes built-in mocking, code coverage reporting, snapshot testing, and parallel test execution. Understanding how to write effective tests is essential for professional software development.\n\nEffective testing involves more than just verifying that code works correctly. It includes testing edge cases, error conditions, and performance characteristics. Good tests are isolated, deterministic, and provide clear feedback when they fail.\n\nTest-driven development (TDD) is a methodology where tests are written before the implementation code. This approach helps ensure that code is testable from the start and leads to better design decisions. While not always practical, TDD principles can improve code quality when applied appropriately.\n\nThis lesson will explore Jest testing patterns including unit testing with mocks and spies, integration testing with real dependencies, async testing techniques, and test configuration. You'll learn to structure test suites, use Jest's assertion library effectively, and implement continuous testing practices.\n\nBy the end of this lesson, you'll be able to write comprehensive test suites that ensure your Node.js applications are reliable, maintainable, and ready for production deployment.",
    "code": {
      "example": "// 1. Sample module to test - User Service\nclass UserService {\n  constructor(database) {\n    this.database = database;\n  }\n\n  async createUser(userData) {\n    // Validate input\n    if (!userData.email || !userData.name) {\n      throw new Error('Email and name are required');\n    }\n\n    // Check if user already exists\n    const existingUser = await this.database.findUserByEmail(userData.email);\n    if (existingUser) {\n      throw new Error('User already exists');\n    }\n\n    // Create user\n    const user = {\n      id: Date.now(),\n      ...userData,\n      createdAt: new Date(),\n      updatedAt: new Date()\n    };\n\n    await this.database.createUser(user);\n    return user;\n  }\n\n  async getUserById(id) {\n    if (!id) {\n      throw new Error('User ID is required');\n    }\n\n    const user = await this.database.findUserById(id);\n    if (!user) {\n      throw new Error('User not found');\n    }\n\n    return user;\n  }\n\n  async updateUser(id, updates) {\n    const user = await this.getUserById(id);\n    \n    const updatedUser = {\n      ...user,\n      ...updates,\n      updatedAt: new Date()\n    };\n\n    await this.database.updateUser(id, updatedUser);\n    return updatedUser;\n  }\n\n  async deleteUser(id) {\n    await this.getUserById(id); // Verify user exists\n    return await this.database.deleteUser(id);\n  }\n\n  async searchUsers(query) {\n    if (!query) {\n      throw new Error('Search query is required');\n    }\n\n    return await this.database.searchUsers(query.toLowerCase());\n  }\n}\n\n// 2. Database mock for testing\nclass MockDatabase {\n  constructor() {\n    this.users = new Map();\n  }\n\n  async findUserByEmail(email) {\n    for (const user of this.users.values()) {\n      if (user.email === email) {\n        return user;\n      }\n    }\n    return null;\n  }\n\n  async findUserById(id) {\n    return this.users.get(id) || null;\n  }\n\n  async createUser(user) {\n    this.users.set(user.id, user);\n    return user;\n  }\n\n  async updateUser(id, user) {\n    if (this.users.has(id)) {\n      this.users.set(id, user);\n      return user;\n    }\n    throw new Error('User not found');\n  }\n\n  async deleteUser(id) {\n    return this.users.delete(id);\n  }\n\n  async searchUsers(query) {\n    const results = [];    for (const user of this.users.values()) {      if (user.name.toLowerCase().includes(query) ||          user.email.toLowerCase().includes(query)) {        results.push(user);      }    }    return results;  }}// 3. Jest test suitedescribe('UserService', () => {  let userService;  let mockDatabase;  beforeEach(() => {    mockDatabase = new MockDatabase();    userService = new UserService(mockDatabase);  });  describe('createUser', () => {    test('creates a new user with valid data', async () => {      const userData = {        name: 'John Doe',        email: 'john@example.com'      };      const user = await userService.createUser(userData);      expect(user).toMatchObject({        name: 'John Doe',        email: 'john@example.com'      });      expect(user.id).toBeDefined();      expect(user.createdAt).toBeInstanceOf(Date);    });    test('throws error when email is missing', async () => {      const userData = { name: 'John Doe' };      await expect(userService.createUser(userData))        .rejects        .toThrow('Email and name are required');    });    test('throws error when user already exists', async () => {      const userData = {        name: 'John Doe',        email: 'john@example.com'      };      // Create first user      await userService.createUser(userData);      // Try to create duplicate      await expect(userService.createUser(userData))        .rejects        .toThrow('User already exists');    });  });  describe('getUserById', () => {    test('retrieves existing user', async () => {      // Setup      const userData = {        name: 'John Doe',        email: 'john@example.com'      };      const createdUser = await userService.createUser(userData);      // Test      const user = await userService.getUserById(createdUser.id);      expect(user).toEqual(createdUser);    });    test('throws error for non-existent user', async () => {      await expect(userService.getUserById(999))        .rejects        .toThrow('User not found');    });  });  describe('updateUser', () => {    test('updates user data successfully', async () => {      // Setup      const userData = {        name: 'John Doe',        email: 'john@example.com'      };      const createdUser = await userService.createUser(userData);      // Test      const updates = { name: 'Jane Doe' };      const updatedUser = await userService.updateUser(createdUser.id, updates);      expect(updatedUser.name).toBe('Jane Doe');      expect(updatedUser.email).toBe('john@example.com');      expect(updatedUser.updatedAt).toBeInstanceOf(Date);      expect(updatedUser.updatedAt).not.toEqual(createdUser.updatedAt);    });  });  describe('searchUsers', () => {    beforeEach(async () => {      // Setup test data      await userService.createUser({ name: 'John Doe', email: 'john@example.com' });      await userService.createUser({ name: 'Jane Smith', email: 'jane@example.com' });      await userService.createUser({ name: 'Bob Johnson', email: 'bob@example.com' });    });    test('finds users by name', async () => {      const results = await userService.searchUsers('john');      expect(results).toHaveLength(2);      expect(results.map(u => u.name)).toEqual(expect.arrayContaining([        'John Doe',        'Bob Johnson'      ]));    });    test('finds users by email', async () => {      const results = await userService.searchUsers('example.com');      expect(results).toHaveLength(3);    });  });  // 4. Testing with mocks and spies  describe('Database interactions', () => {    test('calls database methods with correct parameters', async () => {      // Spy on database methods      const createUserSpy = jest.spyOn(mockDatabase, 'createUser');      const findUserByEmailSpy = jest.spyOn(mockDatabase, 'findUserByEmail');      const userData = {        name: 'John Doe',        email: 'john@example.com'      };      await userService.createUser(userData);      expect(findUserByEmailSpy).toHaveBeenCalledWith('john@example.com');      expect(createUserSpy).toHaveBeenCalled();      // Restore spies      createUserSpy.mockRestore();      findUserByEmailSpy.mockRestore();    });    test('handles database errors gracefully', async () => {      // Mock database error      mockDatabase.createUser = jest.fn().mockRejectedValue(        new Error('Database connection failed')      );      const userData = {        name: 'John Doe',        email: 'john@example.com'      };      await expect(userService.createUser(userData))        .rejects        .toThrow('Database connection failed');    });  });  // 5. Async testing examples  describe('Async operations', () => {    test('handles async operations with resolves', async () => {      const userData = {        name: 'John Doe',        email: 'john@example.com'      };      await expect(userService.createUser(userData)).resolves.toMatchObject({        name: 'John Doe'      });    });    test('tests async error with rejects', async () => {      await expect(userService.getUserById(null))        .rejects        .toThrow('User ID is required');    });    test('uses done callback for callback-based async code', (done) => {      // Example for callback-based code      setTimeout(() => {        try {          expect(1 + 1).toBe(2);          done();        } catch (error) {          done(error);        }      }, 10);    });  });  // 6. Setup and teardown  beforeAll(() => {    // Run once before all tests    console.log('Starting UserService test suite');  });  afterAll(() => {    // Run once after all tests    console.log('UserService test suite completed');  });  afterEach(() => {    // Run after each test    jest.clearAllMocks();  });});// 7. Testing utilitiesconst testUtils = {  createMockUser: (overrides = {}) => ({    id: Date.now(),    name: 'Test User',    email: 'test@example.com',    createdAt: new Date(),    updatedAt: new Date(),    ...overrides  }),  async createTestUsers(userService, count) {    const users = [];    for (let i = 0; i < count; i++) {      const user = await userService.createUser({        name: `User ${i + 1}`,        email: `user${i + 1}@example.com`      });      users.push(user);    }    return users;  }};// 8. Example test run output (commented)/*Expected test output: PASS  ./userService.test.js  UserService    createUser      âœ“ creates a new user with valid data (5 ms)      âœ“ throws error when email is missing (2 ms)      âœ“ throws error when user already exists (3 ms)    getUserById      âœ“ retrieves existing user (1 ms)      âœ“ throws error for non-existent user (1 ms)    updateUser      âœ“ updates user data successfully (2 ms)    searchUsers      âœ“ finds users by name (3 ms)      âœ“ finds users by email (2 ms)    Database interactions      âœ“ calls database methods with correct parameters (2 ms)      âœ“ handles database errors gracefully (1 ms)    Async operations      âœ“ handles async operations with resolves (1 ms)      âœ“ tests async error with rejects (1 ms)      âœ“ uses done callback for callback-based async code (12 ms)Test Suites: 1 passed, 1 totalTests:       14 passed, 14 totalSnapshots:   0 totalTime:        2.15 s*/",
      "explanation": "This example demonstrates comprehensive testing with Jest:\n\n1. **Unit Testing**: Testing individual methods with various input scenarios\n2. **Error Testing**: Verifying proper error handling and rejection cases\n3. **Mocking**: Using spies to verify method calls and parameters\n4. **Async Testing**: Multiple approaches for testing asynchronous code\n5. **Test Organization**: Structured test suites with descriptive names\n6. **Setup/Teardown**: Proper test lifecycle management\n7. **Test Utilities**: Helper functions for common testing scenarios\n\nThe key concepts illustrated:\n- describe() blocks for organizing related tests\n- beforeEach() for test setup\n- expect() assertions with various matchers\n- Mocking with jest.spyOn() and jest.fn()\n- Async testing with resolves/rejects and done callback\n- Test lifecycle hooks (beforeAll, afterAll, afterEach)\n- Comprehensive test coverage including edge cases\n\nJest features demonstrated:\n- Built-in assertion library\n- Mock function capabilities\n- Test organization and reporting\n- Async testing patterns\n- Test environment setup",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Testing implementation details instead of behavior",
        "solution": "Focus on testing what a function does rather than how it does it, making tests more resilient to refactoring",
        "severity": "high"
      },
      {
        "mistake": "Not testing edge cases and error conditions",
        "solution": "Test boundary conditions, invalid inputs, and error scenarios to ensure robust error handling",
        "severity": "high"
      },
      {
        "mistake": "Creating tests that depend on external state or execution order",
        "solution": "Ensure tests are isolated and can run independently in any order",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement a Complete Test Suite for an Express API",
        "description": "Create comprehensive tests for a REST API including unit, integration, and contract tests",
        "checkpoints": [
          "Write unit tests for service layer functions with comprehensive mocking",
          "Implement integration tests for API endpoints with a test database",
          "Create contract tests that verify API responses match expected schemas",
          "Add performance tests for critical endpoints",
          "Configure test coverage reporting and set minimum coverage thresholds"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Testing",
      "node"
    ],
    "legacy": {
      "originalId": 10,
      "originalTopic": "Testing",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-11",
    "moduleSlug": "node-fundamentals",
    "title": "Security Best Practices",
    "order": 11,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Security.\n\nLearn essential security practices for Node.js applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "const express = require('express');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\n\n// Security middleware\napp.use(helmet()); // Sets various HTTP headers\napp.use(express.json({ limit: '10mb' })); // Limit body size\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100 // limit each IP to 100 requests per windowMs\n});\napp.use(limiter);\n\n// Password hashing\nasync function hashPassword(password) {\n  const saltRounds = 12;\n  return await bcrypt.hash(password, saltRounds);\n}\n\n// JWT token creation\nfunction createToken(userId) {\n  return jwt.sign({ userId }, process.env.JWT_SECRET, { expiresIn: '1h' });\n}\n\n// Input validation\nfunction validateEmail(email) {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n  return emailRegex.test(email);\n}\n\nconsole.log('Security measures implemented');",
      "explanation": "This example produces: Security measures implemented\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Security Best Practices",
        "description": "Apply the concepts from this lesson on Security",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Security",
      "node"
    ],
    "legacy": {
      "originalId": 11,
      "originalTopic": "Security",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-12",
    "moduleSlug": "node-fundamentals",
    "title": "Performance Optimization",
    "order": 12,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Performance.\n\nLearn techniques to optimize Node.js application performance.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "const cluster = require('cluster');\nconst os = require('os');\nconst express = require('express');\n\n// Clustering for multi-core utilization\nif (cluster.isMaster) {\n  const numCPUs = os.cpus().length;\n  console.log(`Master process ${process.pid} is running`);\n  \n  // Fork workers\n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker, code, signal) => {\n    console.log(`Worker ${worker.process.pid} died`);\n    cluster.fork(); // Replace dead worker\n  });\n} else {\n  const app = express();\n  \n  // Memory-efficient caching\n  const cache = new Map();\n  const MAX_CACHE_SIZE = 1000;\n  \n  function setCache(key, value) {\n    if (cache.size >= MAX_CACHE_SIZE) {\n      const firstKey = cache.keys().next().value;\n      cache.delete(firstKey);\n    }\n    cache.set(key, value);\n  }\n  \n  // Optimized route with caching\n  app.get('/expensive-operation/:id', (req, res) => {\n    const id = req.params.id;\n    \n    if (cache.has(id)) {\n      return res.json(cache.get(id));\n    }\n    \n    // Simulate expensive operation\n    const result = { id, data: 'Processed data', timestamp: Date.now() };\n    setCache(id, result);\n    res.json(result);\n  });\n  \n  app.listen(3000, () => {\n    console.log(`Worker ${process.pid} started`);\n  });\n}",
      "explanation": "This example produces: Master process [PID] is running\nWorker [PID] started\nWorker [PID] started...\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Performance Optimization",
        "description": "Apply the concepts from this lesson on Performance",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "node"
    ],
    "legacy": {
      "originalId": 12,
      "originalTopic": "Performance",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-13",
    "moduleSlug": "node-fundamentals",
    "title": "Advanced Security Practices in Node.js",
    "order": 13,
    "objectives": [
      "Implement comprehensive security measures in Node.js applications",
      "Understand and prevent common security vulnerabilities",
      "Configure secure authentication and authorization systems"
    ],
    "intro": "Welcome to this comprehensive lesson on Advanced Security Practices in Node.js.\n\nLearn how to secure Node.js applications against common vulnerabilities and implement robust security measures. Security is critical for production applications and requires understanding of various attack vectors and defensive strategies.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "const express = require('express');\nconst helmet = require('helmet');\nconst rateLimit = require('express-rate-limit');\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\nconst xss = require('xss');\nconst validator = require('validator');\n\nconst app = express();\n\n// Security middleware\napp.use(helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\"],\n      scriptSrc: [\"'self'\"],\n      imgSrc: [\"'self'\", \"data:\", \"https:\"]\n    }\n  }\n}));\n\n// Rate limiting\nconst limiter = rateLimit({\n  windowMs: 15 * 60 * 1000, // 15 minutes\n  max: 100, // limit each IP to 100 requests per windowMs\n  message: 'Too many requests from this IP'\n});\napp.use('/api/', limiter);\n\n// Input validation and sanitization\nfunction validateInput(req, res, next) {\n  const { email, password, name } = req.body;\n  \n  // Validate email\n  if (!validator.isEmail(email)) {\n    return res.status(400).json({ error: 'Invalid email format' });\n  }\n  \n  // Validate password strength\n  if (!validator.isStrongPassword(password, {\n    minLength: 8,\n    minLowercase: 1,\n    minUppercase: 1,\n    minNumbers: 1,\n    minSymbols: 1\n  })) {\n    return res.status(400).json({ error: 'Password too weak' });\n  }\n  \n  // Sanitize name input\n  req.body.name = xss(name);\n  \n  next();\n}\n\n// Secure authentication\nclass AuthService {\n  static async hashPassword(password) {\n    const saltRounds = 12;\n    return await bcrypt.hash(password, saltRounds);\n  }\n  \n  static async verifyPassword(password, hash) {\n    return await bcrypt.compare(password, hash);\n  }\n  \n  static generateToken(userId) {\n    return jwt.sign(\n      { userId, iat: Date.now() },\n      process.env.JWT_SECRET,\n      { expiresIn: '24h' }\n    );\n  }\n  \n  static verifyToken(token) {\n    try {\n      return jwt.verify(token, process.env.JWT_SECRET);\n    } catch (error) {\n      throw new Error('Invalid token');\n    }\n  }\n}\n\n// Authentication middleware\nfunction authenticate(req, res, next) {\n  const authHeader = req.headers.authorization;\n  \n  if (!authHeader || !authHeader.startsWith('Bearer ')) {\n    return res.status(401).json({ error: 'No token provided' });\n  }\n  \n  const token = authHeader.substring(7);\n  \n  try {\n    const decoded = AuthService.verifyToken(token);\n    req.user = decoded;\n    next();\n  } catch (error) {\n    return res.status(401).json({ error: 'Invalid token' });\n  }\n}\n\n// SQL injection prevention with parameterized queries\nconst mysql = require('mysql2/promise');\n\nclass UserRepository {\n  static async findByEmail(email) {\n    const connection = await mysql.createConnection({\n      host: process.env.DB_HOST,\n      user: process.env.DB_USER,\n      password: process.env.DB_PASSWORD,\n      database: process.env.DB_NAME\n    });\n    \n    // Safe parameterized query\n    const [rows] = await connection.execute(\n      'SELECT * FROM users WHERE email = ?',\n      [email]\n    );\n    \n    await connection.end();\n    return rows[0];\n  }\n}\n\n// Secure routes\napp.post('/api/register', validateInput, async (req, res) => {\n  try {\n    const { email, password, name } = req.body;\n    \n    // Check if user exists\n    const existingUser = await UserRepository.findByEmail(email);\n    if (existingUser) {\n      return res.status(409).json({ error: 'User already exists' });\n    }\n    \n    // Hash password\n    const hashedPassword = await AuthService.hashPassword(password);\n    \n    // Create user (implementation depends on your database)\n    const user = await UserRepository.create({\n      email,\n      password: hashedPassword,\n      name\n    });\n    \n    // Generate token\n    const token = AuthService.generateToken(user.id);\n    \n    res.status(201).json({\n      message: 'User created successfully',\n      token\n    });\n  } catch (error) {\n    console.error('Registration error:', error);\n    res.status(500).json({ error: 'Internal server error' });\n  }\n});\n\napp.get('/api/profile', authenticate, (req, res) => {\n  res.json({\n    message: 'Protected profile data',\n    userId: req.user.userId\n  });\n});\n\n// Error handling middleware\napp.use((error, req, res, next) => {\n  console.error('Unhandled error:', error);\n  res.status(500).json({ error: 'Internal server error' });\n});\n\napp.listen(3000, () => {\n  console.log('Secure server running on port 3000');\n});",
      "explanation": "This example demonstrates comprehensive security practices including helmet for security headers, rate limiting, input validation and sanitization, secure password hashing, JWT authentication, and SQL injection prevention with parameterized queries.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Storing passwords in plain text",
        "solution": "Always hash passwords using bcrypt with appropriate salt rounds",
        "severity": "high"
      },
      {
        "mistake": "Not validating and sanitizing user input",
        "solution": "Implement comprehensive input validation and XSS protection",
        "severity": "high"
      },
      {
        "mistake": "Using weak JWT secrets or not setting expiration",
        "solution": "Use strong, randomly generated secrets and set appropriate token expiration times",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Advanced Security Practices in Node.js",
        "description": "Implement comprehensive security measures in a Node.js application",
        "checkpoints": [
          "Set up security middleware (helmet, rate limiting)",
          "Implement secure authentication with password hashing",
          "Add input validation and sanitization",
          "Prevent SQL injection with parameterized queries",
          "Test security measures and conduct vulnerability assessment"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 45,
    "difficulty": "Advanced",
    "tags": [
      "Security",
      "Authentication",
      "Validation",
      "node"
    ],
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-14",
    "moduleSlug": "node-fundamentals",
    "title": "Microservices Architecture with Node.js",
    "order": 14,
    "objectives": [
      "Understand microservices architecture principles",
      "Implement service communication patterns",
      "Deploy and orchestrate Node.js microservices"
    ],
    "intro": "Welcome to this comprehensive lesson on Microservices Architecture with Node.js.\n\nLearn how to design, implement, and deploy microservices using Node.js. Microservices architecture enables building scalable, maintainable applications by breaking them into smaller, independent services.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// User Service (users-service.js)\nconst express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.use(express.json());\n\nconst users = [\n  { id: 1, name: 'John Doe', email: 'john@example.com' },\n  { id: 2, name: 'Jane Smith', email: 'jane@example.com' }\n];\n\napp.get('/health', (req, res) => {\n  res.json({ status: 'healthy', service: 'users' });\n});\n\napp.get('/users', (req, res) => {\n  res.json(users);\n});\n\napp.get('/users/:id', (req, res) => {\n  const user = users.find(u => u.id === parseInt(req.params.id));\n  if (!user) {\n    return res.status(404).json({ error: 'User not found' });\n  }\n  res.json(user);\n});\n\napp.listen(3001, () => console.log('Users service on port 3001'));\n\n// Orders Service (orders-service.js)\nconst express = require('express');\nconst axios = require('axios');\nconst app = express();\n\napp.use(express.json());\n\nconst orders = [\n  { id: 1, userId: 1, product: 'Laptop', amount: 999.99 },\n  { id: 2, userId: 2, product: 'Phone', amount: 599.99 }\n];\n\napp.get('/health', (req, res) => {\n  res.json({ status: 'healthy', service: 'orders' });\n});\n\napp.get('/orders', async (req, res) => {\n  try {\n    // Enrich orders with user data\n    const enrichedOrders = await Promise.all(\n      orders.map(async (order) => {\n        try {\n          const userResponse = await axios.get(\n            `http://users-service:3001/users/${order.userId}`,\n            { timeout: 5000 }\n          );\n          return {\n            ...order,\n            user: userResponse.data\n          };\n        } catch (error) {\n          console.error(`Failed to fetch user ${order.userId}:`, error.message);\n          return {\n            ...order,\n            user: { error: 'User data unavailable' }\n          };\n        }\n      })\n    );\n    \n    res.json(enrichedOrders);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to fetch orders' });\n  }\n});\n\napp.listen(3002, () => console.log('Orders service on port 3002'));\n\n// API Gateway (gateway.js)\nconst express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\nconst app = express();\n\napp.use(express.json());\n\n// Service discovery\nconst services = {\n  users: 'http://users-service:3001',\n  orders: 'http://orders-service:3002'\n};\n\n// Health check aggregator\napp.get('/health', async (req, res) => {\n  const healthChecks = await Promise.allSettled(\n    Object.entries(services).map(async ([name, url]) => {\n      try {\n        const response = await axios.get(`${url}/health`);\n        return { service: name, status: 'healthy', ...response.data };\n      } catch (error) {\n        return { service: name, status: 'unhealthy', error: error.message };\n      }\n    })\n  );\n  \n  res.json({\n    overall: healthChecks.every(hc => hc.value?.status === 'healthy') ? 'healthy' : 'degraded',\n    services: healthChecks.map(hc => hc.value)\n  });\n});\n\n// Route proxying\napp.use('/api/users', createProxyMiddleware({\n  target: services.users,\n  changeOrigin: true,\n  pathRewrite: { '^/api/users': '/users' },\n  onError: (err, req, res) => {\n    res.status(503).json({ error: 'Users service unavailable' });\n  }\n}));\n\napp.use('/api/orders', createProxyMiddleware({\n  target: services.orders,\n  changeOrigin: true,\n  pathRewrite: { '^/api/orders': '/orders' },\n  onError: (err, req, res) => {\n    res.status(503).json({ error: 'Orders service unavailable' });\n  }\n}));\n\napp.listen(3000, () => console.log('API Gateway on port 3000'));\n\n// Docker Compose (docker-compose.yml)\n/*\nversion: '3.8'\nservices:\n  users-service:\n    build: ./users-service\n    ports:\n      - \"3001:3001\"\n    environment:\n      - NODE_ENV=production\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3001/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  orders-service:\n    build: ./orders-service\n    ports:\n      - \"3002:3002\"\n    depends_on:\n      - users-service\n    environment:\n      - NODE_ENV=production\n    healthcheck:\n      test: [\"CMD\", \"curl\", \"-f\", \"http://localhost:3002/health\"]\n      interval: 30s\n      timeout: 10s\n      retries: 3\n\n  gateway:\n    build: ./gateway\n    ports:\n      - \"3000:3000\"\n    depends_on:\n      - users-service\n      - orders-service\n    environment:\n      - NODE_ENV=production\n*/",
      "explanation": "This example demonstrates a complete microservices architecture with separate user and order services, an API gateway for routing, service communication with circuit breakers, and Docker orchestration for deployment.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating too many small services (nano-services)",
        "solution": "Design services around business domains, not just code organization",
        "severity": "medium"
      },
      {
        "mistake": "Not implementing proper service communication patterns",
        "solution": "Use circuit breakers, timeouts, and fallback mechanisms for resilient communication",
        "severity": "high"
      },
      {
        "mistake": "Lack of distributed tracing and monitoring",
        "solution": "Implement comprehensive logging, monitoring, and distributed tracing across services",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Microservices Architecture with Node.js",
        "description": "Design and implement a microservices architecture using Node.js",
        "checkpoints": [
          "Design service boundaries based on business domains",
          "Implement service communication with circuit breakers",
          "Set up API gateway for routing and load balancing",
          "Configure Docker containers and orchestration",
          "Implement monitoring and health checks"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 50,
    "difficulty": "Advanced",
    "tags": [
      "Microservices",
      "Architecture",
      "Docker",
      "node"
    ],
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-15",
    "moduleSlug": "node-fundamentals",
    "title": "Production Deployment and DevOps for Node.js",
    "order": 15,
    "objectives": [
      "Configure production-ready Node.js applications",
      "Implement CI/CD pipelines for Node.js deployment",
      "Monitor and maintain Node.js applications in production"
    ],
    "intro": "Welcome to this comprehensive lesson on Production Deployment and DevOps for Node.js.\n\nLearn how to deploy Node.js applications to production environments with proper configuration, monitoring, and automation. Production deployment requires careful consideration of performance, security, and reliability.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Production configuration (config/production.js)\nmodule.exports = {\n  port: process.env.PORT || 3000,\n  nodeEnv: 'production',\n  database: {\n    host: process.env.DB_HOST,\n    port: process.env.DB_PORT || 5432,\n    name: process.env.DB_NAME,\n    user: process.env.DB_USER,\n    password: process.env.DB_PASSWORD,\n    ssl: true,\n    pool: {\n      min: 5,\n      max: 20,\n      acquireTimeoutMillis: 60000,\n      idleTimeoutMillis: 600000\n    }\n  },\n  redis: {\n    host: process.env.REDIS_HOST,\n    port: process.env.REDIS_PORT || 6379,\n    password: process.env.REDIS_PASSWORD\n  },\n  jwt: {\n    secret: process.env.JWT_SECRET,\n    expiresIn: '24h'\n  },\n  logging: {\n    level: 'info',\n    format: 'json'\n  }\n};\n\n// Production server setup (server.js)\nconst express = require('express');\nconst cluster = require('cluster');\nconst os = require('os');\nconst winston = require('winston');\nconst helmet = require('helmet');\nconst compression = require('compression');\nconst cors = require('cors');\nconst config = require('./config/production');\n\n// Configure Winston logger\nconst logger = winston.createLogger({\n  level: config.logging.level,\n  format: winston.format.combine(\n    winston.format.timestamp(),\n    winston.format.errors({ stack: true }),\n    winston.format.json()\n  ),\n  transports: [\n    new winston.transports.Console(),\n    new winston.transports.File({ filename: 'logs/error.log', level: 'error' }),\n    new winston.transports.File({ filename: 'logs/combined.log' })\n  ]\n});\n\nif (cluster.isMaster) {\n  // Master process - create worker processes\n  const numCPUs = os.cpus().length;\n  logger.info(`Master process starting with ${numCPUs} workers`);\n  \n  for (let i = 0; i < numCPUs; i++) {\n    cluster.fork();\n  }\n  \n  cluster.on('exit', (worker, code, signal) => {\n    logger.error(`Worker ${worker.process.pid} died. Restarting...`);\n    cluster.fork();\n  });\n} else {\n  // Worker process\n  const app = express();\n  \n  // Production middleware\n  app.use(helmet());\n  app.use(compression());\n  app.use(cors());\n  app.use(express.json({ limit: '10mb' }));\n  \n  // Request logging\n  app.use((req, res, next) => {\n    logger.info({\n      method: req.method,\n      url: req.url,\n      ip: req.ip,\n      userAgent: req.get('User-Agent')\n    });\n    next();\n  });\n  \n  // Health check endpoint\n  app.get('/health', (req, res) => {\n    res.json({\n      status: 'healthy',\n      timestamp: new Date().toISOString(),\n      uptime: process.uptime(),\n      memory: process.memoryUsage(),\n      pid: process.pid\n    });\n  });\n  \n  // Graceful shutdown\n  process.on('SIGTERM', () => {\n    logger.info('SIGTERM received, shutting down gracefully');\n    server.close(() => {\n      logger.info('Process terminated');\n      process.exit(0);\n    });\n  });\n  \n  const server = app.listen(config.port, () => {\n    logger.info(`Worker ${process.pid} listening on port ${config.port}`);\n  });\n}\n\n// Dockerfile\n/*\nFROM node:18-alpine\n\nWORKDIR /app\n\n# Copy package files\nCOPY package*.json ./\n\n# Install dependencies\nRUN npm ci --only=production && npm cache clean --force\n\n# Copy application code\nCOPY . .\n\n# Create non-root user\nRUN addgroup -g 1001 -S nodejs\nRUN adduser -S nodejs -u 1001\n\n# Change ownership\nRUN chown -R nodejs:nodejs /app\nUSER nodejs\n\nEXPOSE 3000\n\nHEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\\n  CMD node healthcheck.js\n\nCMD [\"node\", \"server.js\"]\n*/\n\n// CI/CD Pipeline (GitHub Actions)\n/*\nname: Deploy to Production\n\non:\n  push:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '18'\n          cache: 'npm'\n      - name: Install dependencies\n        run: npm ci\n      - name: Run tests\n        run: npm test\n      - name: Run security audit\n        run: npm audit --audit-level=high\n\n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Build Docker image\n        run: docker build -t myapp:${{ github.sha }} .\n      - name: Deploy to production\n        run: |\n          # Deploy to your production environment\n          # This could be AWS ECS, Kubernetes, etc.\n*/\n\n// Monitoring with Prometheus metrics\nconst promClient = require('prom-client');\n\n// Create metrics\nconst httpRequestDuration = new promClient.Histogram({\n  name: 'http_request_duration_seconds',\n  help: 'Duration of HTTP requests in seconds',\n  labelNames: ['method', 'status_code', 'route']\n});\n\nconst httpRequestsTotal = new promClient.Counter({\n  name: 'http_requests_total',\n  help: 'Total number of HTTP requests',\n  labelNames: ['method', 'status_code', 'route']\n});\n\n// Middleware to collect metrics\napp.use((req, res, next) => {\n  const start = Date.now();\n  \n  res.on('finish', () => {\n    const duration = (Date.now() - start) / 1000;\n    const route = req.route ? req.route.path : req.path;\n    \n    httpRequestDuration\n      .labels(req.method, res.statusCode, route)\n      .observe(duration);\n    \n    httpRequestsTotal\n      .labels(req.method, res.statusCode, route)\n      .inc();\n  });\n  \n  next();\n});\n\n// Metrics endpoint\napp.get('/metrics', (req, res) => {\n  res.set('Content-Type', promClient.register.contentType);\n  res.end(promClient.register.metrics());\n});",
      "explanation": "This example demonstrates comprehensive production deployment including clustering for scalability, structured logging with Winston, Docker containerization, CI/CD pipeline configuration, and monitoring with Prometheus metrics.\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not implementing proper logging in production",
        "solution": "Use structured logging with appropriate log levels and centralized log aggregation",
        "severity": "high"
      },
      {
        "mistake": "Running single-threaded in production",
        "solution": "Use cluster mode or PM2 to utilize multiple CPU cores",
        "severity": "medium"
      },
      {
        "mistake": "Not implementing health checks and graceful shutdown",
        "solution": "Implement comprehensive health checks and handle SIGTERM for graceful shutdown",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Production Deployment and DevOps for Node.js",
        "description": "Deploy a Node.js application to production with proper DevOps practices",
        "checkpoints": [
          "Configure production environment variables and settings",
          "Implement clustering and process management",
          "Set up Docker containerization and health checks",
          "Configure CI/CD pipeline with automated testing",
          "Implement monitoring, logging, and alerting"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 55,
    "difficulty": "Advanced",
    "tags": [
      "Production",
      "DevOps",
      "Deployment",
      "Monitoring",
      "node"
    ],
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-16",
    "moduleSlug": "node-fundamentals",
    "title": "Advanced Express Patterns",
    "order": 16,
    "objectives": [
      "Implement advanced routing patterns including parameter validation and route organization",
      "Use Express Router for modular application structure",
      "Apply middleware composition patterns for complex request processing",
      "Implement request validation and sanitization techniques"
    ],
    "intro": "Express.js is a minimalist web framework for Node.js that provides a robust set of features for building web and mobile applications. While basic Express usage covers many scenarios, advanced patterns and techniques are essential for building maintainable, scalable applications with clean architecture.\n\nAdvanced routing patterns in Express include techniques for organizing routes into logical modules, implementing parameter validation and transformation, and creating RESTful API structures. Understanding how to use Express Router effectively allows developers to create modular applications that are easier to maintain and test.\n\nMiddleware composition patterns enable developers to build complex request processing pipelines by combining multiple middleware functions. This includes conditional middleware execution, middleware chains for specific routes, and error handling middleware that can process different types of errors appropriately.\n\nRequest validation and sanitization are critical for building secure applications that properly handle user input. Advanced patterns include using validation libraries, implementing custom validation middleware, and applying sanitization techniques to prevent injection attacks and other security vulnerabilities.\n\nIn this lesson, you'll learn to implement advanced Express patterns including sophisticated routing techniques, modular application organization with Express Router, middleware composition for complex processing pipelines, and comprehensive request validation and sanitization strategies.",
    "code": {
      "example": "// routers/users.router.js - Modular route organization\nconst express = require('express');\nconst router = express.Router();\n\n// Validation middleware\nconst validateUserId = (req, res, next) => {\n  const userId = parseInt(req.params.userId);\n  \n  if (isNaN(userId) || userId <= 0) {\n    return res.status(400).json({\n      error: 'Valid user ID required',\n      code: 'INVALID_USER_ID'\n    });\n  }\n  \n  req.userId = userId;\n  next();\n};\n\n// Sanitization middleware\nconst sanitizeUserData = (req, res, next) => {\n  if (req.body && typeof req.body === 'object') {\n    // Normalize email to lowercase\n    if (req.body.email) {\n      req.body.email = req.body.email.toLowerCase().trim();\n    }\n    \n    // Escape HTML to prevent XSS\n    if (req.body.name) {\n      req.body.name = req.body.name.replace(/</g, '&lt;').replace(/>/g, '&gt;');\n    }\n    \n    // Validate and sanitize phone number\n    if (req.body.phone) {\n      req.body.phone = req.body.phone.replace(/[^0-9]/g, '');\n    }\n  }\n  next();\n};\n\n// Conditional middleware\nconst requireAdmin = (req, res, next) => {\n  // In a real app, you would check user roles from JWT or session\n  const userRole = req.headers['x-user-role'] || 'user';\n  \n  if (userRole !== 'admin') {\n    return res.status(403).json({\n      error: 'Admin access required',\n      code: 'INSUFFICIENT_PRIVILEGES'\n    });\n  }\n  \n  next();\n};\n\n// GET /users/:userId - Route with validation\nrouter.get('/:userId', validateUserId, (req, res) => {\n  res.json({\n    message: `User data for user ID: ${req.userId}`\n  });\n});\n\n// POST /users - Route with sanitization\nrouter.post('/', sanitizeUserData, (req, res) => {\n  res.status(201).json({\n    message: 'User created successfully',\n    data: req.body\n  });\n});\n\n// DELETE /users/:userId - Route with admin check\nrouter.delete('/:userId', requireAdmin, validateUserId, (req, res) => {\n  res.json({\n    message: `User ${req.userId} deleted successfully`\n  });\n});\n\nmodule.exports = router;\n\n// routers/products.router.js - Another modular router\nconst express = require('express');\nconst router = express.Router();\n\n// Query parameter validation\nconst validateProductQuery = (req, res, next) => {\n  const { category, minPrice, maxPrice, limit = 10, page = 1 } = req.query;\n  \n  // Validate numeric parameters\n  if (minPrice && isNaN(parseFloat(minPrice))) {\n    return res.status(400).json({\n      error: 'minPrice must be a number',\n      code: 'INVALID_MIN_PRICE'\n    });\n  }\n  \n  if (maxPrice && isNaN(parseFloat(maxPrice))) {\n    return res.status(400).json({\n      error: 'maxPrice must be a number',\n      code: 'INVALID_MAX_PRICE'\n    });\n  }\n  \n  // Validate pagination parameters\n  const limitNum = parseInt(limit);\n  const pageNum = parseInt(page);\n  \n  if (isNaN(limitNum) || limitNum <= 0 || limitNum > 100) {\n    return res.status(400).json({\n      error: 'limit must be between 1 and 100',\n      code: 'INVALID_LIMIT'\n    });\n  }\n  \n  if (isNaN(pageNum) || pageNum <= 0) {\n    return res.status(400).json({\n      error: 'page must be a positive number',\n      code: 'INVALID_PAGE'\n    });\n  }\n  \n  req.queryParams = { category, minPrice: parseFloat(minPrice), maxPrice: parseFloat(maxPrice), limit: limitNum, page: pageNum };\n  next();\n};\n\nrouter.get('/', validateProductQuery, (req, res) => {\n  res.json({\n    message: 'Products retrieved successfully',\n    queryParams: req.queryParams\n  });\n});\n\nmodule.exports = router;\n\n// app.js - Main application with modular routers\nconst express = require('express');\nconst usersRouter = require('./routers/users.router');\nconst productsRouter = require('./routers/products.router');\n\nconst app = express();\n\n// Global middleware\napp.use(express.json());\n\n// Mount modular routers\napp.use('/api/users', usersRouter);\napp.use('/api/products', productsRouter);\n\n// Global error handling middleware\nconst globalErrorHandler = (err, req, res, next) => {\n  console.error('Unhandled error:', err);\n  \n  // Handle specific error types\n  if (err.type === 'entity.parse.failed') {\n    return res.status(400).json({\n      error: 'Invalid JSON in request body',\n      code: 'INVALID_JSON'\n    });\n  }\n  \n  // Default error response\n  res.status(500).json({\n    error: 'Internal server error',\n    code: 'INTERNAL_ERROR'\n  });\n};\n\n// Apply error handling middleware\napp.use(globalErrorHandler);\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Route not found',\n    code: 'ROUTE_NOT_FOUND'\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`\nðŸš€ Advanced Express Patterns server running on port ${PORT}\n\nAvailable endpoints:\n  GET    /api/users/:userId     - Get user by ID\n  POST   /api/users             - Create user\n  DELETE /api/users/:userId     - Delete user (admin only)\n  GET    /api/products          - Get products with query validation\n`);\n});",
      "explanation": "This example demonstrates advanced Express patterns including:\n\n1. **Modular Route Organization**: Using Express.Router to organize routes into separate files\n2. **Parameter Validation**: Custom middleware for validating route parameters\n3. **Data Sanitization**: Middleware for sanitizing user input to prevent security issues\n4. **Conditional Middleware**: Role-based access control middleware\n5. **Query Parameter Validation**: Comprehensive validation for query parameters\n6. **Error Handling**: Global error handling middleware for centralized error management\n7. **Route Mounting**: Mounting modular routers at specific paths\n\nThe output shows:\nðŸš€ Advanced Express Patterns server running on port 3000\n\nAvailable endpoints:\n  GET    /api/users/:userId     - Get user by ID\n  POST   /api/users             - Create user\n  DELETE /api/users/:userId     - Delete user (admin only)\n  GET    /api/products          - Get products with query validation\n\nKey concepts illustrated:\n- Router modularization\n- Middleware composition\n- Input validation and sanitization\n- Conditional route processing\n- Error handling patterns\n- RESTful API design",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not organizing routes into modular structures leading to monolithic applications",
        "solution": "Use Express.Router to organize routes by resource or feature, making applications more maintainable",
        "severity": "high"
      },
      {
        "mistake": "Skipping input validation and sanitization creating security vulnerabilities",
        "solution": "Implement comprehensive validation and sanitization middleware for all user inputs",
        "severity": "high"
      },
      {
        "mistake": "Incorrect middleware order causing unexpected behavior",
        "solution": "Ensure middleware is registered in the correct order, with error handling middleware last",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Advanced Express Routing and Middleware",
        "description": "Create a modular Express application with advanced routing patterns and middleware composition.",
        "checkpoints": [
          "Organize routes into modular routers for different resources (users, products, orders)",
          "Implement comprehensive parameter and query validation middleware",
          "Create sanitization middleware to prevent XSS and injection attacks",
          "Apply conditional middleware for role-based access control",
          "Implement global error handling with specific error type processing"
        ]
      }
    ],
    "next": [
      "node-fundamentals-lesson-17"
    ],
    "estimatedMinutes": 90,
    "difficulty": "Advanced",
    "tags": [
      "Express",
      "Node.js",
      "Routing",
      "Middleware",
      "Validation"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-17",
    "moduleSlug": "node-fundamentals",
    "title": "Authentication and Authorization",
    "order": 17,
    "objectives": [
      "Implement JWT-based authentication for REST APIs",
      "Create role-based and permission-based authorization systems",
      "Secure API endpoints with authentication middleware",
      "Handle password hashing and user session management"
    ],
    "intro": "Authentication and authorization are critical aspects of modern web applications that ensure only legitimate users can access resources and that they can only access what they're permitted to. Proper implementation of these security measures is essential for protecting user data and maintaining application integrity.\n\nJSON Web Tokens (JWT) have become the standard for securing REST APIs in modern applications. JWTs are compact, URL-safe tokens that contain claims about a user and can be verified and trusted because they're digitally signed. Understanding how to implement JWT authentication properly, including token generation, validation, and refresh mechanisms, is crucial for building secure applications.\n\nAuthorization determines what an authenticated user is allowed to do within an application. This includes role-based access control (RBAC) where users are assigned roles that determine their permissions, and permission-based access control where users are granted specific permissions directly. Advanced authorization patterns include hierarchical roles, attribute-based access control (ABAC), and resource-based permissions.\n\nPassword security is a fundamental aspect of authentication systems. Proper password handling includes using strong hashing algorithms like bcrypt or Argon2, implementing password strength requirements, and providing secure password reset mechanisms. Session management for web applications requires careful consideration of token expiration, refresh tokens, and secure storage practices.\n\nIn this lesson, you'll learn to implement comprehensive authentication and authorization systems using JWT tokens, create role-based and permission-based access control mechanisms, secure API endpoints with proper authentication middleware, and handle password security and session management effectively.",
    "code": {
      "example": "// auth.middleware.js - Authentication and authorization middleware\nconst jwt = require('jsonwebtoken');\nconst bcrypt = require('bcryptjs');\n\n// Secret key for JWT signing (in production, use environment variables)\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key';\nconst JWT_EXPIRES_IN = '24h';\n\n// Mock user database (in real applications, use a proper database)\nconst users = [\n  {\n    id: 1,\n    username: 'admin',\n    email: 'admin@example.com',\n    // Password: admin123 (hashed)\n    passwordHash: '$2a$10$8K1p/a0dhrxiowP.dnkgNORTWgdEDHn5L2/xjpEWuC.QQv4rKO9jO',\n    roles: ['admin', 'user'],\n    permissions: ['read_users', 'write_users', 'delete_users', 'read_products', 'write_products']\n  },\n  {\n    id: 2,\n    username: 'user',\n    email: 'user@example.com',\n    // Password: user123 (hashed)\n    passwordHash: '$2a$10$8K1p/a0dhrxiowP.dnkgNORTWgdEDHn5L2/xjpEWuC.QQv4rKO9jO',\n    roles: ['user'],\n    permissions: ['read_products']\n  }\n];\n\n// Authentication middleware - verifies JWT token\nconst authenticateToken = (req, res, next) => {\n  const authHeader = req.headers.authorization;\n  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN\n  \n  if (!token) {\n    return res.status(401).json({\n      error: 'Access token required',\n      code: 'MISSING_TOKEN'\n    });\n  }\n  \n  jwt.verify(token, JWT_SECRET, (err, decoded) => {\n    if (err) {\n      return res.status(403).json({\n        error: 'Invalid or expired token',\n        code: 'INVALID_TOKEN'\n      });\n    }\n    \n    // Add user information to request object\n    req.user = decoded;\n    next();\n  });\n};\n\n// Role-based authorization middleware\nconst requireRole = (...roles) => {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        code: 'AUTH_REQUIRED'\n      });\n    }\n    \n    const userRoles = req.user.roles || [];\n    const hasRole = roles.some(role => userRoles.includes(role));\n    \n    if (!hasRole) {\n      return res.status(403).json({\n        error: `Required roles: ${roles.join(', ')}`,\n        code: 'INSUFFICIENT_ROLES'\n      });\n    }\n    \n    next();\n  };\n};\n\n// Permission-based authorization middleware\nconst requirePermission = (...permissions) => {\n  return (req, res, next) => {\n    if (!req.user) {\n      return res.status(401).json({\n        error: 'Authentication required',\n        code: 'AUTH_REQUIRED'\n      });\n    }\n    \n    const userPermissions = req.user.permissions || [];\n    const hasPermission = permissions.some(permission => userPermissions.includes(permission));\n    \n    if (!hasPermission) {\n      return res.status(403).json({\n        error: `Required permissions: ${permissions.join(', ')}`,\n        code: 'INSUFFICIENT_PERMISSIONS'\n      });\n    }\n    \n    next();\n  };\n};\n\n// Auth controller functions\nconst authController = {\n  // User login\n  async login(req, res) {\n    const { username, password } = req.body;\n    \n    // Validate input\n    if (!username || !password) {\n      return res.status(400).json({\n        error: 'Username and password required',\n        code: 'MISSING_CREDENTIALS'\n      });\n    }\n    \n    // Find user\n    const user = users.find(u => u.username === username);\n    if (!user) {\n      return res.status(401).json({\n        error: 'Invalid credentials',\n        code: 'INVALID_CREDENTIALS'\n      });\n    }\n    \n    // Verify password\n    const isValidPassword = await bcrypt.compare(password, user.passwordHash);\n    if (!isValidPassword) {\n      return res.status(401).json({\n        error: 'Invalid credentials',\n        code: 'INVALID_CREDENTIALS'\n      });\n    }\n    \n    // Generate JWT token\n    const tokenPayload = {\n      userId: user.id,\n      username: user.username,\n      email: user.email,\n      roles: user.roles,\n      permissions: user.permissions\n    };\n    \n    const token = jwt.sign(tokenPayload, JWT_SECRET, {\n      expiresIn: JWT_EXPIRES_IN\n    });\n    \n    res.json({\n      message: 'Login successful',\n      token,\n      user: {\n        id: user.id,\n        username: user.username,\n        email: user.email,\n        roles: user.roles\n      }\n    });\n  },\n  \n  // User registration\n  async register(req, res) {\n    const { username, email, password } = req.body;\n    \n    // Validate input\n    if (!username || !email || !password) {\n      return res.status(400).json({\n        error: 'Username, email, and password required',\n        code: 'MISSING_FIELDS'\n      });\n    }\n    \n    // Check if user already exists\n    if (users.find(u => u.username === username || u.email === email)) {\n      return res.status(409).json({\n        error: 'Username or email already exists',\n        code: 'USER_EXISTS'\n      });\n    }\n    \n    // Hash password\n    const saltRounds = 10;\n    const passwordHash = await bcrypt.hash(password, saltRounds);\n    \n    // Create new user\n    const newUser = {\n      id: users.length + 1,\n      username,\n      email,\n      passwordHash,\n      roles: ['user'], // Default role\n      permissions: ['read_products'] // Default permissions\n    };\n    \n    users.push(newUser);\n    \n    res.status(201).json({\n      message: 'User registered successfully',\n      user: {\n        id: newUser.id,\n        username: newUser.username,\n        email: newUser.email,\n        roles: newUser.roles\n      }\n    });\n  },\n  \n  // Get current user profile\n  getProfile(req, res) {\n    res.json({\n      user: req.user\n    });\n  }\n};\n\n// app.js - Main application\nconst express = require('express');\nconst app = express();\n\napp.use(express.json());\n\n// Public routes\napp.post('/auth/login', authController.login);\napp.post('/auth/register', authController.register);\n\n// Protected routes\napp.get('/profile', authenticateToken, authController.getProfile);\napp.get('/admin/users', authenticateToken, requireRole('admin'), (req, res) => {\n  res.json({\n    message: 'Admin users endpoint',\n    users: users.map(u => ({\n      id: u.id,\n      username: u.username,\n      email: u.email,\n      roles: u.roles\n    }))\n  });\n});\napp.post('/admin/users', authenticateToken, requireRole('admin'), requirePermission('write_users'), (req, res) => {\n  res.json({\n    message: 'Create user endpoint (admin only with write_users permission)'\n  });\n});\n\n// Global error handler\napp.use((err, req, res, next) => {\n  console.error('Unhandled error:', err);\n  res.status(500).json({\n    error: 'Internal server error',\n    code: 'INTERNAL_ERROR'\n  });\n});\n\n// 404 handler\napp.use((req, res) => {\n  res.status(404).json({\n    error: 'Route not found',\n    code: 'ROUTE_NOT_FOUND'\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\napp.listen(PORT, () => {\n  console.log(`\nðŸš€ Authentication & Authorization server running on port ${PORT}\n\nAvailable endpoints:\n  POST /auth/login     - User login\n  POST /auth/register  - User registration\n  GET  /profile        - Get user profile (authenticated)\n  GET  /admin/users    - Get all users (admin only)\n  POST /admin/users    - Create user (admin with write_users permission)\n\nTest credentials:\n  Username: admin, Password: admin123 (admin user)\n  Username: user,  Password: user123  (regular user)\n`);\n});",
      "explanation": "This example demonstrates a complete authentication and authorization system including:\n\n1. **JWT Authentication**: Token generation and verification middleware\n2. **Role-Based Access Control**: Middleware for role-based authorization\n3. **Permission-Based Access Control**: Middleware for permission-based authorization\n4. **Password Security**: bcrypt hashing for secure password storage\n5. **User Management**: Login and registration endpoints\n6. **Protected Routes**: Various levels of access control\n\nThe output shows:\nðŸš€ Authentication & Authorization server running on port 3000\n\nAvailable endpoints:\n  POST /auth/login     - User login\n  POST /auth/register  - User registration\n  GET  /profile        - Get user profile (authenticated)\n  GET  /admin/users    - Get all users (admin only)\n  POST /admin/users    - Create user (admin with write_users permission)\n\nTest credentials:\n  Username: admin, Password: admin123 (admin user)\n  Username: user,  Password: user123  (regular user)\n\nKey concepts illustrated:\n- JWT token generation and verification\n- Role-based middleware implementation\n- Permission-based middleware implementation\n- Password hashing with bcrypt\n- User session management\n- Multi-level access control",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Storing JWT secrets or passwords in plain text in code",
        "solution": "Use environment variables for sensitive configuration and never commit secrets to version control",
        "severity": "high"
      },
      {
        "mistake": "Not implementing proper password hashing leading to security vulnerabilities",
        "solution": "Always use strong hashing algorithms like bcrypt or Argon2 for password storage",
        "severity": "high"
      },
      {
        "mistake": "Inadequate authorization checks allowing privilege escalation",
        "solution": "Implement both role-based and permission-based authorization with proper validation",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement a Complete Authentication System",
        "description": "Create a full authentication and authorization system with JWT tokens and access control.",
        "checkpoints": [
          "Implement JWT token generation and validation middleware",
          "Create role-based and permission-based authorization middleware",
          "Build secure user registration and login endpoints with password hashing",
          "Protect API endpoints with appropriate authentication and authorization checks",
          "Implement refresh token mechanism for improved security"
        ]
      }
    ],
    "next": [
      "node-fundamentals-lesson-18"
    ],
    "estimatedMinutes": 90,
    "difficulty": "Advanced",
    "tags": [
      "Authentication",
      "Authorization",
      "JWT",
      "Security",
      "Node.js"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "node-fundamentals-lesson-18",
    "moduleSlug": "node-fundamentals",
    "title": "Real-time Applications with WebSockets",
    "order": 18,
    "objectives": [
      "Implement real-time communication using WebSockets with Socket.IO",
      "Create scalable real-time applications with room-based messaging",
      "Handle connection lifecycle events and error recovery",
      "Implement security measures for WebSocket connections"
    ],
    "intro": "Real-time web applications have become increasingly important in modern development, enabling instant communication between clients and servers without the need for continuous polling. WebSockets provide a full-duplex communication channel over a single TCP connection, making them ideal for applications that require low-latency, bidirectional data exchange.\n\nSocket.IO is a popular library that provides a WebSocket-like interface with additional features like automatic reconnection, fallback mechanisms for older browsers, and room-based messaging. Understanding how to implement real-time features effectively is crucial for building applications like chat systems, live dashboards, collaborative tools, and gaming platforms.\n\nScalable real-time applications require careful consideration of connection management, message broadcasting, and resource utilization. Room-based messaging patterns allow developers to organize clients into logical groups, enabling targeted communication and reducing unnecessary message traffic. Proper handling of connection lifecycle events ensures robust applications that can gracefully handle client disconnections and server restarts.\n\nSecurity is particularly important for real-time applications since WebSocket connections can remain open for extended periods, creating potential attack vectors. Implementing authentication for WebSocket connections, validating message payloads, and protecting against denial-of-service attacks are essential practices for production applications.\n\nIn this lesson, you'll learn to implement real-time applications using WebSockets and Socket.IO, create scalable messaging systems with room-based communication, handle connection lifecycle events for robust applications, and implement security measures to protect WebSocket connections.",
    "code": {
      "example": "// server.js - WebSocket server with Socket.IO\nconst express = require('express');\nconst http = require('http');\nconst socketIo = require('socket.io');\nconst jwt = require('jsonwebtoken');\n\nconst app = express();\nconst server = http.createServer(app);\nconst io = socketIo(server, {\n  cors: {\n    origin: '*', // In production, specify allowed origins\n    methods: ['GET', 'POST']\n  }\n});\n\n// Secret key for JWT verification\nconst JWT_SECRET = process.env.JWT_SECRET || 'your-super-secret-jwt-key';\n\n// In-memory storage for rooms and users (in production, use Redis or database)\nconst rooms = new Map();\nconst users = new Map();\n\n// Authentication middleware for Socket.IO\nconst authenticateSocket = (socket, next) => {\n  const token = socket.handshake.auth.token;\n  \n  if (!token) {\n    return next(new Error('Authentication required'));\n  }\n  \n  jwt.verify(token, JWT_SECRET, (err, decoded) => {\n    if (err) {\n      return next(new Error('Invalid token'));\n    }\n    \n    socket.userId = decoded.userId;\n    socket.username = decoded.username;\n    next();\n  });\n};\n\n// Apply authentication middleware\nio.use(authenticateSocket);\n\n// Connection event handler\nio.on('connection', (socket) => {\n  console.log(`User connected: ${socket.username} (ID: ${socket.userId})`);\n  \n  // Add user to global users map\n  users.set(socket.id, {\n    id: socket.userId,\n    username: socket.username,\n    socketId: socket.id,\n    currentRoom: null\n  });\n  \n  // Join room event\n  socket.on('joinRoom', (data) => {\n    const { roomName } = data;\n    \n    // Join the room\n    socket.join(roomName);\n    \n    // Update user's current room\n    const user = users.get(socket.id);\n    if (user) {\n      user.currentRoom = roomName;\n    }\n    \n    // Add room to rooms map if it doesn't exist\n    if (!rooms.has(roomName)) {\n      rooms.set(roomName, {\n        name: roomName,\n        users: new Set()\n      });\n    }\n    \n    // Add user to room\n    rooms.get(roomName).users.add(socket.id);\n    \n    // Notify room members\n    socket.to(roomName).emit('userJoined', {\n      username: socket.username,\n      message: `${socket.username} joined the room`\n    });\n    \n    // Send room info to joining user\n    const roomUsers = Array.from(rooms.get(roomName).users)\n      .map(socketId => users.get(socketId)?.username)\n      .filter(name => name && name !== socket.username);\n      \n    socket.emit('roomInfo', {\n      roomName,\n      users: roomUsers\n    });\n    \n    console.log(`${socket.username} joined room: ${roomName}`);\n  });\n  \n  // Leave room event\n  socket.on('leaveRoom', () => {\n    const user = users.get(socket.id);\n    if (user && user.currentRoom) {\n      const roomName = user.currentRoom;\n      \n      // Leave the room\n      socket.leave(roomName);\n      \n      // Remove user from room\n      if (rooms.has(roomName)) {\n        rooms.get(roomName).users.delete(socket.id);\n        \n        // Notify room members\n        socket.to(roomName).emit('userLeft', {\n          username: socket.username,\n          message: `${socket.username} left the room`\n        });\n        \n        // Remove empty rooms\n        if (rooms.get(roomName).users.size === 0) {\n          rooms.delete(roomName);\n        }\n      }\n      \n      // Update user's current room\n      user.currentRoom = null;\n      \n      console.log(`${socket.username} left room: ${roomName}`);\n    }\n  });\n  \n  // Message event\n  socket.on('sendMessage', (data) => {\n    const { message, roomName } = data;\n    \n    // Validate message\n    if (!message || message.trim().length === 0) {\n      return;\n    }\n    \n    // Validate room\n    if (!rooms.has(roomName)) {\n      return;\n    }\n    \n    // Broadcast message to room\n    const timestamp = new Date().toISOString();\n    io.to(roomName).emit('message', {\n      username: socket.username,\n      message: message.trim(),\n      timestamp\n    });\n    \n    console.log(`Message from ${socket.username} in ${roomName}: ${message}`);\n  });\n  \n  // Typing indicator\n  socket.on('typing', (data) => {\n    const { roomName, isTyping } = data;\n    \n    if (rooms.has(roomName)) {\n      socket.to(roomName).emit('userTyping', {\n        username: socket.username,\n        isTyping\n      });\n    }\n  });\n  \n  // Disconnect event\n  socket.on('disconnect', () => {\n    const user = users.get(socket.id);\n    if (user) {\n      console.log(`User disconnected: ${user.username}`);\n      \n      // Handle room cleanup\n      if (user.currentRoom) {\n        const roomName = user.currentRoom;\n        \n        if (rooms.has(roomName)) {\n          rooms.get(roomName).users.delete(socket.id);\n          \n          // Notify room members\n          socket.to(roomName).emit('userLeft', {\n            username: user.username,\n            message: `${user.username} disconnected`\n          });\n          \n          // Remove empty rooms\n          if (rooms.get(roomName).users.size === 0) {\n            rooms.delete(roomName);\n          }\n        }\n      }\n      \n      // Remove user\n      users.delete(socket.id);\n    }\n  });\n  \n  // Error handling\n  socket.on('error', (error) => {\n    console.error(`Socket error for user ${socket.username}:`, error);\n  });\n});\n\n// REST API endpoints for authentication\napp.use(express.json());\n\n// Mock login endpoint\napp.post('/login', (req, res) => {\n  const { username } = req.body;\n  \n  if (!username) {\n    return res.status(400).json({\n      error: 'Username required'\n    });\n  }\n  \n  // Generate JWT token\n  const token = jwt.sign(\n    { userId: Date.now(), username },\n    JWT_SECRET,\n    { expiresIn: '24h' }\n  );\n  \n  res.json({\n    token,\n    username\n  });\n});\n\n// Health check endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    uptime: process.uptime(),\n    rooms: Array.from(rooms.keys()),\n    users: users.size\n  });\n});\n\nconst PORT = process.env.PORT || 3000;\nserver.listen(PORT, () => {\n  console.log(`\nðŸš€ WebSocket server running on port ${PORT}\n\nWebSocket endpoint: ws://localhost:${PORT}\nREST API endpoints:\n  POST /login   - Get authentication token\n  GET  /health  - Server health check\n\nTo test:\n1. POST to /login with {\"username\": \"testuser\"} to get a token\n2. Connect to WebSocket with the token in auth\n3. Emit 'joinRoom' with {\"roomName\": \"general\"}\n4. Emit 'sendMessage' with {\"message\": \"Hello world\", \"roomName\": \"general\"}\n`);\n});",
      "explanation": "This example demonstrates a complete real-time application using WebSockets with Socket.IO including:\n\n1. **Socket.IO Server Setup**: WebSocket server with CORS configuration\n2. **Authentication**: JWT token verification for WebSocket connections\n3. **Room-Based Messaging**: Users can `join` and leave rooms for organized communication\n4. **Message Broadcasting**: Messages sent to specific rooms\n5. **Connection Lifecycle**: Handling connect, disconnect, and error events\n6. **Real-time Features**: Typing indicators and user presence\n7. **Resource Management**: Proper cleanup of rooms and users\n\nThe output shows:\nðŸš€ WebSocket server running on port 3000\n\nWebSocket endpoint: ws://localhost:3000\nREST API endpoints:\n  POST /login   - Get authentication token\n  GET  /health  - Server health check\n\nTo test:\n1. POST to /login with {\"username\": \"testuser\"} to get a token\n2. Connect to WebSocket with the token in auth\n3. Emit 'joinRoom' with {\"roomName\": \"general\"}\n4. Emit 'sendMessage' with {\"message\": \"Hello world\", \"roomName\": \"general\"}\n\nKey concepts illustrated:\n- WebSocket server implementation\n- Authentication for real-time connections\n- Room-based communication patterns\n- Connection lifecycle management\n- Message broadcasting\n- Error handling\n- Resource cleanup",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not implementing authentication for WebSocket connections",
        "solution": "Verify authentication tokens during the connection handshake and validate user permissions for actions",
        "severity": "high"
      },
      {
        "mistake": "Failing to handle connection cleanup leading to memory leaks",
        "solution": "Properly clean up user sessions and room memberships when clients disconnect",
        "severity": "high"
      },
      {
        "mistake": "Broadcasting sensitive information to all connected clients",
        "solution": "Implement proper room-based messaging and user permission checks",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build a Real-time Chat Application",
        "description": "Create a complete real-time chat application with rooms, user presence, and message history.",
        "checkpoints": [
          "Implement WebSocket server with Socket.IO and authentication middleware",
          "Create room-based messaging with join/leave functionality",
          "Add real-time features like typing indicators and user presence",
          "Implement message history and persistence (in-memory or database)",
          "Add security measures including message validation and rate limiting"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 90,
    "difficulty": "Advanced",
    "tags": [
      "WebSockets",
      "Socket.IO",
      "Real-time",
      "Node.js",
      "Chat"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  }
]
