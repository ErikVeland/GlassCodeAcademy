{
  "id": "laravel-lesson-23-deployment-practices",
  "moduleSlug": "laravel-fundamentals",
  "title": "Deployment and DevOps Practices",
  "order": 23,
  "objectives": [
    "Master Laravel application deployment strategies for different environments",
    "Implement CI/CD pipelines with automated testing and deployment",
    "Create robust deployment configurations with environment management",
    "Design scalable infrastructure architectures for Laravel applications"
  ],
  "intro": "Deployment and DevOps practices in Laravel provide essential tools and techniques for reliably delivering applications to production environments while maintaining security, performance, and scalability. This comprehensive lesson explores advanced deployment strategies that ensure smooth, consistent deployments across different environments with minimal downtime and maximum reliability.\n\nYou'll learn to implement sophisticated deployment pipelines that automate testing, building, and deployment processes while maintaining strict quality controls and security measures. We'll explore advanced patterns for environment configuration management, zero-downtime deployments, and rollback strategies that enable confident, frequent releases.\n\nThe lesson covers practical implementation strategies for containerization with Docker, infrastructure as code with configuration management tools, and monitoring and alerting systems that provide visibility into application health and performance. You'll discover how to balance deployment automation with security requirements, implement proper secrets management, and design deployment architectures that scale with application growth.\n\nBy mastering deployment and DevOps practices, you'll be able to create Laravel applications that can be reliably deployed and maintained in production environments with confidence and efficiency.",
  "code": {
    "example": "<?php\n// Advanced Deployment and DevOps Practices\n\n// Environment Configuration Management\n// config/deployment.php\n\nreturn [\n    'environments' => [\n        'local' => [\n            'debug' => true,\n            'log_level' => 'debug',\n            'cache_driver' => 'array',\n            'session_driver' => 'file',\n        ],\n        \n        'staging' => [\n            'debug' => false,\n            'log_level' => 'info',\n            'cache_driver' => 'redis',\n            'session_driver' => 'redis',\n        ],\n        \n        'production' => [\n            'debug' => false,\n            'log_level' => 'error',\n            'cache_driver' => 'redis',\n            'session_driver' => 'redis',\n        ],\n    ],\n    \n    'deployment' => [\n        'strategy' => env('DEPLOYMENT_STRATEGY', 'rolling'),\n        'max_concurrent' => env('DEPLOYMENT_MAX_CONCURRENT', 2),\n        'health_check_url' => env('DEPLOYMENT_HEALTH_CHECK_URL', '/health'),\n        'health_check_timeout' => env('DEPLOYMENT_HEALTH_CHECK_TIMEOUT', 30),\n    ],\n    \n    'monitoring' => [\n        'enabled' => env('MONITORING_ENABLED', true),\n        'providers' => [\n            'sentry' => [\n                'dsn' => env('SENTRY_LARAVEL_DSN'),\n                'traces_sample_rate' => env('SENTRY_TRACES_SAMPLE_RATE', 0.1),\n            ],\n            'newrelic' => [\n                'enabled' => env('NEW_RELIC_ENABLED', false),\n                'license_key' => env('NEW_RELIC_LICENSE_KEY'),\n            ],\n        ],\n    ],\n];\n\n// Deployment Health Check Controller\n// app/Http/Controllers/HealthCheckController.php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Redis;\nuse Illuminate\\Support\\Facades\\Storage;\n\nclass HealthCheckController extends Controller\n{\n    public function index()\n    {\n        $checks = [\n            'database' => $this->checkDatabase(),\n            'cache' => $this->checkCache(),\n            'storage' => $this->checkStorage(),\n            'queue' => $this->checkQueue(),\n        ];\n        \n        $status = collect($checks)->every(fn($check) => $check['status'] === 'healthy') ? 'healthy' : 'degraded';\n        \n        return response()->json([\n            'status' => $status,\n            'timestamp' => now()->toISOString(),\n            'checks' => $checks,\n        ], $status === 'healthy' ? 200 : 503);\n    }\n    \n    protected function checkDatabase()\n    {\n        try {\n            DB::connection()->getPdo();\n            DB::select('SELECT 1');\n            return ['status' => 'healthy', 'message' => 'Database connection successful'];\n        } catch (\\Exception $e) {\n            return ['status' => 'unhealthy', 'message' => $e->getMessage()];\n        }\n    }\n    \n    protected function checkCache()\n    {\n        try {\n            $key = 'health_check_' . time();\n            $value = 'test_value';\n            \n            Redis::setex($key, 10, $value);\n            $result = Redis::get($key);\n            \n            if ($result === $value) {\n                return ['status' => 'healthy', 'message' => 'Cache connection successful'];\n            }\n            \n            return ['status' => 'unhealthy', 'message' => 'Cache value mismatch'];\n        } catch (\\Exception $e) {\n            return ['status' => 'unhealthy', 'message' => $e->getMessage()];\n        }\n    }\n    \n    protected function checkStorage()\n    {\n        try {\n            $testFile = 'health_check_' . time() . '.txt';\n            Storage::put($testFile, 'test');\n            $exists = Storage::exists($testFile);\n            Storage::delete($testFile);\n            \n            return $exists \n                ? ['status' => 'healthy', 'message' => 'Storage accessible']\n                : ['status' => 'unhealthy', 'message' => 'Storage test failed'];\n        } catch (\\Exception $e) {\n            return ['status' => 'unhealthy', 'message' => $e->getMessage()];\n        }\n    }\n    \n    protected function checkQueue()\n    {\n        try {\n            // Dispatch a test job\n            $jobId = uniqid();\n            dispatch(new \\App\\Jobs\\HealthCheckJob($jobId));\n            \n            return ['status' => 'healthy', 'message' => 'Queue system operational'];\n        } catch (\\Exception $e) {\n            return ['status' => 'unhealthy', 'message' => $e->getMessage()];\n        }\n    }\n}\n\n// Health Check Job\n// app/Jobs/HealthCheckJob.php\n\nnamespace App\\Jobs;\n\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass HealthCheckJob implements ShouldQueue\n{\n    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n    \n    protected $jobId;\n    \n    public function __construct($jobId)\n    {\n        $this->jobId = $jobId;\n    }\n    \n    public function handle()\n    {\n        Log::info('Health check job processed successfully', ['job_id' => $this->jobId]);\n        // This job is just for testing queue functionality\n    }\n}\n\n// Deployment Configuration Service\n// app/Services/DeploymentService.php\n\nnamespace App\\Services;\n\nuse Illuminate\\Support\\Facades\\Artisan;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\File;\n\nclass DeploymentService\n{\n    public function preDeploy()\n    {\n        Log::info('Starting pre-deployment tasks');\n        \n        // Run tests\n        $this->runTests();\n        \n        // Backup database (in non-production environments)\n        if (app()->environment('staging')) {\n            $this->backupDatabase();\n        }\n        \n        // Clear caches\n        $this->clearCaches();\n        \n        Log::info('Pre-deployment tasks completed');\n    }\n    \n    public function postDeploy()\n    {\n        Log::info('Starting post-deployment tasks');\n        \n        // Run migrations\n        $this->runMigrations();\n        \n        // Clear and rebuild caches\n        $this->rebuildCaches();\n        \n        // Warm caches\n        $this->warmCaches();\n        \n        // Restart queue workers\n        $this->restartQueueWorkers();\n        \n        Log::info('Post-deployment tasks completed');\n    }\n    \n    protected function runTests()\n    {\n        Log::info('Running tests');\n        // In a real deployment, this would be handled by CI/CD\n        // For demonstration, we're just logging\n    }\n    \n    protected function backupDatabase()\n    {\n        Log::info('Backing up database');\n        // Implementation would depend on database type\n        // For MySQL: mysqldump\n        // For PostgreSQL: pg_dump\n    }\n    \n    protected function clearCaches()\n    {\n        Log::info('Clearing caches');\n        Artisan::call('cache:clear');\n        Artisan::call('config:clear');\n        Artisan::call('route:clear');\n        Artisan::call('view:clear');\n    }\n    \n    protected function runMigrations()\n    {\n        Log::info('Running migrations');\n        Artisan::call('migrate', ['--force' => true]);\n    }\n    \n    protected function rebuildCaches()\n    {\n        Log::info('Rebuilding caches');\n        Artisan::call('config:cache');\n        Artisan::call('route:cache');\n        Artisan::call('view:cache');\n    }\n    \n    protected function warmCaches()\n    {\n        Log::info('Warming caches');\n        // Warm frequently accessed caches\n        app('App\\Services\\CacheManager')->warmCache();\n    }\n    \n    protected function restartQueueWorkers()\n    {\n        Log::info('Restarting queue workers');\n        // This would typically be handled by the process manager\n        // In production, you might use: php artisan queue:restart\n        Artisan::call('queue:restart');\n    }\n    \n    public function rollback($steps = 1)\n    {\n        Log::info('Rolling back migrations', ['steps' => $steps]);\n        Artisan::call('migrate:rollback', ['--step' => $steps]);\n        \n        // Clear and rebuild caches after rollback\n        $this->clearCaches();\n        $this->rebuildCaches();\n    }\n}\n\n// Docker Configuration for Laravel\n// Dockerfile\n\nFROM php:8.1-fpm\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    git \\\n    curl \\\n    libpng-dev \\\n    libonig-dev \\\n    libxml2-dev \\\n    zip \\\n    unzip\n\n# Clear cache\nRUN apt-get clean && rm -rf /var/lib/apt/lists/*\n\n# Install PHP extensions\nRUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd\n\n# Get latest Composer\nCOPY --from=composer:latest /usr/bin/composer /usr/bin/composer\n\n# Set working directory\nWORKDIR /var/www\n\n# Copy existing application directory contents\nCOPY . /var/www\n\n# Install dependencies\nRUN composer install --optimize-autoloader --no-dev\n\n# Set permissions\nRUN chown -R www-data:www-data \\\n    /var/www/vendor \\\n    /var/www/storage \\\n    /var/www/bootstrap/cache\n\n# Expose port 9000 and start PHP-FPM server\nEXPOSE 9000\nCMD [\"php-fpm\"]\n\n// Nginx Configuration\n// nginx.conf\n\nserver {\n    listen 80;\n    server_name example.com;\n    root /var/www/public;\n    \n    add_header X-Frame-Options \"SAMEORIGIN\";\n    add_header X-Content-Type-Options \"nosniff\";\n    \n    index index.php;\n    \n    charset utf-8;\n    \n    location / {\n        try_files $uri $uri/ /index.php?$query_string;\n    }\n    \n    location = /favicon.ico { access_log off; log_not_found off; }\n    location = /robots.txt  { access_log off; log_not_found off; }\n    \n    error_page 404 /index.php;\n    \n    location ~ \\.php$ {\n        fastcgi_pass app:9000;\n        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;\n        include fastcgi_params;\n    }\n    \n    location ~ /\\.(?!well-known).* {\n        deny all;\n    }\n}\n\n// Docker Compose Configuration\n// docker-compose.yml\n\nversion: '3.8'\n\nservices:\n    app:\n        build:\n            context: .\n            dockerfile: Dockerfile\n        image: laravel-app\n        container_name: laravel-app\n        restart: unless-stopped\n        working_dir: /var/www/\n        volumes:\n            - ./:/var/www\n            - ./storage/logs:/var/www/storage/logs\n        networks:\n            - laravel\n    \n    webserver:\n        image: nginx:alpine\n        container_name: laravel-nginx\n        restart: unless-stopped\n        ports:\n            - \"80:80\"\n            - \"443:443\"\n        volumes:\n            - ./:/var/www\n            - ./nginx.conf:/etc/nginx/conf.d/default.conf\n            - ./ssl:/etc/nginx/ssl\n        networks:\n            - laravel\n    \n    db:\n        image: mysql:8.0\n        container_name: laravel-mysql\n        restart: unless-stopped\n        environment:\n            MYSQL_DATABASE: laravel\n            MYSQL_ROOT_PASSWORD: secret\n            MYSQL_PASSWORD: secret\n            MYSQL_USER: laraveluser\n        volumes:\n            - dbdata:/var/lib/mysql\n            - ./mysql/my.cnf:/etc/mysql/my.cnf\n        ports:\n            - \"3306:3306\"\n        networks:\n            - laravel\n    \n    redis:\n        image: redis:alpine\n        container_name: laravel-redis\n        restart: unless-stopped\n        ports:\n            - \"6379:6379\"\n        networks:\n            - laravel\n    \n    queue:\n        build:\n            context: .\n            dockerfile: Dockerfile\n        image: laravel-app\n        container_name: laravel-queue\n        restart: unless-stopped\n        command: 'php artisan queue:work --tries=3'\n        volumes:\n            - ./:/var/www\n        networks:\n            - laravel\n        depends_on:\n            - app\n            - db\n            - redis\n\nnetworks:\n    laravel:\n        driver: bridge\n\nvolumes:\n    dbdata:\n        driver: local\n\n// CI/CD Pipeline Configuration\n// .github/workflows/deploy.yml\n\nname: Deploy Laravel Application\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    services:\n      mysql:\n        image: mysql:8.0\n        env:\n          MYSQL_ROOT_PASSWORD: password\n          MYSQL_DATABASE: test\n        ports:\n          - 3306:3306\n        options: --health-cmd=\"mysqladmin ping\" --health-interval=10s --health-timeout=5s --health-retries=3\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Setup PHP\n      uses: shivammathur/setup-php@v2\n      with:\n        php-version: '8.1'\n        extensions: mbstring, pdo, pdo_mysql\n        coverage: none\n    \n    - name: Copy .env\n      run: php -r \"file_exists('.env') || copy('.env.example', '.env');\"\n    \n    - name: Install Dependencies\n      run: composer install -q --no-ansi --no-interaction --no-scripts --no-progress --prefer-dist\n    \n    - name: Generate key\n      run: php artisan key:generate\n    \n    - name: Directory Permissions\n      run: chmod -R 777 storage bootstrap/cache\n    \n    - name: Create Database\n      run: |\n        mkdir -p database\n        touch database/database.sqlite\n    \n    - name: Execute tests (Unit and Feature tests) via PHPUnit\n      env:\n        DB_CONNECTION: sqlite\n        DB_DATABASE: database/database.sqlite\n      run: vendor/bin/phpunit\n  \n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Deploy to production\n      uses: appleboy/ssh-action@v0.1.5\n      with:\n        host: ${{ secrets.HOST }}\n        username: ${{ secrets.USERNAME }}\n        key: ${{ secrets.KEY }}\n        script: |\n          cd /var/www/html\n          git pull origin main\n          composer install --no-dev --optimize-autoloader\n          php artisan migrate --force\n          php artisan config:cache\n          php artisan route:cache\n          php artisan view:cache\n          php artisan queue:restart\n          sudo systemctl reload php8.1-fpm\n          sudo systemctl reload nginx",
    "explanation": "This example demonstrates advanced Laravel deployment and DevOps practices including:\n\n1. Environment configuration management for different deployment stages\n2. Comprehensive health check implementation for deployment validation\n3. Deployment service with pre and post-deployment tasks\n4. Docker configuration for containerized Laravel applications\n5. Nginx configuration for optimal performance\n6. Docker Compose setup for multi-container applications\n7. CI/CD pipeline configuration with GitHub Actions\n8. Database backup and rollback strategies\n\nThese patterns enable developers to create robust, automated deployment processes that ensure reliable, consistent application delivery with minimal downtime and maximum reliability.",
    "language": "php"
  },
  "pitfalls": [
    {
      "mistake": "Deploying without proper testing and validation checks",
      "solution": "Implement comprehensive CI/CD pipelines with automated testing, health checks, and rollback capabilities",
      "severity": "high"
    },
    {
      "mistake": "Not managing environment-specific configurations properly",
      "solution": "Use proper environment variable management, configuration caching, and environment-specific settings",
      "severity": "high"
    },
    {
      "mistake": "Deploying with downtime or without proper rollback strategies",
      "solution": "Implement zero-downtime deployment strategies, blue-green deployments, and comprehensive rollback procedures",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Implement Complete Deployment Pipeline",
      "description": "Create a comprehensive deployment system with health checks, CI/CD integration, and proper environment management",
      "checkpoints": [
        "Implement environment configuration management",
        "Create comprehensive health check system",
        "Build deployment service with pre/post tasks",
        "Configure Docker for containerized deployment",
        "Set up CI/CD pipeline with automated testing"
      ]
    }
  ],
  "next": ["laravel-interview-questions"],
  "estimatedMinutes": 60,
  "difficulty": "Advanced",
  "tags": [
    "Deployment",
    "DevOps",
    "Docker",
    "CI/CD",
    "Laravel"
  ],
  "lastUpdated": "2025-10-03T10:00:00Z",
  "version": "1.0.0"
}