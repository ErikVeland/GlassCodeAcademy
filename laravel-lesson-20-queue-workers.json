{
  "id": "laravel-lesson-20-queue-workers",
  "moduleSlug": "laravel-fundamentals",
  "title": "Queue Workers and Job Processing",
  "order": 20,
  "objectives": [
    "Master Laravel's queue system for background job processing",
    "Implement reliable job handling with proper error management",
    "Create efficient queue workers with monitoring and optimization",
    "Design scalable job architectures for high-volume applications"
  ],
  "intro": "Queue workers and job processing in Laravel provide a robust foundation for handling time-intensive operations without blocking user requests, enabling applications to maintain responsiveness while processing complex tasks in the background. This comprehensive lesson explores advanced techniques for implementing reliable, scalable queue systems that can handle high volumes of jobs while maintaining system stability.\n\nYou'll learn to implement sophisticated job patterns that handle complex business logic, create reliable error handling and retry mechanisms, and optimize queue workers for performance and resource utilization. We'll explore advanced patterns for job chaining, batching, and rate limiting that enable sophisticated background processing workflows.\n\nThe lesson covers practical implementation strategies for monitoring queue performance, handling failed jobs effectively, and designing queue architectures that scale with application growth. You'll discover how to balance queue throughput with system resources, implement proper logging and alerting, and optimize jobs for different processing requirements.\n\nBy mastering queue workers and job processing, you'll be able to create Laravel applications that efficiently handle complex background operations while maintaining excellent user experience and system reliability.",
  "code": {
    "example": "<?php\n// Advanced Queue Workers and Job Processing\n\n// Complex Job Implementation\n// app/Jobs/ProcessUserReport.php\n\nnamespace App\\Jobs;\n\nuse App\\Models\\User;\nuse App\\Models\\Report;\nuse App\\Services\\ReportGenerator;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Throwable;\n\nclass ProcessUserReport implements ShouldQueue\n{\n    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n    \n    public $tries = 3;\n    public $backoff = [1, 5, 10]; // Exponential backoff\n    public $timeout = 300; // 5 minutes\n    public $maxExceptions = 3;\n    \n    protected $userId;\n    protected $reportType;\n    protected $parameters;\n    \n    public function __construct($userId, $reportType, array $parameters = [])\n    {\n        $this->userId = $userId;\n        $this->reportType = $reportType;\n        $this->parameters = $parameters;\n        \n        // Set queue based on priority\n        $this->onQueue($this->determineQueue($reportType));\n        \n        // Set connection for critical reports\n        if ($this->isCriticalReport($reportType)) {\n            $this->onConnection('redis');\n        }\n    }\n    \n    public function handle(ReportGenerator $reportGenerator)\n    {\n        try {\n            Log::info('Starting report generation', [\n                'user_id' => $this->userId,\n                'report_type' => $this->reportType,\n                'job_id' => $this->job->getJobId()\n            ]);\n            \n            // Check if job should be cancelled\n            if ($this->job->isDeletedOrReleased()) {\n                return;\n            }\n            \n            // Get user\n            $user = User::find($this->userId);\n            if (!$user) {\n                $this->fail('User not found');\n                return;\n            }\n            \n            // Create report record\n            $report = Report::create([\n                'user_id' => $this->userId,\n                'type' => $this->reportType,\n                'status' => 'processing',\n                'parameters' => $this->parameters\n            ]);\n            \n            // Update progress\n            $this->updateProgress($report, 10);\n            \n            // Generate report data\n            $data = $reportGenerator->generate($this->reportType, $this->parameters);\n            \n            // Update progress\n            $this->updateProgress($report, 70);\n            \n            // Save report file\n            $filePath = $this->saveReportFile($report, $data);\n            \n            // Update progress\n            $this->updateProgress($report, 90);\n            \n            // Finalize report\n            $report->update([\n                'status' => 'completed',\n                'file_path' => $filePath,\n                'completed_at' => now()\n            ]);\n            \n            // Notify user\n            $user->notify(new \\App\\Notifications\\ReportCompleted($report));\n            \n            Log::info('Report generation completed', [\n                'report_id' => $report->id,\n                'user_id' => $this->userId\n            ]);\n            \n        } catch (Throwable $e) {\n            Log::error('Report generation failed', [\n                'user_id' => $this->userId,\n                'report_type' => $this->reportType,\n                'error' => $e->getMessage(),\n                'trace' => $e->getTraceAsString()\n            ]);\n            \n            // Update report status\n            if (isset($report)) {\n                $report->update([\n                    'status' => 'failed',\n                    'error_message' => $e->getMessage(),\n                    'failed_at' => now()\n                ]);\n            }\n            \n            // Re-throw to trigger retry mechanism\n            throw $e;\n        }\n    }\n    \n    public function updateProgress(Report $report, int $percentage)\n    {\n        $report->update(['progress' => $percentage]);\n        \n        // Broadcast progress update\n        broadcast(new \\App\\Events\\ReportProgressUpdated($report));\n    }\n    \n    public function saveReportFile(Report $report, array $data): string\n    {\n        $fileName = \"reports/{$report->id}_\" . time() . '.json';\n        Storage::put($fileName, json_encode($data, JSON_PRETTY_PRINT));\n        return $fileName;\n    }\n    \n    public function failed(Throwable $exception)\n    {\n        Log::error('Report job failed permanently', [\n            'user_id' => $this->userId,\n            'report_type' => $this->reportType,\n            'error' => $exception->getMessage()\n        ]);\n        \n        // Update report status\n        Report::where('user_id', $this->userId)\n              ->where('type', $this->reportType)\n              ->where('status', 'processing')\n              ->update([\n                  'status' => 'failed',\n                  'error_message' => $exception->getMessage(),\n                  'failed_at' => now()\n              ]);\n        \n        // Notify user of failure\n        $user = User::find($this->userId);\n        if ($user) {\n            $user->notify(new \\App\\Notifications\\ReportFailed($this->reportType));\n        }\n    }\n    \n    protected function determineQueue(string $reportType): string\n    {\n        return match($reportType) {\n            'financial', 'compliance' => 'high-priority',\n            'analytics', 'statistics' => 'low-priority',\n            default => 'default'\n        };\n    }\n    \n    protected function isCriticalReport(string $reportType): bool\n    {\n        return in_array($reportType, ['financial', 'compliance']);\n    }\n}\n\n// Job Chaining Example\n// app/Jobs/ProcessOrder.php\n\nnamespace App\\Jobs;\n\nuse App\\Models\\Order;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass ProcessOrder implements ShouldQueue\n{\n    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n    \n    protected $orderId;\n    \n    public function __construct($orderId)\n    {\n        $this->orderId = $orderId;\n    }\n    \n    public function handle()\n    {\n        $order = Order::find($this->orderId);\n        if (!$order) {\n            $this->fail('Order not found');\n            return;\n        }\n        \n        // Process payment\n        ProcessPayment::withChain([\n            new UpdateInventory($order->id),\n            new SendConfirmationEmail($order->id),\n            new UpdateAnalytics($order->id)\n        ])->dispatch($order->id);\n        \n        Log::info('Order processing chain initiated', ['order_id' => $order->id]);\n    }\n}\n\n// Batch Job Processing\n// app/Jobs/ImportUsers.php\n\nnamespace App\\Jobs;\n\nuse App\\Models\\User;\nuse Illuminate\\Bus\\Batchable;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Support\\Collection;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass ImportUsers implements ShouldQueue\n{\n    use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n    \n    protected Collection $users;\n    \n    public function __construct(Collection $users)\n    {\n        $this->users = $users;\n    }\n    \n    public function handle()\n    {\n        if ($this->batch()->cancelled()) {\n            return;\n        }\n        \n        foreach ($this->users as $userData) {\n            if ($this->batch()->cancelled()) {\n                return;\n            }\n            \n            try {\n                User::create($userData);\n                $this->batch()->incrementProgress();\n            } catch (\\Exception $e) {\n                Log::error('User import failed', [\n                    'data' => $userData,\n                    'error' => $e->getMessage()\n                ]);\n                \n                $this->batch()->recordFailedJob($this->job->getJobId(), $e);\n            }\n        }\n    }\n    \n    public function failed(\\Throwable $e)\n    {\n        Log::error('Batch job failed', [\n            'error' => $e->getMessage(),\n            'batch_id' => $this->batch()->id\n        ]);\n    }\n}\n\n// Controller to dispatch jobs\n// app/Http/Controllers/ReportController.php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Jobs\\ProcessUserReport;\nuse App\\Models\\Report;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Bus;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass ReportController extends Controller\n{\n    public function generate(Request $request)\n    {\n        $request->validate([\n            'type' => 'required|string',\n            'parameters' => 'array'\n        ]);\n        \n        // Dispatch job\n        $job = new ProcessUserReport(\n            auth()->id(),\n            $request->type,\n            $request->parameters ?? []\n        );\n        \n        // Add delay for non-critical reports\n        if (!in_array($request->type, ['financial', 'compliance'])) {\n            $job->delay(now()->addMinutes(5));\n        }\n        \n        dispatch($job);\n        \n        // Create initial report record for tracking\n        $report = Report::create([\n            'user_id' => auth()->id(),\n            'type' => $request->type,\n            'status' => 'queued',\n            'parameters' => $request->parameters\n        ]);\n        \n        return response()->json([\n            'message' => 'Report generation started',\n            'report_id' => $report->id\n        ], 202);\n    }\n    \n    public function batchImport(Request $request)\n    {\n        $request->validate([\n            'users' => 'required|array',\n            'users.*.email' => 'required|email',\n            'users.*.name' => 'required|string'\n        ]);\n        \n        $userChunks = collect($request->users)->chunk(100);\n        \n        $batch = Bus::batch([])->dispatch();\n        \n        foreach ($userChunks as $chunk) {\n            $batch->add(new \\App\\Jobs\\ImportUsers($chunk));\n        }\n        \n        return response()->json([\n            'message' => 'Batch import started',\n            'batch_id' => $batch->id\n        ], 202);\n    }\n}\n\n// Queue monitoring and optimization\n// app/Console/Commands/MonitorQueues.php\n\nnamespace App\\Console\\Commands;\n\nuse Illuminate\\Console\\Command;\nuse Illuminate\\Support\\Facades\\Redis;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass MonitorQueues extends Command\n{\n    protected $signature = 'queue:monitor';\n    protected $description = 'Monitor queue performance and alert on issues';\n    \n    public function handle()\n    {\n        $queues = ['default', 'high-priority', 'low-priority'];\n        \n        foreach ($queues as $queue) {\n            $pendingJobs = Redis::llen(\"queues:{$queue}\");\n            $failedJobs = \\App\\Models\\FailedJob::where('queue', $queue)\n                                              ->where('failed_at', '>', now()->subHour())\n                                              ->count();\n            \n            // Alert if queue is backing up\n            if ($pendingJobs > 1000) {\n                Log::warning(\"Queue {$queue} has {$pendingJobs} pending jobs\");\n                // Send alert to monitoring system\n            }\n            \n            // Alert on high failure rate\n            if ($failedJobs > 50) {\n                Log::critical(\"High failure rate in queue {$queue}: {$failedJobs} failures in last hour\");\n                // Send critical alert\n            }\n            \n            $this->info(\"Queue {$queue}: {$pendingJobs} pending, {$failedJobs} failed (last hour)\");\n        }\n    }\n}",
    "explanation": "This example demonstrates advanced Laravel queue worker patterns including:\n\n1. Complex job implementation with proper error handling and retry mechanisms\n2. Job chaining for sequential processing workflows\n3. Batch job processing for handling large datasets\n4. Queue prioritization and connection management\n5. Progress tracking and real-time updates\n6. Comprehensive logging and monitoring\n7. Graceful failure handling and cleanup\n8. Performance optimization techniques\n\nThese patterns enable developers to create robust, scalable queue systems that can handle complex background processing requirements while maintaining system reliability and performance.",
    "language": "php"
  },
  "pitfalls": [
    {
      "mistake": "Creating jobs that are too large and take too long to process",
      "solution": "Break large jobs into smaller chunks, implement proper progress tracking, and use batch processing for large datasets",
      "severity": "high"
    },
    {
      "mistake": "Not implementing proper error handling and cleanup in jobs",
      "solution": "Use try-catch blocks, implement failed() method for cleanup, and ensure jobs can be safely retried",
      "severity": "high"
    },
    {
      "mistake": "Ignoring queue monitoring and performance optimization",
      "solution": "Implement queue monitoring, set appropriate timeouts, and optimize job processing for resource utilization",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Implement Advanced Queue Processing System",
      "description": "Create a comprehensive queue system with job chaining, batching, and proper monitoring",
      "checkpoints": [
        "Implement complex jobs with proper error handling and retry mechanisms",
        "Create job chaining for sequential workflows",
        "Build batch processing for large datasets",
        "Add queue monitoring and alerting",
        "Implement progress tracking and real-time updates"
      ]
    }
  ],
  "next": ["laravel-lesson-21-event-broadcasting"],
  "estimatedMinutes": 55,
  "difficulty": "Advanced",
  "tags": [
    "Queue",
    "Jobs",
    "Workers",
    "Background Processing",
    "Laravel"
  ],
  "lastUpdated": "2025-10-03T10:00:00Z",
  "version": "1.0.0"
}