[
  {
    "id": "testing-fundamentals-lesson-1",
    "moduleSlug": "testing-fundamentals",
    "title": "Testing Pyramid and Test Strategies",
    "order": 1,
    "objectives": [
      "Understand the testing pyramid and its three layers: unit, integration, and end-to-end tests",
      "Learn to balance different test types for optimal coverage and performance",
      "Develop a comprehensive testing strategy that aligns with business requirements",
      "Identify appropriate testing tools and frameworks for different testing layers"
    ],
    "intro": "The testing pyramid is a conceptual model that helps developers create a balanced test suite by categorizing tests into different layers based on scope, speed, and cost. Understanding this model is crucial for building robust, maintainable software that can be confidently deployed and evolved over time.\n\nAt the foundation of the pyramid are unit tests, which are fast, isolated tests that verify individual functions, methods, or components in isolation. These tests form the bulk of your test suite and provide rapid feedback during development. Above unit tests are integration tests, which verify that different modules or services work together correctly. These tests are more complex and slower than unit tests but are essential for catching issues that unit tests might miss. At the top of the pyramid are end-to-end (E2E) tests, which simulate real user scenarios and test the entire application flow from user interface to database.\n\nA well-balanced test suite follows the pyramid shape: many unit tests, fewer integration tests, and even fewer E2E tests. This approach optimizes for fast feedback, low maintenance costs, and comprehensive coverage. Each layer serves a specific purpose and provides different types of confidence about the software's quality.\n\nIn this lesson, you'll learn to implement each layer of the testing pyramid effectively, understand when to use different test types, and develop strategies for maintaining a healthy test suite that provides confidence without becoming a maintenance burden. You'll also explore modern testing frameworks and tools that make implementing these strategies more efficient.\n\nBy mastering the testing pyramid, you'll be able to create test suites that catch bugs early, provide rapid feedback during development, and give stakeholders confidence in the software's reliability and correctness.",
    "code": {
      "example": "// Unit test example with Jest\nfunction calculateTotal(items, taxRate = 0.1) {\n  const subtotal = items.reduce((sum, item) => sum + item.price * item.quantity, 0);\n  return subtotal * (1 + taxRate);\n}\n\ndescribe('calculateTotal', () => {\n  test('calculates total correctly with default tax', () => {\n    const items = [\n      { price: 10, quantity: 2 },  // $20\n      { price: 15, quantity: 1 }   // $15\n    ];  // Subtotal: $35, Tax: $3.50, Total: $38.50\n    \n    expect(calculateTotal(items)).toBeCloseTo(38.5);\n  });\n\n  test('calculates total with custom tax rate', () => {\n    const items = [{ price: 100, quantity: 1 }];\n    expect(calculateTotal(items, 0.05)).toBeCloseTo(105);\n  });\n\n  test('handles empty items array', () => {\n    expect(calculateTotal([])).toBeCloseTo(0);\n  });\n\n  test('handles negative quantities correctly', () => {\n    const items = [{ price: 10, quantity: -2 }];\n    expect(calculateTotal(items)).toBeCloseTo(-11); // -$20 + 10% tax = -$22\n  });\n\n  test('handles zero prices', () => {\n    const items = [{ price: 0, quantity: 5 }];\n    expect(calculateTotal(items)).toBeCloseTo(0);\n  });\n});\n\n// Integration test example with Supertest\nconst request = require('supertest');\nconst app = require('../app');\nconst db = require('../database');\n\n// Setup and teardown for integration tests\nbeforeAll(async () => {\n  await db.connect();\n});\n\nafterAll(async () => {\n  await db.close();\n});\n\ndescribe('User API Integration Tests', () => {\n  beforeEach(async () => {\n    await db.clearUsers();\n  });\n\n  describe('POST /api/users', () => {\n    test('creates a new user with valid data', async () => {\n      const userData = {\n        name: 'John Doe',\n        email: 'john@example.com',\n        password: 'securePassword123'\n      };\n\n      const response = await request(app)\n        .post('/api/users')\n        .send(userData)\n        .expect(201)\n        .expect('Content-Type', /json/);\n\n      expect(response.body).toMatchObject({\n        id: expect.any(Number),\n        name: userData.name,\n        email: userData.email\n      });\n\n      // Password should not be returned\n      expect(response.body).not.toHaveProperty('password');\n\n      // Verify user was actually saved to database\n      const savedUser = await db.findUserById(response.body.id);\n      expect(savedUser).toMatchObject({\n        name: userData.name,\n        email: userData.email\n      });\n    });\n\n    test('returns 400 for invalid email', async () => {\n      const invalidData = {\n        name: 'John Doe',\n        email: 'invalid-email',\n        password: 'securePassword123'\n      };\n\n      const response = await request(app)\n        .post('/api/users')\n        .send(invalidData)\n        .expect(400)\n        .expect('Content-Type', /json/);\n\n      expect(response.body).toHaveProperty('error');\n      expect(response.body.error).toContain('email');\n\n      // Verify no user was created\n      const users = await db.findAllUsers();\n      expect(users).toHaveLength(0);\n    });\n  });\n\n  describe('GET /api/users/:id', () => {\n    test('returns user by ID', async () => {\n      // First, create a user\n      const user = await db.createUser({\n        name: 'Test User',\n        email: 'test@example.com',\n        password: 'securePassword123'\n      });\n\n      const response = await request(app)\n        .get(`/api/users/${user.id}`)\n        .expect(200)\n        .expect('Content-Type', /json/);\n\n      expect(response.body).toMatchObject({\n        id: user.id,\n        name: user.name,\n        email: user.email\n      });\n    });\n\n    test('returns 404 for non-existent user', async () => {\n      const response = await request(app)\n        .get('/api/users/99999')\n        .expect(404)\n        .expect('Content-Type', /json/);\n\n      expect(response.body).toHaveProperty('error');\n      expect(response.body.error).toContain('not found');\n    });\n  });\n});",
      "explanation": "This example demonstrates the testing pyramid in practice with both unit and integration tests:\n\n1. **Unit Tests** (calculateTotal function):\n   - Test individual function behavior with various inputs\n   - Cover normal cases, edge cases, and boundary conditions\n   - Fast execution with no external dependencies\n   - Comprehensive assertions for different scenarios\n\n2. **Integration Tests** (User API):\n   - Test the interaction between API endpoints and database\n   - Include setup and teardown with beforeAll/afterAll hooks\n   - Test both success and error scenarios\n   - Verify data persistence in the database\n   - Check proper HTTP status codes and response formats\n\nKey concepts illustrated:\n- Test pyramid implementation with appropriate test distribution\n- Proper test structure with descriptive test names\n- Comprehensive test coverage including edge cases\n- Database integration with proper cleanup\n- HTTP status code verification\n- Security considerations (not returning passwords)\n- Error handling and validation testing",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating an inverted testing pyramid with too many E2E tests",
        "solution": "Follow the pyramid shape: lots of fast unit tests, fewer integration tests, and minimal E2E tests. This approach provides faster feedback and lower maintenance costs.",
        "severity": "high"
      },
      {
        "mistake": "Testing implementation details instead of behavior in unit tests",
        "solution": "Focus unit tests on the public interface and expected behavior rather than internal implementation details. This makes tests more resilient to refactoring.",
        "severity": "medium"
      },
      {
        "mistake": "Not properly isolating unit tests from external dependencies",
        "solution": "Use mocks, stubs, or dependency injection to isolate the unit under test. This ensures tests are fast, reliable, and focused.",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement a Balanced Test Suite for a Shopping Cart",
        "description": "Create a comprehensive test suite following the testing pyramid for a shopping cart application with products, cart operations, and checkout functionality.",
        "checkpoints": [
          "Write unit tests for core cart operations (add, remove, update quantity, calculate totals)",
          "Create integration tests for the cart API endpoints with database persistence",
          "Implement E2E tests for the complete checkout flow using a testing framework like Cypress",
          "Ensure proper test data isolation and cleanup between tests",
          "Add edge case testing for scenarios like empty carts, invalid quantities, and out-of-stock items"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 45,
    "difficulty": "Intermediate",
    "tags": [
      "Testing Pyramid",
      "Test Strategy",
      "Unit Testing",
      "Integration Testing",
      "E2E Testing"
    ],
    "lastUpdated": "2025-10-03T15:00:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "testing-fundamentals-lesson-2",
    "moduleSlug": "testing-fundamentals",
    "title": "Test Structure, Mocking, and Best Practices",
    "order": 2,
    "objectives": [
      "Structure tests using the Arrange-Act-Assert pattern for clarity and maintainability",
      "Implement effective mocking strategies to isolate units of code during testing",
      "Apply best practices for test naming, organization, and maintainability",
      "Utilize setup and teardown methods to ensure test isolation and reliability"
    ],
    "intro": "Effective unit testing requires more than just writing tests that pass; it demands a structured approach that ensures tests are maintainable, reliable, and provide meaningful feedback. The Arrange-Act-Assert (AAA) pattern is a fundamental principle that provides a clear structure for organizing test code, making tests easier to read, understand, and maintain.\n\nMocking is an essential technique for isolating the unit of code under test from its dependencies, allowing developers to focus on testing specific functionality without being affected by external factors. Proper mocking enables faster test execution, deterministic test results, and the ability to simulate various scenarios including error conditions and edge cases.\n\nTest organization and naming conventions play a crucial role in creating a maintainable test suite. Well-structured tests with descriptive names serve as documentation for the expected behavior of the code, making it easier for developers to understand what the code should do and quickly identify when behavior changes.\n\nThis lesson will explore the Arrange-Act-Assert pattern in depth, demonstrating how to structure tests for maximum clarity. You'll learn various mocking techniques using popular testing frameworks, understand when and how to use different types of test doubles (mocks, stubs, spies), and discover best practices for organizing test files and suites.\n\nBy mastering test structure, mocking, and best practices, you'll be able to create robust test suites that provide confidence in code changes, facilitate refactoring, and serve as living documentation for your applications.",
    "code": {
      "example": "// Arrange-Act-Assert pattern with proper test structure\nclass ShoppingCart {\n  constructor() {\n    this.items = [];\n  }\n  \n  addItem(item) {\n    this.items.push(item);\n  }\n  \n  calculateTotal() {\n    return this.items.reduce((total, item) => total + (item.price * item.quantity), 0);\n  }\n  \n  getItemCount() {\n    return this.items.reduce((count, item) => count + item.quantity, 0);\n  }\n  \n  removeItemByName(name) {\n    const index = this.items.findIndex(item => item.name === name);\n    if (index !== -1) {\n      return this.items.splice(index, 1)[0];\n    }\n    return null;\n  }\n  \n  clear() {\n    this.items = [];\n  }\n}\n\ndescribe('ShoppingCart', () => {\n  let cart;\n  \n  // Setup - Run before each test to ensure isolation\n  beforeEach(() => {\n    cart = new ShoppingCart();\n  });\n  \n  // Teardown - Run after each test if needed\n  afterEach(() => {\n    cart.clear();\n  });\n  \n  // Test naming should clearly describe the behavior being tested\n  test('calculates total correctly with multiple items', () => {\n    // Arrange - Set up the test scenario\n    cart.addItem({ name: 'Apple', price: 1.5, quantity: 3 });\n    cart.addItem({ name: 'Banana', price: 0.75, quantity: 2 });\n    \n    // Act - Execute the method under test\n    const total = cart.calculateTotal();\n    \n    // Assert - Verify the expected outcome\n    expect(total).toBeCloseTo(6.0); // (1.5 * 3) + (0.75 * 2) = 4.5 + 1.5 = 6.0\n  });\n  \n  test('returns correct item count when adding multiple items', () => {\n    // Arrange\n    cart.addItem({ name: 'Book', price: 20, quantity: 1 });\n    cart.addItem({ name: 'Pen', price: 2, quantity: 5 });\n    \n    // Act\n    const count = cart.getItemCount();\n    \n    // Assert\n    expect(count).toBe(6); // 1 + 5 = 6\n  });\n  \n  test('starts with zero items and zero total', () => {\n    // Act & Assert - For simple cases, Act and Assert can be combined\n    expect(cart.getItemCount()).toBe(0);\n    expect(cart.calculateTotal()).toBe(0);\n  });\n  \n  test('removes item by name and returns the removed item', () => {\n    // Arrange\n    const apple = { name: 'Apple', price: 1.5, quantity: 3 };\n    const banana = { name: 'Banana', price: 0.75, quantity: 2 };\n    cart.addItem(apple);\n    cart.addItem(banana);\n    \n    // Act\n    const removedItem = cart.removeItemByName('Apple');\n    \n    // Assert\n    expect(removedItem).toEqual(apple);\n    expect(cart.getItemCount()).toBe(2); // Only 2 bananas left\n    expect(cart.calculateTotal()).toBeCloseTo(1.5); // 0.75 * 2 = 1.5\n  });\n  \n  test('returns null when trying to remove non-existent item', () => {\n    // Arrange\n    cart.addItem({ name: 'Apple', price: 1.5, quantity: 3 });\n    \n    // Act\n    const removedItem = cart.removeItemByName('Orange');\n    \n    // Assert\n    expect(removedItem).toBeNull();\n    expect(cart.getItemCount()).toBe(3); // Apple still in cart\n  });\n});\n\n// Using mocks to isolate units of code\n// Example: Testing a user service that depends on database and email services\nconst database = require('../database');\nconst emailService = require('../emailService');\n\nclass UserService {\n  static async createUser(userData) {\n    try {\n      // Save user to database\n      const user = await database.saveUser(userData);\n      \n      // Send welcome email\n      await emailService.sendWelcomeEmail(user);\n      \n      return user;\n    } catch (error) {\n      throw new Error(`Failed to create user: ${error.message}`);\n    }\n  }\n  \n  static async getUserById(id) {\n    return await database.findUserById(id);\n  }\n}\n\n// Manual mocking approach\ndescribe('UserService with Manual Mocks', () => {\n  // Store original implementations\n  let originalSaveUser;\n  let originalSendWelcomeEmail;\n  \n  beforeEach(() => {\n    // Store original functions\n    originalSaveUser = database.saveUser;\n    originalSendWelcomeEmail = emailService.sendWelcomeEmail;\n    \n    // Clear any previous mock state\n    jest.clearAllMocks();\n  });\n  \n  afterEach(() => {\n    // Restore original implementations\n    database.saveUser = originalSaveUser;\n    emailService.sendWelcomeEmail = originalSendWelcomeEmail;\n  });\n  \n  test('sends welcome email after user creation', async () => {\n    // Arrange\n    const userData = { email: 'test@example.com', name: 'Test User' };\n    const mockUser = { id: 1, ...userData };\n    \n    // Manual mocks\n    database.saveUser = jest.fn().mockResolvedValue(mockUser);\n    emailService.sendWelcomeEmail = jest.fn().mockResolvedValue(undefined);\n    \n    // Act\n    const user = await UserService.createUser(userData);\n    \n    // Assert\n    expect(database.saveUser).toHaveBeenCalledWith(userData);\n    expect(emailService.sendWelcomeEmail).toHaveBeenCalledWith(mockUser);\n    expect(user).toEqual(mockUser);\n  });\n  \n  test('handles database errors gracefully', async () => {\n    // Arrange\n    const userData = { email: 'test@example.com', name: 'Test User' };\n    const dbError = new Error('Database connection failed');\n    \n    // Mock database to throw an error\n    database.saveUser = jest.fn().mockRejectedValue(dbError);\n    emailService.sendWelcomeEmail = jest.fn();\n    \n    // Act & Assert\n    await expect(UserService.createUser(userData)).rejects.toThrow('Failed to create user: Database connection failed');\n    expect(emailService.sendWelcomeEmail).not.toHaveBeenCalled();\n  });\n});\n\n// Using Jest's automatic mocking\ndescribe('UserService with Jest Mocks', () => {\n  beforeEach(() => {\n    // Clear all mocks before each test\n    jest.clearAllMocks();\n  });\n  \n  test('creates user and sends welcome email', async () => {\n    // Arrange\n    const userData = { email: 'test@example.com', name: 'Test User' };\n    const mockUser = { id: 1, ...userData };\n    \n    // Jest automatically creates mock functions\n    database.saveUser.mockResolvedValue(mockUser);\n    emailService.sendWelcomeEmail.mockResolvedValue(undefined);\n    \n    // Act\n    const user = await UserService.createUser(userData);\n    \n    // Assert\n    expect(database.saveUser).toHaveBeenCalledWith(userData);\n    expect(emailService.sendWelcomeEmail).toHaveBeenCalledWith(mockUser);\n    expect(user).toEqual(mockUser);\n  });\n  \n  test('does not send email if database operation fails', async () => {\n    // Arrange\n    const userData = { email: 'test@example.com', name: 'Test User' };\n    const dbError = new Error('Database connection failed');\n    \n    database.saveUser.mockRejectedValue(dbError);\n    \n    // Act & Assert\n    await expect(UserService.createUser(userData)).rejects.toThrow('Failed to create user: Database connection failed');\n    expect(database.saveUser).toHaveBeenCalledWith(userData);\n    expect(emailService.sendWelcomeEmail).not.toHaveBeenCalled();\n  });\n});",
      "explanation": "This example demonstrates comprehensive testing techniques including:\n\n1. **Arrange-Act-Assert Pattern**: Clear separation of test setup, execution, and verification\n2. **Test Naming**: Descriptive test names that clearly indicate what is being tested\n3. **Setup and Teardown**: Proper use of beforeEach/afterEach for test isolation\n4. **Edge Case Testing**: Tests for both success and failure scenarios\n5. **Manual Mocking**: Explicitly creating and managing mock functions\n6. **Framework Mocking**: Using Jest's automatic mocking capabilities\n7. **Error Handling**: Testing both successful operations and error conditions\n\nThe code shows how to structure tests for maximum clarity and maintainability while ensuring proper isolation between tests. The examples cover both simple unit tests for a ShoppingCart class and more complex integration-style tests for a UserService that depends on external services.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating tests without clear structure or naming conventions",
        "solution": "Follow the Arrange-Act-Assert pattern and use descriptive test names that clearly state what is being tested and what the expected outcome is",
        "severity": "high"
      },
      {
        "mistake": "Over-mocking or mocking inappropriate dependencies",
        "solution": "Only mock external dependencies like databases, APIs, or file systems; avoid mocking simple value objects or utility functions that don't involve I/O operations",
        "severity": "medium"
      },
      {
        "mistake": "Not properly cleaning up mocks between tests",
        "solution": "Use beforeEach/afterEach hooks to reset mocks and ensure test isolation; clear mock state to prevent tests from affecting each other",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement a Test Suite with Proper Structure and Mocking",
        "description": "Create a comprehensive test suite for a blog post management system using the Arrange-Act-Assert pattern and appropriate mocking strategies",
        "checkpoints": [
          "Structure tests using the Arrange-Act-Assert pattern with descriptive test names",
          "Implement mocking for database operations and external API calls",
          "Use beforeEach/afterEach for proper test setup and teardown",
          "Test both success and error scenarios with appropriate assertions",
          "Ensure test isolation by properly resetting mocks between tests"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Unit Testing",
      "testing"
    ],
    "legacy": {
      "originalId": 2,
      "originalTopic": "Unit Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.489Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-3",
    "moduleSlug": "testing-fundamentals",
    "title": "Advanced Mocking and Testing Asynchronous Code",
    "order": 3,
    "objectives": [
      "Master advanced mocking techniques including spies, stubs, and mock implementations",
      "Effectively test asynchronous code using promises, async/await, and callbacks",
      "Implement time-based testing with fake timers for time-dependent functionality",
      "Handle complex error scenarios and edge cases in asynchronous operations"
    ],
    "intro": "Testing asynchronous code presents unique challenges that require specialized techniques and tools. Unlike synchronous code that executes immediately and predictably, asynchronous operations involve callbacks, promises, and async/await patterns that introduce timing complexities and non-deterministic behavior.\n\nAdvanced mocking techniques are essential for testing code that interacts with external services, databases, file systems, or APIs. Spies allow you to observe how functions are called without changing their behavior, stubs replace functions with predetermined responses, and mocks provide complete control over dependencies with expectations and verifications.\n\nTime-based testing is crucial for code that depends on timers, intervals, or scheduled operations. Jest's fake timers enable you to control time in tests, making time-dependent code predictable and fast to test. This is particularly important for testing retry mechanisms, timeouts, and scheduled tasks.\n\nThis lesson will explore sophisticated mocking strategies using Jest's comprehensive mocking API, demonstrate various approaches to testing asynchronous code patterns, and show how to handle complex error scenarios. You'll learn to test promise chains, async/await functions, callback-based APIs, and time-dependent functionality.\n\nBy mastering advanced mocking and asynchronous testing, you'll be able to create comprehensive test suites that accurately simulate real-world conditions, verify complex interactions, and provide confidence in your application's behavior under various timing and error conditions.",
    "code": {
      "example": "// Advanced mocking with spies, stubs, and custom implementations\nconst database = require('../database');\nconst emailService = require('../emailService');\nconst logger = require('../logger');\n\nclass UserService {\n  static async registerUser(userData) {\n    try {\n      // Check if user already exists\n      const existingUser = await database.findUserByEmail(userData.email);\n      if (existingUser) {\n        throw new Error('User already exists');\n      }\n      \n      // Create user\n      const user = await database.createUser({\n        ...userData,\n        createdAt: new Date()\n      });\n      \n      // Send welcome email\n      await emailService.sendWelcomeEmail(user);\n      \n      // Log successful registration\n      logger.info(`User registered: ${user.email}`);\n      \n      return user;\n    } catch (error) {\n      logger.error(`Registration failed for ${userData.email}: ${error.message}`);\n      throw error;\n    }\n  }\n  \n  static async processBatchUsers(users) {\n    const results = [];\n    \n    for (const user of users) {\n      try {\n        const result = await this.registerUser(user);\n        results.push({ success: true, user: result });\n      } catch (error) {\n        results.push({ success: false, email: user.email, error: error.message });\n      }\n    }\n    \n    return results;\n  }\n}\n\n// Testing with spies to verify function calls without changing behavior\ndescribe('UserService with Spies', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  test('logs successful registration', async () => {\n    // Create a spy on the logger.info method\n    const infoSpy = jest.spyOn(logger, 'info');\n    \n    // Mock database and email service\n    database.findUserByEmail.mockResolvedValue(null);\n    database.createUser.mockResolvedValue({ id: 1, email: 'test@example.com' });\n    emailService.sendWelcomeEmail.mockResolvedValue();\n    \n    // Act\n    await UserService.registerUser({ email: 'test@example.com', name: 'Test User' });\n    \n    // Assert that logger.info was called with expected message\n    expect(infoSpy).toHaveBeenCalledWith('User registered: test@example.com');\n    \n    // Restore the original implementation\n    infoSpy.mockRestore();\n  });\n  \n  test('logs registration errors', async () => {\n    // Create spies\n    const errorSpy = jest.spyOn(logger, 'error');\n    \n    // Mock database to throw an error\n    database.findUserByEmail.mockRejectedValue(new Error('Database connection failed'));\n    \n    // Act & Assert\n    await expect(\n      UserService.registerUser({ email: 'test@example.com', name: 'Test User' })\n    ).rejects.toThrow('Database connection failed');\n    \n    // Verify error was logged\n    expect(errorSpy).toHaveBeenCalledWith(\n      'Registration failed for test@example.com: Database connection failed'\n    );\n    \n    errorSpy.mockRestore();\n  });\n});\n\n// Testing with stubs to replace function behavior\ndescribe('UserService with Stubs', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  test('handles email service failures gracefully', async () => {\n    // Stub database methods\n    database.findUserByEmail.mockResolvedValue(null);\n    database.createUser.mockResolvedValue({ id: 1, email: 'test@example.com' });\n    \n    // Stub email service to simulate failure\n    emailService.sendWelcomeEmail.mockRejectedValue(new Error('Email service unavailable'));\n    \n    // Act & Assert\n    await expect(\n      UserService.registerUser({ email: 'test@example.com', name: 'Test User' })\n    ).rejects.toThrow('Email service unavailable');\n    \n    // Verify user was created but email failed\n    expect(database.createUser).toHaveBeenCalled();\n    expect(emailService.sendWelcomeEmail).toHaveBeenCalled();\n  });\n});\n\n// Testing asynchronous code with different patterns\ndescribe('Async Testing Patterns', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  // Testing promise-based APIs\n  test('handles promise resolution with .then()', () => {\n    const mockData = { id: 1, name: 'Test' };\n    database.findUserByEmail.mockResolvedValue(mockData);\n    \n    return database.findUserByEmail('test@example.com').then(user => {\n      expect(user).toEqual(mockData);\n      expect(database.findUserByEmail).toHaveBeenCalledWith('test@example.com');\n    });\n  });\n  \n  // Testing with async/await (preferred approach)\n  test('handles async/await pattern', async () => {\n    const mockData = { id: 1, name: 'Test' };\n    database.findUserByEmail.mockResolvedValue(mockData);\n    \n    const user = await database.findUserByEmail('test@example.com');\n    \n    expect(user).toEqual(mockData);\n    expect(database.findUserByEmail).toHaveBeenCalledWith('test@example.com');\n  });\n  \n  // Testing callback-based APIs\n  test('handles callback-based APIs', (done) => {\n    const mockData = { id: 1, name: 'Test' };\n    database.findUserByEmail.mockImplementation((email, callback) => {\n      callback(null, mockData);\n    });\n    \n    database.findUserByEmail('test@example.com', (error, user) => {\n      try {\n        expect(error).toBeNull();\n        expect(user).toEqual(mockData);\n        done();\n      } catch (testError) {\n        done(testError);\n      }\n    });\n  });\n  \n  // Testing promise rejection\n  test('handles promise rejection', async () => {\n    const errorMessage = 'User not found';\n    database.findUserByEmail.mockRejectedValue(new Error(errorMessage));\n    \n    await expect(database.findUserByEmail('nonexistent@example.com'))\n      .rejects.toThrow(errorMessage);\n  });\n  \n  // Testing callback errors\n  test('handles callback errors', (done) => {\n    const errorMessage = 'Database error';\n    database.findUserByEmail.mockImplementation((email, callback) => {\n      callback(new Error(errorMessage));\n    });\n    \n    database.findUserByEmail('test@example.com', (error, user) => {\n      try {\n        expect(error).toBeInstanceOf(Error);\n        expect(error.message).toBe(errorMessage);\n        expect(user).toBeUndefined();\n        done();\n      } catch (testError) {\n        done(testError);\n      }\n    });\n  });\n});\n\n// Time-based testing with fake timers\ndescribe('Time-based Testing', () => {\n  // Enable fake timers for this test suite\n  jest.useFakeTimers();\n  \n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  afterEach(() => {\n    // Reset to real timers after each test\n    jest.useRealTimers();\n  });\n  \n  test('retries failed operations with exponential backoff', async () => {\n    // Mock function that fails initially then succeeds\n    const mockOperation = jest.fn()\n      .mockRejectedValueOnce(new Error('First attempt failed'))\n      .mockRejectedValueOnce(new Error('Second attempt failed'))\n      .mockResolvedValue('Success!');\n    \n    // Function with retry logic\n    async function retryOperation(operation, maxRetries = 3, delay = 1000) {\n      for (let i = 0; i < maxRetries; i++) {\n        try {\n          return await operation();\n        } catch (error) {\n          if (i === maxRetries - 1) throw error;\n          \n          // Wait before retrying (exponential backoff)\n          await new Promise(resolve => setTimeout(resolve, delay * Math.pow(2, i)));\n        }\n      }\n    }\n    \n    // Act\n    const resultPromise = retryOperation(mockOperation);\n    \n    // Fast-forward time to execute all retries\n    jest.advanceTimersByTime(3000); // Advance by 3 seconds\n    \n    // Wait for the promise to resolve\n    const result = await resultPromise;\n    \n    // Assert\n    expect(result).toBe('Success!');\n    expect(mockOperation).toHaveBeenCalledTimes(3);\n  });\n  \n  test('handles timeout scenarios', async () => {\n    // Mock a long-running operation\n    const longRunningOperation = () => new Promise(resolve => {\n      setTimeout(() => resolve('Done'), 5000);\n    });\n    \n    // Function with timeout\n    async function withTimeout(operation, timeoutMs) {\n      return Promise.race([\n        operation(),\n        new Promise((_, reject) => \n          setTimeout(() => reject(new Error('Operation timed out')), timeoutMs)\n        )\n      ]);\n    }\n    \n    // Act & Assert\n    const operationPromise = withTimeout(longRunningOperation, 2000);\n    \n    // Advance time past the timeout\n    jest.advanceTimersByTime(3000);\n    \n    await expect(operationPromise).rejects.toThrow('Operation timed out');\n  });\n});\n\n// Testing complex error scenarios\ndescribe('Complex Error Scenarios', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n  \n  test('handles partial batch processing failures', async () => {\n    // Mock database to succeed for first user, fail for second\n    database.findUserByEmail\n      .mockResolvedValueOnce(null)  // First user doesn't exist\n      .mockResolvedValueOnce(null)  // Second user doesn't exist\n      .mockResolvedValueOnce({ id: 1, email: 'existing@example.com' });  // Third user exists\n      \n    database.createUser\n      .mockResolvedValueOnce({ id: 2, email: 'user1@example.com' })  // First user created\n      .mockRejectedValueOnce(new Error('Database full'));  // Second user fails\n      \n    emailService.sendWelcomeEmail\n      .mockResolvedValue()  // First email succeeds\n      .mockResolvedValue();  // Second would succeed if reached\n      \n    const users = [\n      { email: 'user1@example.com', name: 'User 1' },\n      { email: 'user2@example.com', name: 'User 2' },\n      { email: 'existing@example.com', name: 'Existing User' }\n    ];\n    \n    const results = await UserService.processBatchUsers(users);\n    \n    expect(results).toEqual([\n      { success: true, user: { id: 2, email: 'user1@example.com' } },\n      { success: false, email: 'user2@example.com', error: 'Database full' },\n      { success: false, email: 'existing@example.com', error: 'User already exists' }\n    ]);\n    \n    // Verify database calls\n    expect(database.findUserByEmail).toHaveBeenCalledTimes(3);\n    expect(database.createUser).toHaveBeenCalledTimes(1);\n    expect(emailService.sendWelcomeEmail).toHaveBeenCalledTimes(1);\n  });\n});",
      "explanation": "This example demonstrates advanced testing techniques for asynchronous code and mocking:\n\n1. **Spies**: Observing function calls without changing behavior (logger.info, logger.error)\n2. **Stubs**: Replacing function implementations with predetermined responses\n3. **Promise Testing**: Multiple approaches including .then(), async/await, and .rejects\n4. **Callback Testing**: Handling callback-based APIs with proper error handling\n5. **Time-based Testing**: Using fake timers to test retry mechanisms and timeouts\n6. **Complex Error Scenarios**: Testing partial failures in batch operations\n\nThe code shows how to:\n- Create and use spies to verify logging behavior\n- Stub external services to simulate different scenarios\n- Test various asynchronous patterns effectively\n- Use fake timers for time-dependent functionality\n- Handle complex error cases in batch processing\n- Verify the exact number of calls to mocked functions\n\nThese techniques ensure comprehensive test coverage for real-world asynchronous scenarios.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not properly cleaning up spies, which can cause tests to affect each other",
        "solution": "Always call mockRestore() on spies or use jest.restoreAllMocks() in afterEach hooks to ensure test isolation",
        "severity": "high"
      },
      {
        "mistake": "Forgetting to advance fake timers when testing time-dependent code",
        "solution": "Use jest.advanceTimersByTime() or jest.runAllTimers() to execute scheduled callbacks in tests",
        "severity": "high"
      },
      {
        "mistake": "Not handling promise rejections properly in tests",
        "solution": "Always use expect().rejects or try/catch with async/await when testing error scenarios",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement Advanced Mocking for a Notification Service",
        "description": "Create comprehensive tests for a notification service using spies, stubs, and mocks to handle various delivery mechanisms",
        "checkpoints": [
          "Use spies to verify logging behavior without changing logger implementation",
          "Stub external APIs to simulate successful and failed delivery scenarios",
          "Test retry mechanisms with exponential backoff using fake timers",
          "Handle partial failures in batch notification processing",
          "Verify proper cleanup of spies and mocks between tests"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Advanced Mocking",
      "Async Testing",
      "Time-based Testing",
      "Error Handling"
    ],
    "legacy": {
      "originalId": 3,
      "originalTopic": "Unit Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-03T16:00:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "testing-fundamentals-lesson-4",
    "moduleSlug": "testing-fundamentals",
    "title": "API Testing and Database Integration Tests",
    "order": 4,
    "objectives": [
      "Design and implement comprehensive API integration tests with proper setup and teardown",
      "Test database interactions including CRUD operations and complex queries",
      "Handle test data isolation and cleanup to ensure reliable test execution",
      "Verify HTTP status codes, response formats, and error handling in API endpoints"
    ],
    "intro": "API testing and database integration testing are critical for ensuring that different components of your application work together correctly. These tests verify that your API endpoints handle requests properly, your database operations execute as expected, and data flows correctly between layers.\n\nEffective API testing requires understanding HTTP protocols, status codes, request/response formats, and authentication mechanisms. You'll learn to test various HTTP methods (GET, POST, PUT, DELETE), validate response structures, and handle authentication and authorization scenarios.\n\nDatabase integration testing ensures that your application correctly interacts with the database, including creating, reading, updating, and deleting records. Proper test data management is essential to maintain test isolation and prevent tests from affecting each other.\n\nSetup and teardown strategies are crucial for reliable integration tests. You'll learn to initialize test databases, seed test data, clean up after tests, and handle transactions to ensure each test runs in a consistent environment.\n\nThis lesson will cover REST API testing with tools like Supertest, database testing with actual database connections, and strategies for managing test data lifecycle. You'll understand how to test edge cases, error conditions, and performance considerations in integrated environments.\n\nBy mastering API and database integration testing, you'll be able to verify that your application components work together seamlessly, catch integration issues early, and ensure data integrity across your system.",
    "code": {
      "example": "// Comprehensive API and Database Integration Testing\nconst request = require('supertest');\nconst app = require('../app');\nconst db = require('../database');\nconst { setupTestDatabase, clearTestDatabase } = require('../test-utils');\n\n// Product model for testing\nconst Product = {\n  async create(productData) {\n    return await db.query(\n      'INSERT INTO products (name, price, category, description) VALUES (?, ?, ?, ?)',\n      [productData.name, productData.price, productData.category, productData.description]\n    );\n  },\n  \n  async findById(id) {\n    const results = await db.query('SELECT * FROM products WHERE id = ?', [id]);\n    return results[0] || null;\n  },\n  \n  async findByCategory(category) {\n    return await db.query('SELECT * FROM products WHERE category = ?', [category]);\n  },\n  \n  async update(id, updateData) {\n    const fields = Object.keys(updateData);\n    const values = Object.values(updateData);\n    const setClause = fields.map(field => `${field} = ?`).join(', ');\n    \n    return await db.query(\n      `UPDATE products SET ${setClause} WHERE id = ?`,\n      [...values, id]\n    );\n  }\n  \n  async delete(id) {\n    return await db.query('DELETE FROM products WHERE id = ?', [id]);\n  }\n};\n\n// Setup and teardown for integration tests\ndescribe('Product API Integration Tests', () => {\n  // Setup database before all tests\n  beforeAll(async () => {\n    await setupTestDatabase();\n  });\n  \n  // Clean up database after all tests\n  afterAll(async () => {\n    await clearTestDatabase();\n  });\n  \n  // Clear test data before each test\n  beforeEach(async () => {\n    await db.query('DELETE FROM products');\n  });\n  \n  describe('POST /api/products', () => {\n    test('creates a new product with valid data', async () => {\n      // Arrange\n      const productData = {\n        name: 'Laptop',\n        price: 999.99,\n        category: 'Electronics',\n        description: 'High-performance laptop'\n      };\n      \n      // Act\n      const response = await request(app)\n        .post('/api/products')\n        .send(productData)\n        .expect(201)\n        .expect('Content-Type', /json/);\n      \n      // Assert\n      expect(response.body).toMatchObject({\n        id: expect.any(Number),\n        name: productData.name,\n        price: productData.price,\n        category: productData.category,\n        description: productData.description,\n        createdAt: expect.any(String)\n      });\n      \n      // Verify product was actually saved to database\n      const savedProduct = await Product.findById(response.body.id);\n      expect(savedProduct).toMatchObject({\n        name: productData.name,\n        price: productData.price,\n        category: productData.category\n      });\n    });\n    \n    test('returns 400 for invalid product data', async () => {\n      // Arrange\n      const invalidData = {\n        name: 'Laptop',\n        // Missing required price field\n        category: 'Electronics'\n      };\n      \n      // Act\n      const response = await request(app)\n        .post('/api/products')\n        .send(invalidData)\n        .expect(400)\n        .expect('Content-Type', /json/);\n      \n      // Assert\n      expect(response.body).toHaveProperty('error');\n      expect(response.body.error).toContain('price');\n      \n      // Verify no product was created\n      const products = await db.query('SELECT * FROM products');\n      expect(products).toHaveLength(0);\n    });\n    \n    test('returns 409 for duplicate product names', async () => {\n      // Arrange - Create a product first\n      await Product.create({\n        name: 'Unique Laptop',\n        price: 999.99,\n        category: 'Electronics'\n      });\n      \n      // Try to create another product with same name\n      const duplicateData = {\n        name: 'Unique Laptop',\n        price: 1299.99,\n        category: 'Electronics'\n      };\n      \n      // Act\n      const response = await request(app)\n        .post('/api/products')\n        .send(duplicateData)\n        .expect(409)\n        .expect('Content-Type', /json/);\n      \n      // Assert\n      expect(response.body).toHaveProperty('error', 'Product name already exists');\n    });\n  });\n  \n  describe('GET /api/products', () => {\n    test('retrieves all products with pagination', async () => {\n      // Arrange - Create multiple products\n      await Product.create({ name: 'Laptop 1', price: 999.99, category: 'Electronics' });\n      await Product.create({ name: 'Laptop 2', price: 1299.99, category: 'Electronics' });\n      await Product.create({ name: 'Phone', price: 699.99, category: 'Electronics' });\n      \n      // Act\n      const response = await request(app)\n        .get('/api/products?page=1&limit=2')\n        .expect(200)\n        .expect('Content-Type', /json/);\n      \n      // Assert\n      expect(response.body).toMatchObject({\n        products: expect.any(Array),\n        pagination: {\n          page: 1,\n          limit: 2,\n          total: 3,\n          pages: 2\n        }\n      });\n      \n      expect(response.body.products).toHaveLength(2);\n      expect(response.body.products[0]).toHaveProperty('name');\n      expect(response.body.products[0]).toHaveProperty('price');\n    });\n    \n    test('filters products by category', async () => {\n      // Arrange\n      await Product.create({ name: 'Laptop', price: 999.99, category: 'Electronics' });\n      await Product.create({ name: 'Book', price: 29.99, category: 'Education' });\n      await Product.create({ name: 'Phone', price: 699.99, category: 'Electronics' });\n      \n      // Act\n      const response = await request(app)\n        .get('/api/products?category=Electronics')\n        .expect(200)\n        .expect('Content-Type', /json/);\n      \n      // Assert\n      expect(response.body.products).toHaveLength(2);\n      response.body.products.forEach(product => {\n        expect(product.category).toBe('Electronics');\n      });\n    });\n  });\n  \n  describe('GET /api/products/:id', () => {\n    test('retrieves a specific product by ID', async () => {\n      // Arrange\n      const createdProduct = await Product.create({\n        name: 'Test Product',\n        price: 49.99,\n        category: 'Test',\n        description: 'A test product'\n      });\n      \n      // Act\n      const response = await request(app)\n        .get(`/api/products/${createdProduct.insertId}`)\n        .expect(200)\n        .expect('Content-Type', /json/);\n      \n      // Assert\n      expect(response.body).toMatchObject({\n        id: createdProduct.insertId,\n        name: 'Test Product',\n        price: 49.99,\n        category: 'Test',\n        description: 'A test product'\n      });\n    });\n    \n    test('returns 404 for non-existent product', async () => {\n      // Act & Assert\n      await request(app)\n        .get('/api/products/99999')\n        .expect(404)\n        .expect('Content-Type', /json/);\n    });\n    \n    test('returns 400 for invalid product ID format', async () => {\n      // Act & Assert\n      await request(app)\n        .get('/api/products/invalid-id')\n        .expect(400)\n        .expect('Content-Type', /json/);\n    });\n  });\n  \n  describe('PUT /api/products/:id', () => {\n    test('updates an existing product', async () => {\n      // Arrange\n      const createdProduct = await Product.create({\n        name: 'Old Product',\n        price: 99.99,\n        category: 'Old'\n      });\n      \n      const updateData = {\n        name: 'Updated Product',\n        price: 199.99,\n        category: 'Updated'\n      };\n      \n      // Act\n      const response = await request(app)\n        .put(`/api/products/${createdProduct.insertId}`)\n        .send(updateData)\n        .expect(200)\n        .expect('Content-Type', /json/);\n      \n      // Assert\n      expect(response.body).toMatchObject({\n        id: createdProduct.insertId,\n        name: 'Updated Product',\n        price: 199.99,\n        category: 'Updated'\n      });\n      \n      // Verify update was persisted\n      const updatedProduct = await Product.findById(createdProduct.insertId);\n      expect(updatedProduct).toMatchObject(updateData);\n    });\n    \n    test('returns 404 when updating non-existent product', async () => {\n      // Act & Assert\n      await request(app)\n        .put('/api/products/99999')\n        .send({ name: 'Test', price: 99.99 })\n        .expect(404);\n    });\n  });\n  \n  describe('DELETE /api/products/:id', () => {\n    test('deletes an existing product', async () => {\n      // Arrange\n      const createdProduct = await Product.create({\n        name: 'Product to Delete',\n        price: 49.99,\n        category: 'Test'\n      });\n      \n      // Act\n      await request(app)\n        .delete(`/api/products/${createdProduct.insertId}`)\n        .expect(204);\n      \n      // Assert\n      const deletedProduct = await Product.findById(createdProduct.insertId);\n      expect(deletedProduct).toBeNull();\n    });\n    \n    test('returns 404 when deleting non-existent product', async () => {\n      // Act & Assert\n      await request(app)\n        .delete('/api/products/99999')\n        .expect(404);\n    });\n  });\n});\n\n// Database transaction testing\ndescribe('Database Transaction Tests', () => {\n  beforeEach(async () => {\n    await db.query('DELETE FROM products');\n    await db.query('DELETE FROM orders');\n  });\n  \n  test('maintains data consistency during failed transactions', async () => {\n    // This test would verify that if an operation in a transaction fails,\n    // all changes are rolled back, maintaining database consistency\n    \n    // Example: Creating an order with multiple products where one fails\n    // The entire transaction should be rolled back\n    \n    // Implementation would depend on your specific database transaction handling\n    expect(true).toBe(true); // Placeholder assertion\n  });\n  \n  test('handles concurrent database operations', async () => {\n    // Test concurrent access to ensure proper locking and isolation\n    \n    // This might involve simulating multiple simultaneous requests\n    // and verifying that data integrity is maintained\n    \n    expect(true).toBe(true); // Placeholder assertion\n  });\n});\n\n// Error handling and edge case testing\ndescribe('API Error Handling Tests', () => {\n  test('handles database connection errors gracefully', async () => {\n    // This would involve mocking database connection failures\n    // and verifying that the API returns appropriate error responses\n    \n    expect(true).toBe(true); // Placeholder assertion\n  });\n  \n  test('handles malformed JSON in request bodies', async () => {\n    // Test API behavior when clients send invalid JSON\n    \n    const response = await request(app)\n      .post('/api/products')\n      .set('Content-Type', 'application/json')\n      .send('{ invalid json }')\n      .expect(400);\n      \n    expect(response.body).toHaveProperty('error');\n  });\n  \n  test('enforces rate limiting', async () => {\n    // Test that the API properly limits requests\n    \n    // This would involve making multiple rapid requests\n    // and verifying that some are rejected with 429 status\n    \n    expect(true).toBe(true); // Placeholder assertion\n  });\n});",
      "explanation": "This example demonstrates comprehensive API and database integration testing:\n\n1. **Complete CRUD Testing**: Tests for all HTTP methods (POST, GET, PUT, DELETE)\n2. **Proper Test Structure**: Uses beforeAll, afterAll, and beforeEach for setup/teardown\n3. **Data Isolation**: Clears test data between tests to ensure independence\n4. **Validation Testing**: Tests both valid inputs and various error conditions\n5. **Response Verification**: Checks HTTP status codes, headers, and response bodies\n6. **Database Verification**: Confirms that API operations actually affect the database\n7. **Edge Case Testing**: Tests pagination, filtering, and error scenarios\n8. **Error Handling**: Tests various error conditions and HTTP status codes\n\nThe code shows how to:\n- Structure integration tests with proper setup and teardown\n- Test all CRUD operations with appropriate assertions\n- Handle test data isolation and cleanup\n- Verify both successful operations and error conditions\n- Test API endpoints with various query parameters\n- Validate response formats and data integrity\n- Test edge cases like invalid IDs and duplicate data\n\nThese patterns ensure that your API and database work together correctly and handle all expected scenarios.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not properly isolating test data, causing tests to affect each other",
        "solution": "Use beforeEach hooks to clear test data and ensure each test starts with a clean state",
        "severity": "high"
      },
      {
        "mistake": "Testing implementation details instead of API behavior",
        "solution": "Focus on testing HTTP endpoints as users would interact with them, not internal implementation details",
        "severity": "medium"
      },
      {
        "mistake": "Not verifying that database changes actually occurred",
        "solution": "Always check that API operations result in the expected database changes, not just HTTP responses",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement Comprehensive Integration Tests for a Blog API",
        "description": "Create a full suite of integration tests for a blog API including posts, comments, and user authentication",
        "checkpoints": [
          "Implement setup and teardown with proper database initialization",
          "Test all CRUD operations for blog posts with validation",
          "Test comment functionality including nested replies",
          "Implement authentication tests for user registration and login",
          "Test error handling for various failure scenarios",
          "Verify data integrity between API responses and database state"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 35,
    "difficulty": "Advanced",
    "tags": [
      "API Testing",
      "Database Testing",
      "Integration Testing",
      "Supertest"
    ],
    "legacy": {
      "originalId": 4,
      "originalTopic": "Integration Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-03T16:00:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "testing-fundamentals-lesson-5",
    "moduleSlug": "testing-fundamentals",
    "title": "Cypress Advanced Patterns and Best Practices",
    "order": 5,
    "objectives": [
      "Implement advanced Cypress patterns including custom commands and page objects",
      "Master best practices for reliable, maintainable end-to-end tests",
      "Utilize Cypress's powerful features like intercept, clock, and fixture management",
      "Apply proper test organization and data management strategies"
    ],
    "intro": "Cypress is a powerful end-to-end testing framework that provides developers with the tools to write reliable, fast, and maintainable tests for modern web applications. While basic Cypress tests can cover simple scenarios, advanced patterns and best practices are essential for creating robust test suites that scale with your application.\n\nCustom commands allow you to encapsulate common actions and assertions into reusable functions, reducing code duplication and improving test readability. Page objects provide a structured approach to modeling your application's UI, making tests more maintainable and less brittle when UI elements change.\n\nCypress's intercept feature enables powerful network request mocking and response manipulation, allowing you to test various scenarios including error conditions, loading states, and edge cases without relying on actual backend services. Time manipulation with cy.clock() enables testing of time-dependent functionality like timers, intervals, and scheduled events.\n\nProper test organization, data management, and cleanup strategies are crucial for maintaining reliable test suites. You'll learn to structure tests effectively, manage test data lifecycle, and implement proper cleanup to ensure test isolation.\n\nThis lesson will explore advanced Cypress patterns including custom commands, page objects, network interception, time manipulation, and fixture management. You'll understand how to create maintainable test suites that provide confidence in your application's behavior while remaining fast and reliable.\n\nBy mastering Cypress advanced patterns and best practices, you'll be able to create comprehensive end-to-end tests that simulate real user interactions, handle complex scenarios, and provide valuable feedback throughout your development process.",
    "code": {
      "example": "// Advanced Cypress patterns with custom commands and page objects\n\ndescribe('E-Commerce Application Tests', () => {\n  beforeEach(() => {\n    // Reset database and seed test data before each test\n    cy.task('seedDatabase');\n    cy.visit('/');\n  });\n  \n  afterEach(() => {\n    // Take screenshot on test failure for debugging\n    if (Cypress.currentTest.state === 'failed') {\n      cy.screenshot(`failure-${Cypress.currentTest.title}`);\n    }\n  });\n  \n  it('allows users to complete a purchase flow', () => {\n    // Using custom commands for common actions\n    cy.login('user@example.com', 'password123');\n    \n    // Navigate to products page\n    cy.get('[data-cy=nav-products]').click();\n    \n    // Search for a product\n    cy.searchProduct('laptop');\n    \n    // Add product to cart\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    \n    // Go to cart\n    cy.get('[data-cy=cart-link]').click();\n    \n    // Verify cart contents\n    cy.get('[data-cy=cart-items]').should('have.length', 1);\n    cy.get('[data-cy=cart-total]').should('contain', '$999.99');\n    \n    // Proceed to checkout\n    cy.get('[data-cy=checkout-button]').click();\n    \n    // Fill shipping information using page object\n    const checkoutPage = new CheckoutPage();\n    checkoutPage.fillShippingInfo({\n      firstName: 'John',\n      lastName: 'Doe',\n      address: '123 Main St',\n      city: 'New York',\n      zipCode: '10001'\n    });\n    \n    // Confirm order\n    cy.get('[data-cy=order-summary]').should('be.visible');\n    cy.get('[data-cy=confirm-order]').click();\n    \n    // Verify success message\n    cy.get('[data-cy=order-success]').should('contain', 'Order placed successfully');\n    cy.get('[data-cy=order-number]').should('contain', 'ORD-');\n  });\n  \n  it('shows error for invalid coupon code', () => {\n    cy.login('user@example.com', 'password123');\n    \n    // Add item to cart\n    cy.get('[data-cy=nav-products]').click();\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    \n    // Go to cart\n    cy.get('[data-cy=cart-link]').click();\n    \n    // Apply invalid coupon using custom command\n    cy.applyCoupon('INVALID');\n    \n    // Verify error message\n    cy.get('[data-cy=coupon-error]').should('be.visible')\n      .and('contain', 'Invalid coupon code');\n  });\n  \n  it('handles network errors gracefully', () => {\n    // Intercept API calls and simulate network failure\n    cy.intercept('POST', '/api/checkout', {\n      statusCode: 500,\n      body: { error: 'Internal server error' }\n    }).as('checkoutRequest');\n    \n    cy.login('user@example.com', 'password123');\n    \n    // Add item to cart and proceed to checkout\n    cy.get('[data-cy=nav-products]').click();\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    cy.get('[data-cy=cart-link]').click();\n    cy.get('[data-cy=checkout-button]').click();\n    \n    // Fill shipping information\n    const checkoutPage = new CheckoutPage();\n    checkoutPage.fillShippingInfo({\n      firstName: 'John',\n      lastName: 'Doe',\n      address: '123 Main St',\n      city: 'New York',\n      zipCode: '10001'\n    });\n    \n    // Confirm order (will fail due to network error)\n    cy.get('[data-cy=confirm-order]').click();\n    \n    // Verify error handling\n    cy.get('[data-cy=error-message]').should('be.visible')\n      .and('contain', 'Unable to process your order');\n  });\n});\n\n// Page Object pattern for Checkout page\nclass CheckoutPage {\n  constructor() {\n    this.elements = {\n      firstName: () => cy.get('[data-cy=first-name]'),\n      lastName: () => cy.get('[data-cy=last-name]'),\n      address: () => cy.get('[data-cy=address]'),\n      city: () => cy.get('[data-cy=city]'),\n      zipCode: () => cy.get('[data-cy=zip-code]'),\n      submitButton: () => cy.get('[data-cy=submit]')\n    };\n  }\n  \n  fillShippingInfo(shippingData) {\n    this.elements.firstName().type(shippingData.firstName);\n    this.elements.lastName().type(shippingData.lastName);\n    this.elements.address().type(shippingData.address);\n    this.elements.city().type(shippingData.city);\n    this.elements.zipCode().type(shippingData.zipCode);\n    this.elements.submitButton().click();\n    return this;\n  }\n  \n  fillPaymentInfo(paymentData) {\n    // Implementation for payment form\n    return this;\n  }\n}\n\n// Custom Cypress commands (in cypress/support/commands.js)\nCypress.Commands.add('login', (email, password) => {\n  cy.visit('/login');\n  cy.get('[data-cy=email]').type(email);\n  cy.get('[data-cy=password]').type(password);\n  cy.get('[data-cy=submit]').click();\n  cy.get('[data-cy=dashboard]').should('be.visible');\n});\n\nCypress.Commands.add('searchProduct', (searchTerm) => {\n  cy.get('[data-cy=search-input]').type(searchTerm);\n  cy.get('[data-cy=search-button]').click();\n});\n\nCypress.Commands.add('applyCoupon', (couponCode) => {\n  cy.get('[data-cy=coupon-input]').type(couponCode);\n  cy.get('[data-cy=apply-coupon]').click();\n});\n\n// Custom tasks for database operations (in cypress/plugins/index.js)\nmodule.exports = (on, config) => {\n  on('task', {\n    seedDatabase() {\n      // Reset database and insert test data\n      // Implementation would depend on your specific database setup\n      console.log('Seeding test database');\n      return null;\n    },\n    \n    resetDatabase() {\n      // Clear all data\n      console.log('Resetting database');\n      return null;\n    },\n    \n    queryDatabase(query, params = []) {\n      // Execute database query and return results\n      // This would connect to your test database\n      console.log('Executing database query:', query);\n      return [];\n    }\n  });\n};\n\n// Advanced network interception examples\ndescribe('Network Interception Tests', () => {\n  it('tests loading states with delayed responses', () => {\n    // Intercept and delay the response\n    cy.intercept('/api/products', (req) => {\n      req.reply((res) => {\n        res.delay(2000); // Delay response by 2 seconds\n      });\n    }).as('getProducts');\n    \n    cy.visit('/products');\n    \n    // Verify loading state is shown\n    cy.get('[data-cy=loading-spinner]').should('be.visible');\n    \n    // Wait for response and verify content loads\n    cy.wait('@getProducts');\n    cy.get('[data-cy=product-list]').should('be.visible');\n    cy.get('[data-cy=loading-spinner]').should('not.exist');\n  });\n  \n  it('tests error handling with network failures', () => {\n    // Intercept and force network error\n    cy.intercept('/api/products', { forceNetworkError: true }).as('failedRequest');\n    \n    cy.visit('/products');\n    \n    // Verify error message is displayed\n    cy.wait('@failedRequest');\n    cy.get('[data-cy=error-message]').should('contain', 'Failed to load products');\n    cy.get('[data-cy=retry-button]').should('be.visible');\n  });\n  \n  it('tests different response scenarios', () => {\n    // Test with empty response\n    cy.intercept('GET', '/api/products', []).as('emptyProducts');\n    \n    cy.visit('/products');\n    cy.wait('@emptyProducts');\n    cy.get('[data-cy=empty-state]').should('be.visible');\n    \n    // Test with error response\n    cy.intercept('GET', '/api/products', {\n      statusCode: 500,\n      body: { error: 'Server error' }\n    }).as('serverError');\n    \n    cy.reload();\n    cy.wait('@serverError');\n    cy.get('[data-cy=error-message]').should('contain', 'Server error');\n  });\n});\n\n// Time manipulation tests\ndescribe('Time-based Functionality Tests', () => {\n  it('tests auto-logout functionality', () => {\n    // Freeze time\n    cy.clock();\n    \n    cy.login('user@example.com', 'password123');\n    \n    // Advance time by 30 minutes (assuming 30-minute timeout)\n    cy.tick(30 * 60 * 1000);\n    \n    // Verify user is logged out\n    cy.get('[data-cy=login-form]').should('be.visible');\n    cy.get('[data-cy=toast-message]').should('contain', 'Session expired');\n  });\n  \n  it('tests countdown timers', () => {\n    cy.visit('/auction/123');\n    \n    // Freeze time at a specific point\n    const now = new Date(2023, 0, 1, 12, 0, 0);\n    cy.clock(now);\n    \n    // Advance time and verify countdown updates\n    cy.get('[data-cy=countdown]').should('contain', '24:00:00');\n    \n    cy.tick(5 * 60 * 1000); // Advance 5 minutes\n    cy.get('[data-cy=countdown]').should('contain', '23:55:00');\n  });\n});\n\n// Fixture management examples\ndescribe('Fixture-based Tests', () => {\n  it('loads user data from fixture', () => {\n    // Load user data from fixture file\n    cy.fixture('users/admin.json').then((adminUser) => {\n      cy.login(adminUser.email, adminUser.password);\n      cy.get('[data-cy=user-name]').should('contain', adminUser.name);\n    });\n  });\n  \n  it('tests with dynamic fixture data', () => {\n    // Generate dynamic test data\n    const testData = {\n      productName: `Test Product ${Date.now()}`,\n      price: Math.floor(Math.random() * 100) + 1\n    };\n    \n    // Create product via API\n    cy.request('POST', '/api/products', testData);\n    \n    // Verify product appears in UI\n    cy.visit('/products');\n    cy.contains(testData.productName).should('be.visible');\n  });\n});",
      "explanation": "This example demonstrates advanced Cypress testing patterns:\n\n1. **Custom Commands**: Reusable functions for common actions like login and search\n2. **Page Objects**: Structured approach to modeling UI elements and interactions\n3. **Network Interception**: Mocking API responses, simulating delays and errors\n4. **Time Manipulation**: Controlling time to test time-dependent functionality\n5. **Fixture Management**: Loading test data from external files\n6. **Custom Tasks**: Extending Cypress with Node.js operations\n7. **Error Handling**: Testing various error scenarios and edge cases\n\nThe code shows how to:\n- Structure end-to-end tests with proper setup and teardown\n- Use page objects to model complex UI interactions\n- Implement custom commands for reusable test actions\n- Intercept and manipulate network requests\n- Control time for testing timers and session timeouts\n- Manage test data with fixtures and dynamic generation\n- Handle various error conditions and loading states\n\nThese patterns create maintainable, reliable end-to-end tests that provide confidence in your application's behavior.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating overly complex page objects that are difficult to maintain",
        "solution": "Keep page objects focused on specific pages or components, and avoid deep nesting or overly complex abstractions",
        "severity": "medium"
      },
      {
        "mistake": "Not properly cleaning up interceptors between tests",
        "solution": "Use aliases and proper teardown to ensure network interceptors don't leak between tests",
        "severity": "high"
      },
      {
        "mistake": "Overusing custom commands for simple actions",
        "solution": "Reserve custom commands for complex, frequently used actions; simple actions should be explicit in tests",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Advanced Cypress Tests for a Social Media Platform",
        "description": "Create comprehensive end-to-end tests for a social media application using advanced Cypress patterns",
        "checkpoints": [
          "Implement page objects for key application pages (feed, profile, settings)",
          "Create custom commands for common user actions (posting, commenting, liking)",
          "Test network error handling with intercept for API failures",
          "Implement time-based tests for features like story expiration",
          "Use fixtures to manage test user data and content",
          "Test authentication flows including session timeout"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 35,
    "difficulty": "Advanced",
    "tags": [
      "Cypress",
      "End-to-End Testing",
      "Page Objects",
      "Custom Commands"
    ],
    "legacy": {
      "originalId": 5,
      "originalTopic": "End-to-End Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-03T16:00:00.000Z",
    "version": "1.1.0"
  },

      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on End-to-End Testing.\n\nLearn advanced Cypress patterns, custom commands, and best practices for robust end-to-end testing of web applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Cypress E2E test with custom commands and advanced patterns\ndescribe('E-Commerce Application', () => {\n  beforeEach(() => {\n    // Custom command to reset database and seed test data\n    cy.task('seedDatabase');\n    cy.visit('/');\n  });\n  \n  afterEach(() => {\n    // Take screenshot on test failure\n    if (this.currentTest.state === 'failed') {\n      cy.screenshot(`failure-${this.currentTest.title}`);\n    }\n  });\n  \n  it('allows users to complete a purchase flow', () => {\n    // Custom command for login\n    cy.login('user@example.com', 'password123');\n    \n    // Navigate to products page\n    cy.get('[data-cy=nav-products]').click();\n    \n    // Search for a product\n    cy.get('[data-cy=search-input]').type('laptop');\n    cy.get('[data-cy=search-button]').click();\n    \n    // Add product to cart\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    \n    // Go to cart\n    cy.get('[data-cy=cart-link]').click();\n    \n    // Verify cart contents\n    cy.get('[data-cy=cart-items]').should('have.length', 1);\n    cy.get('[data-cy=cart-total]').should('contain', '$999.99');\n    \n    // Proceed to checkout\n    cy.get('[data-cy=checkout-button]').click();\n    \n    // Fill shipping information\n    cy.get('[data-cy=shipping-form]').within(() => {\n      cy.get('[data-cy=first-name]').type('John');\n      cy.get('[data-cy=last-name]').type('Doe');\n      cy.get('[data-cy=address]').type('123 Main St');\n      cy.get('[data-cy=city]').type('New York');\n      cy.get('[data-cy=zip-code]').type('10001');\n      cy.get('[data-cy=submit]').click();\n    });\n    \n    // Confirm order\n    cy.get('[data-cy=order-summary]').should('be.visible');\n    cy.get('[data-cy=confirm-order]').click();\n    \n    // Verify success message\n    cy.get('[data-cy=order-success]').should('contain', 'Order placed successfully');\n    cy.get('[data-cy=order-number]').should('contain', 'ORD-');\n  });\n  \n  it('shows error for invalid coupon code', () => {\n    cy.login('user@example.com', 'password123');\n    \n    // Add item to cart\n    cy.get('[data-cy=nav-products]').click();\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    \n    // Go to cart\n    cy.get('[data-cy=cart-link]').click();\n    \n    // Apply invalid coupon\n    cy.get('[data-cy=coupon-input]').type('INVALID');\n    cy.get('[data-cy=apply-coupon]').click();\n    \n    // Verify error message\n    cy.get('[data-cy=coupon-error]').should('be.visible')\n      .and('contain', 'Invalid coupon code');\n  });\n  \n  it('handles network errors gracefully', () => {\n    // Intercept API calls and simulate network failure\n    cy.intercept('POST', '/api/checkout', {\n      statusCode: 500,\n      body: { error: 'Internal server error' }\n    }).as('checkoutRequest');\n    \n    cy.login('user@example.com', 'password123');\n    \n    // Add item to cart and proceed to checkout\n    cy.get('[data-cy=nav-products]').click();\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    cy.get('[data-cy=cart-link]').click();\n    cy.get('[data-cy=checkout-button]').click();\n    \n    // Fill shipping information\n    cy.get('[data-cy=shipping-form]').within(() => {\n      cy.get('[data-cy=first-name]').type('John');\n      cy.get('[data-cy=last-name]').type('Doe');\n      cy.get('[data-cy=address]').type('123 Main St');\n      cy.get('[data-cy=city]').type('New York');\n      cy.get('[data-cy=zip-code]').type('10001');\n      cy.get('[data-cy=submit]').click();\n    });\n    \n    // Confirm order (will fail due to network error)\n    cy.get('[data-cy=confirm-order]').click();\n    \n    // Verify error handling\n    cy.get('[data-cy=error-message]').should('be.visible')\n      .and('contain', 'Unable to process your order');\n  });\n});\n\n// Custom Cypress commands (in cypress/support/commands.js)\nCypress.Commands.add('login', (email, password) => {\n  cy.visit('/login');\n  cy.get('[data-cy=email]').type(email);\n  cy.get('[data-cy=password]').type(password);\n  cy.get('[data-cy=submit]').click();\n  cy.get('[data-cy=dashboard]').should('be.visible');\n});\n\n// Custom tasks for database operations (in cypress/plugins/index.js)\nmodule.exports = (on, config) => {\n  on('task', {\n    seedDatabase() {\n      // Reset database and insert test data\n      return seedDatabase();\n    },\n    \n    resetDatabase() {\n      // Clear all data\n      return resetDatabase();\n    }\n  });\n};",
      "explanation": "This example produces: Advanced end-to-end tests with custom commands, proper error handling, network interception, and comprehensive user flow testing\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: API Testing and Database Integration Tests",
        "description": "Apply the concepts from this lesson on Integration Testing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Integration Testing",
      "testing"
    ],
    "legacy": {
      "originalId": 4,
      "originalTopic": "Integration Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.489Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-5",
    "moduleSlug": "testing-fundamentals",
    "title": "Cypress Advanced Patterns and Best Practices",
    "order": 5,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on End-to-End Testing.\n\nLearn advanced Cypress patterns, custom commands, and best practices for robust end-to-end testing of web applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Cypress E2E test with custom commands and advanced patterns\ndescribe('E-Commerce Application', () => {\n  beforeEach(() => {\n    // Custom command to reset database and seed test data\n    cy.task('seedDatabase');\n    cy.visit('/');\n  });\n  \n  afterEach(() => {\n    // Take screenshot on test failure\n    if (this.currentTest.state === 'failed') {\n      cy.screenshot(`failure-${this.currentTest.title}`);\n    }\n  });\n  \n  it('allows users to complete a purchase flow', () => {\n    // Custom command for login\n    cy.login('user@example.com', 'password123');\n    \n    // Navigate to products page\n    cy.get('[data-cy=nav-products]').click();\n    \n    // Search for a product\n    cy.get('[data-cy=search-input]').type('laptop');\n    cy.get('[data-cy=search-button]').click();\n    \n    // Add product to cart\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    \n    // Go to cart\n    cy.get('[data-cy=cart-link]').click();\n    \n    // Verify cart contents\n    cy.get('[data-cy=cart-items]').should('have.length', 1);\n    cy.get('[data-cy=cart-total]').should('contain', '$999.99');\n    \n    // Proceed to checkout\n    cy.get('[data-cy=checkout-button]').click();\n    \n    // Fill shipping information\n    cy.get('[data-cy=shipping-form]').within(() => {\n      cy.get('[data-cy=first-name]').type('John');\n      cy.get('[data-cy=last-name]').type('Doe');\n      cy.get('[data-cy=address]').type('123 Main St');\n      cy.get('[data-cy=city]').type('New York');\n      cy.get('[data-cy=zip-code]').type('10001');\n      cy.get('[data-cy=submit]').click();\n    });\n    \n    // Confirm order\n    cy.get('[data-cy=order-summary]').should('be.visible');\n    cy.get('[data-cy=confirm-order]').click();\n    \n    // Verify success message\n    cy.get('[data-cy=order-success]').should('contain', 'Order placed successfully');\n    cy.get('[data-cy=order-number]').should('contain', 'ORD-');\n  });\n  \n  it('shows error for invalid coupon code', () => {\n    cy.login('user@example.com', 'password123');\n    \n    // Add item to cart\n    cy.get('[data-cy=nav-products]').click();\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    \n    // Go to cart\n    cy.get('[data-cy=cart-link]').click();\n    \n    // Apply invalid coupon\n    cy.get('[data-cy=coupon-input]').type('INVALID');\n    cy.get('[data-cy=apply-coupon]').click();\n    \n    // Verify error message\n    cy.get('[data-cy=coupon-error]').should('be.visible')\n      .and('contain', 'Invalid coupon code');\n  });\n  \n  it('handles network errors gracefully', () => {\n    // Intercept API calls and simulate network failure\n    cy.intercept('POST', '/api/checkout', {\n      statusCode: 500,\n      body: { error: 'Internal server error' }\n    }).as('checkoutRequest');\n    \n    cy.login('user@example.com', 'password123');\n    \n    // Add item to cart and proceed to checkout\n    cy.get('[data-cy=nav-products]').click();\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    cy.get('[data-cy=cart-link]').click();\n    cy.get('[data-cy=checkout-button]').click();\n    \n    // Fill shipping information\n    cy.get('[data-cy=shipping-form]').within(() => {\n      cy.get('[data-cy=first-name]').type('John');\n      cy.get('[data-cy=last-name]').type('Doe');\n      cy.get('[data-cy=address]').type('123 Main St');\n      cy.get('[data-cy=city]').type('New York');\n      cy.get('[data-cy=zip-code]').type('10001');\n      cy.get('[data-cy=submit]').click();\n    });\n    \n    // Confirm order (will fail due to network error)\n    cy.get('[data-cy=confirm-order]').click();\n    \n    // Verify error handling\n    cy.get('[data-cy=error-message]').should('be.visible')\n      .and('contain', 'Unable to process your order');\n  });\n});\n\n// Custom Cypress commands (in cypress/support/commands.js)\nCypress.Commands.add('login', (email, password) => {\n  cy.visit('/login');\n  cy.get('[data-cy=email]').type(email);\n  cy.get('[data-cy=password]').type(password);\n  cy.get('[data-cy=submit]').click();\n  cy.get('[data-cy=dashboard]').should('be.visible');\n});\n\n// Custom tasks for database operations (in cypress/plugins/index.js)\nmodule.exports = (on, config) => {\n  on('task', {\n    seedDatabase() {\n      // Reset database and insert test data\n      return seedDatabase();\n    },\n    \n    resetDatabase() {\n      // Clear all data\n      return resetDatabase();\n    }\n  });\n};",
      "explanation": "This example produces: Advanced end-to-end tests with custom commands, proper error handling, network interception, and comprehensive user flow testing\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Cypress Advanced Patterns and Best Practices",
        "description": "Apply the concepts from this lesson on End-to-End Testing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Advanced",
    "tags": [
      "End-to-End Testing",
      "testing"
    ],
    "legacy": {
      "originalId": 5,
      "originalTopic": "End-to-End Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.489Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-6",
    "moduleSlug": "testing-fundamentals",
    "title": "Load Testing and Performance Metrics",
    "order": 6,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Performance Testing.\n\nLearn how to conduct load testing and measure application performance under various conditions.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Performance testing with Jest\nconst { performance } = require('perf_hooks');\n\nfunction measurePerformance(fn, iterations = 1000) {\n  const times = [];\n  \n  for (let i = 0; i < iterations; i++) {\n    const start = performance.now();\n    fn();\n    const end = performance.now();\n    times.push(end - start);\n  }\n  \n  const avg = times.reduce((sum, time) => sum + time, 0) / times.length;\n  const min = Math.min(...times);\n  const max = Math.max(...times);\n  \n  return { avg, min, max };\n}\n\ndescribe('Performance Tests', () => {\n  test('array processing completes within acceptable time', () => {\n    const largeArray = Array.from({ length: 10000 }, (_, i) => i);\n    \n    const stats = measurePerformance(() => {\n      largeArray.filter(n => n % 2 === 0).map(n => n * 2);\n    }, 100);\n    \n    expect(stats.avg).toBeLessThan(5);\n    expect(stats.max).toBeLessThan(20);\n  });\n});",
      "explanation": "This example produces: Performance measurement tools for identifying bottlenecks and ensuring acceptable response times\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Load Testing and Performance Metrics",
        "description": "Apply the concepts from this lesson on Performance Testing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Advanced",
    "tags": [
      "Performance Testing",
      "testing"
    ],
    "legacy": {
      "originalId": 6,
      "originalTopic": "Performance Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.489Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-7",
    "moduleSlug": "testing-fundamentals",
    "title": "Test Data Factories and Fixtures",
    "order": 7,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Test Data Management.\n\nLearn how to manage test data effectively using factories, fixtures, and data builders.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Test data factory pattern\nclass UserFactory {\n  static create(overrides = {}) {\n    return {\n      id: Math.floor(Math.random() * 10000),\n      name: 'John Doe',\n      email: `user${Date.now()}@example.com`,\n      age: 25,\n      isActive: true,\n      createdAt: new Date(),\n      ...overrides\n    };\n  }\n  \n  static createMany(count, overrides = {}) {\n    return Array.from({ length: count }, (_, index) => \n      this.create({ ...overrides, id: index + 1 })\n    );\n  }\n  \n  static createAdmin(overrides = {}) {\n    return this.create({\n      role: 'admin',\n      permissions: ['read', 'write', 'delete'],\n      ...overrides\n    });\n  }\n}\n\n// Builder pattern for complex objects\nclass OrderBuilder {\n  constructor() {\n    this.order = {\n      id: Math.floor(Math.random() * 10000),\n      status: 'pending',\n      items: [],\n      total: 0\n    };\n  }\n  \n  withItem(name, price, quantity = 1) {\n    const item = { name, price, quantity };\n    this.order.items.push(item);\n    this.order.total += price * quantity;\n    return this;\n  }\n  \n  build() {\n    return { ...this.order };\n  }\n}\n\n// Usage in tests\nconst order = new OrderBuilder()\n  .withItem('Laptop', 999.99)\n  .withItem('Mouse', 29.99, 2)\n  .build();",
      "explanation": "This example produces: Flexible test data creation with factories and builders for maintainable test suites\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Test Data Factories and Fixtures",
        "description": "Apply the concepts from this lesson on Test Data Management",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Test Data Management",
      "testing"
    ],
    "legacy": {
      "originalId": 7,
      "originalTopic": "Test Data Management",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.489Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-8",
    "moduleSlug": "testing-fundamentals",
    "title": "Visual Regression Testing",
    "order": 8,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Visual Testing.\n\nLearn how to implement visual regression testing to catch UI changes.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Visual testing with Puppeteer\nconst puppeteer = require('puppeteer');\nconst pixelmatch = require('pixelmatch');\nconst { PNG } = require('pngjs');\nconst fs = require('fs');\n\nclass VisualTester {\n  async captureScreenshot(url, filename) {\n    const browser = await puppeteer.launch();\n    const page = await browser.newPage();\n    await page.setViewport({ width: 1200, height: 800 });\n    await page.goto(url);\n    await page.screenshot({ path: filename });\n    await browser.close();\n  }\n  \n  async compareScreenshots(baseline, current, diff) {\n    const img1 = PNG.sync.read(fs.readFileSync(baseline));\n    const img2 = PNG.sync.read(fs.readFileSync(current));\n    const { width, height } = img1;\n    const diffImg = new PNG({ width, height });\n    \n    const numDiffPixels = pixelmatch(\n      img1.data, img2.data, diffImg.data, width, height\n    );\n    \n    fs.writeFileSync(diff, PNG.sync.write(diffImg));\n    return (numDiffPixels / (width * height)) * 100;\n  }\n}\n\n// Test usage\ntest('homepage visual regression', async () => {\n  const tester = new VisualTester();\n  await tester.captureScreenshot('http://localhost:3000', 'current.png');\n  \n  if (fs.existsSync('baseline.png')) {\n    const diffPercent = await tester.compareScreenshots(\n      'baseline.png', 'current.png', 'diff.png'\n    );\n    expect(diffPercent).toBeLessThan(2);\n  }\n});",
      "explanation": "This example produces: Visual regression testing with screenshot comparison and diff generation\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Visual Regression Testing",
        "description": "Apply the concepts from this lesson on Visual Testing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Visual Testing",
      "testing"
    ],
    "legacy": {
      "originalId": 8,
      "originalTopic": "Visual Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.489Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-9",
    "moduleSlug": "testing-fundamentals",
    "title": "Security Vulnerability Testing",
    "order": 9,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Security Testing.\n\nLearn how to test for common security vulnerabilities.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Security testing examples\nconst request = require('supertest');\nconst app = require('../app');\n\ndescribe('Security Tests', () => {\n  test('prevents SQL injection', async () => {\n    const maliciousPayload = {\n      email: \"'; DROP TABLE users; --\",\n      password: \"password\"\n    };\n    \n    const response = await request(app)\n      .post('/api/auth/login')\n      .send(maliciousPayload)\n      .expect(400);\n    \n    expect(response.body.error).toContain('Invalid');\n  });\n  \n  test('sanitizes XSS attempts', async () => {\n    const xssPayload = {\n      name: '<script>alert(\"XSS\")</script>',\n      bio: '<img src=x onerror=alert(\"XSS\")>'\n    };\n    \n    const response = await request(app)\n      .post('/api/users/profile')\n      .set('Authorization', 'Bearer valid-token')\n      .send(xssPayload)\n      .expect(200);\n    \n    expect(response.body.name).not.toContain('<script>');\n    expect(response.body.name).toBe('&lt;script&gt;alert(\"XSS\")&lt;/script&gt;');\n  });\n  \n  test('enforces rate limiting', async () => {\n    const attempts = [];\n    for (let i = 0; i < 6; i++) {\n      attempts.push(\n        request(app)\n          .post('/api/auth/login')\n          .send({ email: 'test@example.com', password: 'wrong' })\n      );\n    }\n    \n    const responses = await Promise.all(attempts);\n    expect(responses[5].status).toBe(429);\n  });\n});",
      "explanation": "This example produces: Security testing covering SQL injection, XSS protection, and rate limiting\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Security Vulnerability Testing",
        "description": "Apply the concepts from this lesson on Security Testing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Security Testing",
      "testing"
    ],
    "legacy": {
      "originalId": 9,
      "originalTopic": "Security Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.489Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-10",
    "moduleSlug": "testing-fundamentals",
    "title": "Code Coverage Analysis",
    "order": 10,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Test Coverage.\n\nLearn how to measure and analyze test coverage effectively.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Jest coverage configuration\nmodule.exports = {\n  collectCoverage: true,\n  coverageDirectory: 'coverage',\n  coverageReporters: ['text', 'lcov', 'html'],\n  collectCoverageFrom: [\n    'src/**/*.{js,jsx}',\n    '!src/**/*.test.{js,jsx}'\n  ],\n  coverageThreshold: {\n    global: {\n      branches: 80,\n      functions: 80,\n      lines: 80,\n      statements: 80\n    }\n  }\n};\n\n// Example testing all branches\nfunction calculateDiscount(price, customerType, loyaltyYears) {\n  let discount = 0;\n  \n  if (customerType === 'premium') {\n    discount += 0.2;\n  } else if (customerType === 'gold') {\n    discount += 0.15;\n  }\n  \n  if (loyaltyYears >= 5) {\n    discount += 0.05;\n  }\n  \n  return price * (1 - Math.min(discount, 0.3));\n}\n\n// Comprehensive test coverage\ndescribe('calculateDiscount', () => {\n  test('premium customer discount', () => {\n    expect(calculateDiscount(100, 'premium', 0)).toBe(80);\n  });\n  \n  test('gold customer discount', () => {\n    expect(calculateDiscount(100, 'gold', 0)).toBe(85);\n  });\n  \n  test('loyalty bonus', () => {\n    expect(calculateDiscount(100, 'premium', 5)).toBe(75);\n  });\n  \n  test('discount cap', () => {\n    expect(calculateDiscount(100, 'premium', 10)).toBe(70);\n  });\n});",
      "explanation": "This example produces: Code coverage configuration with branch testing and threshold enforcement\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Code Coverage Analysis",
        "description": "Apply the concepts from this lesson on Test Coverage",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Test Coverage",
      "testing"
    ],
    "legacy": {
      "originalId": 10,
      "originalTopic": "Test Coverage",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.489Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-11",
    "moduleSlug": "testing-fundamentals",
    "title": "API Contract Testing",
    "order": 11,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Contract Testing.\n\nLearn how to implement contract testing for API compatibility.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Consumer contract test with Pact\nconst { Pact } = require('@pact-foundation/pact');\nconst { like, eachLike } = require('@pact-foundation/pact').Matchers;\n\nconst mockProvider = new Pact({\n  consumer: 'UserInterface',\n  provider: 'UserService',\n  port: 1234\n});\n\ndescribe('User Service Contract', () => {\n  beforeAll(() => mockProvider.setup());\n  afterEach(() => mockProvider.verify());\n  afterAll(() => mockProvider.finalize());\n  \n  test('gets users successfully', async () => {\n    await mockProvider\n      .given('users exist')\n      .uponReceiving('a request for users')\n      .withRequest({\n        method: 'GET',\n        path: '/api/users'\n      })\n      .willRespondWith({\n        status: 200,\n        body: eachLike({\n          id: like(1),\n          name: like('John Doe'),\n          email: like('john@example.com')\n        })\n      });\n    \n    const users = await getUsersFromAPI();\n    expect(users).toBeInstanceOf(Array);\n    expect(users[0]).toHaveProperty('id');\n  });\n  \n  test('creates user successfully', async () => {\n    await mockProvider\n      .given('user can be created')\n      .uponReceiving('a request to create user')\n      .withRequest({\n        method: 'POST',\n        path: '/api/users',\n        body: {\n          name: 'New User',\n          email: 'new@example.com'\n        }\n      })\n      .willRespondWith({\n        status: 201,\n        body: {\n          id: like(123),\n          name: 'New User',\n          email: 'new@example.com'\n        }\n      });\n    \n    const user = await createUser({ name: 'New User', email: 'new@example.com' });\n    expect(user.id).toBeDefined();\n  });\n});",
      "explanation": "This example produces: Contract testing ensuring API compatibility between consumer and provider services\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: API Contract Testing",
        "description": "Apply the concepts from this lesson on Contract Testing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Contract Testing",
      "testing"
    ],
    "legacy": {
      "originalId": 11,
      "originalTopic": "Contract Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.489Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-12",
    "moduleSlug": "testing-fundamentals",
    "title": "Continuous Integration Testing Strategies",
    "order": 12,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on CI/CD Testing.\n\nLearn how to implement effective testing strategies in CI/CD pipelines.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "# GitHub Actions workflow for testing\nname: Test Pipeline\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    services:\n      postgres:\n        image: postgres:13\n        env:\n          POSTGRES_PASSWORD: postgres\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Setup Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18'\n        cache: 'npm'\n    \n    - name: Install dependencies\n      run: npm ci\n    \n    - name: Run linting\n      run: npm run lint\n    \n    - name: Run unit tests\n      run: npm run test:unit -- --coverage\n    \n    - name: Run integration tests\n      run: npm run test:integration\n      env:\n        DATABASE_URL: postgres://postgres:postgres@localhost:5432/test\n    \n    - name: Build application\n      run: npm run build\n    \n    - name: Run E2E tests\n      run: npm run test:e2e\n    \n    - name: Upload coverage to Codecov\n      uses: codecov/codecov-action@v3\n      with:\n        file: ./coverage/lcov.info\n    \n    - name: Run security audit\n      run: npm audit --audit-level high\n    \n    - name: Check bundle size\n      run: npm run bundlesize\n\n# Package.json test scripts\n{\n  \"scripts\": {\n    \"test\": \"jest\",\n    \"test:unit\": \"jest --testPathPattern=unit\",\n    \"test:integration\": \"jest --testPathPattern=integration\",\n    \"test:e2e\": \"cypress run\",\n    \"test:watch\": \"jest --watch\",\n    \"test:coverage\": \"jest --coverage\",\n    \"lint\": \"eslint src/\",\n    \"bundlesize\": \"bundlesize\"\n  }\n}\n\n// Test configuration for different environments\nconst config = {\n  development: {\n    testTimeout: 10000,\n    setupFilesAfterEnv: ['<rootDir>/src/setupTests.js']\n  },\n  ci: {\n    testTimeout: 30000,\n    maxWorkers: 2,\n    collectCoverage: true,\n    coverageReporters: ['lcov', 'text-summary']\n  },\n  production: {\n    testTimeout: 60000,\n    bail: 1,\n    verbose: false\n  }\n};\n\nmodule.exports = config[process.env.NODE_ENV] || config.development;",
      "explanation": "This example produces: Complete CI/CD testing pipeline with unit, integration, E2E tests, and quality gates\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Continuous Integration Testing Strategies",
        "description": "Apply the concepts from this lesson on CI/CD Testing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "CI/CD Testing",
      "testing"
    ],
    "legacy": {
      "originalId": 12,
      "originalTopic": "CI/CD Testing",
      "migrated": "2025-10-01T06:41:13.489Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.489Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-13",
    "moduleSlug": "testing-fundamentals",
    "title": "Test-Driven Development (TDD) Practice",
    "order": 13,
    "objectives": [
      "Master the TDD red-green-refactor cycle",
      "Write tests that drive design decisions",
      "Understand when and why to use TDD effectively"
    ],
    "intro": "Test-Driven Development (TDD) is a development methodology where you write tests before writing production code. This lesson explores the TDD cycle and its benefits.\n\nTDD follows a simple three-step cycle: Red (write a failing test), Green (write minimal code to pass), and Refactor (improve the code while keeping tests green). This approach leads to better design, higher test coverage, and more confidence in your code.\n\nYou'll learn when TDD is most effective, common pitfalls to avoid, and how to structure your development workflow around test-first thinking. TDD isn't just about testing - it's a design methodology that leads to cleaner, more maintainable code.\n\nBy practicing TDD, you'll develop a deeper understanding of your requirements and create more focused, purposeful code. The discipline of writing tests first forces you to think about interfaces and behavior before implementation details.\n\nThis lesson includes hands-on exercises where you'll implement features using strict TDD practices, experiencing firsthand how tests can drive good design decisions.",
    "code": {
      "example": "// TDD Example: Building a Calculator with strict Red-Green-Refactor\n\n// STEP 1: RED - Write failing test\ndescribe('Calculator', () => {\n  test('should add two numbers', () => {\n    const calculator = new Calculator();\n    const result = calculator.add(2, 3);\n    expect(result).toBe(5);\n  });\n});\n\n// This test fails because Calculator doesn't exist yet\n\n// STEP 2: GREEN - Minimal code to pass\nclass Calculator {\n  add(a, b) {\n    return 5; // Hard-coded to pass the test\n  }\n}\n\n// STEP 3: RED - Add more specific test\ntest('should add different numbers', () => {\n  const calculator = new Calculator();\n  expect(calculator.add(1, 4)).toBe(5);\n  expect(calculator.add(10, 15)).toBe(25);\n});\n\n// STEP 4: GREEN - Real implementation\nclass Calculator {\n  add(a, b) {\n    return a + b;\n  }\n}\n\n// STEP 5: REFACTOR - Improve the tests\ndescribe('Calculator', () => {\n  let calculator;\n  \n  beforeEach(() => {\n    calculator = new Calculator();\n  });\n  \n  describe('addition', () => {\n    test('adds positive numbers', () => {\n      expect(calculator.add(2, 3)).toBe(5);\n      expect(calculator.add(10, 15)).toBe(25);\n    });\n    \n    test('adds negative numbers', () => {\n      expect(calculator.add(-2, -3)).toBe(-5);\n      expect(calculator.add(-5, 3)).toBe(-2);\n    });\n    \n    test('adds zero', () => {\n      expect(calculator.add(0, 5)).toBe(5);\n      expect(calculator.add(5, 0)).toBe(5);\n    });\n    \n    test('adds decimal numbers', () => {\n      expect(calculator.add(1.5, 2.3)).toBeCloseTo(3.8);\n    });\n  });\n});\n\n// TDD for more complex functionality\ndescribe('User Registration (TDD)', () => {\n  // RED: Start with the simplest failing test\n  test('creates user with valid email and password', () => {\n    const userService = new UserService();\n    const user = userService.register('test@example.com', 'password123');\n    \n    expect(user).toHaveProperty('id');\n    expect(user.email).toBe('test@example.com');\n    expect(user).not.toHaveProperty('password'); // Never expose password\n  });\n  \n  // GREEN: Implement minimal UserService\n  // RED: Add validation tests\n  test('throws error for invalid email', () => {\n    const userService = new UserService();\n    \n    expect(() => {\n      userService.register('invalid-email', 'password123');\n    }).toThrow('Invalid email format');\n  });\n  \n  test('throws error for weak password', () => {\n    const userService = new UserService();\n    \n    expect(() => {\n      userService.register('test@example.com', '123');\n    }).toThrow('Password must be at least 8 characters');\n  });\n});\n\n// Final implementation driven by tests\nclass UserService {\n  constructor() {\n    this.users = [];\n    this.nextId = 1;\n  }\n  \n  register(email, password) {\n    this.validateEmail(email);\n    this.validatePassword(password);\n    \n    const user = {\n      id: this.nextId++,\n      email: email,\n      hashedPassword: this.hashPassword(password)\n    };\n    \n    this.users.push(user);\n    \n    // Return user without password\n    return {\n      id: user.id,\n      email: user.email\n    };\n  }\n  \n  validateEmail(email) {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    if (!emailRegex.test(email)) {\n      throw new Error('Invalid email format');\n    }\n  }\n  \n  validatePassword(password) {\n    if (password.length < 8) {\n      throw new Error('Password must be at least 8 characters');\n    }\n  }\n  \n  hashPassword(password) {\n    // Simplified hashing (use bcrypt in real apps)\n    return 'hashed_' + password;\n  }\n}",
      "explanation": "This example demonstrates the full TDD cycle: writing failing tests first, implementing minimal code to pass, then refactoring. Notice how tests drive the design and reveal requirements that might be missed otherwise.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Writing too much production code before getting tests to pass",
        "solution": "Stick to minimal implementation - only write enough code to make the current test pass",
        "severity": "high"
      },
      {
        "mistake": "Skipping the refactor step",
        "solution": "Always refactor after getting tests to pass - this is where code quality improves",
        "severity": "medium"
      },
      {
        "mistake": "Writing tests that are too complex initially",
        "solution": "Start with the simplest possible test and add complexity gradually",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "TDD Banking System",
        "description": "Build a simple banking system using strict TDD practices",
        "checkpoints": [
          "Create Account class with deposit functionality",
          "Add withdrawal with overdraft protection",
          "Implement transfer between accounts",
          "Add transaction history tracking"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 35,
    "difficulty": "Intermediate",
    "tags": [
      "TDD",
      "Unit Testing",
      "Design"
    ],
    "lastUpdated": "2025-10-01T13:30:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "testing-fundamentals-lesson-14",
    "moduleSlug": "testing-fundamentals",
    "title": "Testing Best Practices and Code Coverage",
    "order": 14,
    "objectives": [
      "Understand different types of code coverage metrics",
      "Learn when high coverage is valuable and when it's misleading",
      "Master best practices for maintainable test suites"
    ],
    "intro": "Code coverage is a useful metric for understanding how much of your code is exercised by tests, but it's important to understand what it measures and what it doesn't.\n\nThis lesson explores different types of coverage (line, branch, function, statement) and how to interpret coverage reports effectively. You'll learn why 100% coverage isn't always the goal and how to focus on meaningful testing.\n\nWe'll cover best practices for organizing test suites, naming conventions, test data management, and strategies for keeping tests fast and reliable. Good tests are documentation for your code and should make future changes easier, not harder.\n\nYou'll also learn about test smells - patterns that indicate your tests might be too fragile, too coupled to implementation details, or not providing sufficient value. Recognizing these patterns helps you write better tests.\n\nBy the end of this lesson, you'll understand how to balance test quantity with test quality, create tests that provide real confidence in your code, and build test suites that support rather than hinder development velocity.",
    "code": {
      "example": "// Understanding code coverage types\n\n// Example function to test\nfunction processUser(user) {\n  // Line coverage: Are these lines executed?\n  if (!user) {\n    throw new Error('User is required');\n  }\n  \n  if (!user.email) {\n    throw new Error('Email is required');\n  }\n  \n  // Branch coverage: Are both true/false branches tested?\n  if (user.age >= 18) {\n    user.status = 'adult';\n  } else {\n    user.status = 'minor';\n  }\n  \n  // Function coverage: Is this function called?\n  const result = validateAndFormat(user);\n  \n  return result;\n}\n\nfunction validateAndFormat(user) {\n  user.email = user.email.toLowerCase();\n  return user;\n}\n\n// Tests demonstrating different coverage types\ndescribe('processUser - Coverage Examples', () => {\n  test('processes valid adult user', () => {\n    const user = { email: 'TEST@EXAMPLE.COM', age: 25 };\n    const result = processUser(user);\n    \n    expect(result.status).toBe('adult');\n    expect(result.email).toBe('test@example.com');\n  });\n  \n  // This test alone gives:\n  // - Line coverage: ~80% (doesn't hit minor branch)\n  // - Branch coverage: ~50% (only adult branch)\n  // - Function coverage: 100% (both functions called)\n  \n  test('processes valid minor user', () => {\n    const user = { email: 'CHILD@EXAMPLE.COM', age: 16 };\n    const result = processUser(user);\n    \n    expect(result.status).toBe('minor');\n  });\n  \n  // Now we have 100% branch coverage\n  \n  test('throws error for null user', () => {\n    expect(() => processUser(null)).toThrow('User is required');\n  });\n  \n  test('throws error for user without email', () => {\n    expect(() => processUser({ age: 25 })).toThrow('Email is required');\n  });\n  \n  // Now we have 100% line coverage\n});\n\n// Best practices for test organization\ndescribe('User Management Service', () => {\n  let userService;\n  let mockDatabase;\n  \n  beforeEach(() => {\n    // Fresh setup for each test\n    mockDatabase = {\n      save: jest.fn(),\n      findById: jest.fn(),\n      findByEmail: jest.fn()\n    };\n    userService = new UserService(mockDatabase);\n  });\n  \n  describe('user creation', () => {\n    test('creates user with valid data', async () => {\n      // Arrange\n      const userData = createValidUserData();\n      mockDatabase.save.mockResolvedValue({ id: 1, ...userData });\n      \n      // Act\n      const user = await userService.createUser(userData);\n      \n      // Assert\n      expect(user).toMatchObject({\n        id: expect.any(Number),\n        email: userData.email\n      });\n    });\n    \n    // Group related tests together\n    describe('validation errors', () => {\n      test('rejects invalid email format', async () => {\n        const userData = createValidUserData({ email: 'invalid-email' });\n        \n        await expect(userService.createUser(userData))\n          .rejects.toThrow('Invalid email format');\n      });\n      \n      test('rejects duplicate email', async () => {\n        const userData = createValidUserData();\n        mockDatabase.findByEmail.mockResolvedValue({ id: 1 });\n        \n        await expect(userService.createUser(userData))\n          .rejects.toThrow('Email already exists');\n      });\n    });\n  });\n  \n  describe('user retrieval', () => {\n    test('finds user by ID', async () => {\n      const userId = 1;\n      const mockUser = { id: userId, email: 'test@example.com' };\n      mockDatabase.findById.mockResolvedValue(mockUser);\n      \n      const user = await userService.findUser(userId);\n      \n      expect(user).toEqual(mockUser);\n      expect(mockDatabase.findById).toHaveBeenCalledWith(userId);\n    });\n  });\n});\n\n// Helper functions for test data\nfunction createValidUserData(overrides = {}) {\n  return {\n    email: 'test@example.com',\n    name: 'Test User',\n    age: 25,\n    ...overrides\n  };\n}\n\n// Example of coverage report interpretation\n/*\nCoverage Report:\n\n File              % Stmts   % Branch   % Funcs    % Lines   \n\n userService.js     95.83      87.5       100        95.83   \n validator.js       100        100        100        100     \n database.js        75         66.67      80         75      \n\n\nAnalysis:\n- userService.js: Good coverage but missing some edge cases (87.5% branch)\n- validator.js: Perfect coverage (but check if tests are meaningful)\n- database.js: Low coverage suggests untested error paths\n*/",
      "explanation": "This example shows how different types of coverage work, best practices for test organization, and how to interpret coverage reports to identify gaps in testing.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Focusing only on coverage percentage without considering test quality",
        "solution": "Aim for meaningful tests that verify behavior, not just code execution",
        "severity": "high"
      },
      {
        "mistake": "Writing tests that are too tightly coupled to implementation details",
        "solution": "Test public interfaces and behaviors, not internal implementation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring slow or flaky tests",
        "solution": "Fix or remove tests that don't provide reliable feedback",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Test Suite Analysis",
        "description": "Analyze and improve an existing test suite's coverage and quality",
        "checkpoints": [
          "Generate coverage report for existing code",
          "Identify untested branches and edge cases",
          "Add meaningful tests to improve coverage",
          "Refactor tests for better maintainability"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Intermediate",
    "tags": [
      "Code Coverage",
      "Best Practices",
      "Test Quality"
    ],
    "lastUpdated": "2025-10-01T13:30:00.000Z",
    "version": "1.0.0"
  }
]