[
  {
    "id": "programming-fundamentals-lesson-1",
    "moduleSlug": "programming-fundamentals",
    "title": "Variables and Data Types",
    "order": 1,
    "objectives": [
      "Understand different data types in programming (numbers, strings, booleans)",
      "Learn how to declare and initialize variables",
      "Master variable naming conventions and best practices"
    ],
    "intro": "Variables are fundamental building blocks in programming that store and manage data in your applications. Understanding data types is crucial for writing efficient and bug-free code.\n\nIn this lesson, you'll learn about primitive data types including numbers, strings, and booleans. We'll explore how different programming languages handle these types and when to use each one effectively.\n\nVariables act as containers that hold values which can change during program execution. Proper variable management is essential for memory efficiency and code readability. You'll discover naming conventions that make your code self-documenting and easier to maintain.\n\nBy the end of this lesson, you'll confidently declare variables, choose appropriate data types, and follow industry-standard naming practices. These skills form the foundation for all programming concepts you'll learn throughout your development journey.\n\nWe'll cover practical examples showing how variables store different types of information, from user input to calculation results. Understanding these fundamentals will prepare you for more complex topics like functions, arrays, and object-oriented programming.",
    "code": {
      "example": "// Variable declarations with different data types\n\n// Numbers (integers and floating-point)\nlet age = 25;\nlet price = 19.99;\nlet temperature = -5;\n\n// Strings (text data)\nlet firstName = \"John\";\nlet lastName = \"Doe\";\nlet message = `Hello, ${firstName} ${lastName}!`;\n\n// Booleans (true/false values)\nlet isLoggedIn = true;\nlet hasPermission = false;\nlet isValidEmail = email.includes('@');\n\n// Constants (values that don't change)\nconst PI = 3.14159;\nconst MAX_USERS = 100;\n\n// Variable naming conventions\nlet userName = \"camelCase for variables\";\nconst API_URL = \"UPPER_CASE for constants\";\nlet is_valid = false; // avoid snake_case in JavaScript\n\nconsole.log(`Age: ${age}, Price: $${price}, User: ${firstName}`);",
      "explanation": "This example demonstrates proper variable declaration, different data types, and naming conventions. Notice how we use 'let' for variables that can change, 'const' for constants, and template literals for string interpolation.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Using inconsistent variable naming conventions",
        "solution": "Follow camelCase for variables and UPPER_CASE for constants in JavaScript",
        "severity": "medium"
      },
      {
        "mistake": "Not declaring variables with appropriate keywords (let/const)",
        "solution": "Use 'let' for variables that change and 'const' for constants to prevent accidental reassignment",
        "severity": "high"
      },
      {
        "mistake": "Using global variables unnecessarily",
        "solution": "Limit variable scope to where it's needed to prevent naming conflicts and memory issues",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Variable Declaration Practice",
        "description": "Create a simple program that declares variables for a user profile and displays the information.",
        "checkpoints": [
          "Declare variables for name, age, email, and account status",
          "Use appropriate data types for each variable",
          "Display the user information using template literals",
          "Verify your variable names follow naming conventions"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Beginner",
    "tags": [
      "Logic",
      "Algorithms",
      "Data Structures"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-2",
    "moduleSlug": "programming-fundamentals",
    "title": "Control Structures: Conditionals",
    "order": 2,
    "objectives": [
      "Master if/else statements and conditional logic",
      "Learn about comparison and logical operators",
      "Understand switch statements and ternary operators"
    ],
    "intro": "Control structures are the decision-making components of programming that allow your code to execute different paths based on conditions. Conditionals are essential for creating dynamic applications that respond to user input, data changes, and varying states.\n\nIn this lesson, you'll learn how to implement if/else statements, which form the backbone of conditional logic in most programming languages. We'll explore comparison operators (==, ===, !=, !==, <, >, <=, >=) and logical operators (&&, ||, !) that enable complex decision-making.\n\nYou'll also discover alternative control structures like switch statements for handling multiple conditions and ternary operators for concise conditional assignments. These tools help you write cleaner, more readable code while maintaining functionality.\n\nBy the end of this lesson, you'll be able to create sophisticated conditional logic that handles various scenarios in your applications. You'll understand when to use each control structure and how to avoid common pitfalls that lead to bugs and maintenance issues.\n\nWe'll work through practical examples showing how conditionals control program flow in real-world applications, from user authentication to data validation and feature toggles.",
    "code": {
      "example": "// If/else statements\nconst userAge = 20;\n\nif (userAge >= 18) {\n  console.log(\"You are eligible to vote\");\n} else if (userAge >= 16) {\n  console.log(\"You can get a driver's license\");\n} else {\n  console.log(\"You're still young\");\n}\n\n// Logical operators\nconst isLoggedIn = true;\nconst hasPermission = false;\n\nif (isLoggedIn && hasPermission) {\n  console.log(\"Access granted\");\n} else if (isLoggedIn || hasPermission) {\n  console.log(\"Partial access\");\n} else {\n  console.log(\"Access denied\");\n}\n\n// Switch statement\nconst day = \"Monday\";\nswitch (day) {\n  case \"Monday\":\n    console.log(\"Start of the work week\");\n    break;\n  case \"Friday\":\n    console.log(\"End of the work week\");\n    break;\n  default:\n    console.log(\"Mid-week day\");\n}\n\n// Ternary operator\nconst isStudent = true;\nconst discount = isStudent ? 0.1 : 0;\nconsole.log(`Discount: ${discount * 100}%`);",
      "explanation": "This example shows various conditional structures. Notice how if/else chains handle multiple conditions, logical operators combine boolean values, switch statements efficiently handle multiple discrete values, and ternary operators provide concise conditional assignments.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Using = instead of == or === for comparison",
        "solution": "Always use == for loose equality or === for strict equality comparisons",
        "severity": "high"
      },
      {
        "mistake": "Complex nested if statements that are hard to read",
        "solution": "Consider using early returns or switch statements to simplify complex logic",
        "severity": "medium"
      },
      {
        "mistake": "Not considering all possible cases in switch statements",
        "solution": "Always include a default case to handle unexpected values",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Grade Calculator",
        "description": "Create a program that determines letter grades based on numerical scores using conditional logic.",
        "checkpoints": [
          "Implement if/else statements to handle different grade ranges",
          "Use logical operators to combine conditions",
          "Add a default case for invalid scores",
          "Test with various input values"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 45,
    "difficulty": "Beginner",
    "tags": [
      "Logic",
      "Conditionals",
      "Control Flow"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-3",
    "moduleSlug": "programming-fundamentals",
    "title": "Control Structures: Loops",
    "order": 3,
    "objectives": [
      "Master for, while, and do-while loops",
      "Learn about loop control statements (break, continue)",
      "Understand iteration patterns and when to use each loop type"
    ],
    "intro": "Loops are repetitive control structures that allow you to execute code multiple times without writing the same statements repeatedly. They're essential for processing collections of data, implementing algorithms, and automating repetitive tasks.\n\nIn this lesson, you'll learn about different loop types: for loops for counting iterations, while loops for condition-based repetition, and do-while loops for guaranteed execution. Each has specific use cases and advantages depending on your programming needs.\n\nYou'll also explore loop control statements like break (to exit loops early) and continue (to skip to the next iteration). These tools give you fine-grained control over loop execution and help you handle special cases efficiently.\n\nBy the end of this lesson, you'll be able to choose the appropriate loop type for different scenarios and implement complex iteration patterns. You'll understand how to avoid infinite loops and optimize loop performance for better application efficiency.\n\nWe'll work through practical examples showing how loops process arrays, implement algorithms like searching and sorting, and handle real-world data processing tasks.",
    "code": {
      "example": "// For loop\nfor (let i = 0; i < 5; i++) {\n  console.log(`Count: ${i}`);\n}\n\n// While loop\nlet count = 0;\nwhile (count < 5) {\n  console.log(`While count: ${count}`);\n  count++;\n}\n\n// Do-while loop\nlet attempts = 0;\ndo {\n  console.log(`Attempt: ${attempts}`);\n  attempts++;\n} while (attempts < 3);\n\n// Loop control statements\nfor (let i = 0; i < 10; i++) {\n  if (i === 3) continue; // Skip iteration when i is 3\n  if (i === 7) break;    // Exit loop when i is 7\n  console.log(`Number: ${i}`);\n}\n\n// Iterating over arrays\nconst fruits = [\"apple\", \"banana\", \"orange\"];\nfor (let i = 0; i < fruits.length; i++) {\n  console.log(`Fruit ${i}: ${fruits[i]}`);\n}\n\n// For...of loop (modern approach)\nfor (const fruit of fruits) {\n  console.log(`Delicious: ${fruit}`);\n}",
      "explanation": "This example demonstrates various loop types and control statements. Notice how for loops are ideal for counting, while loops continue based on conditions, do-while loops guarantee at least one execution, and control statements provide flexibility in loop execution.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating infinite loops due to incorrect conditions",
        "solution": "Always ensure loop conditions will eventually become false",
        "severity": "high"
      },
      {
        "mistake": "Off-by-one errors in loop boundaries",
        "solution": "Carefully check loop start/end conditions, especially with array indices",
        "severity": "high"
      },
      {
        "mistake": "Modifying loop variables inside the loop body unexpectedly",
        "solution": "Be cautious when changing loop control variables within the loop",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Array Processor",
        "description": "Create a program that processes an array of numbers using different loop types to calculate statistics.",
        "checkpoints": [
          "Use a for loop to calculate the sum of all numbers",
          "Use a while loop to find the maximum value",
          "Use a do-while loop to count even numbers",
          "Implement break/continue to handle special cases"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 50,
    "difficulty": "Beginner",
    "tags": [
      "Logic",
      "Loops",
      "Control Flow"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-4",
    "moduleSlug": "programming-fundamentals",
    "title": "Functions and Scope",
    "order": 4,
    "objectives": [
      "Learn to define and call functions",
      "Understand function parameters and return values",
      "Master variable scope and closure concepts"
    ],
    "intro": "Functions are reusable blocks of code that perform specific tasks and help organize your programs into logical units. They're fundamental to writing maintainable, modular code and implementing the DRY (Don't Repeat Yourself) principle.\n\nIn this lesson, you'll learn how to define functions with parameters, return values, and proper naming conventions. We'll explore different function syntaxes including traditional function declarations, arrow functions, and anonymous functions.\n\nYou'll also dive deep into variable scope, understanding the difference between global and local scope, and how closures work to maintain access to outer function variables. These concepts are crucial for avoiding naming conflicts and managing data flow in your applications.\n\nBy the end of this lesson, you'll be able to create well-structured functions that encapsulate logic, accept input parameters, and return meaningful results. You'll understand how scope affects variable accessibility and how to use closures effectively.\n\nWe'll work through practical examples showing how functions modularize code, enable code reuse, and create clean interfaces between different parts of your applications.",
    "code": {
      "example": "// Function declaration\nfunction greetUser(name) {\n  return `Hello, ${name}!`;\n}\n\n// Function expression\nconst calculateArea = function(width, height) {\n  return width * height;\n};\n\n// Arrow function\nconst isEven = (number) => number % 2 === 0;\n\n// Function with default parameters\nfunction createUser(name, role = \"user\", isActive = true) {\n  return {\n    name,\n    role,\n    isActive,\n    createdAt: new Date()\n  };\n}\n\n// Scope example\nconst globalVar = \"I'm global\";\n\nfunction scopeDemo() {\n  const localVar = \"I'm local\";\n  console.log(globalVar); // Accessible\n  console.log(localVar);  // Accessible\n  \n  if (true) {\n    const blockVar = \"I'm block-scoped\";\n    console.log(blockVar); // Accessible\n  }\n  // console.log(blockVar); // Error: not accessible outside block\n}\n\n// Closure example\nfunction createCounter() {\n  let count = 0;\n  return function() {\n    count++;\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2",
      "explanation": "This example shows different function syntaxes, parameter handling, and scope concepts. Notice how functions encapsulate logic, arrow functions provide concise syntax, default parameters handle missing values, and closures maintain access to outer variables.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not returning values when expected",
        "solution": "Always explicitly return values from functions that need to provide output",
        "severity": "medium"
      },
      {
        "mistake": "Variable naming conflicts due to scope issues",
        "solution": "Use descriptive names and limit variable scope to where it's needed",
        "severity": "medium"
      },
      {
        "mistake": "Overcomplicating functions with too many responsibilities",
        "solution": "Keep functions focused on single responsibilities for better maintainability",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Math Utility Functions",
        "description": "Create a set of mathematical utility functions that demonstrate parameters, return values, and scope concepts.",
        "checkpoints": [
          "Implement a function to calculate factorial with recursion",
          "Create a function that accepts multiple parameters for complex calculations",
          "Build a function that returns an object with multiple computed values",
          "Use closures to create private variables in a calculator module"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Beginner",
    "tags": [
      "Functions",
      "Scope",
      "Modularity"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-5",
    "moduleSlug": "programming-fundamentals",
    "title": "Arrays and Array Methods",
    "order": 5,
    "objectives": [
      "Learn to create and manipulate arrays",
      "Master essential array methods (map, filter, reduce)",
      "Understand array iteration and transformation techniques"
    ],
    "intro": "Arrays are ordered collections that store multiple values in a single variable. They're essential data structures for managing lists of related data and implementing algorithms that process collections efficiently.\n\nIn this lesson, you'll learn how to create arrays, access elements by index, and modify array contents. We'll explore essential array methods like push, pop, shift, unshift for adding and removing elements, and slice, splice for manipulating array segments.\n\nYou'll dive deep into transformation methods like map (for creating new arrays), filter (for selecting elements), and reduce (for aggregating values). These powerful methods enable functional programming patterns that lead to cleaner, more expressive code.\n\nBy the end of this lesson, you'll be able to manipulate arrays effectively, transform data using functional methods, and choose appropriate techniques for different array operations. You'll understand how to avoid common array-related bugs and optimize array processing for performance.\n\nWe'll work through practical examples showing how arrays manage user data, process API responses, implement shopping carts, and handle real-world collection-based tasks.",
    "code": {
      "example": "// Creating arrays\nconst fruits = [\"apple\", \"banana\", \"orange\"];\nconst numbers = new Array(1, 2, 3, 4, 5);\nconst mixed = [1, \"hello\", true, {name: \"John\"}];\n\n// Accessing and modifying elements\nconsole.log(fruits[0]); // \"apple\"\nfruits[1] = \"grape\";   // Change element\nfruits.push(\"mango\");   // Add to end\nfruits.unshift(\"kiwi\"); // Add to beginning\n\n// Essential array methods\nconst colors = [\"red\", \"green\", \"blue\", \"yellow\"];\n\n// Adding/removing\ncolors.push(\"purple\");     // Add to end\ncolors.pop();              // Remove from end\ncolors.unshift(\"orange\");  // Add to beginning\ncolors.shift();            // Remove from beginning\n\n// Transformation methods\nconst nums = [1, 2, 3, 4, 5];\n\n// Map - transform each element\nconst doubled = nums.map(n => n * 2);\nconsole.log(doubled); // [2, 4, 6, 8, 10]\n\n// Filter - select elements that match condition\nconst evens = nums.filter(n => n % 2 === 0);\nconsole.log(evens); // [2, 4]\n\n// Reduce - aggregate values\nconst sum = nums.reduce((acc, n) => acc + n, 0);\nconsole.log(sum); // 15\n\n// Chaining methods\nconst result = nums\n  .filter(n => n > 2)      // [3, 4, 5]\n  .map(n => n * 2)         // [6, 8, 10]\n  .reduce((a, b) => a + b, 0); // 24\nconsole.log(result);",
      "explanation": "This example demonstrates array creation, element access, and essential methods. Notice how push/pop modify the end, unshift/shift modify the beginning, map transforms elements, filter selects elements, and reduce aggregates values.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Accessing array elements beyond bounds",
        "solution": "Always check array length before accessing elements by index",
        "severity": "medium"
      },
      {
        "mistake": "Modifying original arrays when transformations are needed",
        "solution": "Use methods like map that return new arrays instead of modifying originals",
        "severity": "medium"
      },
      {
        "mistake": "Not understanding that array methods return new arrays (except push, pop, etc.)",
        "solution": "Remember to assign results of methods like map, filter to variables",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Data Processor",
        "description": "Create a program that processes a collection of user objects using array methods to filter, transform, and aggregate data.",
        "checkpoints": [
          "Use filter to select active users",
          "Use map to transform user data into a different format",
          "Use reduce to calculate statistics like average age",
          "Chain multiple array methods for complex transformations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 55,
    "difficulty": "Beginner",
    "tags": [
      "Arrays",
      "Data Structures",
      "Collections"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-6",
    "moduleSlug": "programming-fundamentals",
    "title": "Objects and Object Methods",
    "order": 6,
    "objectives": [
      "Learn to create and manipulate objects",
      "Master object properties and methods",
      "Understand object-oriented programming concepts"
    ],
    "intro": "Objects are collections of key-value pairs that represent entities with properties and behaviors. They're fundamental to organizing complex data and implementing object-oriented programming principles in modern applications.\n\nIn this lesson, you'll learn how to create objects using literals, constructors, and classes. We'll explore property access using dot notation and bracket notation, and how to add, modify, and delete object properties dynamically.\n\nYou'll dive into object methods, understanding how functions can be attached to objects to define behaviors. We'll cover the 'this' keyword and how it refers to the object context when methods are called.\n\nBy the end of this lesson, you'll be able to model real-world entities using objects, organize related data and functions together, and implement basic object-oriented programming patterns. You'll understand how objects enable code organization and data encapsulation.\n\nWe'll work through practical examples showing how objects represent users, products, and application state, and how methods define the behaviors of these entities.",
    "code": {
      "example": "// Object literal\nconst user = {\n  name: \"John Doe\",\n  age: 30,\n  email: \"john@example.com\",\n  isActive: true,\n  \n  // Method\n  greet() {\n    return `Hello, I'm ${this.name}`;\n  },\n  \n  // Method with parameters\n  updateEmail(newEmail) {\n    this.email = newEmail;\n    return `Email updated to ${newEmail}`;\n  }\n};\n\n// Accessing properties\nconsole.log(user.name);        // \"John Doe\"\nconsole.log(user[\"email\"]);   // \"john@example.com\"\n\n// Adding properties\nuser.location = \"New York\";\nuser[\"phoneNumber\"] = \"123-456-7890\";\n\n// Object methods\nconsole.log(user.greet());     // \"Hello, I'm John Doe\"\nconsole.log(user.updateEmail(\"newemail@example.com\"));\n\n// Object constructor\nfunction Car(make, model, year) {\n  this.make = make;\n  this.model = model;\n  this.year = year;\n  this.start = function() {\n    return `${this.make} ${this.model} is starting`;\n  };\n}\n\nconst myCar = new Car(\"Toyota\", \"Camry\", 2022);\nconsole.log(myCar.start());\n\n// Modern class syntax\nclass Product {\n  constructor(name, price, category) {\n    this.name = name;\n    this.price = price;\n    this.category = category;\n  }\n  \n  getInfo() {\n    return `${this.name} - $${this.price} (${this.category})`;\n  }\n  \n  applyDiscount(percent) {\n    this.price = this.price * (1 - percent / 100);\n    return `Discount applied. New price: $${this.price.toFixed(2)}`;\n  }\n}\n\nconst laptop = new Product(\"Laptop\", 999.99, \"Electronics\");\nconsole.log(laptop.getInfo());\nconsole.log(laptop.applyDiscount(10));",
      "explanation": "This example shows object creation with literals, constructors, and classes. Notice how properties store data, methods define behaviors, and the 'this' keyword refers to the object instance.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Confusing dot notation and bracket notation",
        "solution": "Use dot notation for known property names, bracket notation for dynamic or special characters",
        "severity": "medium"
      },
      {
        "mistake": "Misunderstanding the 'this' keyword context",
        "solution": "Remember that 'this' refers to the object that called the method, not where it was defined",
        "severity": "high"
      },
      {
        "mistake": "Not properly initializing object properties",
        "solution": "Always initialize required properties in constructors or at object creation",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Library Management System",
        "description": "Create a simple library system using objects to represent books, patrons, and library operations.",
        "checkpoints": [
          "Create book objects with properties like title, author, and availability",
          "Implement patron objects with borrowing history",
          "Add methods to check out and return books",
          "Use the 'this' keyword correctly in object methods"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Beginner",
    "tags": [
      "Objects",
      "OOP",
      "Data Modeling"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-7",
    "moduleSlug": "programming-fundamentals",
    "title": "Error Handling and Debugging",
    "order": 7,
    "objectives": [
      "Learn to use try/catch blocks for error handling",
      "Master debugging techniques and tools",
      "Understand common error types and prevention strategies"
    ],
    "intro": "Error handling is crucial for creating robust applications that gracefully handle unexpected situations. Debugging skills help you identify, understand, and fix issues in your code efficiently.\n\nIn this lesson, you'll learn about different error types like syntax errors, runtime errors, and logical errors. We'll explore try/catch blocks for handling exceptions and finally blocks for cleanup operations.\n\nYou'll master debugging techniques using console methods, breakpoints, and browser developer tools. We'll cover strategies for effective logging, error tracking, and preventive coding practices.\n\nBy the end of this lesson, you'll be able to write defensive code that handles errors gracefully, debug complex issues systematically, and implement logging for better application monitoring. You'll understand how to create user-friendly error messages while maintaining security.\n\nWe'll work through practical examples showing how to handle network failures, invalid user input, and other common error scenarios in real applications.",
    "code": {
      "example": "// Try/catch for error handling\ntry {\n  const result = riskyOperation();\n  console.log(\"Success:\", result);\n} catch (error) {\n  console.error(\"Error occurred:\", error.message);\n  // Handle error appropriately\n} finally {\n  // Cleanup operations\n  console.log(\"Cleanup completed\");\n}\n\n// Throwing custom errors\nfunction validateAge(age) {\n  if (age < 0) {\n    throw new Error(\"Age cannot be negative\");\n  }\n  if (age > 150) {\n    throw new Error(\"Age seems unrealistic\");\n  }\n  return true;\n}\n\ntry {\n  validateAge(-5);\n} catch (error) {\n  console.error(\"Validation failed:\", error.message);\n}\n\n// Different error types\ntry {\n  // ReferenceError\n  console.log(undefinedVariable);\n  \n  // TypeError\n  null.someMethod();\n  \n  // SyntaxError\n  eval(\"invalid javascript code\");\n  \n} catch (error) {\n  if (error instanceof ReferenceError) {\n    console.error(\"Reference error:\", error.message);\n  } else if (error instanceof TypeError) {\n    console.error(\"Type error:\", error.message);\n  } else {\n    console.error(\"Other error:\", error.message);\n  }\n}\n\n// Debugging with console methods\nconst data = {name: \"John\", age: 30, hobbies: [\"reading\", \"coding\"]};\nconsole.log(\"Basic log:\", data);\nconsole.table(data.hobbies);\nconsole.warn(\"This is a warning\");\nconsole.error(\"This is an error\");\n\n// Conditional debugging\nconst debug = true;\nif (debug) {\n  console.log(\"Debug info:\", data);\n}",
      "explanation": "This example demonstrates error handling with try/catch, custom error throwing, error type checking, and various console debugging methods. Notice how different error types are caught and handled appropriately.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not handling errors that can be anticipated",
        "solution": "Use try/catch blocks around operations that might fail, like network requests or user input processing",
        "severity": "high"
      },
      {
        "mistake": "Swallowing errors without proper handling",
        "solution": "Always log errors or take appropriate action when catching them, don't just ignore them",
        "severity": "high"
      },
      {
        "mistake": "Overusing console.log for debugging in production code",
        "solution": "Use conditional debugging or remove console.log statements before deployment",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Form Validator",
        "description": "Create a form validation system that handles various input errors gracefully and provides helpful feedback.",
        "checkpoints": [
          "Implement try/catch blocks around validation logic",
          "Throw custom errors for specific validation failures",
          "Handle different error types with appropriate user messages",
          "Use console methods for debugging validation issues"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 50,
    "difficulty": "Beginner",
    "tags": [
      "Error Handling",
      "Debugging",
      "Exceptions"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-8",
    "moduleSlug": "programming-fundamentals",
    "title": "Basic Algorithms and Problem Solving",
    "order": 8,
    "objectives": [
      "Learn fundamental algorithms (searching, sorting)",
      "Master problem-solving approaches and techniques",
      "Understand algorithm complexity and efficiency"
    ],
    "intro": "Algorithms are step-by-step procedures for solving problems or completing tasks. Developing algorithmic thinking is essential for writing efficient code and tackling complex programming challenges.\n\nIn this lesson, you'll learn fundamental algorithms like linear search, binary search, bubble sort, and selection sort. We'll explore problem-solving strategies including breaking down complex problems, identifying patterns, and choosing appropriate data structures.\n\nYou'll understand basic algorithm complexity using Big O notation to analyze time and space efficiency. This knowledge helps you make informed decisions about which algorithms and data structures to use in different situations.\n\nBy the end of this lesson, you'll be able to approach programming problems systematically, implement basic algorithms correctly, and evaluate the efficiency of your solutions. You'll develop the analytical skills needed for more advanced algorithmic challenges.\n\nWe'll work through practical examples showing how algorithms solve real-world problems like searching contact lists, sorting product catalogs, and optimizing data processing tasks.",
    "code": {
      "example": "// Linear search\nfunction linearSearch(arr, target) {\n  for (let i = 0; i < arr.length; i++) {\n    if (arr[i] === target) {\n      return i; // Return index if found\n    }\n  }\n  return -1; // Return -1 if not found\n}\n\n// Binary search (for sorted arrays)\nfunction binarySearch(arr, target) {\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    \n    if (arr[mid] === target) {\n      return mid;\n    } else if (arr[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  \n  return -1;\n}\n\n// Bubble sort\nfunction bubbleSort(arr) {\n  const sorted = [...arr]; // Create copy to avoid mutating original\n  \n  for (let i = 0; i < sorted.length - 1; i++) {\n    for (let j = 0; j < sorted.length - i - 1; j++) {\n      if (sorted[j] > sorted[j + 1]) {\n        // Swap elements\n        [sorted[j], sorted[j + 1]] = [sorted[j + 1], sorted[j]];\n      }\n    }\n  }\n  \n  return sorted;\n}\n\n// Selection sort\nfunction selectionSort(arr) {\n  const sorted = [...arr];\n  \n  for (let i = 0; i < sorted.length - 1; i++) {\n    let minIndex = i;\n    \n    // Find minimum element in remaining array\n    for (let j = i + 1; j < sorted.length; j++) {\n      if (sorted[j] < sorted[minIndex]) {\n        minIndex = j;\n      }\n    }\n    \n    // Swap minimum element with first element\n    if (minIndex !== i) {\n      [sorted[i], sorted[minIndex]] = [sorted[minIndex], sorted[i]];\n    }\n  }\n  \n  return sorted;\n}\n\n// Example usage\nconst numbers = [64, 34, 25, 12, 22, 11, 90];\nconsole.log(\"Original:\", numbers);\nconsole.log(\"Linear search for 25:\", linearSearch(numbers, 25));\nconsole.log(\"Sorted (bubble):\", bubbleSort(numbers));\nconsole.log(\"Sorted (selection):\", selectionSort(numbers));\nconst sortedNumbers = selectionSort(numbers);\nconsole.log(\"Binary search for 25:\", binarySearch(sortedNumbers, 25));",
      "explanation": "This example shows fundamental algorithms: linear search for unsorted data, binary search for sorted data, and two sorting algorithms. Notice the time complexity differences and when to use each approach.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not considering algorithm efficiency for large datasets",
        "solution": "Understand Big O notation and choose algorithms appropriate for your data size",
        "severity": "high"
      },
      {
        "mistake": "Mutating original arrays when sorting/searching",
        "solution": "Create copies of arrays before modifying them, or use methods that don't mutate originals",
        "severity": "medium"
      },
      {
        "mistake": "Implementing overly complex solutions for simple problems",
        "solution": "Start with simple, readable solutions and optimize only when necessary",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Algorithm Implementer",
        "description": "Implement additional algorithms and compare their performance with the ones shown in the lesson.",
        "checkpoints": [
          "Implement insertion sort and compare it with bubble sort",
          "Create a function to measure algorithm execution time",
          "Test algorithms with different data sizes to observe performance differences",
          "Document the time complexity of each algorithm implemented"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 70,
    "difficulty": "Beginner",
    "tags": [
      "Algorithms",
      "Problem Solving",
      "Complexity"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-9",
    "moduleSlug": "programming-fundamentals",
    "title": "Strings and String Manipulation",
    "order": 9,
    "objectives": [
      "Master string operations and methods",
      "Learn regular expressions for pattern matching",
      "Understand string encoding and formatting"
    ],
    "intro": "Strings are sequences of characters used to represent text in programming. Effective string manipulation is essential for processing user input, generating output, and working with textual data in applications.\n\nIn this lesson, you'll learn essential string methods for searching, replacing, and transforming text. We'll explore string concatenation, template literals, and formatting techniques for creating dynamic content.\n\nYou'll dive into regular expressions for powerful pattern matching and text processing. We'll cover regex syntax, common patterns, and practical applications like input validation and data extraction.\n\nBy the end of this lesson, you'll be able to manipulate strings effectively, validate and format text input, and use regular expressions for complex pattern matching tasks. You'll understand how to handle string encoding and avoid common string-related issues.\n\nWe'll work through practical examples showing how string manipulation processes user names, formats addresses, validates email addresses, and extracts data from text sources.",
    "code": {
      "example": "// String basics\nconst greeting = \"Hello, World!\";\nconsole.log(greeting.length);        // 13\nconsole.log(greeting.charAt(0));     // \"H\"\nconsole.log(greeting.indexOf(\"World\")); // 7\nconsole.log(greeting.substring(0, 5)); // \"Hello\"\n\n// String methods\nconst text = \"  JavaScript is awesome!  \";\nconsole.log(text.trim());           // \"JavaScript is awesome!\"\nconsole.log(text.toUpperCase());    // \"  JAVASCRIPT IS AWESOME!  \"\nconsole.log(text.toLowerCase());    // \"  javascript is awesome!  \"\n\n// String searching\nconst sentence = \"The quick brown fox jumps over the lazy dog\";\nconsole.log(sentence.includes(\"fox\"));     // true\nconsole.log(sentence.startsWith(\"The\"));   // true\nconsole.log(sentence.endsWith(\"dog\"));     // true\n\n// String replacement\nconst message = \"Hello, NAME. Welcome to PLACE.\";\nconst personalized = message.replace(\"NAME\", \"John\").replace(\"PLACE\", \"our website\");\nconsole.log(personalized); // \"Hello, John. Welcome to our website.\"\n\n// Template literals\nconst name = \"Alice\";\nconst age = 25;\nconst info = `User: ${name}, Age: ${age}, Next year: ${age + 1}`;\nconsole.log(info); // \"User: Alice, Age: 25, Next year: 26\"\n\n// Regular expressions\nconst emailPattern = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\nconst validEmail = \"user@example.com\";\nconst invalidEmail = \"invalid.email\";\n\nconsole.log(emailPattern.test(validEmail));   // true\nconsole.log(emailPattern.test(invalidEmail)); // false\n\n// String extraction with regex\nconst phoneText = \"Call me at 123-456-7890 or 987-654-3210\";\nconst phonePattern = /\\d{3}-\\d{3}-\\d{4}/g;\nconst phones = phoneText.match(phonePattern);\nconsole.log(phones); // [\"123-456-7890\", \"987-654-3210\"]\n\n// String splitting\nconst csvData = \"name,age,city\";\nconst columns = csvData.split(\",\");\nconsole.log(columns); // [\"name\", \"age\", \"city\"]",
      "explanation": "This example demonstrates string operations including length checking, character access, searching, replacement, template literals, and regular expressions for pattern matching.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not escaping special characters in strings",
        "solution": "Use proper escaping for quotes, backslashes, and other special characters",
        "severity": "high"
      },
      {
        "mistake": "Writing overly complex regular expressions",
        "solution": "Start with simple patterns and build complexity gradually, test regex patterns thoroughly",
        "severity": "medium"
      },
      {
        "mistake": "Not validating user input strings",
        "solution": "Always validate and sanitize user input to prevent security issues",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Text Processor",
        "description": "Create a text processing utility that performs various string operations and validations.",
        "checkpoints": [
          "Implement functions to format names (title case, remove extra spaces)",
          "Create email and phone number validators using regular expressions",
          "Build a text analyzer that counts words, characters, and sentences",
          "Develop a search function that finds and highlights keywords in text"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 55,
    "difficulty": "Beginner",
    "tags": [
      "Strings",
      "Regular Expressions",
      "Text Processing"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-10",
    "moduleSlug": "programming-fundamentals",
    "title": "Numbers and Mathematical Operations",
    "order": 10,
    "objectives": [
      "Master number types and mathematical operations",
      "Learn Math object methods and constants",
      "Understand number formatting and precision issues"
    ],
    "intro": "Numbers are fundamental data types used for mathematical calculations, counting, and representing quantitative values in programming. Understanding number handling is crucial for financial calculations, scientific computations, and general arithmetic operations.\n\nIn this lesson, you'll learn about different number types including integers, floating-point numbers, and special values like Infinity and NaN. We'll explore arithmetic operators, assignment operators, and operator precedence rules.\n\nYou'll dive into the Math object, which provides powerful mathematical functions and constants. We'll cover rounding methods, random number generation, and trigonometric functions for more advanced calculations.\n\nBy the end of this lesson, you'll be able to perform precise mathematical operations, handle number formatting and precision issues, and use mathematical functions effectively. You'll understand common pitfalls with floating-point arithmetic and how to avoid them.\n\nWe'll work through practical examples showing how number handling processes financial data, generates random values for games, and performs scientific calculations.",
    "code": {
      "example": "// Number basics\nconst integer = 42;\nconst float = 3.14159;\nconst scientific = 1.23e5; // 123000\n\nconsole.log(integer + float);    // 45.14159\nconsole.log(integer * float);    // 131.94678\nconsole.log(integer / float);    // 13.369000000000001\n\n// Number methods\nconst num = 123.456;\nconsole.log(num.toFixed(2));     // \"123.46\"\nconsole.log(num.toPrecision(5)); // \"123.46\"\nconsole.log(num.toString());     // \"123.456\"\n\n// Math object\nconsole.log(Math.PI);            // 3.141592653589793\nconsole.log(Math.E);             // 2.718281828459045\n\n// Rounding methods\nconst value = 4.7;\nconsole.log(Math.round(value));  // 5\nconsole.log(Math.floor(value));  // 4\nconsole.log(Math.ceil(value));   // 5\nconsole.log(Math.trunc(value));  // 4\n\n// Random numbers\nconst randomInt = Math.floor(Math.random() * 100) + 1; // 1-100\nconsole.log(\"Random number:\", randomInt);\n\n// Power and roots\nconsole.log(Math.pow(2, 3));     // 8\nconsole.log(Math.sqrt(16));      // 4\nconsole.log(Math.cbrt(27));      // 3\n\n// Trigonometric functions\nconst angle = Math.PI / 4; // 45 degrees in radians\nconsole.log(Math.sin(angle));    // 0.7071067811865476\nconsole.log(Math.cos(angle));    // 0.7071067811865476\nconsole.log(Math.tan(angle));    // 0.9999999999999999\n\n// Absolute value and signs\nconsole.log(Math.abs(-5));       // 5\nconsole.log(Math.sign(-5));      // -1\nconsole.log(Math.sign(5));       // 1\nconsole.log(Math.sign(0));       // 0\n\n// Max and min\nconsole.log(Math.max(1, 5, 3, 9, 2)); // 9\nconsole.log(Math.min(1, 5, 3, 9, 2)); // 1\n\n// Handling precision issues\nconst result = 0.1 + 0.2;\nconsole.log(result);             // 0.30000000000000004\nconsole.log(result.toFixed(2));  // \"0.30\"\nconsole.log(Math.round(result * 100) / 100); // 0.3",
      "explanation": "This example demonstrates number operations, Math object methods, rounding techniques, random number generation, and handling floating-point precision issues.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not understanding floating-point precision issues",
        "solution": "Use toFixed() or rounding methods for financial calculations, avoid direct equality comparisons with floats",
        "severity": "high"
      },
      {
        "mistake": "Incorrectly generating random numbers in desired ranges",
        "solution": "Use Math.floor(Math.random() * (max - min + 1)) + min for inclusive ranges",
        "severity": "medium"
      },
      {
        "mistake": "Not validating numeric user input",
        "solution": "Always check if input is actually a number using isNaN() or Number.isNaN()",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Calculator Utility",
        "description": "Create a calculator that performs various mathematical operations and handles number formatting correctly.",
        "checkpoints": [
          "Implement basic arithmetic operations with proper error handling",
          "Create functions for advanced mathematical operations (power, roots, trigonometry)",
          "Handle floating-point precision issues in calculations",
          "Format numbers appropriately for display (currency, percentages, etc.)"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 50,
    "difficulty": "Beginner",
    "tags": [
      "Numbers",
      "Mathematics",
      "Precision"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-11",
    "moduleSlug": "programming-fundamentals",
    "title": "Dates and Time Handling",
    "order": 11,
    "objectives": [
      "Learn to work with Date objects",
      "Master date formatting and manipulation",
      "Understand time zones and internationalization"
    ],
    "intro": "Date and time handling is essential for applications that need to track events, schedule tasks, or display time-based information. Proper date manipulation ensures accurate time calculations and user-friendly date displays.\n\nIn this lesson, you'll learn to create and manipulate Date objects, understanding the various constructor options and methods for getting and setting date components. We'll explore date arithmetic for calculating time differences and scheduling future events.\n\nYou'll dive into date formatting techniques, including internationalization options for displaying dates in different locales. We'll cover common challenges with time zones and how to handle them in web applications.\n\nBy the end of this lesson, you'll be able to work with dates and times effectively, format them for different audiences, and handle time zone complexities. You'll understand how to perform date calculations and avoid common pitfalls with date manipulation.\n\nWe'll work through practical examples showing how date handling manages user registrations, calculates deadlines, schedules notifications, and displays time-sensitive information.",
    "code": {
      "example": "// Creating Date objects\nconst now = new Date();\nconst specificDate = new Date(\"2025-12-25\");\nconst components = new Date(2025, 11, 25, 14, 30, 0); // Year, Month, Day, Hour, Minute, Second\n\nconsole.log(now.toString());\nconsole.log(specificDate.toDateString());\nconsole.log(components.toLocaleString());\n\n// Getting date components\nconst date = new Date();\nconsole.log(date.getFullYear());    // 2025\nconsole.log(date.getMonth());       // 0-11 (January is 0)\nconsole.log(date.getDate());        // 1-31\nconsole.log(date.getDay());         // 0-6 (Sunday is 0)\nconsole.log(date.getHours());       // 0-23\nconsole.log(date.getMinutes());     // 0-59\nconsole.log(date.getSeconds());     // 0-59\n\n// Setting date components\nconst myDate = new Date();\nmyDate.setFullYear(2026);\nmyDate.setMonth(5);        // June (0-based)\nmyDate.setDate(15);\nconsole.log(myDate.toDateString());\n\n// Date arithmetic\nconst start = new Date(\"2025-01-01\");\nconst end = new Date(\"2025-12-31\");\nconst diffMs = end - start; // Difference in milliseconds\nconst diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));\nconsole.log(`Days in 2025: ${diffDays}`);\n\n// Adding days\nfunction addDays(date, days) {\n  const result = new Date(date);\n  result.setDate(result.getDate() + days);\n  return result;\n}\n\nconst today = new Date();\nconst nextWeek = addDays(today, 7);\nconsole.log(`Today: ${today.toDateString()}`);\nconsole.log(`Next week: ${nextWeek.toDateString()}`);\n\n// Date formatting\nconst eventDate = new Date(\"2025-07-04T19:30:00\");\n\n// Different formatting options\nconsole.log(eventDate.toDateString());           // \"Jul 4 2025\"\nconsole.log(eventDate.toLocaleDateString());     // Locale-specific date\nconsole.log(eventDate.toLocaleTimeString());     // Locale-specific time\nconsole.log(eventDate.toLocaleString());         // Locale-specific date and time\n\n// Custom formatting\nconst options = {\n  weekday: 'long',\n  year: 'numeric',\n  month: 'long',\n  day: 'numeric',\n  hour: '2-digit',\n  minute: '2-digit'\n};\n\nconsole.log(eventDate.toLocaleDateString('en-US', options));\n// \"Friday, July 4, 2025, 07:30 PM\"\n\n// Time zone handling\nconst utcDate = new Date();\nconsole.log(utcDate.toUTCString());\nconsole.log(utcDate.getTimezoneOffset()); // Minutes offset from UTC",
      "explanation": "This example demonstrates creating Date objects, accessing and modifying date components, performing date arithmetic, and formatting dates for display in different locales.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not accounting for zero-based months (0-11)",
        "solution": "Remember that January is 0, December is 11 when using Date constructors and setMonth/getMonth",
        "severity": "high"
      },
      {
        "mistake": "Ignoring time zones in web applications",
        "solution": "Always consider user time zones and use UTC for consistent storage, convert to local time for display",
        "severity": "high"
      },
      {
        "mistake": "Performing date calculations with string manipulation",
        "solution": "Use Date objects and proper date arithmetic methods instead of string parsing",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Event Scheduler",
        "description": "Create an event scheduling system that handles date calculations, formatting, and time zone considerations.",
        "checkpoints": [
          "Implement functions to calculate days until events",
          "Create date formatters for different display formats",
          "Handle time zone conversions for international events",
          "Build a function to determine if a date is in the past, present, or future"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 55,
    "difficulty": "Beginner",
    "tags": [
      "Dates",
      "Time",
      "Internationalization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  },
  {
    "id": "programming-fundamentals-lesson-12",
    "moduleSlug": "programming-fundamentals",
    "title": "File I/O and Data Persistence",
    "order": 12,
    "objectives": [
      "Learn basic file operations in Node.js",
      "Master JSON data handling and serialization",
      "Understand localStorage for client-side persistence"
    ],
    "intro": "Data persistence is crucial for applications that need to store and retrieve information beyond the current session. Understanding file operations and storage mechanisms enables you to build applications that maintain state and user data.\n\nIn this lesson, you'll learn file input/output operations in Node.js, including reading from and writing to files. We'll explore different file formats and the importance of proper error handling in file operations.\n\nYou'll dive into JSON (JavaScript Object Notation) for data serialization and exchange. We'll cover parsing JSON data, generating JSON from objects, and handling JSON-related errors safely.\n\nBy the end of this lesson, you'll be able to work with files effectively, handle JSON data properly, and implement basic data persistence in both server-side and client-side applications. You'll understand the differences between various storage options and when to use each.\n\nWe'll work through practical examples showing how file operations manage configuration data, how JSON handles API responses, and how localStorage persists user preferences.",
    "code": {
      "example": "// Node.js file operations (require 'fs' module)\nconst fs = require('fs');\n\n// Reading a file\ntry {\n  const data = fs.readFileSync('example.txt', 'utf8');\n  console.log('File contents:', data);\n} catch (error) {\n  console.error('Error reading file:', error.message);\n}\n\n// Writing to a file\nconst content = 'Hello, File System!\\nThis is a new line.';\ntry {\n  fs.writeFileSync('output.txt', content);\n  console.log('File written successfully');\n} catch (error) {\n  console.error('Error writing file:', error.message);\n}\n\n// JSON handling\nconst userData = {\n  name: \"John Doe\",\n  age: 30,\n  preferences: {\n    theme: \"dark\",\n    notifications: true\n  }\n};\n\n// Converting object to JSON string\nconst jsonString = JSON.stringify(userData, null, 2);\nconsole.log('JSON string:', jsonString);\n\n// Parsing JSON string to object\ntry {\n  const parsedData = JSON.parse(jsonString);\n  console.log('Parsed object:', parsedData);\n} catch (error) {\n  console.error('Error parsing JSON:', error.message);\n}\n\n// Client-side localStorage (browser environment)\n// Storing data\nlocalStorage.setItem('username', 'johndoe');\nlocalStorage.setItem('userPreferences', JSON.stringify(userData));\n\n// Retrieving data\nconst username = localStorage.getItem('username');\nconsole.log('Username:', username);\n\nconst storedPreferences = localStorage.getItem('userPreferences');\nif (storedPreferences) {\n  try {\n    const preferences = JSON.parse(storedPreferences);\n    console.log('User preferences:', preferences);\n  } catch (error) {\n    console.error('Error parsing stored preferences:', error.message);\n  }\n}\n\n// Removing data\n// localStorage.removeItem('username');\n// localStorage.clear(); // Remove all items\n\n// Checking localStorage availability\nfunction isStorageAvailable() {\n  try {\n    const test = '__storage_test__';\n    localStorage.setItem(test, test);\n    localStorage.removeItem(test);\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nif (isStorageAvailable()) {\n  console.log('localStorage is available');\n} else {\n  console.log('localStorage is not available');\n}",
      "explanation": "This example demonstrates file operations in Node.js, JSON serialization and parsing, and client-side data persistence with localStorage. Notice the error handling around file and JSON operations.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not handling file operation errors properly",
        "solution": "Always use try/catch blocks around file operations and handle different error types appropriately",
        "severity": "high"
      },
      {
        "mistake": "Circular references in objects when using JSON.stringify",
        "solution": "Remove or handle circular references before stringifying, or use a replacer function",
        "severity": "high"
      },
      {
        "mistake": "Assuming localStorage is always available",
        "solution": "Check for localStorage availability and provide fallbacks for private browsing modes",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Data Manager",
        "description": "Create a data management system that handles file operations, JSON processing, and client-side storage.",
        "checkpoints": [
          "Implement functions to read and write configuration files",
          "Create utilities for safe JSON parsing and serialization",
          "Build a client-side storage manager with fallbacks",
          "Handle errors gracefully in all data operations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Beginner",
    "tags": [
      "File I/O",
      "JSON",
      "Persistence"
    ],
    "lastUpdated": "2025-10-01T06:42:16.313Z",
    "version": "1.0.0"
  }
]
