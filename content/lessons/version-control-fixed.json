[
  {
    "id": "version-control-lesson-1",
    "moduleSlug": "version-control",
    "title": "Git Fundamentals and Setup",
    "order": 1,
    "objectives": [
      "Understand what version control is and why it's essential",
      "Install and configure Git with proper user settings",
      "Learn basic Git terminology and concepts"
    ],
    "intro": "Version control is the foundation of modern software development, allowing developers to track changes, collaborate effectively, and maintain project history safely. Git is the most widely used version control system in the industry.\n\nIn this lesson, you'll learn why version control is crucial for any development project, from solo work to large team collaborations. You'll understand how Git tracks file changes over time and enables multiple developers to work on the same codebase without conflicts.\n\nGit's distributed nature means every developer has a complete copy of the project history, making it robust and flexible. You'll discover how this differs from older centralized systems and why it's become the industry standard.\n\nProper Git configuration is essential for professional development workflows. You'll learn to set up your identity, configure helpful settings, and understand the basic Git workflow that you'll use throughout your development career.\n\nBy the end of this lesson, you'll have Git installed and configured correctly, understand fundamental concepts like repositories and commits, and be ready to start tracking your code changes professionally. This foundation is critical for all software development work.",
    "code": {
      "example": "# Git Installation and Configuration\n\n# Install Git (varies by operating system)\n# Windows: Download from git-scm.com\n# macOS: brew install git\n# Linux: sudo apt-get install git (Ubuntu/Debian)\n\n# Configure your identity (required for commits)\ngit config --global user.name \"Your Name\"\ngit config --global user.email \"your.email@example.com\"\n\n# Configure helpful settings\ngit config --global init.defaultBranch main\ngit config --global core.editor \"code --wait\"  # Use VS Code as editor\ngit config --global pull.rebase false  # Use merge strategy for pulls\n\n# Check your configuration\ngit config --list\n\n# Get help for any Git command\ngit help <command>\ngit <command> --help\n\n# Initialize a new Git repository\nmkdir my-project\ncd my-project\ngit init\n\n# Check repository status\ngit status\n\n# Create a simple README file\necho \"# My Project\" > README.md\n\n# Add file to staging area\ngit add README.md\n\n# Create your first commit\ngit commit -m \"Initial commit: Add README\"\n\n# View commit history\ngit log\ngit log --oneline  # Compact view\n\n# Check current branch\ngit branch\n\n# View repository status\ngit status",
      "explanation": "This example shows the complete Git setup process from installation to first commit. Notice the global configuration settings that will apply to all your Git repositories, and the basic workflow of add, commit, and status checking.",
      "language": "bash"
    },
    "pitfalls": [
      {
        "mistake": "Not configuring user.name and user.email before first commit",
        "solution": "Always configure your Git identity with 'git config --global user.name' and 'user.email'",
        "severity": "high"
      },
      {
        "mistake": "Using 'git add .' without checking what files are being added",
        "solution": "Use 'git status' first to see changes, then add files selectively or use 'git add -A' intentionally",
        "severity": "medium"
      },
      {
        "mistake": "Working without a .gitignore file",
        "solution": "Create a .gitignore file to exclude build files, dependencies, and sensitive information",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Setup Your First Git Repository",
        "description": "Create a complete Git repository with proper configuration and initial commit.",
        "checkpoints": [
          "Install Git and verify the installation with 'git --version'",
          "Configure your global Git settings (name, email, default branch)",
          "Initialize a new repository and create a README.md file",
          "Make your first commit and view the project history"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Beginner",
    "tags": [
      "Git",
      "GitHub",
      "Version Control"
    ],
    "lastUpdated": "2025-10-01T06:42:16.316Z",
    "version": "1.0.0"
  },
  {
    "id": "version-control-lesson-2",
    "moduleSlug": "version-control",
    "title": "Branching and Merging",
    "order": 2,
    "objectives": [
      "Create and switch between Git branches effectively",
      "Merge branches and resolve basic conflicts",
      "Understand different branching strategies and workflows"
    ],
    "intro": "Branching is one of Git's most powerful features, allowing developers to work on different features simultaneously without interfering with each other's code. Understanding branching is essential for professional development workflows.\n\nIn this lesson, you'll learn how branches allow you to experiment with new features, fix bugs, or try different approaches while keeping your main codebase stable. Each branch represents an independent line of development that can be merged back when ready.\n\nMerging combines changes from different branches, and while Git handles most merges automatically, you'll learn to resolve conflicts when the same code is modified in different ways. This skill is crucial for team collaboration.\n\nYou'll explore different branching strategies used in the industry, from simple feature branches to more complex workflows like Git Flow. Understanding these patterns helps you choose the right approach for your projects.\n\nBy mastering branching and merging, you'll be able to work confidently on multiple features simultaneously, collaborate effectively with team members, and maintain a clean, organized project history that reflects your development process.",
    "code": {
      "example": "# Git Branching and Merging Workflow\n\n# View all branches (local and remote)\ngit branch -a\n\n# Create a new branch for feature development\ngit branch feature/user-authentication\n# OR create and switch in one command\ngit checkout -b feature/user-authentication\n# OR using newer syntax\ngit switch -c feature/user-authentication\n\n# Switch between branches\ngit checkout main\ngit switch feature/user-authentication\n\n# Make changes and commit on feature branch\necho \"function login() { /* TODO */ }\" > auth.js\ngit add auth.js\ngit commit -m \"Add basic authentication function\"\n\n# Switch back to main and create another branch\ngit switch main\ngit switch -c feature/user-profile\n\n# Make different changes\necho \"function getUserProfile() { /* TODO */ }\" > profile.js\ngit add profile.js\ngit commit -m \"Add user profile function\"\n\n# Merge feature branch into main\ngit switch main\ngit merge feature/user-authentication\n\n# If there's a merge conflict, you'll see something like:\n# <<<<<<< HEAD\n# Your changes\n# =======\n# Incoming changes\n# >>>>>>> feature/user-authentication\n\n# Resolve conflicts by editing the file, then:\ngit add <conflicted-file>\ngit commit -m \"Resolve merge conflict\"\n\n# Delete merged branch (optional)\ngit branch -d feature/user-authentication\n\n# View branch history with graph\ngit log --oneline --graph --all\n\n# Create a merge commit even for fast-forward merges\ngit merge --no-ff feature/user-profile\n\n# Rebase instead of merge (alternative workflow)\ngit switch feature/user-profile\ngit rebase main\ngit switch main\ngit merge feature/user-profile  # This will be fast-forward\n\n# Undo a merge (if needed)\ngit reset --hard HEAD~1\n\n# View differences between branches\ngit diff main..feature/user-profile",
      "explanation": "This example demonstrates the complete branching workflow including creating branches, making commits, merging, and handling conflicts. Notice the different merge strategies and how to maintain a clean project history.",
      "language": "bash"
    },
    "pitfalls": [
      {
        "mistake": "Working directly on the main branch for all changes",
        "solution": "Create feature branches for new work and keep main stable and deployable",
        "severity": "high"
      },
      {
        "mistake": "Force pushing to shared branches",
        "solution": "Never use 'git push --force' on branches that others are working on",
        "severity": "high"
      },
      {
        "mistake": "Not testing merged code before pushing",
        "solution": "Always test the merged result before pushing to ensure functionality",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Feature Branch Workflow",
        "description": "Practice the complete feature branch workflow with merge conflict resolution.",
        "checkpoints": [
          "Create two feature branches with conflicting changes to the same file",
          "Merge the first branch successfully into main",
          "Attempt to merge the second branch and resolve the conflict",
          "View the project history with git log --graph to see the branch structure"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Beginner",
    "tags": [
      "Git",
      "GitHub",
      "Version Control"
    ],
    "lastUpdated": "2025-10-01T06:42:16.316Z",
    "version": "1.0.0"
  },
  {
    "id": "version-control-lesson-3",
    "moduleSlug": "version-control",
    "title": "Remote Repositories and Collaboration",
    "order": 3,
    "objectives": [
      "Work with remote repositories on GitHub and other platforms",
      "Collaborate effectively with team members using Git",
      "Manage multiple remotes and synchronize code changes"
    ],
    "intro": "Remote repositories enable developers to collaborate on projects by storing code on centralized servers like GitHub, GitLab, or Bitbucket. Understanding how to work with remotes is essential for team development and open-source contributions.\n\nIn this lesson, you'll learn how to connect your local repository to remote repositories, push your changes to share with others, and pull updates from teammates. You'll understand the difference between cloning, forking, and adding remotes, and when to use each approach.\n\nCollaboration with Git involves more than just pushing and pulling code. You'll learn about pull requests, code reviews, and how to handle merge conflicts that arise when multiple developers modify the same code. These skills are crucial for working in professional development teams.\n\nManaging multiple remotes allows you to work with different versions of a project, contribute to open-source projects, and maintain connections to various repositories. You'll discover how to add, remove, and manage multiple remote repositories effectively.\n\nBy mastering remote repositories and collaboration, you'll be able to contribute to projects, work effectively in teams, and participate in the broader developer community through open-source contributions.",
    "code": {
      "example": "# Working with Remote Repositories and Collaboration\n\n# Clone an existing repository\ngit clone https://github.com/username/repository.git\ncd repository\n\n# View remote repositories\ngit remote -v\n\n# Add a new remote repository\ngit remote add upstream https://github.com/original/repository.git\n\n# Push changes to remote repository\ngit push origin main\n\n# Push a new branch to remote\ngit push -u origin feature/new-feature\n\n# Pull changes from remote repository\ngit pull origin main\n\n# Fetch changes without merging (safer approach)\ngit fetch origin\ngit merge origin/main\n\n# Create a pull request workflow\n# 1. Create feature branch\ngit switch -c feature/user-login\n\n# 2. Make changes and commit\necho 'function login() { /* implementation */ }' > login.js\ngit add login.js\ngit commit -m 'Add user login functionality'\n\n# 3. Push branch to remote\ngit push -u origin feature/user-login\n\n# 4. Create pull request on GitHub (done via web interface)\n\n# Sync with upstream repository (for forked projects)\ngit fetch upstream\ngit switch main\ngit merge upstream/main\ngit push origin main\n\n# Handle merge conflicts\n# When git pull shows conflicts:\n# 1. Edit conflicted files to resolve conflicts\n# 2. Add resolved files\ngit add resolved-file.js\n# 3. Commit the merge\ngit commit\n\n# Review collaborators' changes before merging\ngit log --oneline -10\ngit show commit-hash\n\n# Configure remote tracking branches\ngit branch -u origin/feature-branch\n\n# Remove a remote repository\ngit remote remove upstream\n\n# Check remote branch status\ngit remote show origin\n\n# Pull changes with rebase (keeps history cleaner)\ngit pull --rebase origin main\n\n# Push all branches\ngit push --all origin\n\n# Delete remote branch\ngit push origin --delete feature/old-feature",
      "explanation": "This example demonstrates the complete workflow for working with remote repositories, including cloning, pushing, pulling, handling conflicts, and collaborating with team members. Notice the difference between push and pull operations, and how to manage multiple remotes for forked projects.",
      "language": "bash"
    },
    "pitfalls": [
      {
        "mistake": "Pushing directly to main branch without code review",
        "solution": "Use feature branches and pull requests for all changes, even in small teams",
        "severity": "high"
      },
      {
        "mistake": "Not regularly syncing with remote repositories",
        "solution": "Fetch and merge changes frequently to avoid large conflicts",
        "severity": "medium"
      },
      {
        "mistake": "Hard resetting or force pushing to shared branches",
        "solution": "Never use 'git push --force' on branches others are working on; use '--force-with-lease' if absolutely necessary",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Collaborate on a Shared Repository",
        "description": "Practice the complete collaboration workflow including forking, cloning, making changes, and submitting pull requests.",
        "checkpoints": [
          "Fork an existing repository and clone it locally",
          "Create a feature branch and make changes",
          "Push the branch and create a pull request",
          "Sync with upstream changes and resolve any conflicts"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 45,
    "difficulty": "Intermediate",
    "tags": [
      "Git",
      "GitHub",
      "Version Control",
      "Collaboration"
    ],
    "lastUpdated": "2025-10-03T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "version-control-lesson-4",
    "moduleSlug": "version-control",
    "title": "Git Workflows and Best Practices",
    "order": 4,
    "objectives": [
      "Implement industry-standard Git workflows like Git Flow and GitHub Flow",
      "Follow best practices for commit messages, branching, and code organization",
      "Use tags and releases for version management"
    ],
    "intro": "Git workflows provide structured approaches to managing code changes, enabling teams to collaborate effectively while maintaining code quality and stability. Understanding different workflows helps you choose the right approach for your project's needs.\n\nIn this lesson, you'll learn about popular Git workflows including Git Flow, GitHub Flow, and trunk-based development. Each workflow has its own advantages and is suited to different project sizes, team structures, and release cycles.\n\nBest practices for Git usage extend beyond just the technical commands. You'll discover how to write effective commit messages, organize your branches meaningfully, and structure your repository for maximum clarity and maintainability.\n\nVersion management through tags and releases allows you to mark significant points in your project's history. You'll learn how to create semantic version tags, manage release branches, and use GitHub's release features to distribute your software.\n\nBy mastering Git workflows and best practices, you'll be able to contribute to projects more effectively, maintain cleaner project histories, and follow industry standards that make your code more professional and collaborative.",
    "code": {
      "example": "# Git Workflows and Best Practices\n\n# GitHub Flow (simple workflow for continuous deployment)\n# 1. Create feature branch from main\ngit switch -c feature/user-dashboard\n\n# 2. Add commits with descriptive messages\ngit add dashboard.html\ngit commit -m 'Add user dashboard layout'\n\n# 3. Push branch to remote\ngit push -u origin feature/user-dashboard\n\n# 4. Open pull request (via GitHub UI)\n\n# 5. Code review and discussion\n\n# 6. Merge into main (via GitHub UI)\n\n# 7. Deploy main to production\n\n# Git Flow (more complex workflow for versioned releases)\n# Initialize Git Flow\ngit flow init\n\n# Start a new feature\ngit flow feature start user-authentication\n\n# Finish feature (merge to develop)\ngit flow feature finish user-authentication\n\n# Start a release\ngit flow release start v1.2.0\n\n# Finish release (merge to main and develop, create tag)\ngit flow release finish v1.2.0\n\n# Start a hotfix\ngit flow hotfix start critical-bugfix\n\n# Finish hotfix\ngit flow hotfix finish critical-bugfix\n\n# Best practices for commit messages\n# Use imperative mood, capitalize first letter, no period at end\ngit commit -m 'Add user authentication endpoints'\ngit commit -m 'Fix null pointer exception in profile service'\ngit commit -m 'Update README with installation instructions'\n\n# Semantic versioning with tags\n# Create annotated tag for release\ngit tag -a v1.0.0 -m 'Release version 1.0.0'\n\n# Push tag to remote\ngit push origin v1.0.0\n\n# List all tags\ngit tag -l\n\n# Create lightweight tag for milestone\ngit tag milestone-1\n\n# Check out code at specific tag\ngit checkout v1.0.0\n\n# Delete local tag\ngit tag -d v1.0.0\n\n# Delete remote tag\ngit push --delete origin v1.0.0\n\n# Best practices for branch naming\ngit switch -c feature/payment-integration  # Features\ngit switch -c bugfix/login-error         # Bug fixes\ngit switch -c hotfix/security-patch       # Urgent fixes\ngit switch -c refactor/api-endpoints      # Refactoring\ngit switch -c docs/update-readme          # Documentation\n\n# Squash commits before merging\ngit rebase -i HEAD~3  # Interactive rebase last 3 commits\n\n# Cherry-pick specific commits\ngit cherry-pick commit-hash\n\n# Stash changes temporarily\ngit stash\ngit stash pop\n\n# Clean up merged branches\ngit branch --merged | grep -v main | xargs git branch -d",
      "explanation": "This example demonstrates various Git workflows including GitHub Flow and Git Flow, along with best practices for commit messages, branch naming, tagging, and repository maintenance. Notice the structured approach to different types of work and how to maintain a clean project history.",
      "language": "bash"
    },
    "pitfalls": [
      {
        "mistake": "Writing vague or uninformative commit messages",
        "solution": "Use the imperative mood, be specific about changes, and follow conventional commit formats",
        "severity": "medium"
      },
      {
        "mistake": "Creating long-lived feature branches that diverge significantly",
        "solution": "Keep branches short-lived and integrate frequently with the main branch",
        "severity": "high"
      },
      {
        "mistake": "Not following consistent branch naming conventions",
        "solution": "Establish team conventions for branch names (feature/, bugfix/, hotfix/) and stick to them",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement a Complete Git Workflow",
        "description": "Practice a complete Git workflow from feature development to release, following best practices for commits, branching, and versioning.",
        "checkpoints": [
          "Create a feature branch with proper naming convention",
          "Make multiple commits with descriptive messages following best practices",
          "Open and merge a pull request with code review",
          "Tag and release a version of your project"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Intermediate",
    "tags": [
      "Git",
      "GitHub",
      "Version Control",
      "Workflows",
      "Best Practices"
    ],
    "lastUpdated": "2025-10-03T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "version-control-lesson-5",
    "moduleSlug": "version-control",
    "title": "Advanced Git Commands and Techniques",
    "order": 5,
    "objectives": [
      "Master advanced Git commands for complex repository management",
      "Use interactive rebasing to clean up commit history",
      "Apply cherry-picking and revert strategies for precise changes",
      "Implement advanced merging techniques for complex workflows"
    ],
    "intro": "Advanced Git commands provide powerful tools for managing complex repositories and maintaining clean, professional commit histories. These techniques are essential for experienced developers who need to manipulate repository history, selectively apply changes, and resolve complex merge scenarios.\n\nIn this lesson, you'll learn interactive rebasing, which allows you to rewrite commit history by reordering, editing, or combining commits. This skill is invaluable for cleaning up feature branches before merging them into main branches, ensuring that your project history is clear and logical.\n\nCherry-picking enables you to selectively apply individual commits from one branch to another, which is particularly useful when you need to backport bug fixes or forward-port features without merging entire branches. You'll also learn about the revert command for safely undoing changes without rewriting history.\n\nAdvanced merging techniques go beyond basic merge operations to handle complex scenarios like subtree merges and octopus merges. Understanding these techniques helps you manage complex project structures and integrate multiple feature branches simultaneously.\n\nBy mastering these advanced Git commands, you'll be able to maintain professional-quality repositories, collaborate more effectively with team members, and recover from complex version control scenarios with confidence.",
    "code": {
      "example": "# Advanced Git Commands and Techniques\n\n# Interactive Rebasing\n# Squash multiple commits into one\ngit rebase -i HEAD~3\n\n# In the editor, change 'pick' to 'squash' or 's' for commits to combine\n# pick abc1234 Add user authentication\n# squash def5678 Fix authentication bug\n# squash ghi9012 Update auth tests\n\n# Edit a specific commit\ngit rebase -i HEAD~3\n# Change 'pick' to 'edit' for the commit you want to modify\n# Make changes, then:\ngit add .\ngit commit --amend\ngit rebase --continue\n\n# Reorder commits\ngit rebase -i HEAD~3\n# Simply reorder the lines in the editor\n\n# Split a commit into multiple commits\ngit rebase -i HEAD~1\n# Change 'pick' to 'edit'\n# Reset the commit but keep changes\ngit reset HEAD~1\n# Add and commit changes in smaller chunks\ngit add part1.js\ngit commit -m 'Add first part of feature'\ngit add part2.js\ngit commit -m 'Add second part of feature'\ngit rebase --continue\n\n# Cherry-picking specific commits\ngit cherry-pick commit-hash\n\n# Cherry-pick a range of commits\ngit cherry-pick start-commit^..end-commit\n\n# Cherry-pick without auto-committing\ngit cherry-pick -n commit-hash\n\n# Revert commits (creates new commits that undo changes)\ngit revert commit-hash\n\n# Revert a merge commit (must specify which parent)\ngit revert -m 1 merge-commit-hash\n\n# Find commits that introduced a bug with bisect\ngit bisect start\ngit bisect bad  # Current commit is bad\ngit bisect good v1.0.0  # Last known good commit\n# Git checks out a commit, test it, then:\ngit bisect good  # or git bisect bad\ngit bisect reset  # End bisect session\n\n# Advanced merging techniques\n# Merge without auto-committing\ngit merge --no-commit branch-name\n\n# Squash merge (combine all changes into one commit)\ngit merge --squash feature-branch\ngit commit -m 'Add all feature changes'\n\n# Abort a merge with conflicts\ngit merge --abort\n\n# Use merge strategy options\ngit merge -X theirs branch-name  # Prefer their changes in conflicts\ngit merge -X ours branch-name   # Prefer our changes in conflicts\n\n# Find commits that affect specific files\ngit log --follow filename.js\n\n# Show commits that would be merged\ngit merge-tree main feature-branch\n\n# Clean up unreachable objects\ngit gc\n\n# Remove untracked files and directories\ngit clean -fd  # -f for files, -d for directories\n\n# Stash with message\ngit stash push -m 'Work in progress on feature X'\n\n# Apply specific stash\ngit stash apply stash@{1}\n\n# Show stash contents without applying\ngit stash show -p stash@{0}",
      "explanation": "This example demonstrates advanced Git techniques including interactive rebasing for history manipulation, cherry-picking for selective commit application, and advanced merging strategies. Notice how these commands allow for precise control over repository history while maintaining the distributed nature of Git.",
      "language": "bash"
    },
    "pitfalls": [
      {
        "mistake": "Rewriting history on shared branches",
        "solution": "Only use interactive rebase on feature branches that haven't been pushed or shared with others",
        "severity": "high"
      },
      {
        "mistake": "Cherry-picking merge commits",
        "solution": "Avoid cherry-picking merge commits as they lose their context; cherry-pick individual commits instead",
        "severity": "medium"
      },
      {
        "mistake": "Using git clean without previewing files first",
        "solution": "Always run 'git clean -n' first to see what would be deleted before actually deleting with -f",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Clean Up Commit History with Interactive Rebase",
        "description": "Practice advanced history manipulation techniques to create a clean, professional commit history.",
        "checkpoints": [
          "Create a feature branch with multiple small commits",
          "Use interactive rebase to squash related commits together",
          "Reorder commits to improve logical flow",
          "Edit a commit message during the rebase process"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Git",
      "GitHub",
      "Version Control",
      "Advanced Techniques"
    ],
    "lastUpdated": "2025-10-03T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "version-control-lesson-6",
    "moduleSlug": "version-control",
    "title": "Git Troubleshooting and Recovery",
    "order": 6,
    "objectives": [
      "Diagnose and resolve common Git issues and errors",
      "Recover from accidental commits and branch deletions",
      "Use reflog to navigate Git's history of actions",
      "Handle complex merge conflicts and repository corruption"
    ],
    "intro": "Even experienced developers encounter Git issues that require troubleshooting and recovery techniques. Understanding how to diagnose problems and recover from mistakes is crucial for maintaining productivity and protecting your work.\n\nIn this lesson, you'll learn to use Git's diagnostic tools to understand what went wrong when commands fail. You'll explore reflog, Git's safety net that tracks all actions taken in your repository, allowing you to recover from almost any mistake.\n\nRecovery techniques cover everything from undoing accidental commits to restoring deleted branches and recovering from force pushes. These skills are invaluable when mistakes happen, which they inevitably will in any development workflow.\n\nComplex merge conflicts and repository corruption can seem daunting, but with the right approach, they're almost always recoverable. You'll learn systematic approaches to resolving difficult conflicts and repairing damaged repositories.\n\nBy mastering Git troubleshooting and recovery, you'll gain confidence to experiment with advanced Git features, knowing that you can recover from mistakes. This knowledge is essential for professional development workflows where repository integrity is critical.",
    "code": {
      "example": "# Git Troubleshooting and Recovery\n\n# Diagnose common issues\n# Check repository status\ngit status\n\n# View detailed status\ngit status -v\n\n# Check for configuration issues\ngit config --list\n\n# Verify remote connections\ngit remote -v\n\n# Test remote connectivity\ngit ls-remote origin\n\n# Using reflog to recover from mistakes\n# View reflog\ngit reflog\n\n# Recover a deleted branch\ngit branch feature-branch commit-hash\n\n# Recover to a previous state\ngit reset --hard HEAD@{2}  # Go back 2 actions\n\n# Recover a specific commit\ngit cherry-pick commit-hash\n\n# Recover from accidental commit\n# If you just committed but haven't pushed:\ngit reset --soft HEAD~1  # Keep changes staged\ngit reset HEAD~1       # Unstage changes\ngit reset --hard HEAD~1  # Discard changes completely\n\n# Recover from accidental branch deletion\n# Find the commit with reflog\ngit reflog\n# Recreate the branch\ngit branch branch-name commit-hash\n\n# Recover from force push disasters\n# On the machine that did the force push:\ngit reflog\n# Find the commit before force push\ngit push origin commit-hash:branch-name\n\n# Fix detached HEAD state\ngit switch main  # or whatever branch you want\n\n# Resolve merge conflicts\n# When merge conflict occurs:\n# 1. Edit conflicted files\n# 2. Look for conflict markers:\n# <<<<<<< HEAD\n# Your changes\n# =======\n# Their changes\n# >>>>>>> branch-name\n\n# 3. Resolve conflicts and remove markers\n# 4. Add resolved files\ngit add resolved-file.js\n# 5. Complete merge\ngit commit\n\n# Abort a merge with conflicts\ngit merge --abort\n\n# Abort a rebase\ngit rebase --abort\n\n# Handle corrupted repository\n# Check repository integrity\ngit fsck\n\n# Recover from index corruption\ngit rm --cached -r .\ngit reset --hard\n\n# Recover from object corruption\n# Find corrupt objects\ngit fsck --full\n# Try to recover\ngit prune\n# As last resort\ngit reflog expire --expire=now --all\ngit gc --prune=now\n\n# Fix common configuration issues\n# Reset to default branch name\ngit config --global init.defaultBranch main\n\n# Fix line ending issues\ngit config --global core.autocrlf true  # Windows\ngit config --global core.autocrlf input  # macOS/Linux\n\n# Fix credential helper issues\ngit config --global credential.helper cache  # Cache for 15 minutes\ngit config --global credential.helper store  # Store permanently (less secure)\n\n# Recover from large file commits\n# Install git filter-repo if not available\n# Remove large file from history\ngit filter-repo --path-glob '*.zip' --invert-paths\n\n# Fix 'detached HEAD' after checking out tag\ngit switch -c new-branch-name\n\n# Recover uncommitted changes after hard reset\ngit fsck --unreachable\ngit merge commit-hash  # Merge the dangling commit\n\n# Fix 'fatal: refusing to merge unrelated histories'\ngit pull origin main --allow-unrelated-histories\n\n# Clean up after failed operations\ngit gc\ngit prune\n\n# Check for and remove sensitive data from history\ngit filter-repo --invert-paths --path path/to/sensitive/file\n\n# Fix 'index.lock' file issues\nrm .git/index.lock  # Only if you're sure no Git process is running",
      "explanation": "This example demonstrates comprehensive Git troubleshooting and recovery techniques, including reflog usage for recovery, conflict resolution strategies, and repository repair methods. Notice how Git's reflog acts as a safety net, allowing recovery from almost any mistake as long as the repository hasn't been garbage collected.",
      "language": "bash"
    },
    "pitfalls": [
      {
        "mistake": "Panic and force delete .git directory when things go wrong",
        "solution": "Almost all Git issues are recoverable; use reflog and diagnostic commands first",
        "severity": "high"
      },
      {
        "mistake": "Running git reset --hard without understanding consequences",
        "solution": "Always check git status and consider alternatives like --soft or --mixed before using --hard",
        "severity": "high"
      },
      {
        "mistake": "Not regularly backing up important unpushed work",
        "solution": "Push work frequently and use git bundle for backups of local commits",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Recover from Common Git Mistakes",
        "description": "Practice recovery techniques for various Git mishaps using reflog and other diagnostic tools.",
        "checkpoints": [
          "Accidentally delete a branch and recover it using reflog",
          "Undo an accidental commit while preserving changes",
          "Resolve a complex merge conflict with multiple conflicting files",
          "Fix a corrupted repository using Git's diagnostic and repair tools"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Git",
      "GitHub",
      "Version Control",
      "Troubleshooting",
      "Recovery"
    ],
    "lastUpdated": "2025-10-03T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "version-control-lesson-7",
    "moduleSlug": "version-control",
    "title": "Git Hooks and Automation",
    "order": 7,
    "objectives": [
      "Implement Git hooks to automate development workflows",
      "Create custom pre-commit and post-commit hooks for code quality",
      "Use server-side hooks for continuous integration and deployment",
      "Integrate Git hooks with popular development tools and linters"
    ],
    "intro": "Git hooks are scripts that Git executes automatically at specific points in the Git workflow, enabling powerful automation of development processes. They're essential for enforcing code quality standards, automating repetitive tasks, and integrating with continuous integration systems.\n\nIn this lesson, you'll learn about client-side hooks that run on your local machine, including pre-commit hooks that can prevent bad commits, prepare-commit-msg hooks that format commit messages, and post-commit hooks that notify team members of changes.\n\nServer-side hooks run on remote repositories and can enforce project policies, trigger deployments, or integrate with issue tracking systems. You'll explore pre-receive hooks that can reject pushes that don't meet standards and post-receive hooks that trigger CI/CD pipelines.\n\nIntegration with popular development tools allows you to automate code linting, testing, and security scanning as part of your Git workflow. You'll learn to set up hooks that run linters, execute tests, and scan for security vulnerabilities before code is committed or pushed.\n\nBy mastering Git hooks and automation, you'll be able to create robust development workflows that enforce quality standards, reduce manual tasks, and integrate seamlessly with modern development practices like continuous integration and deployment.",
    "code": {
      "example": "# Git Hooks and Automation\n\n# Client-side hooks (in .git/hooks/)\n\n# Pre-commit hook (.git/hooks/pre-commit)\n#!/bin/sh\n\n# Run linter on staged JavaScript files\nFILES=$(git diff --cached --name-only --diff-filter=ACMR | grep '\\.js$')\nif [ -n \"$FILES\" ]; then\n  ./node_modules/.bin/eslint $FILES\n  if [ $? -ne 0 ]; then\n    echo \"ESLint failed. Please fix errors before committing.\"\n    exit 1\n  fi\nfi\n\n# Prevent committing to main branch\ngit rev-parse --abbrev-ref HEAD | grep '^main$' > /dev/null\nif [ $? -eq 0 ]; then\n  echo \"Direct commits to main branch are not allowed.\"\n  exit 1\nfi\n\n# Check for console.log statements\nFILES=$(git diff --cached --name-only --diff-filter=ACMR | grep '\\.js$')\nif [ -n \"$FILES\" ]; then\n  if grep -n 'console\\.log' $FILES; then\n    echo \"Found console.log statements. Please remove before committing.\"\n    exit 1\n  fi\nfi\n\n# Post-commit hook (.git/hooks/post-commit)\n#!/bin/sh\n\n# Notify team of commit (example with curl)\nCOMMIT_MSG=$(git log -1 --pretty=format:'%h %s')\ncurl -X POST -H 'Content-Type: application/json' \\\n  -d \"{\\\"text\\\": \\\"New commit: $COMMIT_MSG\\\"}\" \\\n  https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK\n\n# Pre-push hook (.git/hooks/pre-push)\n#!/bin/sh\n\n# Run tests before pushing\nnpm test\nif [ $? -ne 0 ]; then\n  echo \"Tests failed. Push aborted.\"\n  exit 1\nfi\n\n# Check for large files (>1MB)\nFILES=$(git diff --name-only HEAD @{u} | xargs ls -l | awk '$5 > 1048576 {print $9}')\nif [ -n \"$FILES\" ]; then\n  echo \"Large files detected. Consider using Git LFS:\"\n  echo \"$FILES\"\n  exit 1\nfi\n\n# Server-side hooks (on remote repository)\n\n# Pre-receive hook (pre-receive hook on server)\n#!/bin/sh\n\n# Read from stdin (oldrev newrev refname)\nwhile read oldrev newrev refname; do\n  # Enforce linear history\n  if [ \"$refname\" = \"refs/heads/main\" ]; then\n    # Check if merge commits are being pushed\n    merge_commits=$(git rev-list --merges \"$oldrev..$newrev\")\n    if [ -n \"$merge_commits\" ]; then\n      echo \"Merge commits not allowed on main branch. Use rebase instead.\"\n      exit 1\n    fi\n  fi\n  \n  # Enforce commit message format\n  commit_messages=$(git log --format=%s \"$oldrev..$newrev\")\n  echo \"$commit_messages\" | while read message; do\n    if ! echo \"$message\" | grep -qE '^(feat|fix|docs|style|refactor|test|chore)(\\([a-z0-9_-]+\\))?: [a-z].+'; then\n      echo \"Invalid commit message format: $message\"\n      echo \"Use conventional commits: https://www.conventionalcommits.org/\"\n      exit 1\n    fi\n  done\ndone\n\n# Post-receive hook (post-receive hook on server)\n#!/bin/sh\n\n# Trigger CI/CD pipeline\nwhile read oldrev newrev refname; do\n  if [ \"$refname\" = \"refs/heads/main\" ]; then\n    # Trigger deployment\n    curl -X POST https://ci.example.com/job/deploy/build \\\n      -H 'Authorization: Bearer YOUR_TOKEN'\n  fi\ndone\n\n# Working with Husky for easier hook management\n# Install Husky\nnpm install husky --save-dev\n\n# Enable Git hooks\nnpx husky install\n\n# Add pre-commit hook\nnpx husky add .husky/pre-commit \"npm test\"\n\n# Add commit-msg hook\nnpx husky add .husky/commit-msg 'npx --no-install commitlint --edit \"$1\"'\n\n# Example package.json configuration for Husky\n{\n  \"scripts\": {\n    \"prepare\": \"husky install\"\n  },\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"lint-staged\",\n      \"commit-msg\": \"commitlint -E HUSKY_GIT_PARAMS\"\n    }\n  },\n  \"lint-staged\": {\n    \"*.js\": [\n      \"eslint --fix\",\n      \"git add\"\n    ]\n  }\n}\n\n# Creating custom hooks for specific workflows\n\n# Pre-commit hook for security scanning\n#!/bin/sh\n\n# Scan for secrets\nif command -v git-secrets >/dev/null 2>&1; then\n  git secrets --pre_commit_hook || exit 1\nfi\n\n# Scan for vulnerabilities in dependencies\nif [ -f package-lock.json ]; then\n  npm audit --audit-level high\n  if [ $? -ne 0 ]; then\n    echo \"High severity vulnerabilities found. Fix before committing.\"\n    exit 1\n  fi\nfi\n\n# Make hooks executable\nchmod +x .git/hooks/pre-commit\nchmod +x .git/hooks/post-commit\nchmod +x .git/hooks/pre-push\n\n# Testing hooks\n# Temporarily disable hooks\ngit commit --no-verify -m \"Test commit\"\n\n# List all available hooks\ngit help hooks\n\n# Debug hooks by adding echo statements\n# echo \"Debug: Running pre-commit hook\" >&2\n\n# Share hooks with team\n# Create hooks directory in project root\nmkdir -p hooks\n# Move hook scripts to project directory\ncp .git/hooks/pre-commit hooks/\n# Document hook installation in README\n\necho '# Git Hooks\\n\\nRun ./hooks/install-hooks.sh to install.' > hooks/README.md\n\n# Installation script for team members (hooks/install-hooks.sh)\n#!/bin/sh\ncp hooks/* .git/hooks/\nchmod +x .git/hooks/*\necho \"Hooks installed successfully!\"",
      "explanation": "This example demonstrates Git hooks for automation, including client-side hooks for code quality enforcement and server-side hooks for CI/CD integration. Notice how hooks can prevent bad commits, enforce standards, and trigger automated processes throughout the development lifecycle.",
      "language": "bash"
    },
    "pitfalls": [
      {
        "mistake": "Writing hooks that are too slow or resource-intensive",
        "solution": "Keep hooks fast and lightweight; move heavy operations to CI/CD pipelines",
        "severity": "high"
      },
      {
        "mistake": "Not making hook scripts executable",
        "solution": "Always run 'chmod +x' on hook scripts or they won't execute",
        "severity": "high"
      },
      {
        "mistake": "Writing hooks that fail silently",
        "solution": "Include proper error handling and informative error messages in hooks",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Automated Code Quality Checks",
        "description": "Create and configure Git hooks to automate code quality enforcement and team notification.",
        "checkpoints": [
          "Set up a pre-commit hook that runs a linter on staged files",
          "Create a pre-push hook that prevents pushing broken tests",
          "Implement a post-commit hook that notifies team members of changes",
          "Configure Husky to manage hooks in a team environment"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Git",
      "GitHub",
      "Version Control",
      "Automation",
      "CI/CD"
    ],
    "lastUpdated": "2025-10-03T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "version-control-lesson-8",
    "moduleSlug": "version-control",
    "title": "Git Internals and Performance Optimization",
    "order": 8,
    "objectives": [
      "Understand Git's internal data structures and object model",
      "Optimize Git performance for large repositories and teams",
      "Use Git's plumbing commands for advanced operations",
      "Implement best practices for repository maintenance and cleanup"
    ],
    "intro": "Understanding Git's internals provides insight into how Git works under the hood, enabling you to optimize performance, troubleshoot complex issues, and leverage advanced features effectively. This knowledge is particularly valuable when working with large repositories or complex workflows.\n\nIn this lesson, you'll explore Git's object model, including blobs, trees, commits, and tags, and how these objects form Git's content-addressable filesystem. Understanding these fundamentals helps you grasp why Git behaves the way it does and how to work with it more effectively.\n\nPerformance optimization techniques address common bottlenecks in large repositories, including strategies for managing large files with Git LFS, optimizing Git configuration for speed, and using shallow clones for faster operations. These skills are essential for maintaining productivity in large-scale projects.\n\nGit's plumbing commands provide low-level access to Git's internal operations, allowing you to perform advanced tasks that aren't possible with the standard porcelain commands. You'll learn to use these tools for repository analysis, custom operations, and deep troubleshooting.\n\nRepository maintenance practices ensure your Git repositories remain healthy and performant over time. You'll discover how to clean up unnecessary objects, optimize storage, and prevent common performance issues through regular maintenance.\n\nBy mastering Git internals and performance optimization, you'll be able to work more effectively with complex repositories, troubleshoot difficult issues, and maintain optimal performance even as your projects grow in size and complexity.",
    "code": {
      "example": "# Git Internals and Performance Optimization\n\n# Understanding Git's Object Model\n\n# View object types\ngit cat-file -t commit-hash  # Shows object type\ngit cat-file -p commit-hash  # Shows object content\n\n# View commit structure\ngit cat-file -p HEAD\n# Output shows:\n# tree tree-hash\n# parent parent-commit-hash\n# author Author Name <email> timestamp\n# committer Committer Name <email> timestamp\n# \n# commit message\n\n# View tree objects (directory structure)\ngit cat-file -p tree-hash\n\n# View blob objects (file contents)\ngit cat-file -p blob-hash\n\n# Hash a file to see its blob hash\necho 'content' | git hash-object --stdin\n\n# Performance optimization for large repositories\n\n# Use shallow clones for faster cloning\ngit clone --depth 1 https://github.com/user/repo.git\n\n# Shallow fetch\ngit fetch --depth 5\n\n# Use sparse-checkout for partial repository\ngit sparse-checkout init --cone\ngit sparse-checkout set path/to/directory\n\n# Configure performance settings\ngit config --global gc.auto 2500\ngit config --global pack.threads 1\ngit config --global core.preloadindex true\ngit config --global core.untrackedcache true\n\n# Optimize for large files with Git LFS\ngit lfs install\ngit lfs track \"*.psd\"\ngit add .gitattributes\ngit add large-file.psd\ngit commit -m \"Add large Photoshop file with LFS\"\n\n# Use partial clone for enormous repositories\ngit clone --filter=blob:none https://github.com/user/large-repo.git\n\n# Performance monitoring and analysis\n\n# Measure command performance\ngit config --global advice.statTimes true\n\n# Analyze repository size\ngit count-objects -vH\n\n# Find large objects in history\ngit rev-list --objects --all | \\\n  git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' | \\\n  awk '/^blob/ {print substr($0, index($0, $4))}' | \\\n  sort --numeric-sort --key=2 | \\\n  tail -n 20\n\n# Analyze commit history\ngit log --oneline --graph --all\n\n# Find commits that modified specific files\ngit log --follow -- filename\n\n# Plumbing commands for advanced operations\n\n# Low-level commit creation\ngit write-tree  # Create tree object\ntree_hash=$(git write-tree)\ncommit_hash=$(git commit-tree -m \"Commit message\" \"$tree_hash\")\ngit update-ref refs/heads/branch-name \"$commit_hash\"\n\n# Manual merge base finding\ngit merge-base branch1 branch2\n\n# Low-level diff operations\ngit diff-tree HEAD~1 HEAD  # Compare trees\ngit diff-index HEAD         # Compare index to HEAD\ngit diff-files              # Compare working directory to index\n\n# Repository maintenance and cleanup\n\n# Garbage collection\ngit gc --aggressive\n\n# Prune unreachable objects\ngit prune\n\n# Expire reflog entries\ngit reflog expire --expire=now --all\n\n# Optimize pack files\ngit repack -ad\n\n# Clean up unreachable objects\ngit fsck --unreachable\n\n# Remove large files from history (dangerous!)\ngit filter-repo --path-glob '*.zip' --invert-paths\n\n# Optimize branch management\n# Clean up merged branches\ngit branch --merged | grep -v main | xargs git branch -d\n\n# Prune remote-tracking branches\ngit remote prune origin\n\n# Repository health checks\n\n# Verify repository integrity\ngit fsck --full\n\n# Check for corrupt objects\ngit fsck --strict\n\n# Verify object connectivity\ngit fsck --connectivity-only\n\n# Performance benchmarking\ngit rev-parse HEAD  # Time this for baseline\n\n# Configuration for large repositories\n# Increase buffer sizes\ngit config --global http.postBuffer 524288000\n\n# Use background maintenance\ngit config --global core.longpaths true\n\n# Enable multi-threaded index preloading\ngit config --global core.preloadindex true\n\n# Optimize for Windows file systems\ngit config --global core.fscache true\n\n# Advanced performance techniques\n\n# Use commit graphs for faster log operations\ngit commit-graph write --reachable\n\n# Enable multi-pack indexing\ngit multi-pack-index write\n\n# Use background maintenance\ngit config --global gc.writeCommitGraph true\n\n# Configure for network performance\ngit config --global http.lowSpeedLimit 0\ngit config --global http.lowSpeedTime 999999\n\n# Repository statistics\ngit shortlog -s -n  # Contributor statistics\ngit log --pretty=format:\"%h %ad | %s%d [%an]\" --date=short\ngit diff --stat HEAD~10 HEAD  # Changes over last 10 commits",
      "explanation": "This example demonstrates Git internals and performance optimization techniques, including object model exploration, performance tuning for large repositories, plumbing commands for advanced operations, and maintenance practices. Notice how understanding Git's internals enables more effective troubleshooting and optimization.",
      "language": "bash"
    },
    "pitfalls": [
      {
        "mistake": "Running aggressive maintenance commands on shared repositories without coordination",
        "solution": "Coordinate with team members before running gc, repack, or filter-repo commands that rewrite history",
        "severity": "high"
      },
      {
        "mistake": "Not configuring Git for large repositories, leading to performance issues",
        "solution": "Use shallow clones, sparse checkouts, and Git LFS for repositories with large files",
        "severity": "high"
      },
      {
        "mistake": "Using plumbing commands without understanding their implications",
        "solution": "Thoroughly understand plumbing commands before using them, as they can corrupt repositories if used incorrectly",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Optimize a Large Repository",
        "description": "Apply performance optimization techniques to improve Git operations in a large repository.",
        "checkpoints": [
          "Analyze repository size and identify performance bottlenecks",
          "Configure Git settings for optimal performance with large repositories",
          "Implement Git LFS for large binary files",
          "Perform repository maintenance to clean up unnecessary objects"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 75,
    "difficulty": "Expert",
    "tags": [
      "Git",
      "GitHub",
      "Version Control",
      "Performance",
      "Internals"
    ],
    "lastUpdated": "2025-10-03T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "version-control-lesson-9",
    "moduleSlug": "version-control",
    "title": "Team Collaboration and Code Review Processes",
    "order": 9,
    "objectives": [
      "Implement effective team collaboration workflows with Git",
      "Master code review processes and best practices",
      "Use Git features to facilitate team communication and coordination",
      "Establish repository governance and contribution guidelines"
    ],
    "intro": "Effective team collaboration is essential for successful software development projects. Git provides powerful features that support collaborative workflows, but realizing their full potential requires understanding best practices and establishing clear processes.\n\nIn this lesson, you'll learn about pull request workflows and code review best practices that ensure code quality while maintaining team productivity. You'll discover how to write effective pull request descriptions, provide constructive feedback, and manage review cycles efficiently.\n\nTeam communication and coordination techniques leverage Git's features to keep everyone informed about project changes and progress. You'll explore strategies for managing multiple contributors, coordinating complex feature development, and handling conflicting changes.\n\nRepository governance establishes clear guidelines for contribution, code quality, and project management. You'll learn to create and enforce contribution guidelines, establish code ownership patterns, and implement approval processes that balance quality with velocity.\n\nBy mastering team collaboration and code review processes, you'll be able to work effectively in development teams of any size, contribute to open-source projects, and lead successful software development initiatives with clear, efficient workflows.",
    "code": {
      "example": "# Team Collaboration and Code Review Processes\n\n# Effective Pull Request Workflows\n\n# Creating high-quality pull requests\n# 1. Keep PRs small and focused\ngit checkout -b feature/user-profile-ui\n\n# 2. Write descriptive commit messages\ngit commit -m \"feat(profile): add user profile UI components\"\ngit commit -m \"fix(profile): resolve responsive layout issues\"\n\n# 3. Create comprehensive PR description\n# Title: feat(profile): implement user profile UI\n# Description:\n# - Implements user profile page with avatar, bio, and settings\n# - Adds responsive design for mobile and desktop\n# - Includes unit tests for profile components\n# - Closes #123\n\n# 4. Link related issues\n# In PR description: \"Closes #123\" or \"Resolves #456\"\n\n# Code review best practices\n\n# As an author:\n# - Self-review your code before requesting review\n# - Include context in PR description\n# - Add comments to complex sections\n# - Respond promptly to feedback\n\n# As a reviewer:\n# - Focus on logic, architecture, and maintainability\n# - Provide constructive, specific feedback\n# - Approve when satisfied with changes\n# - Use GitHub's review features effectively\n\n# Example PR template\n\"\"\"\n## Description\nBrief summary of changes\n\n## Related Issue\nFixes #123\n\n## Implementation Details\n- What was changed\n- Why it was changed\n- Technical approach\n\n## Testing\n- How changes were tested\n- Test scenarios covered\n\n## Screenshots (if applicable)\nVisual representation of changes\n\n## Checklist\n- [ ] Code follows style guidelines\n- [ ] Tests have been added/updated\n- [ ] Documentation has been updated\n- [ ] No breaking changes\n\"\"\"\n\n# Managing multiple contributors\n\n# Coordinate feature development\ngit fetch origin\ngit checkout main\ngit pull origin main\ngit checkout -b feature/new-component\n\n# Sync with main branch regularly\ngit fetch origin\ngit rebase origin/main\n# OR\ngit pull --rebase origin main\n\n# Handle conflicting changes\n# When conflicts occur during rebase:\n# 1. Edit conflicted files\n# 2. Resolve conflicts\n# 3. Add resolved files\ngit add resolved-file.js\n# 4. Continue rebase\ngit rebase --continue\n\n# Team communication strategies\n\n# Use conventional commit messages\ngit commit -m \"feat(auth): implement OAuth login flow\"\ngit commit -m \"fix(api): resolve null pointer in user service\"\ngit commit -m \"docs(readme): update installation instructions\"\n\n# Tag team members in commits when relevant\ngit commit -m \"feat(dashboard): add analytics widgets (@john @sarah)\"\n\n# Use branch naming conventions\ngit checkout -b feature/payment-processing\ngit checkout -b bugfix/login-error\ngit checkout -b hotfix/security-patch\ngit checkout -b refactor/api-endpoints\ngit checkout -b docs/update-readme\n\n# Repository governance and contribution guidelines\n\n# Create CONTRIBUTING.md\n\"\"\"\n# Contributing to Project\n\n## Getting Started\n1. Fork the repository\n2. Clone your fork\n3. Create feature branch\n\n## Code Standards\n- Follow established style guides\n- Write unit tests for new features\n- Maintain existing code quality\n\n## Commit Messages\n- Use conventional commits\n- Be descriptive but concise\n- Reference related issues\n\n## Pull Request Process\n1. Ensure tests pass\n2. Update documentation\n3. Request review from maintainers\n4. Address feedback promptly\n\n## Code Review Guidelines\n- Focus on functionality and maintainability\n- Provide constructive feedback\n- Approve when satisfied\n\"\"\"\n\n# Implement branch protection rules\n# On GitHub:\n# - Require pull request reviews before merging\n# - Require status checks to pass\n# - Require branches to be up to date\n# - Include administrators\n\n# Use CODEOWNERS file\n\"\"\"\n# Code Owners\n* @maintainers\nsrc/components/ @frontend-team\nsrc/api/ @backend-team\nsrc/database/ @database-team\ndocs/ @documentation-team\n**/*.test.js @qa-team\n\"\"\"\n\n# Establish team workflows\n\n# Git Flow for versioned releases\ngit flow init\ngit flow feature start user-authentication\ngit flow feature finish user-authentication\ngit flow release start v2.0.0\ngit flow release finish v2.0.0\n\n# GitHub Flow for continuous deployment\n# 1. Create feature branch from main\ngit switch -c feature/new-feature\n# 2. Add commits\ngit add .\ngit commit -m \"Add new feature\"\n# 3. Push branch\ngit push -u origin feature/new-feature\n# 4. Create pull request\n# 5. Code review and discussion\n# 6. Merge to main\n# 7. Deploy main to production\n\n# Trunk-based development\ngit switch main\ngit pull origin main\ngit switch -c short-lived-feature\ngit add .\ngit commit -m \"Implement feature\"\ngit push -u origin short-lived-feature\n# Create PR, review, merge\n\ngit switch main\ngit pull origin main\n# Continue with next feature\n\n# Managing external contributions\n\n# Review forked pull requests\n# 1. Add remote for contributor's fork\ngit remote add contributor https://github.com/contributor/repo.git\n# 2. Fetch their changes\ngit fetch contributor\n# 3. Checkout their branch\ngit checkout -b contributor-feature contributor/feature-branch\n# 4. Review and test locally\n# 5. Merge or provide feedback\n\n# Handle community contributions\n# - Respond promptly to issues and PRs\n# - Provide clear feedback\n# - Recognize contributors\n# - Maintain consistent standards\n\n# Team onboarding\n\n# Create development setup guide\n\"\"\"\n# Development Setup\n\n## Prerequisites\n- Git 2.0+\n- Node.js 14+\n- Docker (for containerized services)\n\n## Setup\n```bash\ngit clone https://github.com/organization/project.git\ncd project\nnpm install\n```\n\n## Configuration\nCreate .env file with required environment variables\n\n## Running Tests\n```bash\nnpm test\nnpm run test:watch\n```\n\"\"\"\n\n# Implement pre-commit checks\ngit commit -m \"feat(api): add user endpoints\" --no-verify  # Bypass checks only when necessary\n\n# Use GitHub templates\n# PULL_REQUEST_TEMPLATE.md\n# ISSUE_TEMPLATE.md\n# CODE_OF_CONDUCT.md",
      "explanation": "This example demonstrates team collaboration and code review processes, including effective pull request workflows, code review best practices, and repository governance strategies. Notice how structured processes and clear communication facilitate effective team collaboration while maintaining code quality.",
      "language": "bash"
    },
    "pitfalls": [
      {
        "mistake": "Creating large, unfocused pull requests that are difficult to review",
        "solution": "Keep pull requests small and focused on single features or fixes to enable thorough, efficient reviews",
        "severity": "high"
      },
      {
        "mistake": "Not establishing clear contribution guidelines and code standards",
        "solution": "Create comprehensive CONTRIBUTING.md and CODEOWNERS files to set clear expectations for contributors",
        "severity": "high"
      },
      {
        "mistake": "Skipping code reviews or treating them as mere formalities",
        "solution": "Implement mandatory code reviews with specific quality gates and treat reviews as learning opportunities",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement Team Collaboration Workflow",
        "description": "Establish and practice effective team collaboration processes including pull requests, code reviews, and contribution guidelines.",
        "checkpoints": [
          "Create a comprehensive CONTRIBUTING.md file with team standards",
          "Set up branch protection rules and code review requirements",
          "Practice the complete pull request workflow with code review",
          "Implement CODEOWNERS for automatic reviewer assignment"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 75,
    "difficulty": "Intermediate",
    "tags": [
      "Git",
      "GitHub",
      "Version Control",
      "Collaboration",
      "Code Review"
    ],
    "lastUpdated": "2025-10-03T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "version-control-lesson-10",
    "moduleSlug": "version-control",
    "title": "Git Security and Advanced Repository Management",
    "order": 10,
    "objectives": [
      "Implement security best practices for Git repositories",
      "Manage repository access and permissions effectively",
      "Protect sensitive information and prevent data leaks",
      "Use advanced repository management techniques for enterprise environments"
    ],
    "intro": "Security and advanced repository management are critical for protecting intellectual property, maintaining compliance, and ensuring the integrity of software development processes. As projects grow and teams expand, robust security practices become increasingly important.\n\nIn this lesson, you'll learn to identify and protect sensitive information in Git repositories, including passwords, API keys, and other confidential data. You'll discover techniques for removing sensitive information from repository history and preventing future leaks through pre-commit hooks and automated scanning.\n\nAccess control and permission management ensure that only authorized individuals can make changes to critical branches or repositories. You'll explore branch protection rules, required reviews, and deployment controls that maintain code quality while enabling efficient workflows.\n\nAdvanced repository management techniques address the needs of enterprise environments with multiple teams, complex release cycles, and regulatory requirements. You'll learn about repository archiving, mirroring, and audit logging for compliance purposes.\n\nBy mastering Git security and advanced repository management, you'll be able to protect your organization's intellectual property, maintain compliance with industry standards, and implement professional-grade development processes that scale with your organization's needs.",
    "code": {
      "example": "# Git Security and Advanced Repository Management\n\n# Protecting sensitive information\n\n# Preventing sensitive data in commits\n# Create .gitignore to exclude sensitive files\n\"\"\"\n# Dependencies\nnode_modules/\nnpm-debug.log*\nyarn-debug.log*\nyarn-error.log*\n\n# Build outputs\ndist/\nbuild/\n*.min.js\n*.min.css\n\n# Environment variables\n.env\n.env.local\n.env.*.local\n\n# IDE and editor files\n.vscode/\n.idea/\n*.swp\n*.swo\n\n# OS generated files\n.DS_Store\nThumbs.db\n\n# Sensitive files\nconfig/secrets.yml\ncredentials.json\nprivate.key\n*.pem\n*.crt\n*.cer\n\"\"\"\n\n# Scan for sensitive data in history\ngit log -p -S \"password\" --all\ngit log -p -S \"API_KEY\" --all\ngit log -p -S \"SECRET\" --all\n\n# Remove sensitive data from history (dangerous!)\n# Using git filter-repo (recommended)\ngit filter-repo --path config/secrets.yml --invert-paths\n\n# Using BFG Repo-Cleaner (alternative)\nbfg --delete-files secrets.yml\n\n# Using git filter-branch (deprecated but sometimes necessary)\ngit filter-branch --force --index-filter \\\n  'git rm --cached --ignore-unmatch config/secrets.yml' \\\n  --prune-empty --tag-name-filter cat -- --all\n\n# After removing sensitive data\ngit reflog expire --expire=now --all\ngit gc --prune=now --aggressive\n\ngit push origin --force --all\ngit push origin --force --tags\n\n# Security scanning tools\n\n# Install git-secrets\ngit clone https://github.com/awslabs/git-secrets.git\ncd git-secrets\nsudo make install\n\ngit secrets --install\ngit secrets --register-aws\n\ngit secrets --scan\n\ngit secrets --scan-history\n\n# Pre-commit hook for secret detection\n#!/bin/sh\n\ngit secrets --pre_commit_hook || exit 1\n\n# Using trufflehog for advanced scanning\npip install trufflehog\ntrufflehog --regex --entropy=False https://github.com/user/repo.git\n\n# Repository access control and permissions\n\n# Branch protection rules (GitHub)\n# - Require pull request reviews before merging\n# - Require status checks to pass before merging\n# - Require branches to be up to date before merging\n# - Require linear history\n# - Require conversation resolution before merging\n# - Require deployments to succeed before merging\n# - Require signed commits\n# - Do not allow bypassing the above settings\n\n# Protected branch configuration\ngit config branch.main.mergeOptions '--ff-only'\n\n# Signed commits for verification\ngit config --global user.signingkey YOUR_GPG_KEY_ID\ngit config --global commit.gpgsign true\n\ngit commit -S -m \"feat: add security features\"\n\ngit log --show-signature\n\n# Verify signed commits\ngit verify-commit commit-hash\n\ngit verify-tag tag-name\n\n# Access control with deploy keys\n# Generate SSH key for deployment\nssh-keygen -t ed25519 -C \"deployment@company.com\" -f deploy_key\n\n# Add public key to repository deployment keys (GitHub UI)\n\n# Use deploy key for cloning\ngit clone git@github.com:company/private-repo.git\n\n# Advanced repository management\n\n# Repository mirroring\ngit clone --mirror https://github.com/company/main-repo.git\ncd main-repo.git\ngit remote set-url --push origin https://gitlab.company.com/backup/main-repo.git\ngit push --mirror\n\n# Automated mirroring script\n\"\"\"\n#!/bin/bash\n# mirror-repo.sh\n\ngit fetch --all\ngit push --mirror backup-remote\n\"\"\"\n\n# Repository archiving\ngit clone --bare https://github.com/company/project.git project-archive.git\ntar -czf project-archive.tar.gz project-archive.git\n\n# Repository splitting\ngit subtree push --prefix=src/module https://github.com/company/module-repo.git main\n\n# Audit logging and compliance\n\n# Generate contribution statistics\ngit shortlog -s -n --all\n\ngit log --pretty=format:\"%h %an %ad %s\" --date=short --all > audit-log.txt\n\n# Compliance reporting\ngit log --since=\"2023-01-01\" --until=\"2023-12-31\" \\\n  --pretty=format:\"%h %an %ad %s\" --date=iso > annual-report.txt\n\n# Export repository for compliance review\ngit bundle create project.bundle --all\n\n# Security best practices\n\n# Regular security audits\ngit fsck --full --strict\n\ngit gc --aggressive\n\n# Monitor for unauthorized changes\ngit log --oneline --grep=\"^fix\" --since=\"1 week ago\"\n\n# Verify repository integrity\ngit verify-pack -v .git/objects/pack/*.idx\n\n# Check for large files that might contain sensitive data\ngit rev-list --objects --all \\\n  | git cat-file --batch-check='%(objecttype) %(objectname) %(objectsize) %(rest)' \\\n  | awk '/^blob/ && $3 > 1000000 {print $4}'\n\n# Enterprise repository management\n\n# Repository templates for consistency\ngit clone https://github.com/company/template-repo.git new-project\ncd new-project\ngit remote set-url origin https://github.com/company/new-project.git\n\n# Multi-repository management\ngit submodule add https://github.com/company/shared-library.git libs/shared\n\ngit submodule update --init --recursive\n\n# Repository governance policies\n\n# Create SECURITY.md\n\"\"\"\n# Security Policy\n\n## Reporting a Vulnerability\n\nPlease report security vulnerabilities to security@company.com.\n\n## Supported Versions\n\n| Version | Supported          |\n| ------- | ------------------ |\n| 2.x.x   | :white_check_mark: |\n| 1.x.x   | :x:                |\n\n## Security Measures\n\n- All commits are signed\n- Branch protection on main branch\n- Required code reviews\n- Automated security scanning\n\"\"\"\n\n# Implement security scanning in CI/CD\n# .github/workflows/security.yml\n\"\"\"\nname: Security Scan\n\non: [push, pull_request]\n\njobs:\n  security:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n      with:\n        fetch-depth: 0\n    - name: Scan for secrets\n      run: |\n        pip install git-secrets\n        git secrets --scan\n        git secrets --scan-history\n\"\"\"\n\n# Disaster recovery planning\n\n# Backup strategy\ngit bundle create backup.bundle --all\n\n# Recovery procedure\ngit clone backup.bundle recovered-repo\ncd recovered-repo\ngit remote add origin https://github.com/company/recovered-repo.git\ngit push --all origin\ngit push --tags origin\n\n# Business continuity\ngit remote add backup https://gitlab.company.com/company/main-repo.git\ngit push backup --all\ngit push backup --tags",
      "explanation": "This example demonstrates Git security and advanced repository management techniques, including sensitive data protection, access control, compliance auditing, and enterprise-scale repository management. Notice how layered security approaches and systematic management practices protect repositories while enabling efficient development workflows.",
      "language": "bash"
    },
    "pitfalls": [
      {
        "mistake": "Committing sensitive information and only removing it from the latest commit",
        "solution": "Use git filter-repo or BFG to remove sensitive data from entire history, and rotate any exposed credentials immediately",
        "severity": "critical"
      },
      {
        "mistake": "Not implementing branch protection rules on critical branches",
        "solution": "Configure comprehensive branch protection rules including required reviews, status checks, and signed commits",
        "severity": "high"
      },
      {
        "mistake": "Neglecting regular security audits and repository maintenance",
        "solution": "Schedule regular security scans, integrity checks, and maintenance operations as part of your DevOps practices",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement Comprehensive Repository Security",
        "description": "Apply security best practices to protect a repository and implement advanced management techniques for enterprise environments.",
        "checkpoints": [
          "Set up comprehensive .gitignore to prevent sensitive file commits",
          "Implement pre-commit hooks for secret detection",
          "Configure branch protection rules with required reviews and status checks",
          "Create a repository backup and recovery plan"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 90,
    "difficulty": "Expert",
    "tags": [
      "Git",
      "GitHub",
      "Version Control",
      "Security",
      "Enterprise"
    ],
    "lastUpdated": "2025-10-03T10:00:00.000Z",
    "version": "1.0.0"
  }
]