[{
    "id": "security-fundamentals-lesson-1",
    "moduleSlug": "security-fundamentals",
    "title": "Web Security Fundamentals",
    "order": 1,
    "objectives": [
      "Understand common web security vulnerabilities and threats",
      "Learn authentication and authorization best practices",
      "Implement secure coding practices to prevent attacks"
    ],
    "intro": "Web security is critical for protecting applications and user data from malicious attacks. Understanding security fundamentals helps developers build robust applications that resist common vulnerabilities and protect sensitive information.\n\nIn this lesson, you'll learn about the OWASP Top 10 security risks including injection attacks, broken authentication, sensitive data exposure, and security misconfigurations. These represent the most critical security issues facing web applications today.\n\nAuthentication and authorization form the backbone of application security. You'll understand the difference between these concepts and learn to implement secure login systems, session management, and access controls that protect user accounts and data.\n\nSecure coding practices prevent vulnerabilities at the source. You'll discover input validation techniques, output encoding, secure storage methods, and proper error handling that make applications resilient against attacks.\n\nBy mastering these security fundamentals, you'll be equipped to identify potential vulnerabilities early, implement robust security measures, and follow industry best practices that protect both applications and users from cyber threats.",
    "code": {
      "example": "// Web Security Best Practices Implementation\n\n// 1. Input Validation and Sanitization\nfunction validateAndSanitizeInput(input, type) {\n  // Remove potentially harmful characters\n  const sanitized = input.replace(/<script[^>]*>.*?</script>/gi, '');\n  \n  switch (type) {\n    case 'email':\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      if (!emailRegex.test(sanitized)) {\n        throw new Error('Invalid email format');\n      }\n      break;\n    \n    case 'username':\n      const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;\n      if (!usernameRegex.test(sanitized)) {\n        throw new Error('Username must be 3-20 characters, alphanumeric and underscore only');\n      }\n      break;\n      \n    case 'password':\n      if (sanitized.length < 8) {\n        throw new Error('Password must be at least 8 characters');\n      }\n      break;\n  }\n  \n  return sanitized;\n}\n\n// 2. Secure Authentication Implementation\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\n\nclass AuthService {\n  static async hashPassword(password) {\n    const saltRounds = 12; // Increased for better security\n    return await bcrypt.hash(password, saltRounds);\n  }\n  \n  static async verifyPassword(password, hashedPassword) {\n    return await bcrypt.compare(password, hashedPassword);\n  }\n  \n  static generateToken(user) {\n    const payload = {\n      userId: user.id,\n      email: user.email,\n      role: user.role\n    };\n    \n    return jwt.sign(payload, process.env.JWT_SECRET, {\n      expiresIn: '15m', // Short-lived tokens\n      issuer: 'your-app-name',\n      audience: 'your-app-users'\n    });\n  }\n  \n  static verifyToken(token) {\n    try {\n      return jwt.verify(token, process.env.JWT_SECRET, {\n        issuer: 'your-app-name',\n        audience: 'your-app-users'\n      });\n    } catch (error) {\n      throw new Error('Invalid or expired token');\n    }\n  }\n}\n\n// 3. Authorization Middleware\nfunction authorize(requiredRole) {\n  return (req, res, next) => {\n    try {\n      const token = req.headers.authorization?.split(' ')[1];\n      \n      if (!token) {\n        return res.status(401).json({ error: 'Access token required' });\n      }\n      \n      const decoded = AuthService.verifyToken(token);\n      \n      if (requiredRole && decoded.role !== requiredRole) {\n        return res.status(403).json({ error: 'Insufficient permissions' });\n      }\n      \n      req.user = decoded;\n      next();\n    } catch (error) {\n      return res.status(401).json({ error: 'Invalid token' });\n    }\n  };\n}\n\n// 4. SQL Injection Prevention\nconst mysql = require('mysql2/promise');\n\nclass UserRepository {\n  static async findByEmail(email) {\n    // Use parameterized queries to prevent SQL injection\n    const query = 'SELECT * FROM users WHERE email = ? AND active = 1';\n    const [rows] = await db.execute(query, [email]);\n    return rows[0];\n  }\n  \n  static async createUser(userData) {\n    const query = `\n      INSERT INTO users (email, password_hash, name, role, created_at) \n      VALUES (?, ?, ?, ?, NOW())\n    `;\n    \n    const [result] = await db.execute(query, [\n      userData.email,\n      userData.passwordHash,\n      userData.name,\n      userData.role || 'user'\n    ]);\n    \n    return result.insertId;\n  }\n}\n\n// 5. Security Headers Middleware\nfunction securityHeaders(req, res, next) {\n  // Prevent XSS attacks\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  \n  // Prevent MIME type sniffing\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  \n  // Prevent clickjacking\n  res.setHeader('X-Frame-Options', 'DENY');\n  \n  // HTTPS enforcement\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');\n  \n  // Content Security Policy\n  res.setHeader('Content-Security-Policy', \n    \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';\");\n  \n  next();\n}\n\n// Usage Examples\napp.use(securityHeaders);\napp.post('/api/login', async (req, res) => {\n  try {\n    const email = validateAndSanitizeInput(req.body.email, 'email');\n    const password = validateAndSanitizeInput(req.body.password, 'password');\n    \n    const user = await UserRepository.findByEmail(email);\n    \n    if (!user || !await AuthService.verifyPassword(password, user.password_hash)) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n    \n    const token = AuthService.generateToken(user);\n    res.json({ token, user: { id: user.id, email: user.email, role: user.role } });\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n\napp.get('/api/admin/users', authorize('admin'), (req, res) => {\n  // Only admin users can access this endpoint\n  res.json({ message: 'Admin access granted' });\n});",
      "explanation": "This comprehensive example demonstrates essential web security practices including input validation, secure authentication with bcrypt and JWT, authorization middleware, SQL injection prevention, and security headers implementation.",
      "language": "javascript"
    },
    "pitfalls": [{
        "mistake": "Not following Security best practices",
        "solution": "Review official documentation and established patterns for Security",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [{
      "title": "Practice Testing Fundamentals",
      "description": "Apply the concepts learned in this lesson through hands-on practice.",
      "checkpoints": [
        "Complete the basic implementation",
        "Test your solution",
        "Identify areas for improvement"
      ]
    }],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Security",
      "Authentication",
      "Authorization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.318Z",
    "version": "1.0.0"
  },
  {
    "id": "security-fundamentals-lesson-2",
    "moduleSlug": "security-fundamentals",
    "title": "OWASP Top 10 Security Risks",
    "order": 2,
    "objectives": [
      "Identify and understand the OWASP Top 10 security vulnerabilities",
      "Implement preventive measures for each security risk category",
      "Apply security testing techniques to detect vulnerabilities"
    ],
    "intro": "The OWASP Top 10 is a widely recognized awareness document for web application security that represents a broad consensus about the most critical security risks to web applications. Understanding these vulnerabilities is essential for any developer who wants to build secure applications.\n\nIn this lesson, you'll dive deep into each of the OWASP Top 10 security risks, learning how they occur, what damage they can cause, and most importantly, how to prevent them. You'll explore real-world examples of each vulnerability and see how attackers exploit them.\n\nInjection flaws, such as SQL injection, command injection, and LDAP injection, remain one of the most dangerous vulnerabilities. You'll learn how to properly sanitize inputs and use parameterized queries to prevent these attacks.\n\nBroken authentication and session management vulnerabilities allow attackers to compromise passwords, keys, or session tokens. You'll discover secure authentication patterns, proper session handling, and multi-factor authentication implementation.\n\nSensitive data exposure occurs when applications don't adequately protect sensitive data such as financial information, healthcare records, or personal identification. You'll learn encryption techniques, secure data transmission, and proper data handling practices.\n\nBy mastering the OWASP Top 10, you'll be able to identify security weaknesses in applications, implement appropriate countermeasures, and conduct security reviews that significantly improve application security posture.",
    "code": {
      "example": "// OWASP Top 10 Security Risk Prevention Examples\n\n// 1. Injection Prevention (SQL Injection Example)\n// Vulnerable code - NEVER do this:\n// const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n\n// Secure approach using parameterized queries:\nclass SecureUserRepository {\n  static async authenticateUser(username, password) {\n    // Parameterized query prevents SQL injection\n    const query = 'SELECT * FROM users WHERE username = ? AND active = 1';\n    const [users] = await db.execute(query, [username]);\n    \n    if (users.length === 0) return null;\n    \n    const user = users[0];\n    const isValidPassword = await bcrypt.compare(password, user.password_hash);\n    \n    return isValidPassword ? user : null;\n  }\n  \n  // Command injection prevention\n  static async getUserFiles(userId) {\n    // Validate input to prevent command injection\n    if (!Number.isInteger(userId) || userId <= 0) {\n      throw new Error('Invalid user ID');\n    }\n    \n    // Use path.join and validate paths to prevent directory traversal\n    const userDir = path.join('/user_files', userId.toString());\n    \n    // Additional validation to ensure path is within allowed directory\n    if (!userDir.startsWith('/user_files/')) {\n      throw new Error('Access denied');\n    }\n    \n    return fs.readdirSync(userDir);\n  }\n}\n\n// 2. Broken Authentication Prevention\nconst crypto = require('crypto');\n\nclass SecureAuthService {\n  // Implement account lockout after failed attempts\n  static async loginWithLockout(username, password, maxAttempts = 5, lockoutTime = 900000) { // 15 minutes\n    const user = await UserRepository.findByUsername(username);\n    \n    if (!user) return null;\n    \n    // Check if account is locked\n    if (user.locked_until && new Date(user.locked_until) > new Date()) {\n      throw new Error('Account temporarily locked due to multiple failed attempts');\n    }\n    \n    const isValid = await bcrypt.compare(password, user.password_hash);\n    \n    if (isValid) {\n      // Reset failed attempts on successful login\n      await UserRepository.resetFailedAttempts(user.id);\n      return this.generateToken(user);\n    } else {\n      // Increment failed attempts\n      const updatedUser = await UserRepository.incrementFailedAttempts(user.id);\n      \n      // Lock account if max attempts exceeded\n      if (updatedUser.failed_attempts >= maxAttempts) {\n        await UserRepository.lockAccount(user.id, new Date(Date.now() + lockoutTime));\n        throw new Error('Account locked due to multiple failed attempts');\n      }\n      \n      return null;\n    }\n  }\n  \n  // Secure password reset with time-limited tokens\n  static async generatePasswordResetToken(email) {\n    const user = await UserRepository.findByEmail(email);\n    if (!user) return;\n    \n    // Generate secure random token\n    const token = crypto.randomBytes(32).toString('hex');\n    const expiresAt = new Date(Date.now() + 3600000); // 1 hour\n    \n    await UserRepository.savePasswordResetToken(user.id, token, expiresAt);\n    \n    // Send email with reset link (implementation not shown)\n    await emailService.sendPasswordReset(email, token);\n  }\n  \n  static async resetPassword(token, newPassword) {\n    const user = await UserRepository.findByPasswordResetToken(token);\n    \n    if (!user || new Date(user.reset_token_expires) < new Date()) {\n      throw new Error('Invalid or expired reset token');\n    }\n    \n    // Validate password strength\n    if (newPassword.length < 12) {\n      throw new Error('Password must be at least 12 characters long');\n    }\n    \n    const hashedPassword = await bcrypt.hash(newPassword, 12);\n    await UserRepository.updatePassword(user.id, hashedPassword);\n    await UserRepository.clearPasswordResetToken(user.id);\n  }\n}\n\n// 3. Sensitive Data Exposure Prevention\nconst crypto = require('crypto');\n\nclass DataProtectionService {\n  // Encrypt sensitive data\n  static encryptData(data, key) {\n    const algorithm = 'aes-256-gcm';\n    const iv = crypto.randomBytes(16);\n    \n    const cipher = crypto.createCipher(algorithm, key);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return {\n      encryptedData: encrypted,\n      iv: iv.toString('hex'),\n      authTag: authTag.toString('hex')\n    };\n  }\n  \n  // Decrypt sensitive data\n  static decryptData(encryptedObj, key) {\n    const { encryptedData, iv, authTag } = encryptedObj;\n    const algorithm = 'aes-256-gcm';\n    \n    const decipher = crypto.createDecipher(algorithm, key);\n    decipher.setAuthTag(Buffer.from(authTag, 'hex'));\n    \n    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  }\n  \n  // Hash sensitive data that doesn't need to be decrypted\n  static hashData(data) {\n    return crypto.createHash('sha256').update(data).digest('hex');\n  }\n  \n  // Securely store passwords\n  static async hashPassword(password) {\n    const salt = crypto.randomBytes(32).toString('hex');\n    const hashed = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n    return `${salt}:${hashed}`;\n  }\n  \n  static async verifyPassword(password, hashedPassword) {\n    const [salt, hash] = hashedPassword.split(':');\n    const hashed = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n    return hashed === hash;\n  }\n}\n\n// 4. XML External Entities (XXE) Prevention\nconst { XMLParser } = require('fast-xml-parser');\n\nclass SecureXMLProcessor {\n  static parseXML(xmlString) {\n    // Disable external entities to prevent XXE attacks\n    const options = {\n      ignoreAttributes: false,\n      allowBooleanAttributes: true,\n      parseAttributeValue: true,\n      // Critical: Disable external entities\n      ignoreDeclaration: true,\n      ignorePiTags: true,\n      // Prevent billion laughs attack\n      maxFileSize: 5 * 1024 * 1024, // 5MB limit\n      // Disable DTD processing\n      allowDTD: false\n    };\n    \n    const parser = new XMLParser(options);\n    return parser.parse(xmlString);\n  }\n}\n\n// 5. Broken Access Control Prevention\nfunction requirePermission(requiredPermission) {\n  return async (req, res, next) => {\n    try {\n      const user = req.user;\n      \n      // Check if user has the required permission\n      const hasPermission = await UserRepository.hasPermission(user.id, requiredPermission);\n      \n      if (!hasPermission) {\n        return res.status(403).json({ error: 'Insufficient permissions' });\n      }\n      \n      next();\n    } catch (error) {\n      return res.status(500).json({ error: 'Permission check failed' });\n    }\n  };\n}\n\n// Example usage in routes\napp.get('/api/users/:id', authenticateToken, async (req, res) => {\n  try {\n    const userId = parseInt(req.params.id);\n    \n    // Check if user can access this resource\n    if (req.user.id !== userId && req.user.role !== 'admin') {\n      return res.status(403).json({ error: 'Access denied' });\n    }\n    \n    const user = await UserRepository.findById(userId);\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json(user);\n  } catch (error) {\n    res.status(500).json({ error: 'Server error' });\n  }\n});\n\n// 6. Security Misconfiguration Prevention\n// Environment-specific configuration\nconst config = {\n  development: {\n    logging: true,\n    debug: true\n  },\n  production: {\n    logging: false,\n    debug: false,\n    // Security headers\n    securityHeaders: {\n      'X-Content-Type-Options': 'nosniff',\n      'X-Frame-Options': 'DENY',\n      'X-XSS-Protection': '1; mode=block',\n      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',\n      'Content-Security-Policy': \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';\"\n    }\n  }\n};\n\n// Apply security headers in production\nif (process.env.NODE_ENV === 'production') {\n  app.use((req, res, next) => {\n    Object.entries(config.production.securityHeaders).forEach(([header, value]) => {\n      res.setHeader(header, value);\n    });\n    next();\n  });\n}",
      "explanation": "This example demonstrates prevention techniques for the OWASP Top 10 security risks including injection prevention with parameterized queries, secure authentication with account lockout mechanisms, data encryption for sensitive information, XXE prevention in XML processing, access control implementation, and security misconfiguration handling.",
      "language": "javascript"
    },
    "pitfalls": [{
        "mistake": "Relying on client-side validation alone for security",
        "solution": "Always implement server-side validation and never trust client-side input",
        "severity": "high"
      },
      {
        "mistake": "Using weak password hashing algorithms",
        "solution": "Use strong, salted hashing algorithms like bcrypt, scrypt, or Argon2",
        "severity": "high"
      },
      {
        "mistake": "Exposing sensitive information in error messages",
        "solution": "Provide generic error messages to users while logging detailed errors server-side",
        "severity": "medium"
      }
    ],
    "exercises": [{
      "title": "OWASP Top 10 Vulnerability Assessment",
      "description": "Conduct a security review of a sample application to identify OWASP Top 10 vulnerabilities and implement fixes.",
      "checkpoints": [
        "Analyze sample code for injection vulnerabilities and implement parameterized queries",
        "Review authentication mechanisms and add account lockout functionality",
        "Identify sensitive data exposure and implement proper encryption",
        "Check access controls and implement role-based permissions",
        "Review security configurations and apply appropriate headers"
      ]
    }],
    "next": [],
    "estimatedMinutes": 45,
    "difficulty": "Advanced",
    "tags": [
      "OWASP",
      "Security",
      "Vulnerabilities",
      "Risk Management"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-3",
    "moduleSlug": "security-fundamentals",
    "title": "Input Validation and Data Sanitization",
    "order": 3,
    "objectives": [
      "Implement comprehensive input validation strategies",
      "Apply data sanitization techniques to prevent injection attacks",
      "Use validation libraries and frameworks effectively",
      "Handle file upload security and validation"
    ],
    "intro": "Input validation and data sanitization are fundamental security practices that protect applications from a wide range of attacks including injection, cross-site scripting (XSS), and data corruption. Every piece of data that enters your application from external sources represents a potential security risk that must be properly validated and sanitized.\n\nIn this lesson, you'll learn the principles of secure input validation including whitelist and blacklist validation approaches, data type validation, range checking, and format validation. You'll understand when to use each approach and how to implement them effectively in your applications.\n\nData sanitization techniques help clean and normalize input data to prevent malicious content from affecting your application. You'll explore HTML entity encoding, JavaScript escaping, URL encoding, and other sanitization methods that protect against XSS and other injection attacks.\n\nFile upload security is a critical area that often presents significant vulnerabilities in web applications. You'll learn how to validate file types, scan for malicious content, limit file sizes, and store uploaded files securely to prevent exploitation.\n\nBy mastering input validation and data sanitization, you'll be able to build applications that are resilient to data-based attacks, maintain data integrity, and provide a secure user experience while maintaining functionality.",
    "code": {
      "example": "// Comprehensive Input Validation and Data Sanitization Implementation\n\n// 1. Input Validation Utilities\nconst validator = require('validator');\n\nclass InputValidator {\n  // Email validation with multiple checks\n  static validateEmail(email) {\n    // Basic format check\n    if (!validator.isEmail(email)) {\n      throw new Error('Invalid email format');\n    }\n    \n    // Length check\n    if (email.length > 254) {\n      throw new Error('Email too long');\n    }\n    \n    // Domain validation\n    const domain = email.split('@')[1];\n    if (!validator.isFQDN(domain)) {\n      throw new Error('Invalid domain in email');\n    }\n    \n    return email.toLowerCase().trim();\n  }\n  \n  // Username validation\n  static validateUsername(username) {\n    // Length check\n    if (username.length < 3 || username.length > 30) {\n      throw new Error('Username must be between 3 and 30 characters');\n    }\n    \n    // Character validation (alphanumeric, underscore, hyphen only)\n    if (!/^[a-zA-Z0-9_-]+$/.test(username)) {\n      throw new Error('Username can only contain letters, numbers, underscores, and hyphens');\n    }\n    \n    // No consecutive special characters\n    if (/[-_]{2,}/.test(username)) {\n      throw new Error('Username cannot contain consecutive special characters');\n    }\n    \n    // Cannot start or end with special characters\n    if (/^[-_]|[-_]$/.test(username)) {\n      throw new Error('Username cannot start or end with special characters');\n    }\n    \n    return username;\n  }\n  \n  // Password validation\n  static validatePassword(password) {\n    // Length check\n    if (password.length < 12) {\n      throw new Error('Password must be at least 12 characters long');\n    }\n    \n    // Complexity checks\n    if (!/(?=.*[a-z])/.test(password)) {\n      throw new Error('Password must contain at least one lowercase letter');\n    }\n    \n    if (!/(?=.*[A-Z])/.test(password)) {\n      throw new Error('Password must contain at least one uppercase letter');\n    }\n    \n    if (!/(?=.*\\d)/.test(password)) {\n      throw new Error('Password must contain at least one digit');\n    }\n    \n    if (!/(?=.*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?])/.test(password)) {\n      throw new Error('Password must contain at least one special character');\n    }\n    \n    // No common patterns\n    const commonPasswords = ['password', '12345678', 'qwerty'];\n    if (commonPasswords.some(common => password.toLowerCase().includes(common))) {\n      throw new Error('Password contains common patterns');\n    }\n    \n    return password;\n  }\n  \n  // Phone number validation\n  static validatePhoneNumber(phone) {\n    // Remove all non-digit characters\n    const digitsOnly = phone.replace(/\\D/g, '');\n    \n    // Check length (assuming US format)\n    if (digitsOnly.length !== 10 && digitsOnly.length !== 11) {\n      throw new Error('Invalid phone number format');\n    }\n    \n    // Format consistently\n    if (digitsOnly.length === 11 && digitsOnly[0] !== '1') {\n      throw new Error('Invalid country code');\n    }\n    \n    return digitsOnly;\n  }\n  \n  // URL validation\n  static validateURL(url) {\n    if (!validator.isURL(url, {\n      protocols: ['http', 'https'],\n      require_tld: true,\n      require_protocol: true,\n      allow_underscores: false,\n      host_whitelist: [],\n      host_blacklist: ['localhost', '127.0.0.1'],\n      allow_trailing_dot: false,\n      allow_protocol_relative_urls: false,\n      disallow_auth: true\n    })) {\n      throw new Error('Invalid URL');\n    }\n    \n    // Additional checks\n    const parsedUrl = new URL(url);\n    if (parsedUrl.hostname.length > 253) {\n      throw new Error('URL hostname too long');\n    }\n    \n    return url;\n  }\n}\n\n// 2. Data Sanitization Functions\nconst xss = require('xss');\n\nclass DataSanitizer {\n  // HTML sanitization to prevent XSS\n  static sanitizeHTML(input) {\n    if (typeof input !== 'string') return input;\n    \n    // Use a whitelist approach\n    const options = {\n      whiteList: {\n        a: ['href', 'title'],\n        b: [],\n        i: [],\n        strong: [],\n        em: [],\n        p: [],\n        br: [],\n        ul: [],\n        ol: [],\n        li: []\n      },\n      stripIgnoreTag: true, // Strip all tags not in whitelist\n      stripIgnoreTagBody: ['script'] // Remove script tag content\n    };\n    \n    return xss(input, options);\n  }\n  \n  // JavaScript string escaping\n  static escapeJS(input) {\n    if (typeof input !== 'string') return input;\n    \n    return input\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/'/g, '\\\\'')\n      .replace(/\"/g, '\\\\\"')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/</g, '\\\\u003c')\n      .replace(/>/g, '\\\\u003e');\n  }\n  \n  // CSS escaping\n  static escapeCSS(input) {\n    if (typeof input !== 'string') return input;\n    \n    return input.replace(/[\\\"'();\\\\]/g, '\\\\$&');\n  }\n  \n  // URL parameter encoding\n  static encodeURLParam(param) {\n    return encodeURIComponent(param);\n  }\n  \n  // SQL value escaping (for cases where parameterized queries aren't possible)\n  static escapeSQLValue(value) {\n    if (typeof value !== 'string') return value;\n    \n    return value\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/'/g, \"''\") // Escape single quotes\n      .replace(/\"/g, '\\\\\"') // Escape double quotes\n      .replace(/\\x00/g, '\\\\0') // Null byte\n      .replace(/\\n/g, '\\\\n') // Newline\n      .replace(/\\r/g, '\\\\r') // Carriage return\n      .replace(/\\x1a/g, '\\\\Z'); // Substitute character\n  }\n}\n\n// 3. File Upload Security\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs').promises;\nconst { exec } = require('child_process');\nconst util = require('util');\n\nconst execPromise = util.promisify(exec);\n\n// Configure multer with security restrictions\nconst upload = multer({\n  storage: multer.diskStorage({\n    destination: async (req, file, cb) => {\n      // Create user-specific directory\n      const uploadDir = path.join(__dirname, 'uploads', req.user.id.toString());\n      \n      try {\n        await fs.mkdir(uploadDir, { recursive: true });\n        cb(null, uploadDir);\n      } catch (error) {\n        cb(new Error('Failed to create upload directory'), null);\n      }\n    },\n    filename: (req, file, cb) => {\n      // Generate safe filename\n      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n      const ext = path.extname(file.originalname).toLowerCase();\n      const basename = path.basename(file.originalname, ext);\n      \n      // Sanitize filename\n      const safeBasename = basename.replace(/[^a-zA-Z0-9_-]/g, '_');\n      \n      cb(null, `${safeBasename}-${uniqueSuffix}${ext}`);\n    }\n  }),\n  limits: {\n    fileSize: 5 * 1024 * 1024, // 5MB limit\n    files: 1 // Single file upload\n  },\n  fileFilter: (req, file, cb) => {\n    // Whitelist allowed file types\n    const allowedTypes = [\n      'image/jpeg',\n      'image/png',\n      'image/gif',\n      'application/pdf',\n      'text/plain'\n    ];\n    \n    if (allowedTypes.includes(file.mimetype)) {\n      cb(null, true);\n    } else {\n      cb(new Error('Invalid file type'), false);\n    }\n  }\n});\n\n// File validation service\nclass FileValidationService {\n  static async validateFile(filePath, mimeType) {\n    try {\n      // Check file size\n      const stats = await fs.stat(filePath);\n      if (stats.size > 5 * 1024 * 1024) { // 5MB\n        throw new Error('File too large');\n      }\n      \n      // Validate file extension matches content\n      const ext = path.extname(filePath).toLowerCase();\n      const validExtensions = {\n        'image/jpeg': ['.jpg', '.jpeg'],\n        'image/png': ['.png'],\n        'image/gif': ['.gif'],\n        'application/pdf': ['.pdf'],\n        'text/plain': ['.txt']\n      };\n      \n      if (!validExtensions[mimeType] || !validExtensions[mimeType].includes(ext)) {\n        throw new Error('File extension does not match content type');\n      }\n      \n      // For images, validate with ImageMagick or similar tool\n      if (mimeType.startsWith('image/')) {\n        await this.validateImage(filePath);\n      }\n      \n      // For PDFs, validate with pdfinfo or similar\n      if (mimeType === 'application/pdf') {\n        await this.validatePDF(filePath);\n      }\n      \n      return true;\n    } catch (error) {\n      throw new Error(`File validation failed: ${error.message}`);\n    }\n  }\n  \n  static async validateImage(filePath) {\n    try {\n      // Use ImageMagick to validate image\n      const { stdout } = await execPromise(`identify -format '%m' '${filePath}'`);\n      if (!stdout) {\n        throw new Error('Invalid image file');\n      }\n    } catch (error) {\n      throw new Error('Image validation failed');\n    }\n  }\n  \n  static async validatePDF(filePath) {\n    try {\n      // Use pdfinfo to validate PDF\n      const { stdout } = await execPromise(`pdfinfo '${filePath}'`);\n      if (!stdout.includes('Pages:')) {\n        throw new Error('Invalid PDF file');\n      }\n    } catch (error) {\n      throw new Error('PDF validation failed');\n    }\n  }\n  \n  // Scan file for malware (integration with ClamAV or similar)\n  static async scanForMalware(filePath) {\n    try {\n      const { stdout } = await execPromise(`clamdscan --no-summary '${filePath}'`);\n      if (stdout.includes('FOUND')) {\n        throw new Error('Malware detected in file');\n      }\n      return true;\n    } catch (error) {\n      throw new Error('Malware scan failed');\n    }\n  }\n}\n\n// Express route with secure file upload\napp.post('/api/upload', authenticateToken, upload.single('file'), async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ error: 'No file uploaded' });\n    }\n    \n    // Validate file\n    await FileValidationService.validateFile(req.file.path, req.file.mimetype);\n    \n    // Scan for malware\n    await FileValidationService.scanForMalware(req.file.path);\n    \n    // Store file reference in database\n    const fileRecord = await FileRepository.create({\n      userId: req.user.id,\n      filename: req.file.filename,\n      originalName: req.file.originalname,\n      mimeType: req.file.mimetype,\n      size: req.file.size,\n      path: req.file.path\n    });\n    \n    res.json({\n      message: 'File uploaded successfully',\n      fileId: fileRecord.id\n    });\n  } catch (error) {\n    // Clean up uploaded file on error\n    if (req.file && req.file.path) {\n      try {\n        await fs.unlink(req.file.path);\n      } catch (unlinkError) {\n        console.error('Failed to clean up file:', unlinkError);\n      }\n    }\n    \n    res.status(400).json({ error: error.message });\n  }\n});\n\n// 4. Validation Middleware\nfunction validateRequest(schema) {\n  return (req, res, next) => {\n    try {\n      // Validate request body\n      if (schema.body) {\n        Object.keys(schema.body).forEach(field => {\n          const validatorFunc = schema.body[field];\n          if (req.body[field] !== undefined) {\n            req.body[field] = validatorFunc(req.body[field]);\n          }\n        });\n      }\n      \n      // Validate query parameters\n      if (schema.query) {\n        Object.keys(schema.query).forEach(field => {\n          const validatorFunc = schema.query[field];\n          if (req.query[field] !== undefined) {\n            req.query[field] = validatorFunc(req.query[field]);\n          }\n        });\n      }\n      \n      // Validate route parameters\n      if (schema.params) {\n        Object.keys(schema.params).forEach(field => {\n          const validatorFunc = schema.params[field];\n          if (req.params[field] !== undefined) {\n            req.params[field] = validatorFunc(req.params[field]);\n          }\n        });\n      }\n      \n      next();\n    } catch (error) {\n      res.status(400).json({ error: error.message });\n    }\n  };\n}\n\n// Usage example\nconst userSchema = {\n  body: {\n    email: InputValidator.validateEmail,\n    username: InputValidator.validateUsername,\n    password: InputValidator.validatePassword\n  }\n};\n\napp.post('/api/users', validateRequest(userSchema), async (req, res) => {\n  try {\n    // At this point, req.body is validated and safe to use\n    const user = await UserService.create(req.body);\n    res.status(201).json(user);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to create user' });\n  }\n});",
      "explanation": "This comprehensive example demonstrates input validation and data sanitization techniques including email, username, and password validation; HTML, JavaScript, and CSS sanitization; secure file upload handling with validation and malware scanning; and reusable validation middleware for Express applications.",
      "language": "javascript"
    },
    "pitfalls": [{
        "mistake": "Relying only on client-side validation",
        "solution": "Always implement server-side validation as client-side validation can be bypassed",
        "severity": "high"
      },
      {
        "mistake": "Using blacklist validation instead of whitelist validation",
        "solution": "Use whitelist validation to only allow known good values rather than trying to block all bad values",
        "severity": "high"
      },
      {
        "mistake": "Storing uploaded files in web-accessible directories",
        "solution": "Store uploaded files outside the web root and serve them through authenticated endpoints",
        "severity": "high"
      }
    ],
    "exercises": [{
      "title": "Implement Secure Input Validation",
      "description": "Create a comprehensive input validation system for a user registration form with email, username, password, and profile fields.",
      "checkpoints": [
        "Implement validation for all form fields with appropriate constraints",
        "Add sanitization for user-provided content to prevent XSS",
        "Create secure file upload handling for profile pictures",
        "Implement validation middleware for Express routes",
        "Test validation with both valid and invalid inputs"
      ]
    }],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Input Validation",
      "Data Sanitization",
      "File Upload Security",
      "XSS Prevention"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-4",
    "moduleSlug": "security-fundamentals",
    "title": "Security Performance Testing and Optimization",
    "order": 4,
    "objectives": [
      "Understand security implications of performance testing",
      "Implement secure load testing practices",
      "Optimize security controls for performance",
      "Balance security and performance requirements"
    ],
    "intro": "Performance testing in security contexts requires a unique approach that considers both the functional aspects of security controls and their impact on system performance. Security mechanisms often introduce overhead that can significantly affect application performance, making it essential to test both aspects together.\n\nIn this lesson, you'll learn how to conduct performance testing specifically for security features, including authentication systems, encryption processes, access controls, and logging mechanisms. You'll understand how security controls can become bottlenecks and how to identify these issues before they impact production systems.\n\nLoad testing security mechanisms is critical because authentication and authorization systems often become performance bottlenecks under high load. You'll learn techniques for simulating realistic attack scenarios, testing rate limiting mechanisms, and evaluating the performance impact of security controls like encryption, hashing, and session management.\n\nOptimizing security controls for performance requires careful consideration of trade-offs between security and performance. You'll explore techniques for caching security decisions, optimizing cryptographic operations, implementing efficient access control checks, and designing scalable authentication systems that maintain security without sacrificing performance.\n\nBy mastering security performance testing, you'll be able to build systems that are both secure and performant, ensuring that security measures enhance rather than hinder user experience while maintaining robust protection against threats.",
    "code": {
      "example": "// Security Performance Testing and Optimization Implementation\n\n// 1. Secure Authentication Performance Testing\nconst bcrypt = require('bcrypt');\nconst crypto = require('crypto');\n\n// Benchmark different bcrypt cost factors\nasync function benchmarkBcryptCost(password, minCost = 10, maxCost = 14) {\n    const results = [];\n    \n    for (let cost = minCost; cost <= maxCost; cost++) {\n        const startTime = process.hrtime.bigint();\n        await bcrypt.hash(password, cost);\n        const endTime = process.hrtime.bigint();\n        \n        const durationMs = Number(endTime - startTime) / 1000000;\n        results.push({\n            cost,\n            durationMs,\n            recommendation: durationMs < 100 ? 'Acceptable' : \n                         durationMs < 250 ? 'Consider optimization' : 'Too slow for interactive use'\n        });\n    }\n    \n    return results;\n}\n\n// Optimized session management with caching\nclass OptimizedSessionManager {\n    constructor(redisClient, cacheTtl = 3600) {\n        this.redis = redisClient;\n        this.cacheTtl = cacheTtl;\n    }\n    \n    async createSession(userId, permissions) {\n        const sessionId = crypto.randomBytes(32).toString('hex');\n        const sessionData = {\n            userId,\n            permissions,\n            createdAt: Date.now(),\n            lastAccessed: Date.now()\n        };\n        \n        // Store in Redis with expiration\n        await this.redis.setex(`session:${sessionId}`, \n            this.cacheTtl, \n            JSON.stringify(sessionData)\n        );\n        \n        return sessionId;\n    }\n    \n    async validateSession(sessionId) {\n        // First check if session exists\n        const sessionStr = await this.redis.get(`session:${sessionId}`);\n        if (!sessionStr) return null;\n        \n        const session = JSON.parse(sessionStr);\n        \n        // Update last accessed time\n        session.lastAccessed = Date.now();\n        await this.redis.setex(`session:${sessionId}`, \n            this.cacheTtl, \n            JSON.stringify(session)\n        );\n        \n        return session;\n    }\n    \n    async destroySession(sessionId) {\n        await this.redis.del(`session:${sessionId}`);\n    }\n}\n\n// 2. Rate Limiting with Performance Considerations\nclass PerformanceOptimizedRateLimiter {\n    constructor(redisClient) {\n        this.redis = redisClient;\n    }\n    \n    async isAllowed(identifier, maxRequests = 100, windowSeconds = 60) {\n        const key = `rate_limit:${identifier}`;\n        const now = Math.floor(Date.now() / 1000);\n        const windowStart = now - windowSeconds;\n        \n        // Use Redis pipeline for atomic operations\n        const pipeline = this.redis.multi();\n        \n        // Remove expired entries\n        pipeline.zremrangebyscore(key, 0, windowStart);\n        \n        // Add current request\n        pipeline.zadd(key, now, `${now}-${Math.random()}`);\n        \n        // Set expiration\n        pipeline.expire(key, windowSeconds);\n        \n        // Get count\n        pipeline.zcard(key);\n        \n        const results = await pipeline.exec();\n        const requestCount = results[3][1]; // Result of zcard\n        \n        return {\n            allowed: requestCount <= maxRequests,\n            count: requestCount,\n            remaining: Math.max(0, maxRequests - requestCount)\n        };\n    }\n}\n\n// 3. Efficient Access Control with Caching\nclass CachedAccessControl {\n    constructor(redisClient, db) {\n        this.redis = redisClient;\n        this.db = db;\n        this.cacheTtl = 300; // 5 minutes\n    }\n    \n    async hasPermission(userId, resource, action) {\n        const cacheKey = `permission:${userId}:${resource}:${action}`;\n        \n        // Try cache first\n        const cachedResult = await this.redis.get(cacheKey);\n        if (cachedResult !== null) {\n            return cachedResult === 'true';\n        }\n        \n        // Check database if not in cache\n        const hasPermission = await this.db.checkPermission(userId, resource, action);\n        \n        // Cache result\n        await this.redis.setex(\n            cacheKey, \n            this.cacheTtl, \n            hasPermission ? 'true' : 'false'\n        );\n        \n        return hasPermission;\n    }\n    \n    // Invalidate cache when permissions change\n    async invalidateUserPermissions(userId) {\n        const pattern = `permission:${userId}:*`;\n        const keys = await this.redis.keys(pattern);\n        if (keys.length > 0) {\n            await this.redis.del(...keys);\n        }\n    }\n}\n\n// 4. Cryptographic Operation Optimization\nconst crypto = require('crypto');\n\n// Use streaming for large data encryption\nfunction encryptLargeFile(inputStream, outputStream, key) {\n    const algorithm = 'aes-256-gcm';\n    const iv = crypto.randomBytes(16);\n    \n    const cipher = crypto.createCipher(algorithm, key);\n    \n    // Write IV to output stream\n    outputStream.write(iv);\n    \n    // Stream encryption\n    inputStream.pipe(cipher).pipe(outputStream);\n    \n    return new Promise((resolve, reject) => {\n        cipher.on('end', resolve);\n        cipher.on('error', reject);\n    });\n}\n\n// Batch processing for multiple small operations\nasync function batchHashPasswords(passwords, saltRounds = 12) {\n    const results = [];\n    \n    // Process in smaller batches to avoid blocking the event loop\n    const batchSize = 10;\n    \n    for (let i = 0; i < passwords.length; i += batchSize) {\n        const batch = passwords.slice(i, i + batchSize);\n        const batchResults = await Promise.all(\n            batch.map(password => bcrypt.hash(password, saltRounds))\n        );\n        results.push(...batchResults);\n        \n        // Allow event loop to process other tasks\n        await new Promise(resolve => setImmediate(resolve));\n    }\n    \n    return results;\n}\n\n// 5. Security Performance Testing Utilities\nconst autocannon = require('autocannon');\n\nasync function securityPerformanceTest(url, requests, connections) {\n    const result = await autocannon({\n        url,\n        requests,\n        connections,\n        duration: 30, // 30 seconds\n        pipelining: 1,\n        setupClient: (client) => {\n            // Add authentication token for security testing\n            client.on('headers', {\n                authorization: 'Bearer test-token'\n            });\n        }\n    });\n    \n    return {\n        requestsPerSecond: result.requests.average,\n        latency: result.latency.average,\n        throughput: result.throughput.average,\n        errors: result.errors,\n        timeouts: result.timeouts\n    };\n}\n\n// Example usage\napp.post('/api/login', async (req, res) => {\n    try {\n        const { email, password } = req.body;\n        \n        // Simulate optimized authentication\n        const user = await UserRepository.findByEmail(email);\n        if (!user) {\n            return res.status(401).json({ error: 'Invalid credentials' });\n        }\n        \n        const isValid = await bcrypt.compare(password, user.password_hash);\n        if (!isValid) {\n            return res.status(401).json({ error: 'Invalid credentials' });\n        }\n        \n        // Create optimized session\n        const sessionId = await sessionManager.createSession(user.id, user.permissions);\n        \n        res.json({ \n            token: sessionId,\n            user: { id: user.id, email: user.email }\n        });\n    } catch (error) {\n        res.status(500).json({ error: 'Authentication failed' });\n    }\n});",
      "explanation": "This example demonstrates security performance optimization techniques including bcrypt cost factor benchmarking, optimized session management with Redis caching, performance-optimized rate limiting using Redis pipelines, cached access control to reduce database queries, streaming encryption for large files, batch processing for cryptographic operations, and security-focused performance testing utilities.",
      "language": "javascript"
    },
    "pitfalls": [{
        "mistake": "Using overly expensive cryptographic operations in request path",
        "solution": "Benchmark different security parameter levels and choose appropriate trade-offs between security and performance",
        "severity": "high"
      },
      {
        "mistake": "Not caching security decisions that don't change frequently",
        "solution": "Implement intelligent caching for access control decisions and user permissions with proper invalidation",
        "severity": "medium"
      },
      {
        "mistake": "Blocking the event loop with synchronous security operations",
        "solution": "Use asynchronous operations and batch processing for multiple security operations",
        "severity": "high"
      }
    ],
    "exercises": [{
      "title": "Security Performance Optimization Implementation",
      "description": "Implement performance optimizations for a security system including benchmarking cryptographic operations, implementing cached access control, and optimizing session management.",
      "checkpoints": [
        "Benchmark different bcrypt cost factors and document performance impact",
        "Implement cached access control with proper invalidation",
        "Optimize session management with Redis caching",
        "Create batch processing for multiple password hashing operations",
        "Measure performance improvements before and after optimizations"
      ]
    }],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Security",
      "Performance Testing",
      "Optimization",
      "Authentication"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-5",
    "moduleSlug": "security-fundamentals",
    "title": "Automated Security Testing and Vulnerability Scanning",
    "order": 5,
    "objectives": [
      "Implement automated security testing in CI/CD pipelines",
      "Conduct vulnerability scanning for applications and dependencies",
      "Integrate security testing tools effectively",
      "Analyze and remediate security findings"
    ],
    "intro": "Automated security testing is a critical component of modern software development that enables teams to identify vulnerabilities early in the development lifecycle. By integrating security testing into automated pipelines, organizations can catch security issues before they reach production while maintaining development velocity.\n\nIn this lesson, you'll learn how to implement automated security testing across different phases of the software development lifecycle, including static application security testing (SAST), dynamic application security testing (DAST), and software composition analysis (SCA) for dependency scanning. You'll understand how to select appropriate tools, configure them for your technology stack, and integrate them into continuous integration pipelines.\n\nVulnerability scanning for applications and dependencies is essential for maintaining a secure software supply chain. You'll learn techniques for scanning container images, infrastructure as code (IaC) templates, and application dependencies for known vulnerabilities. You'll also explore how to prioritize findings based on risk and exploitability to focus remediation efforts effectively.\n\nIntegrating security testing tools effectively requires understanding their strengths, limitations, and appropriate use cases. You'll learn how to configure tools to minimize false positives, establish baseline security requirements, and create automated gates that prevent vulnerable code from being deployed to production environments.\n\nBy mastering automated security testing, you'll be able to build more secure applications while maintaining development speed, establish measurable security practices, and create a culture of security awareness within development teams.",
    "code": {
      "example": "// Automated Security Testing Implementation\n\n// 1. Dependency Vulnerability Scanning\nconst { exec } = require('child_process');\nconst util = require('util');\nconst execPromise = util.promisify(exec);\n\n// Function to scan dependencies for vulnerabilities\nasync function scanDependencies() {\n    try {\n        // Run npm audit to check for known vulnerabilities\n        const { stdout, stderr } = await execPromise('npm audit --json');\n        \n        if (stderr) {\n            console.warn('npm audit warnings:', stderr);\n        }\n        \n        const auditReport = JSON.parse(stdout);\n        \n        // Process and categorize vulnerabilities\n        const vulnerabilities = {\n            critical: [],\n            high: [],\n            moderate: [],\n            low: []\n        };\n        \n        Object.values(auditReport.advisories || {}).forEach(advisory => {\n            switch (advisory.severity) {\n                case 'critical':\n                    vulnerabilities.critical.push(advisory);\n                    break;\n                case 'high':\n                    vulnerabilities.high.push(advisory);\n                    break;\n                case 'moderate':\n                    vulnerabilities.moderate.push(advisory);\n                    break;\n                case 'low':\n                    vulnerabilities.low.push(advisory);\n                    break;\n            }\n        });\n        \n        return {\n            total: auditReport.metadata.vulnerabilities.total,\n            vulnerabilities,\n            // Fail build if critical vulnerabilities found\n            shouldFailBuild: vulnerabilities.critical.length > 0 || vulnerabilities.high.length > 5\n        };\n    } catch (error) {\n        // npm audit fails with exit code 1 when vulnerabilities found\n        if (error.stdout) {\n            try {\n                const auditReport = JSON.parse(error.stdout);\n                return {\n                    total: auditReport.metadata.vulnerabilities.total,\n                    vulnerabilities: categorizeVulnerabilities(auditReport.advisories),\n                    shouldFailBuild: true\n                };\n            } catch (parseError) {\n                throw new Error(`Failed to parse npm audit output: \\${parseError.message}`);\n            }\n        }\n        throw error;\n    }\n}\n\nfunction categorizeVulnerabilities(advisories) {\n    const vulnerabilities = {\n        critical: [],\n        high: [],\n        moderate: [],\n        low: []\n    };\n    \n    Object.values(advisories || {}).forEach(advisory => {\n        switch (advisory.severity) {\n            case 'critical':\n                vulnerabilities.critical.push({\n                    id: advisory.id,\n                    title: advisory.title,\n                    module: advisory.module_name,\n                    patched: advisory.patched_versions,\n                    recommendation: advisory.recommendation\n                });\n                break;\n            case 'high':\n                vulnerabilities.high.push({\n                    id: advisory.id,\n                    title: advisory.title,\n                    module: advisory.module_name,\n                    patched: advisory.patched_versions,\n                    recommendation: advisory.recommendation\n                });\n                break;\n            case 'moderate':\n                vulnerabilities.moderate.push({\n                    id: advisory.id,\n                    title: advisory.title,\n                    module: advisory.module_name,\n                    patched: advisory.patched_versions,\n                    recommendation: advisory.recommendation\n                });\n                break;\n            case 'low':\n                vulnerabilities.low.push({\n                    id: advisory.id,\n                    title: advisory.title,\n                    module: advisory.module_name,\n                    patched: advisory.patched_versions,\n                    recommendation: advisory.recommendation\n                });\n                break;\n        }\n    });\n    \n    return vulnerabilities;\n}\n\n// 2. Static Application Security Testing (SAST) Integration\nasync function runSASTScan(sourceDir = './src') {\n    try {\n        // Run ESLint with security plugins\n        const eslintCommand = `npx eslint \\${sourceDir} --ext .js,.ts --format json`;\n        const { stdout } = await execPromise(eslintCommand);\n        \n        const results = JSON.parse(stdout);\n        \n        // Filter for security-related issues\n        const securityIssues = results.flatMap(file =>\n            file.messages.filter(message =>\n                message.ruleId && (\n                    message.ruleId.includes('security') ||\n                    message.ruleId.includes('no-eval') ||\n                    message.ruleId.includes('no-new-func') ||\n                    message.ruleId.includes('xss')\n                )\n            ).map(issue => ({\n                filePath: file.filePath,\n                line: issue.line,\n                column: issue.column,\n                message: issue.message,\n                ruleId: issue.ruleId,\n                severity: issue.severity\n            }))\n        );\n        \n        return {\n            totalIssues: securityIssues.length,\n            criticalIssues: securityIssues.filter(i => i.severity === 2),\n            issues: securityIssues\n        };\n    } catch (error) {\n        if (error.stdout) {\n            try {\n                const results = JSON.parse(error.stdout);\n                // Process results even when ESLint exits with errors\n                return processSASTResults(results);\n            } catch (parseError) {\n                throw new Error(`Failed to parse ESLint output: \\${parseError.message}`);\n            }\n        }\n        throw new Error(`SAST scan failed: \\${error.message}`);\n    }\n}\n\nfunction processSASTResults(results) {\n    const securityIssues = results.flatMap(file =>\n        file.messages.filter(message =>\n            message.ruleId && (\n                message.ruleId.includes('security') ||\n                message.ruleId.includes('no-eval') ||\n                message.ruleId.includes('no-new-func') ||\n                message.ruleId.includes('xss')\n            )\n        ).map(issue => ({\n            filePath: file.filePath,\n            line: issue.line,\n            column: issue.column,\n            message: issue.message,\n            ruleId: issue.ruleId,\n            severity: issue.severity\n        }))\n    );\n    \n    return {\n        totalIssues: securityIssues.length,\n        criticalIssues: securityIssues.filter(i => i.severity === 2),\n        issues: securityIssues\n    };\n}\n\n// 3. Security Testing in CI/CD Pipeline\nclass SecurityPipeline {\n    constructor() {\n        this.failOnCritical = process.env.SECURITY_FAIL_ON_CRITICAL !== 'false';\n        this.failOnHigh = process.env.SECURITY_FAIL_ON_HIGH !== 'false';\n    }\n    \n    async runSecurityChecks() {\n        console.log('Running security checks...');\n        \n        // Run dependency scanning\n        const dependencyScan = await scanDependencies();\n        console.log(`Dependency scan found \\${dependencyScan.total} vulnerabilities`);\n        \n        // Run SAST\n        const sastScan = await runSASTScan();\n        console.log(`SAST scan found \\${sastScan.totalIssues} issues`);\n        \n        // Determine if pipeline should fail\n        let shouldFail = false;\n        \n        if (this.failOnCritical && (\n            dependencyScan.vulnerabilities.critical.length > 0 ||\n            sastScan.criticalIssues.length > 0\n        )) {\n            console.error('CRITICAL security issues found, failing pipeline');\n            shouldFail = true;\n        }\n        \n        if (this.failOnHigh && (\n            dependencyScan.vulnerabilities.high.length > 0\n        )) {\n            console.error('HIGH security issues found, failing pipeline');\n            shouldFail = true;\n        }\n        \n        // Generate security report\n        const report = {\n            timestamp: new Date().toISOString(),\n            dependencyScan,\n            sastScan,\n            shouldFail\n        };\n        \n        // Save report\n        require('fs').writeFileSync(\n            'security-report.json',\n            JSON.stringify(report, null, 2)\n        );\n        \n        if (shouldFail) {\n            process.exit(1);\n        }\n        \n        return report;\n    }\n}\n\n// 4. Container Image Security Scanning\nasync function scanContainerImage(imageName) {\n    try {\n        // Use Trivy or similar tool to scan container images\n        const scanCommand = `trivy image --format json --output trivy-report.json \\${imageName}`;\n        await execPromise(scanCommand);\n        \n        // Parse results\n        const report = JSON.parse(require('fs').readFileSync('trivy-report.json', 'utf8'));\n        \n        // Categorize vulnerabilities\n        const vulnerabilities = {\n            critical: [],\n            high: [],\n            medium: [],\n            low: []\n        };\n        \n        report.Results.forEach(result => {\n            if (result.Vulnerabilities) {\n                result.Vulnerabilities.forEach(vuln => {\n                    switch (vuln.Severity.toLowerCase()) {\n                        case 'critical':\n                            vulnerabilities.critical.push(vuln);\n                            break;\n                        case 'high':\n                            vulnerabilities.high.push(vuln);\n                            break;\n                        case 'medium':\n                            vulnerabilities.medium.push(vuln);\n                            break;\n                        case 'low':\n                            vulnerabilities.low.push(vuln);\n                            break;\n                    }\n                });\n            }\n        });\n        \n        return {\n            total: Object.values(vulnerabilities).reduce((sum, arr) => sum + arr.length, 0),\n            vulnerabilities,\n            shouldFail: vulnerabilities.critical.length > 0\n        };\n    } catch (error) {\n        throw new Error(`Container scan failed: \\${error.message}`);\n    }\n}\n\n// 5. Security Testing Utilities\nclass SecurityTestUtils {\n    // Generate security test report\n    static generateReport(testResults) {\n        const report = {\n            summary: {\n                totalTests: testResults.length,\n                passed: testResults.filter(t => t.passed).length,\n                failed: testResults.filter(t => !t.passed).length,\n                criticalIssues: testResults.flatMap(t => t.issues?.critical || []).length\n            },\n            details: testResults\n        };\n        \n        return report;\n    }\n    \n    // Check for common security misconfigurations\n    static async checkSecurityConfig(configPath = './config') {\n        const fs = require('fs');\n        const path = require('path');\n        \n        const issues = [];\n        \n        // Check for exposed secrets\n        try {\n            const files = fs.readdirSync(configPath);\n            for (const file of files) {\n                if (file.endsWith('.env') || file.endsWith('.json')) {\n                    const content = fs.readFileSync(path.join(configPath, file), 'utf8');\n                    \n                    // Look for common patterns of exposed secrets\n                    if (content.includes('API_KEY=') && !content.includes('API_KEY=\"\"')) {\n                        issues.push({\n                            file,\n                            issue: 'Potential API key exposure',\n                            severity: 'high'\n                        });\n                    }\n                    \n                    if (content.includes('PASSWORD=') && !content.includes('PASSWORD=\"\"')) {\n                        issues.push({\n                            file,\n                            issue: 'Potential password exposure',\n                            severity: 'critical'\n                        });\n                    }\n                }\n            }\n        } catch (error) {\n            // Config directory might not exist, which is fine\n        }\n        \n        return issues;\n    }\n}\n\n// Example usage in CI/CD pipeline\n// This would typically be in a separate script or pipeline configuration\nasync function runPipelineSecurityChecks() {\n    const pipeline = new SecurityPipeline();\n    \n    try {\n        const report = await pipeline.runSecurityChecks();\n        console.log('Security checks completed successfully');\n        return report;\n    } catch (error) {\n        console.error('Security checks failed:', error.message);\n        process.exit(1);\n    }\n}\n\n// Example GitHub Actions workflow integration\n/*\nname: Security Checks\non: [push, pull_request]\njobs:\n  security-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n      - name: Install dependencies\n        run: npm ci\n      - name: Run security checks\n        run: node security-pipeline.js\n      - name: Upload security report\n        uses: actions/upload-artifact@v2\n        if: always()\n        with:\n          name: security-report\n          path: security-report.json\n*/",
      "explanation": "This example demonstrates automated security testing implementation including dependency vulnerability scanning with npm audit, static application security testing (SAST) with ESLint, CI/CD pipeline integration with configurable failure thresholds, container image scanning, and security configuration checking utilities.",
      "language": "javascript"
    },
    "pitfalls": [{
        "mistake": "Failing to configure security tools properly leading to excessive false positives",
        "solution": "Spend time configuring security tools for your specific technology stack and establish baseline configurations that minimize noise while catching real issues",
        "severity": "medium"
      },
      {
        "mistake": "Not prioritizing security findings effectively, leading to team fatigue",
        "solution": "Implement risk-based prioritization of security findings and establish clear remediation SLAs based on severity levels",
        "severity": "high"
      },
      {
        "mistake": "Running security scans only in production environments",
        "solution": "Integrate security scanning into development workflows and CI/CD pipelines to catch issues early",
        "severity": "high"
      }
    ],
    "exercises": [{
      "title": "Automated Security Testing Implementation",
      "description": "Implement a comprehensive automated security testing pipeline including dependency scanning, SAST integration, and CI/CD pipeline configuration.",
      "checkpoints": [
        "Implement dependency vulnerability scanning with npm audit",
        "Integrate ESLint with security plugins for SAST",
        "Create a CI/CD pipeline configuration that runs security checks",
        "Implement risk-based vulnerability prioritization",
        "Generate and analyze security reports from pipeline runs"
      ]
    }],
    "next": [],
    "estimatedMinutes": 75,
    "difficulty": "Advanced",
    "tags": [
      "Security Testing",
      "CI/CD",
      "Vulnerability Scanning",
      "DevSecOps"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-6",
    "moduleSlug": "security-fundamentals",
    "title": "Secure Code Quality and Review Practices",
    "order": 6,
    "objectives": [
      "Implement security-focused code quality standards",
      "Conduct effective security code reviews",
      "Establish automated security quality gates",
      "Measure and improve security code quality metrics"
    ],
    "intro": "Secure code quality practices are essential for building robust, maintainable, and secure applications. Code quality directly impacts security because poorly written code is more likely to contain vulnerabilities, logic errors, and implementation flaws that attackers can exploit. Establishing security-focused code quality standards helps teams write code that is not only functional but also resilient to attacks.\n\nIn this lesson, you'll learn how to implement security-focused code quality standards that go beyond basic formatting and style guidelines. You'll explore how to configure static analysis tools to catch security anti-patterns, establish coding conventions that prevent common vulnerabilities, and create automated checks that enforce security best practices throughout the development process.\n\nConducting effective security code reviews requires specialized knowledge and techniques that differ from general code reviews. You'll learn how to identify security-relevant code changes, review authentication and authorization logic, examine input validation and output encoding implementations, and assess cryptographic usage. You'll also discover how to make security reviews efficient and scalable within development workflows.\n\nEstablishing automated security quality gates ensures that security issues are caught early and consistently. You'll learn how to integrate security checks into development environments, continuous integration pipelines, and deployment processes. You'll explore tools and techniques for measuring code quality metrics that correlate with security posture and establishing thresholds that prevent vulnerable code from reaching production.\n\nBy mastering secure code quality practices, you'll be able to build applications that are not only functionally correct but also secure by design, reduce the cost of fixing security issues through early detection, and foster a culture of security consciousness within development teams.",
    "code": {
      "example": "// Secure Code Quality and Review Practices Implementation\n\n// 1. Security-Focused ESLint Configuration\n/*\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:security/recommended\"\n  ],\n  \"plugins\": [\n    \"security\",\n    \"xss\"\n  ],\n  \"rules\": {\n    // Security-specific rules\n    \"security/detect-object-injection\": \"warn\",\n    \"security/detect-non-literal-fs-filename\": \"error\",\n    \"security/detect-unsafe-regex\": \"error\",\n    \"security/detect-buffer-noassert\": \"error\",\n    \"security/detect-child-process\": \"error\",\n    \"security/detect-disable-mustache-escape\": \"error\",\n    \"security/detect-eval-with-expression\": \"error\",\n    \"security/detect-no-csrf-before-method-override\": \"error\",\n    \"security/detect-non-literal-regexp\": \"error\",\n    \"security/detect-non-literal-require\": \"warn\",\n    \"security/detect-possible-timing-attacks\": \"warn\",\n    \"security/detect-pseudoRandomBytes\": \"error\",\n    \n    // XSS prevention rules\n    \"xss/no-mixed-html\": \"error\",\n    \"xss/no-location-href-assign\": \"error\",\n    \n    // General security best practices\n    \"no-eval\": \"error\",\n    \"no-implied-eval\": \"error\",\n    \"no-new-func\": \"error\",\n    \"no-console\": \"warn\"\n  }\n}\n*/\n\n// 2. Security Code Review Checklist Utility\nclass SecurityCodeReviewChecklist {\n  static getChecklist() {\n    return {\n      authentication: [\n        'Are passwords properly hashed with strong algorithms?',\n        'Is multi-factor authentication implemented where appropriate?',\n        'Are session tokens securely generated and managed?',\n        'Is there proper account lockout mechanism for brute force protection?',\n        'Are authentication tokens properly validated and expired?'\n      ],\n      authorization: [\n        'Is access control enforced on all sensitive operations?',\n        'Are roles and permissions properly validated?',\n        'Is there proper separation of privileges?',\n        'Are direct object references properly protected?',\n        'Is there horizontal and vertical access control?'\n      ],\n      inputValidation: [\n        'Is all user input properly validated and sanitized?',\n        'Are there proper length and format constraints?',\n        'Is output properly encoded to prevent XSS?',\n        'Are file uploads properly validated and scanned?',\n        'Are command injections prevented in system calls?'\n      ],\n      cryptography: [\n        'Are strong, up-to-date cryptographic algorithms used?',\n        'Are keys properly managed and rotated?',\n        'Is random number generation cryptographically secure?',\n        'Are encryption keys never hardcoded?',\n        'Is sensitive data properly encrypted at rest and in transit?'\n      ],\n      errorHandling: [\n        'Are detailed error messages hidden from users?',\n        'Are security-related events properly logged?',\n        'Is sensitive information excluded from logs?',\n        'Are exceptions properly caught and handled?',\n        'Is there proper audit trail for security events?'\n      ],\n      generalSecurity: [\n        'Are security headers properly configured?',\n        'Is CSRF protection implemented for state-changing operations?',\n        'Are security dependencies up to date?',\n        'Is there proper rate limiting for APIs?',\n        'Are security configurations externalized and not hardcoded?'\n      ]\n    };\n  }\n  \n  static generateReviewReport(codeChanges, reviewer) {\n    const checklist = this.getChecklist();\n    const findings = [];\n    \n    // This would typically integrate with actual code analysis tools\n    Object.keys(checklist).forEach(category => {\n      checklist[category].forEach(item => {\n        // In a real implementation, this would analyze the actual code\n        // For demo purposes, we'll simulate some findings\n        if (Math.random() < 0.1) { // 10% chance of finding\n          findings.push({\n            category,\n            item,\n            severity: ['low', 'medium', 'high'][Math.floor(Math.random() * 3)],\n            location: 'example-file.js:42',\n            recommendation: 'Implement proper validation and sanitization'\n          });\n        }\n      });\n    });\n    \n    return {\n      reviewer,\n      timestamp: new Date().toISOString(),\n      codeChanges,\n      findings,\n      summary: {\n        totalFindings: findings.length,\n        critical: findings.filter(f => f.severity === 'high').length,\n        moderate: findings.filter(f => f.severity === 'medium').length,\n        low: findings.filter(f => f.severity === 'low').length\n      }\n    };\n  }\n}\n\n// 3. Automated Security Quality Gates\nclass SecurityQualityGate {\n  constructor(config = {}) {\n    this.config = {\n      maxCriticalIssues: config.maxCriticalIssues || 0,\n      maxHighIssues: config.maxHighIssues || 5,\n      maxMediumIssues: config.maxMediumIssues || 20,\n      failOnSecurityIssues: config.failOnSecurityIssues !== false\n    };\n  }\n  \n  async evaluateQualityGate(analysisResults) {\n    const issues = this.categorizeIssues(analysisResults);\n    \n    const gateResult = {\n      passed: true,\n      issues,\n      violations: []\n    };\n    \n    // Check against configured thresholds\n    if (issues.critical > this.config.maxCriticalIssues) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'critical',\n        count: issues.critical,\n        threshold: this.config.maxCriticalIssues,\n        message: `Critical issues (${issues.critical}) exceed threshold (${this.config.maxCriticalIssues})`\n      });\n    }\n    \n    if (issues.high > this.config.maxHighIssues) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'high',\n        count: issues.high,\n        threshold: this.config.maxHighIssues,\n        message: `High severity issues (${issues.high}) exceed threshold (${this.config.maxHighIssues})`\n      });\n    }\n    \n    if (issues.medium > this.config.maxMediumIssues) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'medium',\n        count: issues.medium,\n        threshold: this.config.maxMediumIssues,\n        message: `Medium severity issues (${issues.medium}) exceed threshold (${this.config.maxMediumIssues})`\n      });\n    }\n    \n    return gateResult;\n  }\n  \n  categorizeIssues(analysisResults) {\n    // This would integrate with actual analysis tools\n    // For demo, we'll simulate based on analysis results\n    return {\n      critical: analysisResults.criticalIssues || 0,\n      high: analysisResults.highIssues || 0,\n      medium: analysisResults.mediumIssues || 0,\n      low: analysisResults.lowIssues || 0\n    };\n  }\n  \n  async runQualityChecks() {\n    console.log('Running security quality checks...');\n    \n    // In a real implementation, this would run actual security tools\n    // For demo, we'll simulate results\n    const analysisResults = {\n      criticalIssues: Math.floor(Math.random() * 3),\n      highIssues: Math.floor(Math.random() * 10),\n      mediumIssues: Math.floor(Math.random() * 25),\n      lowIssues: Math.floor(Math.random() * 50)\n    };\n    \n    const gateResult = await this.evaluateQualityGate(analysisResults);\n    \n    console.log(`Quality gate result: ${gateResult.passed ? 'PASSED' : 'FAILED'}`);\n    console.log(`Issues found - Critical: ${analysisResults.criticalIssues}, High: ${analysisResults.highIssues}, Medium: ${analysisResults.mediumIssues}, Low: ${analysisResults.lowIssues}`);\n    \n    if (!gateResult.passed) {\n      console.error('Quality gate violations:');\n      gateResult.violations.forEach(violation => {\n        console.error(`  - ${violation.message}`);\n      });\n      \n      if (this.config.failOnSecurityIssues) {\n        process.exit(1);\n      }\n    }\n    \n    return gateResult;\n  }\n}\n\n// 4. Security Code Quality Metrics\nclass SecurityCodeQualityMetrics {\n  static calculateMetrics(codebaseInfo) {\n    return {\n      // Security coverage metrics\n      inputValidationCoverage: this.calculateInputValidationCoverage(codebaseInfo),\n      authenticationCoverage: this.calculateAuthenticationCoverage(codebaseInfo),\n      authorizationCoverage: this.calculateAuthorizationCoverage(codebaseInfo),\n      \n      // Vulnerability density metrics\n      vulnerabilitiesPerKLOC: this.calculateVulnerabilityDensity(codebaseInfo),\n      securityIssuesTrend: this.calculateSecurityTrend(codebaseInfo),\n      \n      // Code quality metrics\n      codeComplexityScore: this.calculateComplexityScore(codebaseInfo),\n      securityAntiPatterns: this.countSecurityAntiPatterns(codebaseInfo),\n      \n      // Review metrics\n      codeReviewCoverage: this.calculateReviewCoverage(codebaseInfo),\n      securityFindingsRate: this.calculateFindingsRate(codebaseInfo)\n    };\n  }\n  \n  static calculateInputValidationCoverage(codebaseInfo) {\n    // This would analyze actual codebase\n    // For demo, return simulated value\n    return {\n      percentage: 85,\n      validatedEndpoints: 42,\n      totalEndpoints: 50\n    };\n  }\n  \n  static calculateAuthenticationCoverage(codebaseInfo) {\n    // This would analyze actual codebase\n    // For demo, return simulated value\n    return {\n      percentage: 95,\n      protectedRoutes: 38,\n      totalRoutes: 40\n    };\n  }\n  \n  static calculateAuthorizationCoverage(codebaseInfo) {\n    // This would analyze actual codebase\n    // For demo, return simulated value\n    return {\n      percentage: 78,\n      authorizedOperations: 31,\n      totalOperations: 40\n    };\n  }\n  \n  static calculateVulnerabilityDensity(codebaseInfo) {\n    // Vulnerabilities per thousand lines of code\n    const vulnerabilities = codebaseInfo.vulnerabilities || 12;\n    const kloc = codebaseInfo.linesOfCode ? codebaseInfo.linesOfCode / 1000 : 15;\n    return vulnerabilities / kloc;\n  }\n  \n  static calculateSecurityTrend(codebaseInfo) {\n    // Compare current vulnerabilities to previous period\n    const current = codebaseInfo.vulnerabilities || 12;\n    const previous = codebaseInfo.previousVulnerabilities || 15;\n    return ((previous - current) / previous) * 100; // Percentage improvement\n  }\n  \n  static calculateComplexityScore(codebaseInfo) {\n    // Cyclomatic complexity weighted for security-sensitive code\n    return codebaseInfo.complexityScore || 7.2;\n  }\n  \n  static countSecurityAntiPatterns(codebaseInfo) {\n    // Count occurrences of known security anti-patterns\n    return codebaseInfo.securityAntiPatterns || 8;\n  }\n  \n  static calculateReviewCoverage(codebaseInfo) {\n    // Percentage of security-sensitive code that has been reviewed\n    return codebaseInfo.reviewCoverage || 92;\n  }\n  \n  static calculateFindingsRate(codebaseInfo) {\n    // Security findings per reviewer hour\n    const findings = codebaseInfo.securityFindings || 24;\n    const reviewerHours = codebaseInfo.reviewerHours || 40;\n    return findings / reviewerHours;\n  }\n}\n\n// 5. Security Code Review Automation\nclass AutomatedSecurityReviewer {\n  constructor() {\n    this.patterns = [\n      {\n        name: 'Hardcoded Secrets',\n        pattern: /(password|api[_-]?key|secret|token)\\s*[=: ]\\s*['\\\"]\\w+/i,\n        severity: 'high',\n        message: 'Hardcoded secrets detected. Use environment variables or secure vault.'\n      },\n      {\n        name: 'SQL Injection Risk',\n        pattern: /\\.(query|execute)\\s*\\([^)]*['\\\"`]\\s*\\+\\s*[^)]*\\)/i,\n        severity: 'high',\n        message: 'Potential SQL injection vulnerability detected.'\n      },\n      {\n        name: 'Weak Cryptography',\n        pattern: /\\b(md5|sha1)\\s*\\(/i,\n        severity: 'medium',\n        message: 'Weak cryptographic hash function detected. Use SHA-256 or stronger.'\n      },\n      {\n        name: 'Insecure Random',\n        pattern: /\\b(Math\\.random|crypto\\.random)\\b/i,\n        severity: 'medium',\n        message: 'Insecure random number generation. Use cryptographically secure random.'\n      }\n    ];\n  }\n  \n  async reviewCode(code, fileName) {\n    const findings = [];\n    \n    this.patterns.forEach(pattern => {\n      const matches = code.match(pattern.pattern);\n      if (matches) {\n        findings.push({\n          pattern: pattern.name,\n          severity: pattern.severity,\n          message: pattern.message,\n          file: fileName,\n          line: this.findLine(code, matches.index)\n        });\n      }\n    });\n    \n    return findings;\n  }\n  \n  findLine(code, index) {\n    const lines = code.substring(0, index).split('\\n');\n    return lines.length;\n  }\n  \n  async reviewFile(filePath) {\n    const fs = require('fs');\n    const path = require('path');\n    \n    try {\n      const code = fs.readFileSync(filePath, 'utf8');\n      return await this.reviewCode(code, path.basename(filePath));\n    } catch (error) {\n      throw new Error(`Failed to review file ${filePath}: ${error.message}`);\n    }\n  }\n}\n\n// Example usage\nasync function runSecurityCodeReview() {\n  // Generate a sample review report\n  const reviewReport = SecurityCodeReviewChecklist.generateReviewReport(\n    'feature/authentication',\n    'security-team'\n  );\n  \n  console.log('Security Code Review Report:');\n  console.log(JSON.stringify(reviewReport, null, 2));\n  \n  // Run quality gate checks\n  const qualityGate = new SecurityQualityGate({\n    maxCriticalIssues: 0,\n    maxHighIssues: 5\n  });\n  \n  const gateResult = await qualityGate.runQualityChecks();\n  \n  // Calculate and display metrics\n  const metrics = SecurityCodeQualityMetrics.calculateMetrics({\n    linesOfCode: 15000,\n    vulnerabilities: 8,\n    previousVulnerabilities: 12,\n    securityAntiPatterns: 5\n  });\n  \n  console.log('\\nSecurity Code Quality Metrics:');\n  console.log(JSON.stringify(metrics, null, 2));\n  \n  return { reviewReport, gateResult, metrics };\n}\n\n// Example pre-commit hook integration\n/*\n#!/bin/bash\n# pre-commit hook for security checks\n\necho \"Running security code quality checks...\"\n\n# Run ESLint with security rules\nnpx eslint . --ext .js,.ts --quiet\n\n# Run security quality gate\nnode security-quality-gate.js\n\nif [ $? -ne 0 ]; then\n  echo \"Security quality checks failed. Commit aborted.\"\n  exit 1\nfi\n\necho \"Security checks passed.\"\nexit 0\n*/",
      "explanation": "This example demonstrates secure code quality practices including security-focused ESLint configuration with security plugins, a comprehensive security code review checklist utility, automated security quality gates with configurable thresholds, security code quality metrics calculation, and automated security review tools that detect common vulnerabilities and anti-patterns.",
      "language": "javascript"
    },
    "pitfalls": [{
        "mistake": "Treating security code reviews as separate from regular code reviews",
        "solution": "Integrate security considerations into all code reviews and train all developers to recognize security-relevant changes",
        "severity": "high"
      },
      {
        "mistake": "Focusing only on automated tools without human review",
        "solution": "Use automated tools to catch obvious issues but rely on human expertise for complex security analysis and context-aware evaluations",
        "severity": "medium"
      },
      {
        "mistake": "Not establishing meaningful security quality metrics",
        "solution": "Define metrics that correlate with actual security posture and track them over time to measure improvement",
        "severity": "medium"
      }
    ],
    "exercises": [{
      "title": "Secure Code Quality Implementation",
      "description": "Implement a comprehensive secure code quality system including ESLint security configuration, automated quality gates, and security metrics tracking.",
      "checkpoints": [
        "Configure ESLint with security plugins and rules",
        "Implement automated security quality gates with configurable thresholds",
        "Create security code quality metrics dashboard",
        "Set up automated security review tools for common vulnerabilities",
        "Integrate security checks into development workflow"
      ]
    }],
    "next": [],
    "estimatedMinutes": 90,
    "difficulty": "Advanced",
    "tags": [
      "Code Quality",
      "Security Review",
      "Static Analysis",
      "DevSecOps"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-7",
    "moduleSlug": "security-fundamentals",
    "title": "Security Review Processes and Collaboration",
    "order": 7,
    "objectives": [
      "Implement structured security review processes",
      "Facilitate effective security collaboration between teams",
      "Establish security review automation and tooling",
      "Measure and improve security review effectiveness"
    ],
    "intro": "Security review processes are critical for identifying vulnerabilities and ensuring that security considerations are integrated throughout the software development lifecycle. Effective security reviews require structured approaches, clear collaboration between development and security teams, and appropriate automation to scale security practices across organizations.\n\nIn this lesson, you'll learn how to implement structured security review processes that fit into modern development workflows. You'll explore different types of security reviews including architecture reviews, code reviews, and penetration testing coordination. You'll understand how to establish review criteria, create review checklists, and integrate security reviews into existing development processes without creating bottlenecks.\n\nFacilitating effective security collaboration between teams requires breaking down traditional silos and creating shared responsibility for security. You'll learn techniques for working effectively with development teams, product managers, and other stakeholders to make security a collaborative effort rather than an obstacle. You'll explore how to communicate security findings effectively and work with teams to prioritize and remediate issues.\n\nEstablishing security review automation and tooling helps scale security practices and ensures consistency across reviews. You'll learn how to select and configure automated security review tools, integrate them into development workflows, and create custom tooling to address organization-specific security concerns. You'll also explore how to balance automated and manual review processes for optimal effectiveness.\n\nBy mastering security review processes, you'll be able to identify security issues early in the development lifecycle, build security awareness throughout your organization, and create sustainable security practices that scale with your team and codebase.",
    "code": {
      "example": "// Security Review Processes and Collaboration Implementation\n\n// 1. Structured Security Review Framework\nclass SecurityReviewFramework {\n    constructor() {\n        this.reviewTypes = {\n            architecture: {\n                checklist: [\n                    'Threat modeling completed',\n                    'Security requirements documented',\n                    'Data flow analysis performed',\n                    'Authentication/authorization design reviewed',\n                    'Cryptography implementation design reviewed',\n                    'Security controls identified and documented'\n                ],\n                participants: ['security-architect', 'lead-developer', 'product-manager'],\n                timeline: 'Before development begins'\n            },\n            code: {\n                checklist: [\n                    'Input validation implemented',\n                    'Output encoding applied',\n                    'Authentication/authorization logic reviewed',\n                    'Error handling does not leak information',\n                    'Cryptography usage is correct',\n                    'Security dependencies are current'\n                ],\n                participants: ['security-engineer', 'code-reviewer', 'developer'],\n                timeline: 'During code review process'\n            },\n            deployment: {\n                checklist: [\n                    'Security configurations validated',\n                    'Environment isolation verified',\n                    'Monitoring and alerting configured',\n                    'Backup and recovery procedures tested',\n                    'Incident response procedures documented'\n                ],\n                participants: ['devops-engineer', 'security-ops', 'system-admin'],\n                timeline: 'Before production deployment'\n            }\n        };\n    }\n    \n    async conductReview(reviewType, target, reviewers) {\n        const reviewConfig = this.reviewTypes[reviewType];\n        if (!reviewConfig) {\n            throw new Error(`Unknown review type: ${reviewType}`);\n        }\n        \n        console.log(`Conducting ${reviewType} review for ${target}`);\n        \n        // In a real implementation, this would integrate with actual review tools\n        // For demo, we'll simulate the review process\n        const findings = [];\n        \n        // Simulate review process\n        reviewConfig.checklist.forEach(item => {\n            // Randomly generate findings for demo purposes\n            if (Math.random() < 0.2) { // 20% chance of finding\n                findings.push({\n                    item,\n                    severity: ['low', 'medium', 'high'][Math.floor(Math.random() * 3)],\n                    recommendation: 'Implement proper security controls'\n                });\n            }\n        });\n        \n        return {\n            reviewType,\n            target,\n            reviewers,\n            timestamp: new Date().toISOString(),\n            checklist: reviewConfig.checklist,\n            findings,\n            status: findings.length > 0 ? 'needs_attention' : 'approved'\n        };\n    }\n    \n    generateReviewTemplate(reviewType) {\n        const template = this.reviewTypes[reviewType];\n        if (!template) {\n            throw new Error(`Unknown review type: ${reviewType}`);\n        }\n        \n        return {\n            type: reviewType,\n            checklist: template.checklist.map(item => ({\n                item,\n                checked: false,\n                notes: ''\n            })),\n            participants: template.participants\n        };\n    }\n}\n\n// 2. Security Collaboration Platform\nclass SecurityCollaborationPlatform {\n    constructor() {\n        this.issues = [];\n        this.reviewers = new Map();\n    }\n    \n    // Create a security issue for collaboration\n    createIssue(title, description, severity, assignees = []) {\n        const issue = {\n            id: `SEC-${Date.now()}-${Math.floor(Math.random() * 1000)}`,\n            title,\n            description,\n            severity,\n            status: 'open',\n            assignees,\n            createdAt: new Date().toISOString(),\n            updatedAt: new Date().toISOString(),\n            comments: [],\n            tags: ['security']\n        };\n        \n        this.issues.push(issue);\n        return issue.id;\n    }\n    \n    // Add comment to security issue\n    addComment(issueId, author, comment) {\n        const issue = this.issues.find(i => i.id === issueId);\n        if (!issue) {\n            throw new Error(`Issue not found: ${issueId}`);\n        }\n        \n        issue.comments.push({\n            author,\n            comment,\n            timestamp: new Date().toISOString()\n        });\n        \n        issue.updatedAt = new Date().toISOString();\n        return issue;\n    }\n    \n    // Update issue status\n    updateStatus(issueId, status, updatedBy) {\n        const issue = this.issues.find(i => i.id === issueId);\n        if (!issue) {\n            throw new Error(`Issue not found: ${issueId}`);\n        }\n        \n        issue.status = status;\n        issue.updatedAt = new Date().toISOString();\n        \n        this.addComment(issueId, updatedBy, `Status updated to ${status}`);\n        return issue;\n    }\n    \n    // Assign reviewers to security issues\n    assignReviewers(issueId, reviewers) {\n        const issue = this.issues.find(i => i.id === issueId);\n        if (!issue) {\n            throw new Error(`Issue not found: ${issueId}`);\n        }\n        \n        issue.assignees = [...new Set([...issue.assignees, ...reviewers])];\n        issue.updatedAt = new Date().toISOString();\n        \n        this.addComment(issueId, 'system', `Reviewers assigned: ${reviewers.join(', ')}`);\n        return issue;\n    }\n    \n    // Get issues by severity\n    getIssuesBySeverity(severity) {\n        return this.issues.filter(issue => issue.severity === severity);\n    }\n    \n    // Get issues assigned to a reviewer\n    getIssuesForReviewer(reviewer) {\n        return this.issues.filter(issue => issue.assignees.includes(reviewer));\n    }\n}\n\n// 3. Automated Security Review Integration\nclass AutomatedSecurityReview {\n    constructor(gitProvider, ciProvider) {\n        this.gitProvider = gitProvider;\n        this.ciProvider = ciProvider;\n        this.reviewThresholds = {\n            critical: 0,\n            high: 5,\n            medium: 20\n        };\n    }\n    \n    // Analyze pull request for security issues\n    async analyzePullRequest(prNumber, repository) {\n        console.log(`Analyzing PR #${prNumber} in ${repository} for security issues`);\n        \n        // In a real implementation, this would integrate with actual security tools\n        // For demo, we'll simulate analysis\n        const analysis = {\n            prNumber,\n            repository,\n            timestamp: new Date().toISOString(),\n            findings: [],\n            summary: {\n                critical: 0,\n                high: 0,\n                medium: 0,\n                low: 0\n            }\n        };\n        \n        // Simulate finding security issues\n        const issueTypes = [\n            'Hardcoded secrets',\n            'SQL injection risk',\n            'XSS vulnerability',\n            'Insecure dependencies',\n            'Weak cryptography',\n            'Missing input validation'\n        ];\n        \n        // Randomly generate findings\n        const issueCount = Math.floor(Math.random() * 10);\n        for (let i = 0; i < issueCount; i++) {\n            const severity = ['low', 'medium', 'high', 'critical'][Math.floor(Math.random() * 4)];\n            analysis.findings.push({\n                id: `FINDING-${Date.now()}-${i}`,\n                type: issueTypes[Math.floor(Math.random() * issueTypes.length)],\n                severity,\n                file: `src/file${Math.floor(Math.random() * 20)}.js`,\n                line: Math.floor(Math.random() * 100) + 1,\n                description: 'Security issue detected during automated review',\n                recommendation: 'Implement proper security controls'\n            });\n            \n            analysis.summary[severity]++;\n        }\n        \n        return analysis;\n    }\n    \n    // Post security review comments to PR\n    async postReviewComments(prNumber, repository, analysis) {\n        console.log(`Posting ${analysis.findings.length} security comments to PR #${prNumber}`);\n        \n        // In a real implementation, this would integrate with Git provider APIs\n        // For demo, we'll just log the actions\n        analysis.findings.forEach(finding => {\n            console.log(`Commenting on ${finding.file}:${finding.line}: ${finding.type} (${finding.severity})`);\n        });\n        \n        // Determine if PR should be blocked\n        const shouldBlock = (\n            analysis.summary.critical > this.reviewThresholds.critical ||\n            analysis.summary.high > this.reviewThresholds.high ||\n            analysis.summary.medium > this.reviewThresholds.medium\n        );\n        \n        return {\n            prNumber,\n            shouldBlock,\n            reason: shouldBlock ? 'Security issues exceed thresholds' : 'Security review passed'\n        };\n    }\n    \n    // Generate security review report\n    generateReviewReport(analysis) {\n        return {\n            title: `Security Review Report - PR #${analysis.prNumber}`,\n            timestamp: analysis.timestamp,\n            summary: analysis.summary,\n            findings: analysis.findings,\n            recommendations: [\n                'Address all critical and high severity issues before merging',\n                'Review medium severity issues for potential improvements',\n                'Consider implementing additional security controls'\n            ]\n        };\n    }\n}\n\n// 4. Security Review Metrics and Analytics\nclass SecurityReviewMetrics {\n    constructor() {\n        this.reviews = [];\n    }\n    \n    // Record a completed security review\n    recordReview(review) {\n        this.reviews.push({\n            ...review,\n            recordedAt: new Date().toISOString()\n        });\n    }\n    \n    // Calculate review effectiveness metrics\n    calculateEffectivenessMetrics() {\n        if (this.reviews.length === 0) {\n            return {\n                reviewCount: 0,\n                avgFindingsPerReview: 0,\n                criticalIssueDetectionRate: 0,\n                reviewCompletionRate: 0\n            };\n        }\n        \n        const totalFindings = this.reviews.reduce((sum, review) => \n            sum + review.findings.length, 0);\n        \n        const criticalFindings = this.reviews\n            .flatMap(review => review.findings)\n            .filter(finding => finding.severity === 'critical').length;\n        \n        const completedReviews = this.reviews\n            .filter(review => review.status === 'completed').length;\n        \n        return {\n            reviewCount: this.reviews.length,\n            avgFindingsPerReview: totalFindings / this.reviews.length,\n            criticalIssueDetectionRate: (criticalFindings / totalFindings * 100) || 0,\n            reviewCompletionRate: (completedReviews / this.reviews.length * 100)\n        };\n    }\n    \n    // Get review trends over time\n    getReviewTrends(days = 30) {\n        const cutoffDate = new Date();\n        cutoffDate.setDate(cutoffDate.getDate() - days);\n        \n        const recentReviews = this.reviews.filter(review => \n            new Date(review.recordedAt) > cutoffDate);\n        \n        // Group reviews by week\n        const weeklyData = {};\n        recentReviews.forEach(review => {\n            const week = new Date(review.recordedAt);\n            week.setDate(week.getDate() - week.getDay()); // Start of week\n            const weekKey = week.toISOString().split('T')[0];\n            \n            if (!weeklyData[weekKey]) {\n                weeklyData[weekKey] = {\n                    reviews: 0,\n                    findings: 0,\n                    critical: 0\n                };\n            }\n            \n            weeklyData[weekKey].reviews++;\n            weeklyData[weekKey].findings += review.findings.length;\n            weeklyData[weekKey].critical += review.findings\n                .filter(f => f.severity === 'critical').length;\n        });\n        \n        return weeklyData;\n    }\n}\n\n// Example usage\nasync function demonstrateSecurityReviewProcess() {\n    // Initialize security review framework\n    const reviewFramework = new SecurityReviewFramework();\n    \n    // Generate a code review template\n    const codeReviewTemplate = reviewFramework.generateReviewTemplate('code');\n    console.log('Code Review Template:', JSON.stringify(codeReviewTemplate, null, 2));\n    \n    // Conduct a sample architecture review\n    const archReview = await reviewFramework.conductReview(\n        'architecture',\n        'user-authentication-service',\n        ['security-architect', 'lead-developer']\n    );\n    console.log('Architecture Review:', JSON.stringify(archReview, null, 2));\n    \n    // Initialize collaboration platform\n    const collabPlatform = new SecurityCollaborationPlatform();\n    \n    // Create security issues\n    const issue1 = collabPlatform.createIssue(\n        'SQL Injection Vulnerability',\n        'User input is not properly sanitized in login endpoint',\n        'high',\n        ['backend-developer', 'security-engineer']\n    );\n    \n    const issue2 = collabPlatform.createIssue(\n        'Hardcoded API Key',\n        'Production API key found in source code',\n        'critical',\n        ['devops-engineer']\n    );\n    \n    // Add comments to issues\n    collabPlatform.addComment(issue1, 'security-engineer', 'This needs immediate attention');\n    collabPlatform.addComment(issue2, 'devops-engineer', 'Key has been rotated, removing from code');\n    \n    // Update issue statuses\n    collabPlatform.updateStatus(issue1, 'in_progress', 'project-manager');\n    collabPlatform.updateStatus(issue2, 'resolved', 'devops-engineer');\n    \n    console.log('Security issues:', collabPlatform.issues);\n    \n    // Initialize metrics tracking\n    const metrics = new SecurityReviewMetrics();\n    metrics.recordReview(archReview);\n    \n    // Calculate and display metrics\n    const effectiveness = metrics.calculateEffectivenessMetrics();\n    console.log('Review Effectiveness Metrics:', JSON.stringify(effectiveness, null, 2));\n    \n    return {\n        reviewFramework,\n        collabPlatform,\n        metrics,\n        archReview\n    };\n}\n\n// Example GitHub Actions integration for automated security reviews\n/*\nname: Security Review\non: [pull_request]\njobs:\n  security-review:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          fetch-depth: 0\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n      - name: Install dependencies\n        run: npm ci\n      - name: Run security analysis\n        run: node security-review.js\n      - name: Post security comments\n        if: always()\n        run: node post-security-comments.js\n        env:\n          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}\n*/",
      "explanation": "This example demonstrates security review processes and collaboration including a structured security review framework with different review types and checklists, a security collaboration platform for issue tracking and team communication, automated security review integration with pull requests, and security review metrics and analytics for measuring effectiveness.",
      "language": "javascript"
    },
    "pitfalls": [{
        "mistake": "Creating security review processes that are too slow or bureaucratic",
        "solution": "Design streamlined review processes with clear criteria and integrate automated checks to handle routine issues, reserving human review for complex security decisions",
        "severity": "high"
      },
      {
        "mistake": "Not involving the right stakeholders in security reviews",
        "solution": "Identify key stakeholders for each type of review and ensure they're included in the process, providing appropriate context and training for effective participation",
        "severity": "medium"
      },
      {
        "mistake": "Failing to track and measure security review effectiveness",
        "solution": "Implement metrics to track review outcomes, issue resolution times, and security posture improvements to continuously refine the review process",
        "severity": "medium"
      }
    ],
    "exercises": [{
      "title": "Security Review Process Implementation",
      "description": "Implement a comprehensive security review process including structured review frameworks, collaboration tools, and metrics tracking.",
      "checkpoints": [
        "Create security review templates for different review types",
        "Implement a security collaboration platform for issue tracking",
        "Set up automated security review integration with pull requests",
        "Establish security review metrics and reporting",
        "Test the end-to-end review process with sample code changes"
      ]
    }],
    "next": [],
    "estimatedMinutes": 90,
    "difficulty": "Advanced",
    "tags": [
      "Security Review",
      "Collaboration",
      "Code Review",
      "DevSecOps"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-8",
    "moduleSlug": "security-fundamentals",
    "title": "Security in Continuous Integration and Deployment",
    "order": 8,
    "objectives": [
      "Integrate security testing into CI/CD pipelines",
      "Implement security gates and quality checks",
      "Automate security validation for deployments",
      "Monitor and respond to security events in production"
    ],
    "intro": "Security in continuous integration and deployment (CI/CD) is essential for maintaining rapid development velocity while ensuring that security is not compromised. Modern DevOps practices require security to be integrated throughout the pipeline rather than treated as a separate phase. This approach, often called DevSecOps, enables organizations to deliver secure software quickly and reliably.\n\nIn this lesson, you'll learn how to integrate security testing into CI/CD pipelines effectively. You'll explore different types of security tests that can be automated, including static analysis, dependency scanning, and vulnerability assessments. You'll understand how to configure these tests to run at appropriate stages in your pipeline and how to interpret and act on their results.\n\nImplementing security gates and quality checks ensures that vulnerable code doesn't progress through the deployment pipeline. You'll learn how to establish security thresholds, configure automated gates that prevent insecure code from being deployed, and create feedback loops that help developers quickly address security issues. You'll also explore how to balance security requirements with development speed.\n\nAutomating security validation for deployments reduces the risk of security incidents in production environments. You'll learn techniques for validating security configurations, scanning container images, and verifying that security controls are properly implemented before code reaches production. You'll also explore infrastructure as code (IaC) security scanning and configuration validation.\n\nBy mastering security in CI/CD, you'll be able to build and deploy secure applications at scale, reduce the time and cost of addressing security issues, and create a culture where security is everyone's responsibility rather than a bottleneck.",
    "code": {
      "example": "// Security in Continuous Integration and Deployment Implementation\n\n// 1. CI/CD Security Pipeline Configuration\n/*\n# Example GitHub Actions workflow with security checks\nname: Security CI/CD Pipeline\non: [push, pull_request]\njobs:\n  security-analysis:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n      - name: Install dependencies\n        run: npm ci\n      \n      # Security dependency scanning\n      - name: Run npm audit\n        run: npm audit || npm audit --audit-level=moderate\n      \n      # Static Application Security Testing (SAST)\n      - name: Run ESLint with security rules\n        run: npx eslint . --ext .js,.ts --quiet\n      \n      # Security unit tests\n      - name: Run security tests\n        run: npm run test:security\n      \n      # Security quality gate\n      - name: Run security quality gate\n        run: node security-gate.js\n      \n  build-and-scan:\n    runs-on: ubuntu-latest\n    needs: security-analysis\n    steps:\n      - uses: actions/checkout@v2\n      - name: Build application\n        run: npm run build\n      \n      # Container image scanning\n      - name: Build Docker image\n        run: docker build -t myapp:\\${{ github.sha }} .\n      - name: Scan container image\n        run: trivy image --exit-code 1 --severity HIGH,CRITICAL myapp:\\${{ github.sha }}\n      \n  deploy-to-staging:\n    runs-on: ubuntu-latest\n    needs: build-and-scan\n    environment: staging\n    steps:\n      - name: Deploy to staging\n        run: |\n          # Deployment commands here\n          echo \"Deploying to staging environment\"\n      \n      # Post-deployment security validation\n      - name: Validate security configuration\n        run: node validate-security-config.js\n*/\n\n// 2. Security Quality Gate Implementation\nclass SecurityQualityGate {\n  constructor(config = {}) {\n    this.config = {\n      maxCriticalVulnerabilities: config.maxCriticalVulnerabilities || 0,\n      maxHighVulnerabilities: config.maxHighVulnerabilities || 5,\n      maxMediumVulnerabilities: config.maxMediumVulnerabilities || 20,\n      failOnSecurityIssues: config.failOnSecurityIssues !== false\n    };\n  }\n  \n  async evaluatePipelineSecurity(analysisResults) {\n    const vulnerabilities = this.categorizeVulnerabilities(analysisResults);\n    \n    const gateResult = {\n      passed: true,\n      vulnerabilities,\n      violations: []\n    };\n    \n    // Check against configured thresholds\n    if (vulnerabilities.critical > this.config.maxCriticalVulnerabilities) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'critical',\n        count: vulnerabilities.critical,\n        threshold: this.config.maxCriticalVulnerabilities,\n        message: `Critical vulnerabilities (\\${vulnerabilities.critical}) exceed threshold (\\${this.config.maxCriticalVulnerabilities})`\n      });\n    }\n    \n    if (vulnerabilities.high > this.config.maxHighVulnerabilities) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'high',\n        count: vulnerabilities.high,\n        threshold: this.config.maxHighVulnerabilities,\n        message: `High severity vulnerabilities (\\${vulnerabilities.high}) exceed threshold (\\${this.config.maxHighVulnerabilities})`\n      });\n    }\n    \n    if (vulnerabilities.medium > this.config.maxMediumVulnerabilities) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'medium',\n        count: vulnerabilities.medium,\n        threshold: this.config.maxMediumVulnerabilities,\n        message: `Medium severity vulnerabilities (\\${vulnerabilities.medium}) exceed threshold (\\${this.config.maxMediumVulnerabilities})`\n      });\n    }\n    \n    return gateResult;\n  }\n  \n  categorizeVulnerabilities(analysisResults) {\n    // This would integrate with actual security tools\n    // For demo, we'll simulate based on analysis results\n    return {\n      critical: analysisResults.criticalVulnerabilities || 0,\n      high: analysisResults.highVulnerabilities || 0,\n      medium: analysisResults.mediumVulnerabilities || 0,\n      low: analysisResults.lowVulnerabilities || 0\n    };\n  }\n  \n  async runSecurityGate() {\n    console.log('Running security quality gate...');\n    \n    // In a real implementation, this would run actual security tools\n    // For demo, we'll simulate results\n    const analysisResults = {\n      criticalVulnerabilities: Math.floor(Math.random() * 3),\n      highVulnerabilities: Math.floor(Math.random() * 10),\n      mediumVulnerabilities: Math.floor(Math.random() * 25),\n      lowVulnerabilities: Math.floor(Math.random() * 50)\n    };\n    \n    const gateResult = await this.evaluatePipelineSecurity(analysisResults);\n    \n    console.log(`Security gate result: \\${gateResult.passed ? 'PASSED' : 'FAILED'}`);\n    console.log(`Vulnerabilities found - Critical: \\${analysisResults.criticalVulnerabilities}, High: \\${analysisResults.highVulnerabilities}, Medium: \\${analysisResults.mediumVulnerabilities}, Low: \\${analysisResults.lowVulnerabilities}`);\n    \n    if (!gateResult.passed) {\n      console.error('Security gate violations:');\n      gateResult.violations.forEach(violation => {\n        console.error(`  - \\${violation.message}`);\n      });\n      \n      if (this.config.failOnSecurityIssues) {\n        process.exit(1);\n      }\n    }\n    \n    return gateResult;\n  }\n}\n\n// 3. Automated Security Validation for Deployments\nclass DeploymentSecurityValidator {\n  constructor() {\n    this.validationChecks = [\n      {\n        name: 'Environment Variables',\n        check: this.validateEnvironmentVariables\n      },\n      {\n        name: 'Security Headers',\n        check: this.validateSecurityHeaders\n      },\n      {\n        name: 'TLS Configuration',\n        check: this.validateTLSConfiguration\n      },\n      {\n        name: 'Authentication',\n        check: this.validateAuthentication\n      },\n      {\n        name: 'Authorization',\n        check: this.validateAuthorization\n      }\n    ];\n  }\n  \n  async validateDeployment(environment) {\n    console.log(`Validating security for \\${environment} deployment...`);\n    \n    const results = {\n      environment,\n      timestamp: new Date().toISOString(),\n      checks: [],\n      passed: true\n    };\n    \n    // Run all validation checks\n    for (const validation of this.validationChecks) {\n      try {\n        const checkResult = await validation.check(environment);\n        results.checks.push({\n          name: validation.name,\n          passed: checkResult.passed,\n          details: checkResult.details\n        });\n        \n        if (!checkResult.passed) {\n          results.passed = false;\n        }\n      } catch (error) {\n        results.checks.push({\n          name: validation.name,\n          passed: false,\n          details: `Validation failed: \\${error.message}`\n        });\n        results.passed = false;\n      }\n    }\n    \n    return results;\n  }\n  \n  async validateEnvironmentVariables(environment) {\n    // In a real implementation, this would check actual environment\n    // For demo, we'll simulate validation\n    const issues = [];\n    \n    // Simulate finding issues\n    if (Math.random() < 0.3) {\n      issues.push('Hardcoded secrets detected in environment configuration');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      details: issues.length === 0 ? 'Environment variables properly configured' : issues\n    };\n  }\n  \n  async validateSecurityHeaders(environment) {\n    // Simulate security header validation\n    const issues = [];\n    \n    if (Math.random() < 0.2) {\n      issues.push('Missing Content-Security-Policy header');\n    }\n    \n    if (Math.random() < 0.1) {\n      issues.push('Missing X-Frame-Options header');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      details: issues.length === 0 ? 'Security headers properly configured' : issues\n    };\n  }\n  \n  async validateTLSConfiguration(environment) {\n    // Simulate TLS configuration validation\n    const issues = [];\n    \n    if (Math.random() < 0.15) {\n      issues.push('TLS certificate expires within 30 days');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      details: issues.length === 0 ? 'TLS configuration valid' : issues\n    };\n  }\n  \n  async validateAuthentication(environment) {\n    // Simulate authentication validation\n    const issues = [];\n    \n    if (Math.random() < 0.25) {\n      issues.push('Weak password policy detected');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      details: issues.length === 0 ? 'Authentication properly configured' : issues\n    };\n  }\n  \n  async validateAuthorization(environment) {\n    // Simulate authorization validation\n    const issues = [];\n    \n    if (Math.random() < 0.2) {\n      issues.push('Overly permissive role assignments detected');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      details: issues.length === 0 ? 'Authorization properly configured' : issues\n    };\n  }\n}\n\n// 4. Security Monitoring and Alerting\nclass SecurityMonitor {\n  constructor(alertingSystem) {\n    this.alertingSystem = alertingSystem;\n    this.monitors = [\n      {\n        name: 'Failed Authentication Attempts',\n        check: this.checkFailedAuthAttempts,\n        threshold: 10,\n        window: 300 // 5 minutes\n      },\n      {\n        name: 'Suspicious File Access',\n        check: this.checkSuspiciousFileAccess,\n        threshold: 5,\n        window: 300\n      },\n      {\n        name: 'High Error Rates',\n        check: this.checkHighErrorRates,\n        threshold: 50,\n        window: 300\n      }\n    ];\n  }\n  \n  async runMonitoringChecks() {\n    console.log('Running security monitoring checks...');\n    \n    const alerts = [];\n    \n    for (const monitor of this.monitors) {\n      try {\n        const result = await monitor.check(monitor.window);\n        \n        if (result.count > monitor.threshold) {\n          const alert = {\n            monitor: monitor.name,\n            count: result.count,\n            threshold: monitor.threshold,\n            timestamp: new Date().toISOString(),\n            details: result.details\n          };\n          \n          alerts.push(alert);\n          await this.alertingSystem.sendAlert(alert);\n        }\n      } catch (error) {\n        console.error(`Monitoring check failed for \\${monitor.name}: \\${error.message}`);\n      }\n    }\n    \n    return alerts;\n  }\n  \n  async checkFailedAuthAttempts(windowSeconds) {\n    // In a real implementation, this would query actual logs/metrics\n    // For demo, we'll simulate results\n    return {\n      count: Math.floor(Math.random() * 20),\n      details: 'Failed authentication attempts detected'\n    };\n  }\n  \n  async checkSuspiciousFileAccess(windowSeconds) {\n    // Simulate suspicious file access detection\n    return {\n      count: Math.floor(Math.random() * 10),\n      details: 'Suspicious file access patterns detected'\n    };\n  }\n  \n  async checkHighErrorRates(windowSeconds) {\n    // Simulate high error rate detection\n    return {\n      count: Math.floor(Math.random() * 100),\n      details: 'High error rates detected'\n    };\n  }\n}\n\n// 5. CI/CD Security Metrics and Reporting\nclass CICDSecurityMetrics {\n  constructor() {\n    this.pipelineRuns = [];\n  }\n  \n  recordPipelineRun(runData) {\n    this.pipelineRuns.push({\n      ...runData,\n      timestamp: new Date().toISOString()\n    });\n  }\n  \n  calculateDeploymentFrequency() {\n    if (this.pipelineRuns.length === 0) return 0;\n    \n    // Calculate deployments per day\n    const earliest = new Date(Math.min(...this.pipelineRuns.map(r => new Date(r.timestamp))));\n    const latest = new Date();\n    const days = (latest - earliest) / (1000 * 60 * 60 * 24);\n    \n    const successfulDeployments = this.pipelineRuns\n      .filter(run => run.status === 'success' && run.type === 'deployment').length;\n    \n    return successfulDeployments / days;\n  }\n  \n  calculateMeanTimeToRecovery() {\n    // Calculate average time to recover from security incidents\n    const incidents = this.pipelineRuns.filter(run => run.incident);\n    if (incidents.length === 0) return 0;\n    \n    const totalRecoveryTime = incidents.reduce((sum, incident) => \n      sum + (incident.recoveryTime || 0), 0);\n    \n    return totalRecoveryTime / incidents.length;\n  }\n  \n  calculateChangeFailPercentage() {\n    const totalChanges = this.pipelineRuns.length;\n    if (totalChanges === 0) return 0;\n    \n    const failedChanges = this.pipelineRuns\n      .filter(run => run.status === 'failed').length;\n    \n    return (failedChanges / totalChanges) * 100;\n  }\n  \n  generateSecurityReport() {\n    return {\n      deploymentFrequency: this.calculateDeploymentFrequency(),\n      meanTimeToRecovery: this.calculateMeanTimeToRecovery(),\n      changeFailPercentage: this.calculateChangeFailPercentage(),\n      totalPipelineRuns: this.pipelineRuns.length,\n      securityIncidents: this.pipelineRuns.filter(run => run.incident).length\n    };\n  }\n}\n\n// Example usage\nasync function runCICDSecurityDemo() {\n  // Run security quality gate\n  const qualityGate = new SecurityQualityGate({\n    maxCriticalVulnerabilities: 0,\n    maxHighVulnerabilities: 5\n  });\n  \n  const gateResult = await qualityGate.runSecurityGate();\n  \n  // Validate deployment security\n  const validator = new DeploymentSecurityValidator();\n  const validationResults = await validator.validateDeployment('staging');\n  console.log('Deployment validation:', JSON.stringify(validationResults, null, 2));\n  \n  // Run security monitoring\n  const mockAlertingSystem = {\n    sendAlert: async (alert) => {\n      console.log(`ALERT: \\${alert.monitor} - \\${alert.details}`);\n    }\n  };\n  \n  const monitor = new SecurityMonitor(mockAlertingSystem);\n  const alerts = await monitor.runMonitoringChecks();\n  console.log(`Generated \\${alerts.length} security alerts`);\n  \n  // Generate metrics report\n  const metrics = new CICDSecurityMetrics();\n  metrics.recordPipelineRun({\n    type: 'deployment',\n    status: 'success',\n    duration: 300\n  });\n  \n  metrics.recordPipelineRun({\n    type: 'deployment',\n    status: 'failed',\n    duration: 150\n  });\n  \n  const report = metrics.generateSecurityReport();\n  console.log('CI/CD Security Metrics:', JSON.stringify(report, null, 2));\n  \n  return {\n    qualityGate: gateResult,\n    validation: validationResults,\n    alerts,\n    metrics: report\n  };\n}\n\n// Example Jenkins pipeline integration\n/*\npipeline {\n  agent any\n  \n  stages {\n    stage('Security Analysis') {\n      steps {\n        sh 'npm audit'\n        sh 'npx eslint . --ext .js,.ts --quiet'\n        sh 'node security-gate.js'\n      }\n    }\n    \n    stage('Build and Test') {\n      steps {\n        sh 'npm run build'\n        sh 'npm test'\n      }\n    }\n    \n    stage('Container Scan') {\n      steps {\n        sh 'docker build -t myapp:$BUILD_NUMBER .'\n        sh 'trivy image --exit-code 1 --severity HIGH,CRITICAL myapp:$BUILD_NUMBER'\n      }\n    }\n    \n    stage('Deploy to Staging') {\n      steps {\n        sh 'kubectl apply -f k8s/staging'\n        sh 'node validate-security-config.js'\n      }\n    }\n  }\n  \n  post {\n    failure {\n      script {\n        // Notify security team on pipeline failure\n        sh 'curl -X POST -d \\\"Pipeline failed due to security issues\\\" https://chat.webhook/security-alerts'\n      }\n    }\n  }\n}*/",
      "explanation": "This example demonstrates security in CI/CD including CI/CD pipeline configuration with security checks, security quality gate implementation with configurable thresholds, automated security validation for deployments, security monitoring and alerting systems, and CI/CD security metrics and reporting.",
      "language": "javascript"
    },
    "pitfalls": [{
        "mistake": "Adding too many security checks which slow down the pipeline",
        "solution": "Prioritize security checks based on risk and implement them at appropriate stages in the pipeline, using fast feedback loops for critical issues and more thorough analysis for less critical ones",
        "severity": "high"
      },
      {
        "mistake": "Not properly configuring security tools for the pipeline environment",
        "solution": "Ensure security tools are properly configured for your technology stack and pipeline environment, with appropriate baselines and thresholds to minimize false positives",
        "severity": "medium"
      },
      {
        "mistake": "Failing to monitor security in production after deployment",
        "solution": "Implement continuous security monitoring with alerting for production environments, including anomaly detection, threat hunting, and incident response procedures",
        "severity": "high"
      }
    ],
    "exercises": [{
      "title": "CI/CD Security Implementation",
      "description": "Implement a comprehensive CI/CD security pipeline including security gates, deployment validation, and monitoring.",
      "checkpoints": [
        "Configure security checks in a CI/CD pipeline",
        "Implement security quality gates with configurable thresholds",
        "Set up automated deployment security validation",
        "Create security monitoring and alerting for production",
        "Establish CI/CD security metrics and reporting"
      ]
    }],
    "next": [],
    "estimatedMinutes": 120,
    "difficulty": "Expert",
    "tags": [
      "CI/CD",
      "DevSecOps",
      "Pipeline Security",
      "Automation"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-9",
    "moduleSlug": "security-fundamentals",
    "title": "Security Monitoring and Incident Response",
    "order": 9,
    "objectives": [
      "Implement comprehensive security monitoring solutions",
      "Configure security alerts and notification systems",
      "Establish incident response procedures and playbooks",
      "Conduct security investigations and forensics"
    ],
    "intro": "Security monitoring and incident response are critical capabilities for detecting, responding to, and recovering from security threats. Effective monitoring provides visibility into security events across your systems, while well-defined incident response procedures ensure that security incidents are handled quickly and effectively to minimize impact.\n\nIn this lesson, you'll learn how to implement comprehensive security monitoring solutions that provide visibility into authentication events, authorization failures, system anomalies, and potential security breaches. You'll explore different types of security monitoring including network monitoring, host-based monitoring, application monitoring, and user behavior analytics. You'll understand how to select appropriate monitoring tools and configure them to detect relevant security events.\n\nConfiguring security alerts and notification systems ensures that security teams are promptly notified of potential threats. You'll learn how to design alerting systems that minimize false positives while ensuring that critical security events are not missed. You'll explore techniques for alert correlation, escalation procedures, and notification channels that ensure the right people are informed at the right time.\n\nEstablishing incident response procedures and playbooks creates a structured approach to handling security incidents. You'll learn how to develop incident response plans that cover different types of security events, establish clear roles and responsibilities, and create repeatable processes for investigation, containment, eradication, and recovery. You'll also explore how to maintain and test incident response capabilities to ensure they remain effective.\n\nBy mastering security monitoring and incident response, you'll be able to detect security threats early, respond to incidents effectively, and continuously improve your security posture based on lessons learned from real-world events.",
    "code": {
      "example": "// Security Monitoring and Incident Response Implementation\n\n// 1. Security Monitoring Framework\nclass SecurityMonitoringFramework {\n    constructor() {\n        this.monitors = new Map();\n        this.alerts = [];\n        this.incidents = [];\n    }\n    \n    // Register a security monitor\n    registerMonitor(name, monitor) {\n        this.monitors.set(name, monitor);\n    }\n    \n    // Run all registered monitors\n    async runAllMonitors() {\n        console.log('Running all security monitors...');\n        \n        const results = [];\n        for (const [name, monitor] of this.monitors) {\n            try {\n                const result = await monitor.check();\n                results.push({\n                    monitor: name,\n                    result\n                });\n                \n                // Generate alerts for any findings\n                if (result.findings && result.findings.length > 0) {\n                    for (const finding of result.findings) {\n                        await this.generateAlert(name, finding);\n                    }\n                }\n            } catch (error) {\n                console.error(`Monitor ${name} failed: ${error.message}`);\n                results.push({\n                    monitor: name,\n                    error: error.message\n                });\n            }\n        }\n        \n        return results;\n    }\n    \n    // Generate a security alert\n    async generateAlert(monitorName, finding) {\n        const alert = {\n            id: `ALERT-${Date.now()}-${Math.floor(Math.random() * 1000)}`,\n            monitor: monitorName,\n            severity: finding.severity || 'medium',\n            timestamp: new Date().toISOString(),\n            finding,\n            status: 'open'\n        };\n        \n        this.alerts.push(alert);\n        \n        // Notify appropriate channels\n        await this.notify(alert);\n        \n        return alert.id;\n    }\n    \n    // Notify security team about alert\n    async notify(alert) {\n        console.log(`SECURITY ALERT: ${alert.monitor} - ${alert.finding.description}`);\n        \n        // In a real implementation, this would send notifications via:\n        // - Email\n        // - Slack/Discord\n        // - SMS\n        // - Incident management systems\n        \n        // Escalate high severity alerts\n        if (alert.severity === 'critical' || alert.severity === 'high') {\n            console.log(`ESCALATING ${alert.severity} severity alert to security team`);\n        }\n    }\n    \n    // Get alerts by severity\n    getAlertsBySeverity(severity) {\n        return this.alerts.filter(alert => alert.severity === severity);\n    }\n    \n    // Get open alerts\n    getOpenAlerts() {\n        return this.alerts.filter(alert => alert.status === 'open');\n    }\n}\n\n// 2. Specific Security Monitors\n\n// Authentication Monitor\nclass AuthenticationMonitor {\n    constructor(authService, threshold = 10) {\n        this.authService = authService;\n        this.threshold = threshold; // Failed attempts threshold\n    }\n    \n    async check() {\n        // In a real implementation, this would query auth logs\n        // For demo, we'll simulate checking for brute force attempts\n        \n        // Simulate failed login attempts\n        const failedAttempts = Math.floor(Math.random() * 20);\n        \n        const findings = [];\n        if (failedAttempts > this.threshold) {\n            findings.push({\n                type: 'brute_force_attempt',\n                description: `High number of failed login attempts detected: ${failedAttempts}`,\n                severity: failedAttempts > this.threshold * 2 ? 'high' : 'medium',\n                details: { failedAttempts, threshold: this.threshold }\n            });\n        }\n        \n        return {\n            timestamp: new Date().toISOString(),\n            findings\n        };\n    }\n}\n\n// Authorization Monitor\nclass AuthorizationMonitor {\n    constructor(auditService, threshold = 25) {\n        this.auditService = auditService;\n        this.threshold = threshold; // Authorisation failures threshold\n    }\n    \n    async check() {\n        // Simulate authorisation failures within window\n        const authzFailures = Math.floor(Math.random() * 40);\n        const findings = [];\n        if (authzFailures > this.threshold) {\n            findings.push({\n                type: 'authorization_failures_exceeded',\n                description: `Spike in authorisation failures: ${authzFailures}`,\n                severity: authzFailures > this.threshold * 2 ? 'high' : 'medium',\n                details: { authzFailures, threshold: this.threshold }\n            });\n        }\n        return {\n            timestamp: new Date().toISOString(),\n            findings\n        };\n    }\n}\n\n// System Anomaly Monitor\nclass SystemAnomalyMonitor {\n    constructor(metricsService, cpuThreshold = 85, errorRateThreshold = 5) {\n        this.metricsService = metricsService;\n        this.cpuThreshold = cpuThreshold;\n        this.errorRateThreshold = errorRateThreshold; // percent\n    }\n    \n    async check() {\n        // Simulate metrics\n        const cpu = 50 + Math.floor(Math.random() * 60); // 50-110%\n        const errorRate = Math.floor(Math.random() * 12); // 0-11%\n        const findings = [];\n        if (cpu > this.cpuThreshold) {\n            findings.push({\n                type: 'cpu_anomaly',\n                description: `CPU usage anomaly detected: ${cpu}%`,\n                severity: cpu > this.cpuThreshold + 20 ? 'high' : 'medium',\n                details: { cpu, threshold: this.cpuThreshold }\n            });\n        }\n        if (errorRate > this.errorRateThreshold) {\n            findings.push({\n                type: 'error_rate_spike',\n                description: `Application error rate spike detected: ${errorRate}%`,\n                severity: errorRate > this.errorRateThreshold + 5 ? 'high' : 'medium',\n                details: { errorRate, threshold: this.errorRateThreshold }\n            });\n        }\n        return {\n            timestamp: new Date().toISOString(),\n            findings\n        };\n    }\n}\n\n// User Behaviour Analytics (UBA) Monitor\nclass UBAMonitor {\n    constructor(windowMinutes = 15) {\n        this.windowMinutes = windowMinutes;\n    }\n    \n    async check() {\n        // Simulate anomalous behaviour\n        const impossibleTravelDetected = Math.random() < 0.2;\n        const findings = [];\n        if (impossibleTravelDetected) {\n            findings.push({\n                type: 'impossible_travel',\n                description: 'User logged in from geographically distant locations within a short window',\n                severity: 'high',\n                details: { windowMinutes: this.windowMinutes }\n            });\n        }\n        return {\n            timestamp: new Date().toISOString(),\n            findings\n        };\n    }\n}\n\n// 3. Incident Response Management\nclass IncidentResponseManager {\n    constructor() {\n        this.playbooks = this.defaultPlaybooks();\n        this.incidents = [];\n    }\n    \n    defaultPlaybooks() {\n        return {\n            brute_force_attempt: {\n                severity: 'medium',\n                steps: [\n                    'Triage alert and verify spike source',\n                    'Enable rate limiting and temporary IP blocking as needed',\n                    'Force MFA challenge for impacted accounts',\n                    'Review recent password reset activity',\n                    'Document findings and update detection rules'\n                ]\n            },\n            authorization_failures_exceeded: {\n                severity: 'medium',\n                steps: [\n                    'Identify impacted services and endpoints',\n                    'Audit role and permission changes in the last 24 hours',\n                    'Deploy least-privilege hotfix if misconfig detected',\n                    'Notify service owners and track remediation',\n                    'Create post-incident review entry'\n                ]\n            },\n            cpu_anomaly: {\n                severity: 'medium',\n                steps: [\n                    'Correlate with recent releases and traffic spikes',\n                    'Scale service or roll back recent changes',\n                    'Collect diagnostics (profiles, heap, thread dumps)',\n                    'Monitor post-mitigation metrics',\n                    'Update capacity plans'\n                ]\n            },\n            error_rate_spike: {\n                severity: 'high',\n                steps: [\n                    'Halt canary/rollout and enable feature flags fallback',\n                    'Check dependencies (DB, cache, third-parties)',\n                    'Roll back or hotfix',\n                    'Add tests to prevent regression',\n                    'Publish incident report'\n                ]\n            },\n            impossible_travel: {\n                severity: 'high',\n                steps: [\n                    'Invalidate active sessions for the user',\n                    'Require password reset and enforce MFA',\n                    'Review recent access and data exfil indicators',\n                    'Block suspicious IP ranges and create case with evidence',\n                    'Update risk scoring for the identity'\n                ]\n            }\n        };\n    }\n    \n    openIncident(alert) {\n        const playbook = this.playbooks[alert.finding.type] || { severity: alert.severity, steps: ['Triage and investigate', 'Contain', 'Eradicate root cause', 'Recover services', 'Post-incident review'] };\n        const incident = {\n            id: `INC-${Date.now()}-${Math.floor(Math.random() * 1000)}`,\n            alertId: alert.id,\n            type: alert.finding.type,\n            severity: playbook.severity || alert.severity,\n            status: 'investigating',\n            createdAt: new Date().toISOString(),\n            updates: [\n                { at: new Date().toISOString(), note: 'Incident opened from alert' }\n            ],\n            steps: playbook.steps,\n            owner: 'oncall-security'\n        };\n        this.incidents.push(incident);\n        return incident;\n    }\n    \n    updateIncident(incidentId, note, status) {\n        const inc = this.incidents.find(i => i.id === incidentId);\n        if (!inc) throw new Error(`Incident not found: ${incidentId}`);\n        inc.updates.push({ at: new Date().toISOString(), note });\n        if (status) inc.status = status;\n        return inc;\n    }\n    \n    closeIncident(incidentId) {\n        return this.updateIncident(incidentId, 'Incident closed', 'resolved');\n    }\n}\n\n// 4. Wiring it together (example usage)\nasync function demoSecurityMonitoringAndIR() {\n    const framework = new SecurityMonitoringFramework();\n    const irManager = new IncidentResponseManager();\n    \n    // Register monitors\n    framework.registerMonitor('authentication', new AuthenticationMonitor({}));\n    framework.registerMonitor('authorization', new AuthorizationMonitor({}));\n    framework.registerMonitor('system_anomaly', new SystemAnomalyMonitor({}));\n    framework.registerMonitor('uba', new UBAMonitor());\n    \n    // Run monitors\n    const runResults = await framework.runAllMonitors();\n    console.log('Monitor run results:', JSON.stringify(runResults, null, 2));\n    \n    // Open incidents for newly created alerts\n    const newOpenAlerts = framework.getOpenAlerts();\n    const openedIncidents = [];\n    for (const alert of newOpenAlerts) {\n        const inc = irManager.openIncident(alert);\n        openedIncidents.push(inc);\n    }\n    \n    // Simulate an update on first incident\n    if (openedIncidents.length > 0) {\n        irManager.updateIncident(openedIncidents[0].id, 'Applied containment measures and monitoring impact', 'mitigating');\n    }\n    \n    return {\n        alerts: framework.alerts,\n        incidents: irManager.incidents\n    };\n}\n\n// Export for external usage\nmodule.exports = {\n    SecurityMonitoringFramework,\n    AuthenticationMonitor,\n    AuthorizationMonitor,\n    SystemAnomalyMonitor,\n    UBAMonitor,\n    IncidentResponseManager,\n    demoSecurityMonitoringAndIR\n};\n",
      "explanation": "This example demonstrates security monitoring and incident response including a security monitoring framework with pluggable monitors, specific security monitors for authentication and file integrity, an incident response system with playbooks, a notification system for alerts and incidents, and security monitoring playbooks for common incident types.",
      "language": "javascript"
    },
    "pitfalls": [{
        "mistake": "Creating too many alerts which lead to alert fatigue",
        "solution": "Implement alert correlation and prioritization to reduce noise and ensure that critical alerts are not lost in a sea of low-priority notifications",
        "severity": "high"
      },
      {
        "mistake": "Not regularly testing and updating incident response playbooks",
        "solution": "Schedule regular incident response drills and update playbooks based on lessons learned from real incidents and changes in the threat landscape",
        "severity": "medium"
      },
      {
        "mistake": "Failing to maintain adequate forensic evidence during incident response",
        "solution": "Implement proper logging and retention policies, and ensure that incident response procedures include evidence preservation steps to support investigations and potential legal proceedings",
        "severity": "high"
      }
    ],
    "exercises": [{
      "title": "Security Monitoring Implementation",
      "description": "Implement a comprehensive security monitoring and incident response system including monitoring framework, alerting, and incident response playbooks.",
      "checkpoints": [
        "Create a security monitoring framework with pluggable monitors",
        "Implement specific security monitors for common threats",
        "Set up alerting and notification systems",
        "Develop incident response playbooks for different threat types",
        "Test the end-to-end monitoring and response workflow"
      ]
    }],
    "next": [],
    "estimatedMinutes": 120,
    "difficulty": "Expert",
    "tags": [
      "Security Monitoring",
      "Incident Response",
      "SIEM",
      "Forensics"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-10",
    "moduleSlug": "security-fundamentals",
    "title": "Security Debugging and Forensic Analysis",
    "order": 10,
    "objectives": [
      "Apply advanced security debugging techniques",
      "Conduct forensic analysis of security incidents",
      "Use specialized tools for security investigation",
      "Preserve evidence and maintain chain of custody"
    ],
    "intro": "Security debugging and forensic analysis are specialized skills that enable security professionals to investigate security incidents, understand attack vectors, and gather evidence for remediation and potential legal proceedings. Unlike traditional debugging, security debugging requires understanding attacker methodologies, recognizing signs of compromise, and preserving evidence in a forensically sound manner.\n\nIn this lesson, you'll learn how to apply advanced security debugging techniques to investigate potential security incidents. You'll explore methods for analyzing authentication failures, examining network traffic for signs of malicious activity, and identifying unauthorized access attempts. You'll understand how to use debugging tools effectively while ensuring that evidence is preserved and not inadvertently altered during the investigation process.\n\nConducting forensic analysis of security incidents requires systematic approaches to evidence collection, analysis, and interpretation. You'll learn how to examine log files, analyze system artifacts, and reconstruct attack timelines. You'll explore techniques for identifying persistence mechanisms, understanding attacker tools and techniques, and determining the scope and impact of security incidents.\n\nUsing specialized tools for security investigation enhances the effectiveness and efficiency of forensic analysis. You'll learn about tools for memory analysis, network traffic inspection, file system examination, and log analysis. You'll understand how to select appropriate tools for different types of investigations and how to interpret their output correctly.\n\nBy mastering security debugging and forensic analysis, you'll be able to investigate security incidents thoroughly, gather actionable intelligence about attack methods, and contribute to improving your organization's security posture based on lessons learned from real incidents.",
    "code": {
      "example": "// Security Debugging and Forensic Analysis Implementation\n\n// 1. Security Debugging Framework\nclass SecurityDebuggingFramework {\n  constructor() {\n    this.evidence = [];\n    this.timeline = [];\n    this.findings = [];\n  }\n  \n  // Start a forensic investigation\n  startInvestigation(incidentDetails) {\n    console.log('Starting security investigation...');\n    \n    const investigation = {\n      id: `INV-${Date.now()}-${Math.floor(Math.random() * 1000)}`,\n      startTime: new Date().toISOString(),\n      incident: incidentDetails,\n      status: 'active'\n    };\n    \n    this.timeline.push({\n      action: 'investigation_started',\n      timestamp: investigation.startTime,\n      details: incidentDetails\n    });\n    \n    return investigation;\n  }\n  \n  // Collect evidence in a forensically sound manner\n  collectEvidence(evidenceItem) {\n    const evidence = {\n      id: `EVID-${Date.now()}-${Math.floor(Math.random() * 1000)}`,\n      timestamp: new Date().toISOString(),\n      ...evidenceItem,\n      hash: this.calculateHash(evidenceItem.data || evidenceItem.description)\n    };\n    \n    this.evidence.push(evidence);\n    \n    this.timeline.push({\n      action: 'evidence_collected',\n      timestamp: evidence.timestamp,\n      details: { evidenceId: evidence.id, type: evidence.type }\n    });\n    \n    return evidence.id;\n  }\n  \n  // Calculate hash for evidence integrity\n  calculateHash(data) {\n    const crypto = require('crypto');\n    return crypto.createHash('sha256').update(JSON.stringify(data)).digest('hex');\n  }\n  \n  // Add finding to investigation\n  addFinding(finding) {\n    const findingRecord = {\n      id: `FIND-${Date.now()}-${Math.floor(Math.random() * 1000)}`,\n      timestamp: new Date().toISOString(),\n      ...finding\n    };\n    \n    this.findings.push(findingRecord);\n    \n    this.timeline.push({\n      action: 'finding_added',\n      timestamp: findingRecord.timestamp,\n      details: { findingId: findingRecord.id, severity: findingRecord.severity }\n    });\n    \n    return findingRecord.id;\n  }\n  \n  // Generate investigation report\n  generateReport(investigation) {\n    return {\n      investigationId: investigation.id,\n      incident: investigation.incident,\n      startTime: investigation.startTime,\n      endTime: new Date().toISOString(),\n      evidence: this.evidence,\n      findings: this.findings,\n      timeline: this.timeline,\n      summary: {\n        totalEvidence: this.evidence.length,\n        totalFindings: this.findings.length,\n        criticalFindings: this.findings.filter(f => f.severity === 'critical').length\n      }\n    };\n  }\n}\n\n// 2. Log Analysis Tools\nclass LogAnalyzer {\n  constructor(logSources = []) {\n    this.logSources = logSources;\n    this.suspiciousPatterns = [\n      /failed login/i,\n      /authentication failure/i,\n      /unauthorized access/i,\n      /SQL injection/i,\n      /XSS attack/i,\n      /brute force/i,\n      /malicious file/i\n    ];\n  }\n  \n  // Analyze logs for security events\n  async analyzeLogs() {\n    console.log('Analyzing logs for security events...');\n    \n    const findings = [];\n    \n    // In a real implementation, this would read actual log files\n    // For demo, we'll simulate log analysis\n    for (const source of this.logSources) {\n      // Simulate reading log entries\n      const logEntries = this.generateSampleLogs(50);\n      \n      for (const entry of logEntries) {\n        const suspicious = this.suspiciousPatterns.some(pattern => \n          pattern.test(entry.message));\n        \n        if (suspicious) {\n          findings.push({\n            source: source,\n            timestamp: entry.timestamp,\n            message: entry.message,\n            severity: this.assessSeverity(entry.message),\n            rawEntry: entry\n          });\n        }\n      }\n    }\n    \n    return findings;\n  }\n  \n  // Generate sample log entries for demo\n  generateSampleLogs(count) {\n    const logs = [];\n    const messages = [\n      'User login successful',\n      'Failed login attempt for user admin',\n      'Authentication failure for user guest',\n      'SQL injection attempt detected',\n      'File upload successful',\n      'Suspicious file access detected',\n      'Normal system operation'\n    ];\n    \n    for (let i = 0; i < count; i++) {\n      logs.push({\n        timestamp: new Date(Date.now() - Math.random() * 86400000).toISOString(),\n        message: messages[Math.floor(Math.random() * messages.length)],\n        level: ['info', 'warn', 'error'][Math.floor(Math.random() * 3)]\n      });\n    }\n    \n    return logs;\n  }\n  \n  // Assess severity of log entry\n  assessSeverity(message) {\n    if (message.includes('SQL injection') || message.includes('Failed login')) {\n      return 'high';\n    } else if (message.includes('suspicious') || message.includes('unauthorized')) {\n      return 'medium';\n    } else {\n      return 'low';\n    }\n  }\n}\n\n// 3. Memory Analysis Tools\nclass MemoryAnalyzer {\n  constructor() {\n    this.suspiciousIndicators = [\n      'mimikatz',\n      'lsass.exe',\n      'credential',\n      'password',\n      'token',\n      'reverse shell'\n    ];\n  }\n  \n  // Analyze process memory for suspicious content\n  async analyzeProcessMemory(processId) {\n    console.log(`Analyzing memory for process ${processId}...`);\n    \n    // In a real implementation, this would use tools like Volatility\n    // For demo, we'll simulate memory analysis\n    const findings = [];\n    \n    // Simulate finding suspicious strings in memory\n    const memoryStrings = this.generateSampleMemoryStrings(100);\n    \n    for (const str of memoryStrings) {\n      const suspicious = this.suspiciousIndicators.some(indicator => \n        str.toLowerCase().includes(indicator));\n      \n      if (suspicious) {\n        findings.push({\n          type: 'suspicious_memory_content',\n          content: str,\n          severity: 'high',\n          details: `Suspicious string found in process memory: ${str}`\n        });\n      }\n    }\n    \n    return findings;\n  }\n  \n  // Generate sample memory strings for demo\n  generateSampleMemoryStrings(count) {\n    const strings = [\n      'C:\\\\Windows\\\\System32\\\\cmd.exe',\n      'SELECT * FROM users WHERE id=1',\n      'admin:password123',\n      'mimikatz.exe',\n      'reverse shell connection',\n      'lsass.exe memory dump',\n      'Normal application data',\n      'User session token: abc123'\n    ];\n    \n    const result = [];\n    for (let i = 0; i < count; i++) {\n      result.push(strings[Math.floor(Math.random() * strings.length)]);\n    }\n    \n    return result;\n  }\n}\n\n// 4. Network Traffic Analysis\nclass NetworkAnalyzer {\n  constructor() {\n    this.suspiciousPatterns = [\n      { pattern: /\\b(?:[0-9]{1,3}\\.){3}[0-9]{1,3}\\b.*:\\d{4,5}/, description: 'Suspicious outbound connection' },\n      { pattern: /POST.*\\.php.*\\b(?:union|select|insert|delete)\\b/i, description: 'SQL injection attempt' },\n      { pattern: /<script.*>[^<]*<\\/script>/i, description: 'XSS attempt' }\n    ];\n  }\n  \n  // Analyze network traffic captures\n  async analyzeTraffic(pcapFile) {\n    console.log(`Analyzing network traffic from ${pcapFile}...`);\n    \n    // In a real implementation, this would use tools like Wireshark/tshark\n    // For demo, we'll simulate traffic analysis\n    const findings = [];\n    \n    // Simulate analyzing packets\n    const packets = this.generateSamplePackets(50);\n    \n    for (const packet of packets) {\n      for (const { pattern, description } of this.suspiciousPatterns) {\n        if (pattern.test(packet.content)) {\n          findings.push({\n            type: 'suspicious_traffic',\n            description: description,\n            packet: packet,\n            severity: 'high'\n          });\n        }\n      }\n    }\n    \n    return findings;\n  }\n  \n  // Generate sample packets for demo\n  generateSamplePackets(count) {\n    const packets = [];\n    const contents = [\n      'GET /index.html HTTP/1.1',\n      'POST /login.php HTTP/1.1\\nContent-Type: application/x-www-form-urlencoded\\n\\nusername=admin&password=test123',\n      'GET /admin.php?param=1 UNION SELECT * FROM users HTTP/1.1',\n      'POST /upload.php HTTP/1.1\\nContent-Type: multipart/form-data\\n\\nfile content here',\n      '<script>alert(\"XSS\")</script>'\n    ];\n    \n    for (let i = 0; i < count; i++) {\n      packets.push({\n        id: Math.floor(Math.random() * 10000),\n        timestamp: new Date(Date.now() - Math.random() * 3600000).toISOString(),\n        source: `192.168.1.${Math.floor(Math.random() * 255)}`,\n        destination: `10.0.0.${Math.floor(Math.random() * 255)}`,\n        content: contents[Math.floor(Math.random() * contents.length)]\n      });\n    }\n    \n    return packets;\n  }\n}\n\n// 5. File System Analysis\nclass FileSystemAnalyzer {\n  constructor(suspiciousPaths = []) {\n    this.suspiciousPaths = suspiciousPaths;\n    this.suspiciousExtensions = ['.exe', '.dll', '.scr', '.bat', '.cmd', '.ps1'];\n    this.tempDirectories = ['/tmp', '/var/tmp', 'C:\\\\Windows\\\\Temp'];\n  }\n  \n  // Analyze file system for suspicious files\n  async analyzeFileSystem() {\n    console.log('Analyzing file system for suspicious files...');\n    \n    // In a real implementation, this would scan actual file systems\n    // For demo, we'll simulate file system analysis\n    const findings = [];\n    \n    // Simulate scanning directories\n    for (const path of this.suspiciousPaths) {\n      const files = this.generateSampleFiles(20);\n      \n      for (const file of files) {\n        // Check for suspicious extensions\n        const hasSuspiciousExt = this.suspiciousExtensions.some(ext => \n          file.name.toLowerCase().endsWith(ext));\n        \n        // Check for suspicious locations\n        const inTempDir = this.tempDirectories.some(dir => \n          path.includes(dir));\n        \n        if (hasSuspiciousExt || inTempDir) {\n          findings.push({\n            type: 'suspicious_file',\n            file: file,\n            path: path,\n            severity: hasSuspiciousExt ? 'high' : 'medium',\n            details: `Suspicious file found: ${file.name}`\n          });\n        }\n      }\n    }\n    \n    return findings;\n  }\n  \n  // Generate sample files for demo\n  generateSampleFiles(count) {\n    const files = [];\n    const names = [\n      'document.pdf',\n      'image.jpg',\n      'malware.exe',\n      'script.ps1',\n      'backup.bat',\n      'normal.txt'\n    ];\n    \n    for (let i = 0; i < count; i++) {\n      files.push({\n        name: names[Math.floor(Math.random() * names.length)],\n        size: Math.floor(Math.random() * 1000000),\n        modified: new Date(Date.now() - Math.random() * 86400000).toISOString(),\n        permissions: 'rw-r--r--'\n      });\n    }\n    \n    return files;\n  }\n}\n\n// Example usage\nasync function demonstrateSecurityDebugging() {\n  // Initialize debugging framework\n  const debuggerFramework = new SecurityDebuggingFramework();\n  \n  // Start investigation\n  const investigation = debuggerFramework.startInvestigation({\n    type: 'unauthorized_access',\n    description: 'Multiple failed login attempts detected',\n    affectedSystem: 'web-server-01'\n  });\n  \n  // Collect evidence\n  debuggerFramework.collectEvidence({\n    type: 'log_file',\n    source: '/var/log/auth.log',\n    description: 'Authentication log showing failed login attempts',\n    data: '2023-01-01 12:00:00 - Failed login for user admin from 192.168.1.100'\n  });\n  \n  debuggerFramework.collectEvidence({\n    type: 'network_capture',\n    source: '/captures/attack.pcap',\n    description: 'Network capture during attack window'\n  });\n  \n  // Analyze logs\n  const logAnalyzer = new LogAnalyzer(['/var/log/auth.log', '/var/log/app.log']);\n  const logFindings = await logAnalyzer.analyzeLogs();\n  \n  for (const finding of logFindings) {\n    debuggerFramework.addFinding({\n      type: 'log_analysis',\n      severity: finding.severity,\n      details: finding.message,\n      source: finding.source\n    });\n  }\n  \n  // Analyze memory\n  const memoryAnalyzer = new MemoryAnalyzer();\n  const memoryFindings = await memoryAnalyzer.analyzeProcessMemory(1234);\n  \n  for (const finding of memoryFindings) {\n    debuggerFramework.addFinding({\n      type: 'memory_analysis',\n      severity: finding.severity,\n      details: finding.details\n    });\n  }\n  \n  // Analyze network traffic\n  const networkAnalyzer = new NetworkAnalyzer();\n  const networkFindings = await networkAnalyzer.analyzeTraffic('attack.pcap');\n  \n  for (const finding of networkFindings) {\n    debuggerFramework.addFinding({\n      type: 'network_analysis',\n      severity: finding.severity,\n      details: finding.description\n    });\n  }\n  \n  // Generate report\n  const report = debuggerFramework.generateReport(investigation);\n  console.log('Investigation Report:', JSON.stringify(report, null, 2));\n  \n  return {\n    debuggerFramework,\n    investigation,\n    report\n  };\n}\n\n// Example debug configuration for Node.js security debugging\n/*\n{\n  \"name\": \"Security Debugging\",\n  \"type\": \"node\",\n  \"request\": \"launch\",\n  \"program\": \"${workspaceFolder}/app.js\",\n  \"env\": {\n    \"DEBUG\": \"security*,auth*,crypto*\",\n    \"NODE_OPTIONS\": \"--inspect=0.0.0.0:9229\"\n  },\n  \"console\": \"integratedTerminal\",\n  \"internalConsoleOptions\": \"neverOpen\",\n  \"skipFiles\": [\n    \"<node_internals>/**\"\n  ]\n}*/\n\n// Example debug logging for security events\n/*\nconst winston = require('winston');\nconst { format, transports } = winston;\n\nconst securityLogger = winston.createLogger({\n  level: 'info',\n  format: format.combine(\n    format.timestamp(),\n    format.errors({ stack: true }),\n    format.json()\n  ),\n  defaultMeta: { service: 'security-service' },\n  transports: [\n    new transports.File({\n      filename: 'security-info.log',\n      level: 'info'\n    }),\n    new transports.File({\n      filename: 'security-warn.log',\n      level: 'warn'\n    }),\n    new transports.File({\n      filename: 'security-error.log',\n      level: 'error'\n    }),\n    new transports.File({\n      filename: 'security-combined.log'\n    })\n  ]\n});\n\n// Security event logging examples\nsecurityLogger.info('User authentication successful', {\n  userId: 'user123',\n  ip: '192.168.1.100',\n  userAgent: 'Mozilla/5.0...'\n});\n\nsecurityLogger.warn('Failed login attempt', {\n  username: 'admin',\n  ip: '192.168.1.101',\n  attempts: 3\n});\n\nsecurityLogger.error('Security violation detected', {\n  type: 'SQL injection',\n  payload: 'UNION SELECT *',\n  ip: '192.168.1.102'\n});*/",
      "explanation": "This example demonstrates security debugging and forensic analysis including a security debugging framework for evidence collection, log analysis tools for detecting security events, memory analysis tools for finding suspicious content, network traffic analysis for identifying malicious activity, and file system analysis for detecting suspicious files.",
      "language": "javascript"
    },
    "pitfalls": [{
        "mistake": "Creating too many alerts which lead to alert fatigue",
        "solution": "Implement alert correlation and prioritization to reduce noise and ensure that critical alerts are not lost in a sea of low-priority notifications",
        "severity": "high"
      },
      {
        "mistake": "Not regularly testing and updating incident response playbooks",
        "solution": "Schedule regular incident response drills and update playbooks based on lessons learned from real incidents and changes in the threat landscape",
        "severity": "medium"
      },
      {
        "mistake": "Failing to maintain adequate forensic evidence during incident response",
        "solution": "Implement proper logging and retention policies, and ensure that incident response procedures include evidence preservation steps to support investigations and potential legal proceedings",
        "severity": "high"
      }
    ],
    "exercises": [{
      "title": "Security Monitoring Implementation",
      "description": "Implement a comprehensive security monitoring and incident response system including monitoring framework, alerting, and incident response playbooks.",
      "checkpoints": [
        "Create a security monitoring framework with pluggable monitors",
        "Implement specific security monitors for common threats",
        "Set up alerting and notification systems",
        "Develop incident response playbooks for different threat types",
        "Test the end-to-end monitoring and response workflow"
      ]
    }],
    "next": [],
    "estimatedMinutes": 120,
    "difficulty": "Expert",
    "tags": [
      "Security Monitoring",
      "Incident Response",
      "SIEM",
      "Forensics"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  }
]
