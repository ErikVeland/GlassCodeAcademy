[
  {
    "id": "security-fundamentals-lesson-1",
    "moduleSlug": "security-fundamentals",
    "title": "Web Security Fundamentals",
    "order": 1,
    "objectives": [
      "Understand common web security vulnerabilities and threats",
      "Learn authentication and authorization best practices",
      "Implement secure coding practices to prevent attacks"
    ],
    "intro": "Web security is critical for protecting applications and user data from malicious attacks. Understanding security fundamentals helps developers build robust applications that resist common vulnerabilities and protect sensitive information.\n\nIn this lesson, you'll learn about the OWASP Top 10 security risks including injection attacks, broken authentication, sensitive data exposure, and security misconfigurations. These represent the most critical security issues facing web applications today.\n\nAuthentication and authorization form the backbone of application security. You'll understand the difference between these concepts and learn to implement secure login systems, session management, and access controls that protect user accounts and data.\n\nSecure coding practices prevent vulnerabilities at the source. You'll discover input validation techniques, output encoding, secure storage methods, and proper error handling that make applications resilient against attacks.\n\nBy mastering these security fundamentals, you'll be equipped to identify potential vulnerabilities early, implement robust security measures, and follow industry best practices that protect both applications and users from cyber threats.",
    "code": {
      "example": "// Web Security Best Practices Implementation\n\n// 1. Input Validation and Sanitization\nfunction validateAndSanitizeInput(input, type) {\n  // Remove potentially harmful characters\n  const sanitized = input.replace(/<script[^>]*>.*?</script>/gi, '');\n  \n  switch (type) {\n    case 'email':\n      const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n      if (!emailRegex.test(sanitized)) {\n        throw new Error('Invalid email format');\n      }\n      break;\n    \n    case 'username':\n      const usernameRegex = /^[a-zA-Z0-9_]{3,20}$/;\n      if (!usernameRegex.test(sanitized)) {\n        throw new Error('Username must be 3-20 characters, alphanumeric and underscore only');\n      }\n      break;\n      \n    case 'password':\n      if (sanitized.length < 8) {\n        throw new Error('Password must be at least 8 characters');\n      }\n      break;\n  }\n  \n  return sanitized;\n}\n\n// 2. Secure Authentication Implementation\nconst bcrypt = require('bcrypt');\nconst jwt = require('jsonwebtoken');\n\nclass AuthService {\n  static async hashPassword(password) {\n    const saltRounds = 12; // Increased for better security\n    return await bcrypt.hash(password, saltRounds);\n  }\n  \n  static async verifyPassword(password, hashedPassword) {\n    return await bcrypt.compare(password, hashedPassword);\n  }\n  \n  static generateToken(user) {\n    const payload = {\n      userId: user.id,\n      email: user.email,\n      role: user.role\n    };\n    \n    return jwt.sign(payload, process.env.JWT_SECRET, {\n      expiresIn: '15m', // Short-lived tokens\n      issuer: 'your-app-name',\n      audience: 'your-app-users'\n    });\n  }\n  \n  static verifyToken(token) {\n    try {\n      return jwt.verify(token, process.env.JWT_SECRET, {\n        issuer: 'your-app-name',\n        audience: 'your-app-users'\n      });\n    } catch (error) {\n      throw new Error('Invalid or expired token');\n    }\n  }\n}\n\n// 3. Authorization Middleware\nfunction authorize(requiredRole) {\n  return (req, res, next) => {\n    try {\n      const token = req.headers.authorization?.split(' ')[1];\n      \n      if (!token) {\n        return res.status(401).json({ error: 'Access token required' });\n      }\n      \n      const decoded = AuthService.verifyToken(token);\n      \n      if (requiredRole && decoded.role !== requiredRole) {\n        return res.status(403).json({ error: 'Insufficient permissions' });\n      }\n      \n      req.user = decoded;\n      next();\n    } catch (error) {\n      return res.status(401).json({ error: 'Invalid token' });\n    }\n  };\n}\n\n// 4. SQL Injection Prevention\nconst mysql = require('mysql2/promise');\n\nclass UserRepository {\n  static async findByEmail(email) {\n    // Use parameterized queries to prevent SQL injection\n    const query = 'SELECT * FROM users WHERE email = ? AND active = 1';\n    const [rows] = await db.execute(query, [email]);\n    return rows[0];\n  }\n  \n  static async createUser(userData) {\n    const query = `\n      INSERT INTO users (email, password_hash, name, role, created_at) \n      VALUES (?, ?, ?, ?, NOW())\n    `;\n    \n    const [result] = await db.execute(query, [\n      userData.email,\n      userData.passwordHash,\n      userData.name,\n      userData.role || 'user'\n    ]);\n    \n    return result.insertId;\n  }\n}\n\n// 5. Security Headers Middleware\nfunction securityHeaders(req, res, next) {\n  // Prevent XSS attacks\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  \n  // Prevent MIME type sniffing\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  \n  // Prevent clickjacking\n  res.setHeader('X-Frame-Options', 'DENY');\n  \n  // HTTPS enforcement\n  res.setHeader('Strict-Transport-Security', 'max-age=31536000; includeSubDomains');\n  \n  // Content Security Policy\n  res.setHeader('Content-Security-Policy', \n    \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';\");\n  \n  next();\n}\n\n// Usage Examples\napp.use(securityHeaders);\napp.post('/api/login', async (req, res) => {\n  try {\n    const email = validateAndSanitizeInput(req.body.email, 'email');\n    const password = validateAndSanitizeInput(req.body.password, 'password');\n    \n    const user = await UserRepository.findByEmail(email);\n    \n    if (!user || !await AuthService.verifyPassword(password, user.password_hash)) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n    \n    const token = AuthService.generateToken(user);\n    res.json({ token, user: { id: user.id, email: user.email, role: user.role } });\n  } catch (error) {\n    res.status(400).json({ error: error.message });\n  }\n});\n\napp.get('/api/admin/users', authorize('admin'), (req, res) => {\n  // Only admin users can access this endpoint\n  res.json({ message: 'Admin access granted' });\n});",
      "explanation": "This comprehensive example demonstrates essential web security practices including input validation, secure authentication with bcrypt and JWT, authorization middleware, SQL injection prevention, and security headers implementation.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Security best practices",
        "solution": "Review official documentation and established patterns for Security",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Testing Fundamentals",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Security",
      "Authentication",
      "Authorization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.318Z",
    "version": "1.0.0"
  },
  {
    "id": "security-fundamentals-lesson-2",
    "moduleSlug": "security-fundamentals",
    "title": "OWASP Top 10 Security Risks",
    "order": 2,
    "objectives": [
      "Identify and understand the OWASP Top 10 security vulnerabilities",
      "Implement preventive measures for each security risk category",
      "Apply security testing techniques to detect vulnerabilities"
    ],
    "intro": "The OWASP Top 10 is a widely recognized awareness document for web application security that represents a broad consensus about the most critical security risks to web applications. Understanding these vulnerabilities is essential for any developer who wants to build secure applications.\n\nIn this lesson, you'll dive deep into each of the OWASP Top 10 security risks, learning how they occur, what damage they can cause, and most importantly, how to prevent them. You'll explore real-world examples of each vulnerability and see how attackers exploit them.\n\nInjection flaws, such as SQL injection, command injection, and LDAP injection, remain one of the most dangerous vulnerabilities. You'll learn how to properly sanitize inputs and use parameterized queries to prevent these attacks.\n\nBroken authentication and session management vulnerabilities allow attackers to compromise passwords, keys, or session tokens. You'll discover secure authentication patterns, proper session handling, and multi-factor authentication implementation.\n\nSensitive data exposure occurs when applications don't adequately protect sensitive data such as financial information, healthcare records, or personal identification. You'll learn encryption techniques, secure data transmission, and proper data handling practices.\n\nBy mastering the OWASP Top 10, you'll be able to identify security weaknesses in applications, implement appropriate countermeasures, and conduct security reviews that significantly improve application security posture.",
    "code": {
      "example": "// OWASP Top 10 Security Risk Prevention Examples\n\n// 1. Injection Prevention (SQL Injection Example)\n// Vulnerable code - NEVER do this:\n// const query = `SELECT * FROM users WHERE username = '${username}' AND password = '${password}'`;\n\n// Secure approach using parameterized queries:\nclass SecureUserRepository {\n  static async authenticateUser(username, password) {\n    // Parameterized query prevents SQL injection\n    const query = 'SELECT * FROM users WHERE username = ? AND active = 1';\n    const [users] = await db.execute(query, [username]);\n    \n    if (users.length === 0) return null;\n    \n    const user = users[0];\n    const isValidPassword = await bcrypt.compare(password, user.password_hash);\n    \n    return isValidPassword ? user : null;\n  }\n  \n  // Command injection prevention\n  static async getUserFiles(userId) {\n    // Validate input to prevent command injection\n    if (!Number.isInteger(userId) || userId <= 0) {\n      throw new Error('Invalid user ID');\n    }\n    \n    // Use path.join and validate paths to prevent directory traversal\n    const userDir = path.join('/user_files', userId.toString());\n    \n    // Additional validation to ensure path is within allowed directory\n    if (!userDir.startsWith('/user_files/')) {\n      throw new Error('Access denied');\n    }\n    \n    return fs.readdirSync(userDir);\n  }\n}\n\n// 2. Broken Authentication Prevention\nconst crypto = require('crypto');\n\nclass SecureAuthService {\n  // Implement account lockout after failed attempts\n  static async loginWithLockout(username, password, maxAttempts = 5, lockoutTime = 900000) { // 15 minutes\n    const user = await UserRepository.findByUsername(username);\n    \n    if (!user) return null;\n    \n    // Check if account is locked\n    if (user.locked_until && new Date(user.locked_until) > new Date()) {\n      throw new Error('Account temporarily locked due to multiple failed attempts');\n    }\n    \n    const isValid = await bcrypt.compare(password, user.password_hash);\n    \n    if (isValid) {\n      // Reset failed attempts on successful login\n      await UserRepository.resetFailedAttempts(user.id);\n      return this.generateToken(user);\n    } else {\n      // Increment failed attempts\n      const updatedUser = await UserRepository.incrementFailedAttempts(user.id);\n      \n      // Lock account if max attempts exceeded\n      if (updatedUser.failed_attempts >= maxAttempts) {\n        await UserRepository.lockAccount(user.id, new Date(Date.now() + lockoutTime));\n        throw new Error('Account locked due to multiple failed attempts');\n      }\n      \n      return null;\n    }\n  }\n  \n  // Secure password reset with time-limited tokens\n  static async generatePasswordResetToken(email) {\n    const user = await UserRepository.findByEmail(email);\n    if (!user) return;\n    \n    // Generate secure random token\n    const token = crypto.randomBytes(32).toString('hex');\n    const expiresAt = new Date(Date.now() + 3600000); // 1 hour\n    \n    await UserRepository.savePasswordResetToken(user.id, token, expiresAt);\n    \n    // Send email with reset link (implementation not shown)\n    await emailService.sendPasswordReset(email, token);\n  }\n  \n  static async resetPassword(token, newPassword) {\n    const user = await UserRepository.findByPasswordResetToken(token);\n    \n    if (!user || new Date(user.reset_token_expires) < new Date()) {\n      throw new Error('Invalid or expired reset token');\n    }\n    \n    // Validate password strength\n    if (newPassword.length < 12) {\n      throw new Error('Password must be at least 12 characters long');\n    }\n    \n    const hashedPassword = await bcrypt.hash(newPassword, 12);\n    await UserRepository.updatePassword(user.id, hashedPassword);\n    await UserRepository.clearPasswordResetToken(user.id);\n  }\n}\n\n// 3. Sensitive Data Exposure Prevention\nconst crypto = require('crypto');\n\nclass DataProtectionService {\n  // Encrypt sensitive data\n  static encryptData(data, key) {\n    const algorithm = 'aes-256-gcm';\n    const iv = crypto.randomBytes(16);\n    \n    const cipher = crypto.createCipher(algorithm, key);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return {\n      encryptedData: encrypted,\n      iv: iv.toString('hex'),\n      authTag: authTag.toString('hex')\n    };\n  }\n  \n  // Decrypt sensitive data\n  static decryptData(encryptedObj, key) {\n    const { encryptedData, iv, authTag } = encryptedObj;\n    const algorithm = 'aes-256-gcm';\n    \n    const decipher = crypto.createDecipher(algorithm, key);\n    decipher.setAuthTag(Buffer.from(authTag, 'hex'));\n    \n    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n    decrypted += decipher.final('utf8');\n    \n    return decrypted;\n  }\n  \n  // Hash sensitive data that doesn't need to be decrypted\n  static hashData(data) {\n    return crypto.createHash('sha256').update(data).digest('hex');\n  }\n  \n  // Securely store passwords\n  static async hashPassword(password) {\n    const salt = crypto.randomBytes(32).toString('hex');\n    const hashed = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n    return `${salt}:${hashed}`;\n  }\n  \n  static async verifyPassword(password, hashedPassword) {\n    const [salt, hash] = hashedPassword.split(':');\n    const hashed = crypto.pbkdf2Sync(password, salt, 10000, 64, 'sha512').toString('hex');\n    return hashed === hash;\n  }\n}\n\n// 4. XML External Entities (XXE) Prevention\nconst { XMLParser } = require('fast-xml-parser');\n\nclass SecureXMLProcessor {\n  static parseXML(xmlString) {\n    // Disable external entities to prevent XXE attacks\n    const options = {\n      ignoreAttributes: false,\n      allowBooleanAttributes: true,\n      parseAttributeValue: true,\n      // Critical: Disable external entities\n      ignoreDeclaration: true,\n      ignorePiTags: true,\n      // Prevent billion laughs attack\n      maxFileSize: 5 * 1024 * 1024, // 5MB limit\n      // Disable DTD processing\n      allowDTD: false\n    };\n    \n    const parser = new XMLParser(options);\n    return parser.parse(xmlString);\n  }\n}\n\n// 5. Broken Access Control Prevention\nfunction requirePermission(requiredPermission) {\n  return async (req, res, next) => {\n    try {\n      const user = req.user;\n      \n      // Check if user has the required permission\n      const hasPermission = await UserRepository.hasPermission(user.id, requiredPermission);\n      \n      if (!hasPermission) {\n        return res.status(403).json({ error: 'Insufficient permissions' });\n      }\n      \n      next();\n    } catch (error) {\n      return res.status(500).json({ error: 'Permission check failed' });\n    }\n  };\n}\n\n// Example usage in routes\napp.get('/api/users/:id', authenticateToken, async (req, res) => {\n  try {\n    const userId = parseInt(req.params.id);\n    \n    // Check if user can access this resource\n    if (req.user.id !== userId && req.user.role !== 'admin') {\n      return res.status(403).json({ error: 'Access denied' });\n    }\n    \n    const user = await UserRepository.findById(userId);\n    if (!user) {\n      return res.status(404).json({ error: 'User not found' });\n    }\n    \n    res.json(user);\n  } catch (error) {\n    res.status(500).json({ error: 'Server error' });\n  }\n});\n\n// 6. Security Misconfiguration Prevention\n// Environment-specific configuration\nconst config = {\n  development: {\n    logging: true,\n    debug: true\n  },\n  production: {\n    logging: false,\n    debug: false,\n    // Security headers\n    securityHeaders: {\n      'X-Content-Type-Options': 'nosniff',\n      'X-Frame-Options': 'DENY',\n      'X-XSS-Protection': '1; mode=block',\n      'Strict-Transport-Security': 'max-age=31536000; includeSubDomains',\n      'Content-Security-Policy': \"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline';\"\n    }\n  }\n};\n\n// Apply security headers in production\nif (process.env.NODE_ENV === 'production') {\n  app.use((req, res, next) => {\n    Object.entries(config.production.securityHeaders).forEach(([header, value]) => {\n      res.setHeader(header, value);\n    });\n    next();\n  });\n}",
      "explanation": "This example demonstrates prevention techniques for the OWASP Top 10 security risks including injection prevention with parameterized queries, secure authentication with account lockout mechanisms, data encryption for sensitive information, XXE prevention in XML processing, access control implementation, and security misconfiguration handling.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Relying on client-side validation alone for security",
        "solution": "Always implement server-side validation and never trust client-side input",
        "severity": "high"
      },
      {
        "mistake": "Using weak password hashing algorithms",
        "solution": "Use strong, salted hashing algorithms like bcrypt, scrypt, or Argon2",
        "severity": "high"
      },
      {
        "mistake": "Exposing sensitive information in error messages",
        "solution": "Provide generic error messages to users while logging detailed errors server-side",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "OWASP Top 10 Vulnerability Assessment",
        "description": "Conduct a security review of a sample application to identify OWASP Top 10 vulnerabilities and implement fixes.",
        "checkpoints": [
          "Analyze sample code for injection vulnerabilities and implement parameterized queries",
          "Review authentication mechanisms and add account lockout functionality",
          "Identify sensitive data exposure and implement proper encryption",
          "Check access controls and implement role-based permissions",
          "Review security configurations and apply appropriate headers"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 45,
    "difficulty": "Advanced",
    "tags": [
      "OWASP",
      "Security",
      "Vulnerabilities",
      "Risk Management"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-3",
    "moduleSlug": "security-fundamentals",
    "title": "Input Validation and Data Sanitization",
    "order": 3,
    "objectives": [
      "Implement comprehensive input validation strategies",
      "Apply data sanitization techniques to prevent injection attacks",
      "Use validation libraries and frameworks effectively",
      "Handle file upload security and validation"
    ],
    "intro": "Input validation and data sanitization are fundamental security practices that protect applications from a wide range of attacks including injection, cross-site scripting (XSS), and data corruption. Every piece of data that enters your application from external sources represents a potential security risk that must be properly validated and sanitized.\n\nIn this lesson, you'll learn the principles of secure input validation including whitelist and blacklist validation approaches, data type validation, range checking, and format validation. You'll understand when to use each approach and how to implement them effectively in your applications.\n\nData sanitization techniques help clean and normalize input data to prevent malicious content from affecting your application. You'll explore HTML entity encoding, JavaScript escaping, URL encoding, and other sanitization methods that protect against XSS and other injection attacks.\n\nFile upload security is a critical area that often presents significant vulnerabilities in web applications. You'll learn how to validate file types, scan for malicious content, limit file sizes, and store uploaded files securely to prevent exploitation.\n\nBy mastering input validation and data sanitization, you'll be able to build applications that are resilient to data-based attacks, maintain data integrity, and provide a secure user experience while maintaining functionality.",
    "code": {
      "example": "// Comprehensive Input Validation and Data Sanitization Implementation\n\n// 1. Input Validation Utilities\nconst validator = require('validator');\n\nclass InputValidator {\n  // Email validation with multiple checks\n  static validateEmail(email) {\n    // Basic format check\n    if (!validator.isEmail(email)) {\n      throw new Error('Invalid email format');\n    }\n    \n    // Length check\n    if (email.length > 254) {\n      throw new Error('Email too long');\n    }\n    \n    // Domain validation\n    const domain = email.split('@')[1];\n    if (!validator.isFQDN(domain)) {\n      throw new Error('Invalid domain in email');\n    }\n    \n    return email.toLowerCase().trim();\n  }\n  \n  // Username validation\n  static validateUsername(username) {\n    // Length check\n    if (username.length < 3 || username.length > 30) {\n      throw new Error('Username must be between 3 and 30 characters');\n    }\n    \n    // Character validation (alphanumeric, underscore, hyphen only)\n    if (!/^[a-zA-Z0-9_-]+$/.test(username)) {\n      throw new Error('Username can only contain letters, numbers, underscores, and hyphens');\n    }\n    \n    // No consecutive special characters\n    if (/[-_]{2,}/.test(username)) {\n      throw new Error('Username cannot contain consecutive special characters');\n    }\n    \n    // Cannot start or end with special characters\n    if (/^[-_]|[-_]$/.test(username)) {\n      throw new Error('Username cannot start or end with special characters');\n    }\n    \n    return username;\n  }\n  \n  // Password validation\n  static validatePassword(password) {\n    // Length check\n    if (password.length < 12) {\n      throw new Error('Password must be at least 12 characters long');\n    }\n    \n    // Complexity checks\n    if (!/(?=.*[a-z])/.test(password)) {\n      throw new Error('Password must contain at least one lowercase letter');\n    }\n    \n    if (!/(?=.*[A-Z])/.test(password)) {\n      throw new Error('Password must contain at least one uppercase letter');\n    }\n    \n    if (!/(?=.*\\d)/.test(password)) {\n      throw new Error('Password must contain at least one digit');\n    }\n    \n    if (!/(?=.*[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?])/.test(password)) {\n      throw new Error('Password must contain at least one special character');\n    }\n    \n    // No common patterns\n    const commonPasswords = ['password', '12345678', 'qwerty'];\n    if (commonPasswords.some(common => password.toLowerCase().includes(common))) {\n      throw new Error('Password contains common patterns');\n    }\n    \n    return password;\n  }\n  \n  // Phone number validation\n  static validatePhoneNumber(phone) {\n    // Remove all non-digit characters\n    const digitsOnly = phone.replace(/\\D/g, '');\n    \n    // Check length (assuming US format)\n    if (digitsOnly.length !== 10 && digitsOnly.length !== 11) {\n      throw new Error('Invalid phone number format');\n    }\n    \n    // Format consistently\n    if (digitsOnly.length === 11 && digitsOnly[0] !== '1') {\n      throw new Error('Invalid country code');\n    }\n    \n    return digitsOnly;\n  }\n  \n  // URL validation\n  static validateURL(url) {\n    if (!validator.isURL(url, {\n      protocols: ['http', 'https'],\n      require_tld: true,\n      require_protocol: true,\n      allow_underscores: false,\n      host_whitelist: [],\n      host_blacklist: ['localhost', '127.0.0.1'],\n      allow_trailing_dot: false,\n      allow_protocol_relative_urls: false,\n      disallow_auth: true\n    })) {\n      throw new Error('Invalid URL');\n    }\n    \n    // Additional checks\n    const parsedUrl = new URL(url);\n    if (parsedUrl.hostname.length > 253) {\n      throw new Error('URL hostname too long');\n    }\n    \n    return url;\n  }\n}\n\n// 2. Data Sanitization Functions\nconst xss = require('xss');\n\nclass DataSanitizer {\n  // HTML sanitization to prevent XSS\n  static sanitizeHTML(input) {\n    if (typeof input !== 'string') return input;\n    \n    // Use a whitelist approach\n    const options = {\n      whiteList: {\n        a: ['href', 'title'],\n        b: [],\n        i: [],\n        strong: [],\n        em: [],\n        p: [],\n        br: [],\n        ul: [],\n        ol: [],\n        li: []\n      },\n      stripIgnoreTag: true, // Strip all tags not in whitelist\n      stripIgnoreTagBody: ['script'] // Remove script tag content\n    };\n    \n    return xss(input, options);\n  }\n  \n  // JavaScript string escaping\n  static escapeJS(input) {\n    if (typeof input !== 'string') return input;\n    \n    return input\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/'/g, '\\\\'')\n      .replace(/\"/g, '\\\\"')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/</g, '\\\\u003c')\n      .replace(/>/g, '\\\\u003e');\n  }\n  \n  // CSS escaping\n  static escapeCSS(input) {\n    if (typeof input !== 'string') return input;\n    \n    return input.replace(/[\"'();\\\\]/g, '\\\\$&');\n  }\n  \n  // URL parameter encoding\n  static encodeURLParam(param) {\n    return encodeURIComponent(param);\n  }\n  \n  // SQL value escaping (for cases where parameterized queries aren't possible)\n  static escapeSQLValue(value) {\n    if (typeof value !== 'string') return value;\n    \n    return value\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/'/g, \"''\") // Escape single quotes\n      .replace(/\"/g, '\\\\"') // Escape double quotes\n      .replace(/\\x00/g, '\\\\0') // Null byte\n      .replace(/\\n/g, '\\\\n') // Newline\n      .replace(/\\r/g, '\\\\r') // Carriage return\n      .replace(/\\x1a/g, '\\\\Z'); // Substitute character\n  }\n}\n\n// 3. File Upload Security\nconst multer = require('multer');\nconst path = require('path');\nconst fs = require('fs').promises;\nconst { exec } = require('child_process');\nconst util = require('util');\n\nconst execPromise = util.promisify(exec);\n\n// Configure multer with security restrictions\nconst upload = multer({\n  storage: multer.diskStorage({\n    destination: async (req, file, cb) => {\n      // Create user-specific directory\n      const uploadDir = path.join(__dirname, 'uploads', req.user.id.toString());\n      \n      try {\n        await fs.mkdir(uploadDir, { recursive: true });\n        cb(null, uploadDir);\n      } catch (error) {\n        cb(new Error('Failed to create upload directory'), null);\n      }\n    },\n    filename: (req, file, cb) => {\n      // Generate safe filename\n      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);\n      const ext = path.extname(file.originalname).toLowerCase();\n      const basename = path.basename(file.originalname, ext);\n      \n      // Sanitize filename\n      const safeBasename = basename.replace(/[^a-zA-Z0-9_-]/g, '_');\n      \n      cb(null, `${safeBasename}-${uniqueSuffix}${ext}`);\n    }\n  }),\n  limits: {\n    fileSize: 5 * 1024 * 1024, // 5MB limit\n    files: 1 // Single file upload\n  },\n  fileFilter: (req, file, cb) => {\n    // Whitelist allowed file types\n    const allowedTypes = [\n      'image/jpeg',\n      'image/png',\n      'image/gif',\n      'application/pdf',\n      'text/plain'\n    ];\n    \n    if (allowedTypes.includes(file.mimetype)) {\n      cb(null, true);\n    } else {\n      cb(new Error('Invalid file type'), false);\n    }\n  }\n});\n\n// File validation service\nclass FileValidationService {\n  static async validateFile(filePath, mimeType) {\n    try {\n      // Check file size\n      const stats = await fs.stat(filePath);\n      if (stats.size > 5 * 1024 * 1024) { // 5MB\n        throw new Error('File too large');\n      }\n      \n      // Validate file extension matches content\n      const ext = path.extname(filePath).toLowerCase();\n      const validExtensions = {\n        'image/jpeg': ['.jpg', '.jpeg'],\n        'image/png': ['.png'],\n        'image/gif': ['.gif'],\n        'application/pdf': ['.pdf'],\n        'text/plain': ['.txt']\n      };\n      \n      if (!validExtensions[mimeType] || !validExtensions[mimeType].includes(ext)) {\n        throw new Error('File extension does not match content type');\n      }\n      \n      // For images, validate with ImageMagick or similar tool\n      if (mimeType.startsWith('image/')) {\n        await this.validateImage(filePath);\n      }\n      \n      // For PDFs, validate with pdfinfo or similar\n      if (mimeType === 'application/pdf') {\n        await this.validatePDF(filePath);\n      }\n      \n      return true;\n    } catch (error) {\n      throw new Error(`File validation failed: ${error.message}`);\n    }\n  }\n  \n  static async validateImage(filePath) {\n    try {\n      // Use ImageMagick to validate image\n      const { stdout } = await execPromise(`identify -format '%m' '${filePath}'`);\n      if (!stdout) {\n        throw new Error('Invalid image file');\n      }\n    } catch (error) {\n      throw new Error('Image validation failed');\n    }\n  }\n  \n  static async validatePDF(filePath) {\n    try {\n      // Use pdfinfo to validate PDF\n      const { stdout } = await execPromise(`pdfinfo '${filePath}'`);\n      if (!stdout.includes('Pages:')) {\n        throw new Error('Invalid PDF file');\n      }\n    } catch (error) {\n      throw new Error('PDF validation failed');\n    }\n  }\n  \n  // Scan file for malware (integration with ClamAV or similar)\n  static async scanForMalware(filePath) {\n    try {\n      const { stdout } = await execPromise(`clamdscan --no-summary '${filePath}'`);\n      if (stdout.includes('FOUND')) {\n        throw new Error('Malware detected in file');\n      }\n      return true;\n    } catch (error) {\n      throw new Error('Malware scan failed');\n    }\n  }\n}\n\n// Express route with secure file upload\napp.post('/api/upload', authenticateToken, upload.single('file'), async (req, res) => {\n  try {\n    if (!req.file) {\n      return res.status(400).json({ error: 'No file uploaded' });\n    }\n    \n    // Validate file\n    await FileValidationService.validateFile(req.file.path, req.file.mimetype);\n    \n    // Scan for malware\n    await FileValidationService.scanForMalware(req.file.path);\n    \n    // Store file reference in database\n    const fileRecord = await FileRepository.create({\n      userId: req.user.id,\n      filename: req.file.filename,\n      originalName: req.file.originalname,\n      mimeType: req.file.mimetype,\n      size: req.file.size,\n      path: req.file.path\n    });\n    \n    res.json({\n      message: 'File uploaded successfully',\n      fileId: fileRecord.id\n    });\n  } catch (error) {\n    // Clean up uploaded file on error\n    if (req.file && req.file.path) {\n      try {\n        await fs.unlink(req.file.path);\n      } catch (unlinkError) {\n        console.error('Failed to clean up file:', unlinkError);\n      }\n    }\n    \n    res.status(400).json({ error: error.message });\n  }\n});\n\n// 4. Validation Middleware\nfunction validateRequest(schema) {\n  return (req, res, next) => {\n    try {\n      // Validate request body\n      if (schema.body) {\n        Object.keys(schema.body).forEach(field => {\n          const validatorFunc = schema.body[field];\n          if (req.body[field] !== undefined) {\n            req.body[field] = validatorFunc(req.body[field]);\n          }\n        });\n      }\n      \n      // Validate query parameters\n      if (schema.query) {\n        Object.keys(schema.query).forEach(field => {\n          const validatorFunc = schema.query[field];\n          if (req.query[field] !== undefined) {\n            req.query[field] = validatorFunc(req.query[field]);\n          }\n        });\n      }\n      \n      // Validate route parameters\n      if (schema.params) {\n        Object.keys(schema.params).forEach(field => {\n          const validatorFunc = schema.params[field];\n          if (req.params[field] !== undefined) {\n            req.params[field] = validatorFunc(req.params[field]);\n          }\n        });\n      }\n      \n      next();\n    } catch (error) {\n      res.status(400).json({ error: error.message });\n    }\n  };\n}\n\n// Usage example\nconst userSchema = {\n  body: {\n    email: InputValidator.validateEmail,\n    username: InputValidator.validateUsername,\n    password: InputValidator.validatePassword\n  }\n};\n\napp.post('/api/users', validateRequest(userSchema), async (req, res) => {\n  try {\n    // At this point, req.body is validated and safe to use\n    const user = await UserService.create(req.body);\n    res.status(201).json(user);\n  } catch (error) {\n    res.status(500).json({ error: 'Failed to create user' });\n  }\n});",
      "explanation": "This comprehensive example demonstrates input validation and data sanitization techniques including email, username, and password validation; HTML, JavaScript, and CSS sanitization; secure file upload handling with validation and malware scanning; and reusable validation middleware for Express applications.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Relying only on client-side validation",
        "solution": "Always implement server-side validation as client-side validation can be bypassed",
        "severity": "high"
      },
      {
        "mistake": "Using blacklist validation instead of whitelist validation",
        "solution": "Use whitelist validation to only allow known good values rather than trying to block all bad values",
        "severity": "high"
      },
      {
        "mistake": "Storing uploaded files in web-accessible directories",
        "solution": "Store uploaded files outside the web root and serve them through authenticated endpoints",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement Secure Input Validation",
        "description": "Create a comprehensive input validation system for a user registration form with email, username, password, and profile fields.",
        "checkpoints": [
          "Implement validation for all form fields with appropriate constraints",
          "Add sanitization for user-provided content to prevent XSS",
          "Create secure file upload handling for profile pictures",
          "Implement validation middleware for Express routes",
          "Test validation with both valid and invalid inputs"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Input Validation",
      "Data Sanitization",
      "File Upload Security",
      "XSS Prevention"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-4",
    "moduleSlug": "security-fundamentals",
    "title": "Security Performance Testing and Optimization",
    "order": 4,
    "objectives": [
      "Understand security implications of performance testing",
      "Implement secure load testing practices",
      "Optimize security controls for performance",
      "Balance security and performance requirements"
    ],
    "intro": "Performance testing in security contexts requires a unique approach that considers both the functional aspects of security controls and their impact on system performance. Security mechanisms often introduce overhead that can significantly affect application performance, making it essential to test both aspects together.\n\nIn this lesson, you'll learn how to conduct performance testing specifically for security features, including authentication systems, encryption processes, access controls, and logging mechanisms. You'll understand how security controls can become bottlenecks and how to identify these issues before they impact production systems.\n\nLoad testing security mechanisms is critical because authentication and authorization systems often become performance bottlenecks under high load. You'll learn techniques for simulating realistic attack scenarios, testing rate limiting mechanisms, and evaluating the performance impact of security controls like encryption, hashing, and session management.\n\nOptimizing security controls for performance requires careful consideration of trade-offs between security and performance. You'll explore techniques for caching security decisions, optimizing cryptographic operations, implementing efficient access control checks, and designing scalable authentication systems that maintain security without sacrificing performance.\n\nBy mastering security performance testing, you'll be able to build systems that are both secure and performant, ensuring that security measures enhance rather than hinder user experience while maintaining robust protection against threats.",
    "code": {
      "example": "// Security Performance Testing and Optimization Implementation\n\n// 1. Secure Authentication Performance Testing\nconst bcrypt = require('bcrypt');\nconst crypto = require('crypto');\n\n// Benchmark different bcrypt cost factors\nasync function benchmarkBcryptCost(password, minCost = 10, maxCost = 14) {\n  const results = [];\n  \n  for (let cost = minCost; cost <= maxCost; cost++) {\n    const startTime = process.hrtime.bigint();\n    await bcrypt.hash(password, cost);\n    const endTime = process.hrtime.bigint();\n    \n    const durationMs = Number(endTime - startTime) / 1000000;\n    results.push({\n      cost,\n      durationMs,\n      recommendation: durationMs < 100 ? 'Acceptable' : \n                     durationMs < 250 ? 'Consider optimization' : 'Too slow for interactive use'\n    });\n  }\n  \n  return results;\n}\n\n// Optimized session management with caching\nclass OptimizedSessionManager {\n  constructor(redisClient, cacheTtl = 3600) {\n    this.redis = redisClient;\n    this.cacheTtl = cacheTtl;\n  }\n  \n  async createSession(userId, permissions) {\n    const sessionId = crypto.randomBytes(32).toString('hex');\n    const sessionData = {\n      userId,\n      permissions,\n      createdAt: Date.now(),\n      lastAccessed: Date.now()\n    };\n    \n    // Store in Redis with expiration\n    await this.redis.setex(\`session:${sessionId}\`, \n      this.cacheTtl, \n      JSON.stringify(sessionData)\n    );\n    \n    return sessionId;\n  }\n  \n  async validateSession(sessionId) {\n    // First check if session exists\n    const sessionStr = await this.redis.get(\`session:${sessionId}\`);\n    if (!sessionStr) return null;\n    \n    const session = JSON.parse(sessionStr);\n    \n    // Update last accessed time\n    session.lastAccessed = Date.now();\n    await this.redis.setex(\`session:${sessionId}\`, \n      this.cacheTtl, \n      JSON.stringify(session)\n    );\n    \n    return session;\n  }\n  \n  async destroySession(sessionId) {\n    await this.redis.del(\`session:${sessionId}\`);\n  }\n}\n\n// 2. Rate Limiting with Performance Considerations\nclass PerformanceOptimizedRateLimiter {\n  constructor(redisClient) {\n    this.redis = redisClient;\n  }\n  \n  async isAllowed(identifier, maxRequests = 100, windowSeconds = 60) {\n    const key = \`rate_limit:${identifier}\`;\n    const now = Math.floor(Date.now() / 1000);\n    const windowStart = now - windowSeconds;\n    \n    // Use Redis pipeline for atomic operations\n    const pipeline = this.redis.multi();\n    \n    // Remove expired entries\n    pipeline.zremrangebyscore(key, 0, windowStart);\n    \n    // Add current request\n    pipeline.zadd(key, now, \`\${now}-\${Math.random()}\`);\n    \n    // Set expiration\n    pipeline.expire(key, windowSeconds);\n    \n    // Get count\n    pipeline.zcard(key);\n    \n    const results = await pipeline.exec();\n    const requestCount = results[3][1]; // Result of zcard\n    \n    return {\n      allowed: requestCount <= maxRequests,\n      count: requestCount,\n      remaining: Math.max(0, maxRequests - requestCount)\n    };\n  }\n}\n\n// 3. Efficient Access Control with Caching\nclass CachedAccessControl {\n  constructor(redisClient, db) {\n    this.redis = redisClient;\n    this.db = db;\n    this.cacheTtl = 300; // 5 minutes\n  }\n  \n  async hasPermission(userId, resource, action) {\n    const cacheKey = \`permission:${userId}:${resource}:${action}\`;\n    \n    // Try cache first\n    const cachedResult = await this.redis.get(cacheKey);\n    if (cachedResult !== null) {\n      return cachedResult === 'true';\n    }\n    \n    // Check database if not in cache\n    const hasPermission = await this.db.checkPermission(userId, resource, action);\n    \n    // Cache result\n    await this.redis.setex(\n      cacheKey, \n      this.cacheTtl, \n      hasPermission ? 'true' : 'false'\n    );\n    \n    return hasPermission;\n  }\n  \n  // Invalidate cache when permissions change\n  async invalidateUserPermissions(userId) {\n    const pattern = \`permission:${userId}:*\`;\n    const keys = await this.redis.keys(pattern);\n    if (keys.length > 0) {\n      await this.redis.del(...keys);\n    }\n  }\n}\n\n// 4. Cryptographic Operation Optimization\nconst crypto = require('crypto');\n\n// Use streaming for large data encryption\nfunction encryptLargeFile(inputStream, outputStream, key) {\n  const algorithm = 'aes-256-gcm';\n  const iv = crypto.randomBytes(16);\n  \n  const cipher = crypto.createCipher(algorithm, key);\n  \n  // Write IV to output stream\n  outputStream.write(iv);\n  \n  // Stream encryption\n  inputStream.pipe(cipher).pipe(outputStream);\n  \n  return new Promise((resolve, reject) => {\n    cipher.on('end', resolve);\n    cipher.on('error', reject);\n  });\n}\n\n// Batch processing for multiple small operations\nasync function batchHashPasswords(passwords, saltRounds = 12) {\n  const results = [];\n  \n  // Process in smaller batches to avoid blocking the event loop\n  const batchSize = 10;\n  \n  for (let i = 0; i < passwords.length; i += batchSize) {\n    const batch = passwords.slice(i, i + batchSize);\n    const batchResults = await Promise.all(\n      batch.map(password => bcrypt.hash(password, saltRounds))\n    );\n    results.push(...batchResults);\n    \n    // Allow event loop to process other tasks\n    await new Promise(resolve => setImmediate(resolve));\n  }\n  \n  return results;\n}\n\n// 5. Security Performance Testing Utilities\nconst autocannon = require('autocannon');\n\nasync function securityPerformanceTest(url, requests, connections) {\n  const result = await autocannon({\n    url,\n    requests,\n    connections,\n    duration: 30, // 30 seconds\n    pipelining: 1,\n    setupClient: (client) => {\n      // Add authentication token for security testing\n      client.on('headers', {\n        authorization: 'Bearer test-token'\n      });\n    }\n  });\n  \n  return {\n    requestsPerSecond: result.requests.average,\n    latency: result.latency.average,\n    throughput: result.throughput.average,\n    errors: result.errors,\n    timeouts: result.timeouts\n  };\n}\n\n// Example usage\napp.post('/api/login', async (req, res) => {\n  try {\n    const { email, password } = req.body;\n    \n    // Simulate optimized authentication\n    const user = await UserRepository.findByEmail(email);\n    if (!user) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n    \n    const isValid = await bcrypt.compare(password, user.password_hash);\n    if (!isValid) {\n      return res.status(401).json({ error: 'Invalid credentials' });\n    }\n    \n    // Create optimized session\n    const sessionId = await sessionManager.createSession(user.id, user.permissions);\n    \n    res.json({ \n      token: sessionId,\n      user: { id: user.id, email: user.email }\n    });\n  } catch (error) {\n    res.status(500).json({ error: 'Authentication failed' });\n  }\n});",
      "explanation": "This example demonstrates security performance optimization techniques including bcrypt cost factor benchmarking, optimized session management with Redis caching, performance-optimized rate limiting using Redis pipelines, cached access control to reduce database queries, streaming encryption for large files, batch processing for cryptographic operations, and security-focused performance testing utilities.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Using overly expensive cryptographic operations in request path",
        "solution": "Benchmark different security parameter levels and choose appropriate trade-offs between security and performance",
        "severity": "high"
      },
      {
        "mistake": "Not caching security decisions that don't change frequently",
        "solution": "Implement intelligent caching for access control decisions and user permissions with proper invalidation",
        "severity": "medium"
      },
      {
        "mistake": "Blocking the event loop with synchronous security operations",
        "solution": "Use asynchronous operations and batch processing for multiple security operations",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Security Performance Optimization Implementation",
        "description": "Implement performance optimizations for a security system including benchmarking cryptographic operations, implementing cached access control, and optimizing session management.",
        "checkpoints": [
          "Benchmark different bcrypt cost factors and document performance impact",
          "Implement cached access control with proper invalidation",
          "Optimize session management with Redis caching",
          "Create batch processing for multiple password hashing operations",
          "Measure performance improvements before and after optimizations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Security",
      "Performance Testing",
      "Optimization",
      "Authentication"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-5",
    "moduleSlug": "security-fundamentals",
    "title": "Automated Security Testing and Vulnerability Scanning",
    "order": 5,
    "objectives": [
      "Implement automated security testing in CI/CD pipelines",
      "Conduct vulnerability scanning for applications and dependencies",
      "Integrate security testing tools effectively",
      "Analyze and remediate security findings"
    ],
    "intro": "Automated security testing is a critical component of modern software development that enables teams to identify vulnerabilities early in the development lifecycle. By integrating security testing into automated pipelines, organizations can catch security issues before they reach production while maintaining development velocity.\n\nIn this lesson, you'll learn how to implement automated security testing across different phases of the software development lifecycle, including static application security testing (SAST), dynamic application security testing (DAST), and software composition analysis (SCA) for dependency scanning. You'll understand how to select appropriate tools, configure them for your technology stack, and integrate them into continuous integration pipelines.\n\nVulnerability scanning for applications and dependencies is essential for maintaining a secure software supply chain. You'll learn techniques for scanning container images, infrastructure as code (IaC) templates, and application dependencies for known vulnerabilities. You'll also explore how to prioritize findings based on risk and exploitability to focus remediation efforts effectively.\n\nIntegrating security testing tools effectively requires understanding their strengths, limitations, and appropriate use cases. You'll learn how to configure tools to minimize false positives, establish baseline security requirements, and create automated gates that prevent vulnerable code from being deployed to production environments.\n\nBy mastering automated security testing, you'll be able to build more secure applications while maintaining development speed, establish measurable security practices, and create a culture of security awareness within development teams.",
    "code": {
      "example": "// Automated Security Testing Implementation\n\n// 1. Dependency Vulnerability Scanning\nconst { exec } = require('child_process');\nconst util = require('util');\nconst execPromise = util.promisify(exec);\n\n// Function to scan dependencies for vulnerabilities\nasync function scanDependencies() {\n  try {\n    // Run npm audit to check for known vulnerabilities\n    const { stdout, stderr } = await execPromise('npm audit --json');\n    \n    if (stderr) {\n      console.warn('npm audit warnings:', stderr);\n    }\n    \n    const auditReport = JSON.parse(stdout);\n    \n    // Process and categorize vulnerabilities\n    const vulnerabilities = {\n      critical: [],\n      high: [],\n      moderate: [],\n      low: []\n    };\n    \n    Object.values(auditReport.advisories || {}).forEach(advisory => {\n      switch (advisory.severity) {\n        case 'critical':\n          vulnerabilities.critical.push(advisory);\n          break;\n        case 'high':\n          vulnerabilities.high.push(advisory);\n          break;\n        case 'moderate':\n          vulnerabilities.moderate.push(advisory);\n          break;\n        case 'low':\n          vulnerabilities.low.push(advisory);\n          break;\n      }\n    });\n    \n    return {\n      total: auditReport.metadata.vulnerabilities.total,\n      vulnerabilities,\n      // Fail build if critical vulnerabilities found\n      shouldFailBuild: vulnerabilities.critical.length > 0 || vulnerabilities.high.length > 5\n    };\n  } catch (error) {\n    // npm audit fails with exit code 1 when vulnerabilities found\n    if (error.stdout) {\n      try {\n        const auditReport = JSON.parse(error.stdout);\n        return {\n          total: auditReport.metadata.vulnerabilities.total,\n          vulnerabilities: categorizeVulnerabilities(auditReport.advisories),\n          shouldFailBuild: true\n        };\n      } catch (parseError) {\n        throw new Error(`Failed to parse npm audit output: \${parseError.message}`);\n      }\n    }\n    throw error;\n  }\n}\n\nfunction categorizeVulnerabilities(advisories) {\n  const vulnerabilities = {\n    critical: [],\n    high: [],\n    moderate: [],\n    low: []\n  };\n  \n  Object.values(advisories || {}).forEach(advisory => {\n    switch (advisory.severity) {\n      case 'critical':\n        vulnerabilities.critical.push({\n          id: advisory.id,\n          title: advisory.title,\n          module: advisory.module_name,\n          patched: advisory.patched_versions,\n          recommendation: advisory.recommendation\n        });\n        break;\n      case 'high':\n        vulnerabilities.high.push({\n          id: advisory.id,\n          title: advisory.title,\n          module: advisory.module_name,\n          patched: advisory.patched_versions,\n          recommendation: advisory.recommendation\n        });\n        break;\n      case 'moderate':\n        vulnerabilities.moderate.push({\n          id: advisory.id,\n          title: advisory.title,\n          module: advisory.module_name,\n          patched: advisory.patched_versions,\n          recommendation: advisory.recommendation\n        });\n        break;\n      case 'low':\n        vulnerabilities.low.push({\n          id: advisory.id,\n          title: advisory.title,\n          module: advisory.module_name,\n          patched: advisory.patched_versions,\n          recommendation: advisory.recommendation\n        });\n        break;\n    }\n  });\n  \n  return vulnerabilities;\n}\n\n// 2. Static Application Security Testing (SAST) Integration\nasync function runSASTScan(sourceDir = './src') {\n  try {\n    // Run ESLint with security plugins\n    const eslintCommand = `npx eslint \${sourceDir} --ext .js,.ts --format json`;\n    const { stdout } = await execPromise(eslintCommand);\n    \n    const results = JSON.parse(stdout);\n    \n    // Filter for security-related issues\n    const securityIssues = results.flatMap(file =>\n      file.messages.filter(message =>\n        message.ruleId && (\n          message.ruleId.includes('security') ||\n          message.ruleId.includes('no-eval') ||\n          message.ruleId.includes('no-new-func') ||\n          message.ruleId.includes('xss')\n        )\n      ).map(issue => ({\n        filePath: file.filePath,\n        line: issue.line,\n        column: issue.column,\n        message: issue.message,\n        ruleId: issue.ruleId,\n        severity: issue.severity\n      }))\n    );\n    \n    return {\n      totalIssues: securityIssues.length,\n      criticalIssues: securityIssues.filter(i => i.severity === 2),\n      issues: securityIssues\n    };\n  } catch (error) {\n    if (error.stdout) {\n      try {\n        const results = JSON.parse(error.stdout);\n        // Process results even when ESLint exits with errors\n        return processSASTResults(results);\n      } catch (parseError) {\n        throw new Error(`Failed to parse ESLint output: \${parseError.message}`);\n      }\n    }\n    throw new Error(`SAST scan failed: \${error.message}`);\n  }\n}\n\nfunction processSASTResults(results) {\n  const securityIssues = results.flatMap(file =>\n    file.messages.filter(message =>\n      message.ruleId && (\n        message.ruleId.includes('security') ||\n        message.ruleId.includes('no-eval') ||\n        message.ruleId.includes('no-new-func') ||\n        message.ruleId.includes('xss')\n      )\n    ).map(issue => ({\n      filePath: file.filePath,\n      line: issue.line,\n      column: issue.column,\n      message: issue.message,\n      ruleId: issue.ruleId,\n      severity: issue.severity\n    }))\n  );\n  \n  return {\n    totalIssues: securityIssues.length,\n    criticalIssues: securityIssues.filter(i => i.severity === 2),\n    issues: securityIssues\n  };\n}\n\n// 3. Security Testing in CI/CD Pipeline\nclass SecurityPipeline {\n  constructor() {\n    this.failOnCritical = process.env.SECURITY_FAIL_ON_CRITICAL !== 'false';\n    this.failOnHigh = process.env.SECURITY_FAIL_ON_HIGH !== 'false';\n  }\n  \n  async runSecurityChecks() {\n    console.log('Running security checks...');\n    \n    // Run dependency scanning\n    const dependencyScan = await scanDependencies();\n    console.log(`Dependency scan found \${dependencyScan.total} vulnerabilities`);\n    \n    // Run SAST\n    const sastScan = await runSASTScan();\n    console.log(`SAST scan found \${sastScan.totalIssues} issues`);\n    \n    // Determine if pipeline should fail\n    let shouldFail = false;\n    \n    if (this.failOnCritical && (\n      dependencyScan.vulnerabilities.critical.length > 0 ||\n      sastScan.criticalIssues.length > 0\n    )) {\n      console.error('CRITICAL security issues found, failing pipeline');\n      shouldFail = true;\n    }\n    \n    if (this.failOnHigh && (\n      dependencyScan.vulnerabilities.high.length > 0\n    )) {\n      console.error('HIGH security issues found, failing pipeline');\n      shouldFail = true;\n    }\n    \n    // Generate security report\n    const report = {\n      timestamp: new Date().toISOString(),\n      dependencyScan,\n      sastScan,\n      shouldFail\n    };\n    \n    // Save report\n    require('fs').writeFileSync(\n      'security-report.json',\n      JSON.stringify(report, null, 2)\n    );\n    \n    if (shouldFail) {\n      process.exit(1);\n    }\n    \n    return report;\n  }\n}\n\n// 4. Container Image Security Scanning\nasync function scanContainerImage(imageName) {\n  try {\n    // Use Trivy or similar tool to scan container images\n    const scanCommand = `trivy image --format json --output trivy-report.json \${imageName}`;\n    await execPromise(scanCommand);\n    \n    // Parse results\n    const report = JSON.parse(require('fs').readFileSync('trivy-report.json', 'utf8'));\n    \n    // Categorize vulnerabilities\n    const vulnerabilities = {\n      critical: [],\n      high: [],\n      medium: [],\n      low: []\n    };\n    \n    report.Results.forEach(result => {\n      if (result.Vulnerabilities) {\n        result.Vulnerabilities.forEach(vuln => {\n          switch (vuln.Severity.toLowerCase()) {\n            case 'critical':\n              vulnerabilities.critical.push(vuln);\n              break;\n            case 'high':\n              vulnerabilities.high.push(vuln);\n              break;\n            case 'medium':\n              vulnerabilities.medium.push(vuln);\n              break;\n            case 'low':\n              vulnerabilities.low.push(vuln);\n              break;\n          }\n        });\n      }\n    });\n    \n    return {\n      total: Object.values(vulnerabilities).reduce((sum, arr) => sum + arr.length, 0),\n      vulnerabilities,\n      shouldFail: vulnerabilities.critical.length > 0\n    };\n  } catch (error) {\n    throw new Error(`Container scan failed: \${error.message}`);\n  }\n}\n\n// 5. Security Testing Utilities\nclass SecurityTestUtils {\n  // Generate security test report\n  static generateReport(testResults) {\n    const report = {\n      summary: {\n        totalTests: testResults.length,\n        passed: testResults.filter(t => t.passed).length,\n        failed: testResults.filter(t => !t.passed).length,\n        criticalIssues: testResults.flatMap(t => t.issues?.critical || []).length\n      },\n      details: testResults\n    };\n    \n    return report;\n  }\n  \n  // Check for common security misconfigurations\n  static async checkSecurityConfig(configPath = './config') {\n    const fs = require('fs');\n    const path = require('path');\n    \n    const issues = [];\n    \n    // Check for exposed secrets\n    try {\n      const files = fs.readdirSync(configPath);\n      for (const file of files) {\n        if (file.endsWith('.env') || file.endsWith('.json')) {\n          const content = fs.readFileSync(path.join(configPath, file), 'utf8');\n          \n          // Look for common patterns of exposed secrets\n          if (content.includes('API_KEY=') && !content.includes('API_KEY=\"\"')) {\n            issues.push({\n              file,\n              issue: 'Potential API key exposure',\n              severity: 'high'\n            });\n          }\n          \n          if (content.includes('PASSWORD=') && !content.includes('PASSWORD=\"\"')) {\n            issues.push({\n              file,\n              issue: 'Potential password exposure',\n              severity: 'critical'\n            });\n          }\n        }\n      }\n    } catch (error) {\n      // Config directory might not exist, which is fine\n    }\n    \n    return issues;\n  }\n}\n\n// Example usage in CI/CD pipeline\n// This would typically be in a separate script or pipeline configuration\nasync function runPipelineSecurityChecks() {\n  const pipeline = new SecurityPipeline();\n  \n  try {\n    const report = await pipeline.runSecurityChecks();\n    console.log('Security checks completed successfully');\n    return report;\n  } catch (error) {\n    console.error('Security checks failed:', error.message);\n    process.exit(1);\n  }\n}\n\n// Example GitHub Actions workflow integration\n/*\nname: Security Checks\non: [push, pull_request]\njobs:\n  security-scan:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n      - name: Install dependencies\n        run: npm ci\n      - name: Run security checks\n        run: node security-pipeline.js\n      - name: Upload security report\n        uses: actions/upload-artifact@v2\n        if: always()\n        with:\n          name: security-report\n          path: security-report.json\n*/",
      "explanation": "This example demonstrates automated security testing implementation including dependency vulnerability scanning with npm audit, static application security testing (SAST) with ESLint, CI/CD pipeline integration with configurable failure thresholds, container image scanning, and security configuration checking utilities.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Failing to configure security tools properly leading to excessive false positives",
        "solution": "Spend time configuring security tools for your specific technology stack and establish baseline configurations that minimize noise while catching real issues",
        "severity": "medium"
      },
      {
        "mistake": "Not prioritizing security findings effectively, leading to team fatigue",
        "solution": "Implement risk-based prioritization of security findings and establish clear remediation SLAs based on severity levels",
        "severity": "high"
      },
      {
        "mistake": "Running security scans only in production environments",
        "solution": "Integrate security scanning into development workflows and CI/CD pipelines to catch issues early",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Automated Security Testing Implementation",
        "description": "Implement a comprehensive automated security testing pipeline including dependency scanning, SAST integration, and CI/CD pipeline configuration.",
        "checkpoints": [
          "Implement dependency vulnerability scanning with npm audit",
          "Integrate ESLint with security plugins for SAST",
          "Create a CI/CD pipeline configuration that runs security checks",
          "Implement risk-based vulnerability prioritization",
          "Generate and analyze security reports from pipeline runs"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 75,
    "difficulty": "Advanced",
    "tags": [
      "Security Testing",
      "CI/CD",
      "Vulnerability Scanning",
      "DevSecOps"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-6",
    "moduleSlug": "security-fundamentals",
    "title": "Secure Code Quality and Review Practices",
    "order": 6,
    "objectives": [
      "Implement security-focused code quality standards",
      "Conduct effective security code reviews",
      "Establish automated security quality gates",
      "Measure and improve security code quality metrics"
    ],
    "intro": "Secure code quality practices are essential for building robust, maintainable, and secure applications. Code quality directly impacts security because poorly written code is more likely to contain vulnerabilities, logic errors, and implementation flaws that attackers can exploit. Establishing security-focused code quality standards helps teams write code that is not only functional but also resilient to attacks.\n\nIn this lesson, you'll learn how to implement security-focused code quality standards that go beyond basic formatting and style guidelines. You'll explore how to configure static analysis tools to catch security anti-patterns, establish coding conventions that prevent common vulnerabilities, and create automated checks that enforce security best practices throughout the development process.\n\nConducting effective security code reviews requires specialized knowledge and techniques that differ from general code reviews. You'll learn how to identify security-relevant code changes, review authentication and authorization logic, examine input validation and output encoding implementations, and assess cryptographic usage. You'll also discover how to make security reviews efficient and scalable within development workflows.\n\nEstablishing automated security quality gates ensures that security issues are caught early and consistently. You'll learn how to integrate security checks into development environments, continuous integration pipelines, and deployment processes. You'll explore tools and techniques for measuring code quality metrics that correlate with security posture and establishing thresholds that prevent vulnerable code from reaching production.\n\nBy mastering secure code quality practices, you'll be able to build applications that are not only functionally correct but also secure by design, reduce the cost of fixing security issues through early detection, and foster a culture of security consciousness within development teams.",
    "code": {
      "example": "// Secure Code Quality and Review Practices Implementation\n\n// 1. Security-Focused ESLint Configuration\n/*\n{\n  \"extends\": [\n    \"eslint:recommended\",\n    \"plugin:security/recommended\"\n  ],\n  \"plugins\": [\n    \"security\",\n    \"xss\"\n  ],\n  \"rules\": {\n    // Security-specific rules\n    \"security/detect-object-injection\": \"warn\",\n    \"security/detect-non-literal-fs-filename\": \"error\",\n    \"security/detect-unsafe-regex\": \"error\",\n    \"security/detect-buffer-noassert\": \"error\",\n    \"security/detect-child-process\": \"error\",\n    \"security/detect-disable-mustache-escape\": \"error\",\n    \"security/detect-eval-with-expression\": \"error\",\n    \"security/detect-no-csrf-before-method-override\": \"error\",\n    \"security/detect-non-literal-regexp\": \"error\",\n    \"security/detect-non-literal-require\": \"warn\",\n    \"security/detect-possible-timing-attacks\": \"warn\",\n    \"security/detect-pseudoRandomBytes\": \"error\",\n    \n    // XSS prevention rules\n    \"xss/no-mixed-html\": \"error\",\n    \"xss/no-location-href-assign\": \"error\",\n    \n    // General security best practices\n    \"no-eval\": \"error\",\n    \"no-implied-eval\": \"error\",\n    \"no-new-func\": \"error\",\n    \"no-console\": \"warn\"\n  }\n}\n*/\n\n// 2. Security Code Review Checklist Utility\nclass SecurityCodeReviewChecklist {\n  static getChecklist() {\n    return {\n      authentication: [\n        'Are passwords properly hashed with strong algorithms?',\n        'Is multi-factor authentication implemented where appropriate?',\n        'Are session tokens securely generated and managed?',\n        'Is there proper account lockout mechanism for brute force protection?',\n        'Are authentication tokens properly validated and expired?'\n      ],\n      authorization: [\n        'Is access control enforced on all sensitive operations?',\n        'Are roles and permissions properly validated?',\n        'Is there proper separation of privileges?',\n        'Are direct object references properly protected?',\n        'Is there horizontal and vertical access control?'\n      ],\n      inputValidation: [\n        'Is all user input properly validated and sanitized?',\n        'Are there proper length and format constraints?',\n        'Is output properly encoded to prevent XSS?',\n        'Are file uploads properly validated and scanned?',\n        'Are command injections prevented in system calls?'\n      ],\n      cryptography: [\n        'Are strong, up-to-date cryptographic algorithms used?',\n        'Are keys properly managed and rotated?',\n        'Is random number generation cryptographically secure?',\n        'Are encryption keys never hardcoded?',\n        'Is sensitive data properly encrypted at rest and in transit?'\n      ],\n      errorHandling: [\n        'Are detailed error messages hidden from users?',\n        'Are security-related events properly logged?',\n        'Is sensitive information excluded from logs?',\n        'Are exceptions properly caught and handled?',\n        'Is there proper audit trail for security events?'\n      ],\n      generalSecurity: [\n        'Are security headers properly configured?',\n        'Is CSRF protection implemented for state-changing operations?',\n        'Are security dependencies up to date?',\n        'Is there proper rate limiting for APIs?',\n        'Are security configurations externalized and not hardcoded?'\n      ]\n    };\n  }\n  \n  static generateReviewReport(codeChanges, reviewer) {\n    const checklist = this.getChecklist();\n    const findings = [];\n    \n    // This would typically integrate with actual code analysis tools\n    Object.keys(checklist).forEach(category => {\n      checklist[category].forEach(item => {\n        // In a real implementation, this would analyze the actual code\n        // For demo purposes, we'll simulate some findings\n        if (Math.random() < 0.1) { // 10% chance of finding\n          findings.push({\n            category,\n            item,\n            severity: ['low', 'medium', 'high'][Math.floor(Math.random() * 3)],\n            location: 'example-file.js:42',\n            recommendation: 'Implement proper validation and sanitization'\n          });\n        }\n      });\n    });\n    \n    return {\n      reviewer,\n      timestamp: new Date().toISOString(),\n      codeChanges,\n      findings,\n      summary: {\n        totalFindings: findings.length,\n        critical: findings.filter(f => f.severity === 'high').length,\n        moderate: findings.filter(f => f.severity === 'medium').length,\n        low: findings.filter(f => f.severity === 'low').length\n      }\n    };\n  }\n}\n\n// 3. Automated Security Quality Gates\nclass SecurityQualityGate {\n  constructor(config = {}) {\n    this.config = {\n      maxCriticalIssues: config.maxCriticalIssues || 0,\n      maxHighIssues: config.maxHighIssues || 5,\n      maxMediumIssues: config.maxMediumIssues || 20,\n      failOnSecurityIssues: config.failOnSecurityIssues !== false\n    };\n  }\n  \n  async evaluateQualityGate(analysisResults) {\n    const issues = this.categorizeIssues(analysisResults);\n    \n    const gateResult = {\n      passed: true,\n      issues,\n      violations: []\n    };\n    \n    // Check against configured thresholds\n    if (issues.critical > this.config.maxCriticalIssues) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'critical',\n        count: issues.critical,\n        threshold: this.config.maxCriticalIssues,\n        message: `Critical issues (\${issues.critical}) exceed threshold (\${this.config.maxCriticalIssues})`\n      });\n    }\n    \n    if (issues.high > this.config.maxHighIssues) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'high',\n        count: issues.high,\n        threshold: this.config.maxHighIssues,\n        message: `High severity issues (\${issues.high}) exceed threshold (\${this.config.maxHighIssues})`\n      });\n    }\n    \n    if (issues.medium > this.config.maxMediumIssues) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'medium',\n        count: issues.medium,\n        threshold: this.config.maxMediumIssues,\n        message: `Medium severity issues (\${issues.medium}) exceed threshold (\${this.config.maxMediumIssues})`\n      });\n    }\n    \n    return gateResult;\n  }\n  \n  categorizeIssues(analysisResults) {\n    // This would integrate with actual analysis tools\n    // For demo, we'll simulate based on analysis results\n    return {\n      critical: analysisResults.criticalIssues || 0,\n      high: analysisResults.highIssues || 0,\n      medium: analysisResults.mediumIssues || 0,\n      low: analysisResults.lowIssues || 0\n    };\n  }\n  \n  async runQualityChecks() {\n    console.log('Running security quality checks...');\n    \n    // In a real implementation, this would run actual security tools\n    // For demo, we'll simulate results\n    const analysisResults = {\n      criticalIssues: Math.floor(Math.random() * 3),\n      highIssues: Math.floor(Math.random() * 10),\n      mediumIssues: Math.floor(Math.random() * 25),\n      lowIssues: Math.floor(Math.random() * 50)\n    };\n    \n    const gateResult = await this.evaluateQualityGate(analysisResults);\n    \n    console.log(`Quality gate result: \${gateResult.passed ? 'PASSED' : 'FAILED'}`);\n    console.log(`Issues found - Critical: \${analysisResults.criticalIssues}, High: \${analysisResults.highIssues}, Medium: \${analysisResults.mediumIssues}, Low: \${analysisResults.lowIssues}`);\n    \n    if (!gateResult.passed) {\n      console.error('Quality gate violations:');\n      gateResult.violations.forEach(violation => {\n        console.error(`  - \${violation.message}`);\n      });\n      \n      if (this.config.failOnSecurityIssues) {\n        process.exit(1);\n      }\n    }\n    \n    return gateResult;\n  }\n}\n\n// 4. Security Code Quality Metrics\nclass SecurityCodeQualityMetrics {\n  static calculateMetrics(codebaseInfo) {\n    return {\n      // Security coverage metrics\n      inputValidationCoverage: this.calculateInputValidationCoverage(codebaseInfo),\n      authenticationCoverage: this.calculateAuthenticationCoverage(codebaseInfo),\n      authorizationCoverage: this.calculateAuthorizationCoverage(codebaseInfo),\n      \n      // Vulnerability density metrics\n      vulnerabilitiesPerKLOC: this.calculateVulnerabilityDensity(codebaseInfo),\n      securityIssuesTrend: this.calculateSecurityTrend(codebaseInfo),\n      \n      // Code quality metrics\n      codeComplexityScore: this.calculateComplexityScore(codebaseInfo),\n      securityAntiPatterns: this.countSecurityAntiPatterns(codebaseInfo),\n      \n      // Review metrics\n      codeReviewCoverage: this.calculateReviewCoverage(codebaseInfo),\n      securityFindingsRate: this.calculateFindingsRate(codebaseInfo)\n    };\n  }\n  \n  static calculateInputValidationCoverage(codebaseInfo) {\n    // This would analyze actual codebase\n    // For demo, return simulated value\n    return {\n      percentage: 85,\n      validatedEndpoints: 42,\n      totalEndpoints: 50\n    };\n  }\n  \n  static calculateAuthenticationCoverage(codebaseInfo) {\n    // This would analyze actual codebase\n    // For demo, return simulated value\n    return {\n      percentage: 95,\n      protectedRoutes: 38,\n      totalRoutes: 40\n    };\n  }\n  \n  static calculateAuthorizationCoverage(codebaseInfo) {\n    // This would analyze actual codebase\n    // For demo, return simulated value\n    return {\n      percentage: 78,\n      authorizedOperations: 31,\n      totalOperations: 40\n    };\n  }\n  \n  static calculateVulnerabilityDensity(codebaseInfo) {\n    // Vulnerabilities per thousand lines of code\n    const vulnerabilities = codebaseInfo.vulnerabilities || 12;\n    const kloc = codebaseInfo.linesOfCode ? codebaseInfo.linesOfCode / 1000 : 15;\n    return vulnerabilities / kloc;\n  }\n  \n  static calculateSecurityTrend(codebaseInfo) {\n    // Compare current vulnerabilities to previous period\n    const current = codebaseInfo.vulnerabilities || 12;\n    const previous = codebaseInfo.previousVulnerabilities || 15;\n    return ((previous - current) / previous) * 100; // Percentage improvement\n  }\n  \n  static calculateComplexityScore(codebaseInfo) {\n    // Cyclomatic complexity weighted for security-sensitive code\n    return codebaseInfo.complexityScore || 7.2;\n  }\n  \n  static countSecurityAntiPatterns(codebaseInfo) {\n    // Count occurrences of known security anti-patterns\n    return codebaseInfo.securityAntiPatterns || 8;\n  }\n  \n  static calculateReviewCoverage(codebaseInfo) {\n    // Percentage of security-sensitive code that has been reviewed\n    return codebaseInfo.reviewCoverage || 92;\n  }\n  \n  static calculateFindingsRate(codebaseInfo) {\n    // Security findings per reviewer hour\n    const findings = codebaseInfo.securityFindings || 24;\n    const reviewerHours = codebaseInfo.reviewerHours || 40;\n    return findings / reviewerHours;\n  }\n}\n\n// 5. Security Code Review Automation\nclass AutomatedSecurityReviewer {\n  constructor() {\n    this.patterns = [\n      {\n        name: 'Hardcoded Secrets',\n        pattern: /(password|api[_-]?key|secret|token)\s*[=: ]\s*['\"]\w+/i,\n        severity: 'high',\n        message: 'Hardcoded secrets detected. Use environment variables or secure vault.'\n      },\n      {\n        name: 'SQL Injection Risk',\n        pattern: /\.(query|execute)\s*\([^)]*['\"`]\s*\+\s*[^)]*\)/i,\n        severity: 'high',\n        message: 'Potential SQL injection vulnerability detected.'\n      },\n      {\n        name: 'Weak Cryptography',\n        pattern: /\b(md5|sha1)\s*\(/i,\n        severity: 'medium',\n        message: 'Weak cryptographic hash function detected. Use SHA-256 or stronger.'\n      },\n      {\n        name: 'Insecure Random',\n        pattern: /\b(Math\.random|crypto\.random)\b/i,\n        severity: 'medium',\n        message: 'Insecure random number generation. Use cryptographically secure random.'\n      }\n    ];\n  }\n  \n  async reviewCode(code, fileName) {\n    const findings = [];\n    \n    this.patterns.forEach(pattern => {\n      const matches = code.match(pattern.pattern);\n      if (matches) {\n        findings.push({\n          pattern: pattern.name,\n          severity: pattern.severity,\n          message: pattern.message,\n          file: fileName,\n          line: this.findLine(code, matches.index)\n        });\n      }\n    });\n    \n    return findings;\n  }\n  \n  findLine(code, index) {\n    const lines = code.substring(0, index).split('\n');\n    return lines.length;\n  }\n  \n  async reviewFile(filePath) {\n    const fs = require('fs');\n    const path = require('path');\n    \n    try {\n      const code = fs.readFileSync(filePath, 'utf8');\n      return await this.reviewCode(code, path.basename(filePath));\n    } catch (error) {\n      throw new Error(`Failed to review file \${filePath}: \${error.message}`);\n    }\n  }\n}\n\n// Example usage\nasync function runSecurityCodeReview() {\n  // Generate a sample review report\n  const reviewReport = SecurityCodeReviewChecklist.generateReviewReport(\n    'feature/authentication',\n    'security-team'\n  );\n  \n  console.log('Security Code Review Report:');\n  console.log(JSON.stringify(reviewReport, null, 2));\n  \n  // Run quality gate checks\n  const qualityGate = new SecurityQualityGate({\n    maxCriticalIssues: 0,\n    maxHighIssues: 5\n  });\n  \n  const gateResult = await qualityGate.runQualityChecks();\n  \n  // Calculate and display metrics\n  const metrics = SecurityCodeQualityMetrics.calculateMetrics({\n    linesOfCode: 15000,\n    vulnerabilities: 8,\n    previousVulnerabilities: 12,\n    securityAntiPatterns: 5\n  });\n  \n  console.log('\nSecurity Code Quality Metrics:');\n  console.log(JSON.stringify(metrics, null, 2));\n  \n  return { reviewReport, gateResult, metrics };\n}\n\n// Example pre-commit hook integration\n/*\n#!/bin/bash\n# pre-commit hook for security checks\n\necho \"Running security code quality checks...\"\n\n# Run ESLint with security rules\nnpx eslint . --ext .js,.ts --quiet\n\n# Run security quality gate\nnode security-quality-gate.js\n\nif [ \$? -ne 0 ]; then\n  echo \"Security quality checks failed. Commit aborted.\"\n  exit 1\nfi\n\necho \"Security checks passed.\"\nexit 0\n*/",
      "explanation": "This example demonstrates secure code quality practices including security-focused ESLint configuration with security plugins, a comprehensive security code review checklist utility, automated security quality gates with configurable thresholds, security code quality metrics calculation, and automated security review tools that detect common vulnerabilities and anti-patterns.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Treating security code reviews as separate from regular code reviews",
        "solution": "Integrate security considerations into all code reviews and train all developers to recognize security-relevant changes",
        "severity": "high"
      },
      {
        "mistake": "Focusing only on automated tools without human review",
        "solution": "Use automated tools to catch obvious issues but rely on human expertise for complex security analysis and context-aware evaluations",
        "severity": "medium"
      },
      {
        "mistake": "Not establishing meaningful security quality metrics",
        "solution": "Define metrics that correlate with actual security posture and track them over time to measure improvement",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Secure Code Quality Implementation",
        "description": "Implement a comprehensive secure code quality system including ESLint security configuration, automated quality gates, and security metrics tracking.",
        "checkpoints": [
          "Configure ESLint with security plugins and rules",
          "Implement automated security quality gates with configurable thresholds",
          "Create security code quality metrics dashboard",
          "Set up automated security review tools for common vulnerabilities",
          "Integrate security checks into development workflow"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 90,
    "difficulty": "Advanced",
    "tags": [
      "Code Quality",
      "Security Review",
      "Static Analysis",
      "DevSecOps"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-7",
    "moduleSlug": "security-fundamentals",
    "title": "Security Review Processes and Collaboration",
    "order": 7,
    "objectives": [
      "Implement structured security review processes",
      "Facilitate effective security collaboration between teams",
      "Establish security review automation and tooling",
      "Measure and improve security review effectiveness"
    ],
    "intro": "Security review processes are critical for identifying vulnerabilities and ensuring that security considerations are integrated throughout the software development lifecycle. Effective security reviews require structured approaches, clear collaboration between development and security teams, and appropriate automation to scale security practices across organizations.\n\nIn this lesson, you'll learn how to implement structured security review processes that fit into modern development workflows. You'll explore different types of security reviews including architecture reviews, code reviews, and penetration testing coordination. You'll understand how to establish review criteria, create review checklists, and integrate security reviews into existing development processes without creating bottlenecks.\n\nFacilitating effective security collaboration between teams requires breaking down traditional silos and creating shared responsibility for security. You'll learn techniques for working effectively with development teams, product managers, and other stakeholders to make security a collaborative effort rather than an obstacle. You'll explore how to communicate security findings effectively and work with teams to prioritize and remediate issues.\n\nEstablishing security review automation and tooling helps scale security practices and ensures consistency across reviews. You'll learn how to select and configure automated security review tools, integrate them into development workflows, and create custom tooling to address organization-specific security concerns. You'll also explore how to balance automated and manual review processes for optimal effectiveness.\n\nBy mastering security review processes, you'll be able to identify security issues early in the development lifecycle, build security awareness throughout your organization, and create sustainable security practices that scale with your team and codebase.",
    "code": {
      "example": "// Security Review Processes and Collaboration Implementation\n\n// 1. Structured Security Review Framework\nclass SecurityReviewFramework {\n  constructor() {\n    this.reviewTypes = {\n      architecture: {\n        checklist: [\n          'Threat modeling completed',\n          'Security requirements documented',\n          'Data flow analysis performed',\n          'Authentication/authorization design reviewed',\n          'Cryptography implementation design reviewed',\n          'Security controls identified and documented'\n        ],\n        participants: ['security-architect', 'lead-developer', 'product-manager'],\n        timeline: 'Before development begins'\n      },\n      code: {\n        checklist: [\n          'Input validation implemented',\n          'Output encoding applied',\n          'Authentication/authorization logic reviewed',\n          'Error handling does not leak information',\n          'Cryptography usage is correct',\n          'Security dependencies are current'\n        ],\n        participants: ['security-engineer', 'code-reviewer', 'developer'],\n        timeline: 'During code review process'\n      },\n      deployment: {\n        checklist: [\n          'Security configurations validated',\n          'Environment isolation verified',\n          'Monitoring and alerting configured',\n          'Backup and recovery procedures tested',\n          'Incident response procedures documented'\n        ],\n        participants: ['devops-engineer', 'security-ops', 'system-admin'],\n        timeline: 'Before production deployment'\n      }\n    };\n  }\n  \n  async conductReview(reviewType, target, reviewers) {\n    const reviewConfig = this.reviewTypes[reviewType];\n    if (!reviewConfig) {\n      throw new Error(`Unknown review type: \${reviewType}`);\n    }\n    \n    console.log(`Conducting \${reviewType} review for \${target}`);\n    \n    // In a real implementation, this would integrate with actual review tools\n    // For demo, we'll simulate the review process\n    const findings = [];\n    \n    // Simulate review process\n    reviewConfig.checklist.forEach(item => {\n      // Randomly generate findings for demo purposes\n      if (Math.random() < 0.2) { // 20% chance of finding\n        findings.push({\n          item,\n          severity: ['low', 'medium', 'high'][Math.floor(Math.random() * 3)],\n          recommendation: 'Implement proper security controls'\n        });\n      }\n    });\n    \n    return {\n      reviewType,\n      target,\n      reviewers,\n      timestamp: new Date().toISOString(),\n      checklist: reviewConfig.checklist,\n      findings,\n      status: findings.length > 0 ? 'needs_attention' : 'approved'\n    };\n  }\n  \n  generateReviewTemplate(reviewType) {\n    const template = this.reviewTypes[reviewType];\n    if (!template) {\n      throw new Error(`Unknown review type: \${reviewType}`);\n    }\n    \n    return {\n      type: reviewType,\n      checklist: template.checklist.map(item => ({\n        item,\n        checked: false,\n        notes: ''\n      })),\n      participants: template.participants\n    };\n  }\n}\n\n// 2. Security Collaboration Platform\nclass SecurityCollaborationPlatform {\n  constructor() {\n    this.issues = [];\n    this.reviewers = new Map();\n  }\n  \n  // Create a security issue for collaboration\n  createIssue(title, description, severity, assignees = []) {\n    const issue = {\n      id: `SEC-\${Date.now()}-\${Math.floor(Math.random() * 1000)}`,\n      title,\n      description,\n      severity,\n      status: 'open',\n      assignees,\n      createdAt: new Date().toISOString(),\n      updatedAt: new Date().toISOString(),\n      comments: [],\n      tags: ['security']\n    };\n    \n    this.issues.push(issue);\n    return issue.id;\n  }\n  \n  // Add comment to security issue\n  addComment(issueId, author, comment) {\n    const issue = this.issues.find(i => i.id === issueId);\n    if (!issue) {\n      throw new Error(`Issue not found: \${issueId}`);\n    }\n    \n    issue.comments.push({\n      author,\n      comment,\n      timestamp: new Date().toISOString()\n    });\n    \n    issue.updatedAt = new Date().toISOString();\n    return issue;\n  }\n  \n  // Update issue status\n  updateStatus(issueId, status, updatedBy) {\n    const issue = this.issues.find(i => i.id === issueId);\n    if (!issue) {\n      throw new Error(`Issue not found: \${issueId}`);\n    }\n    \n    issue.status = status;\n    issue.updatedAt = new Date().toISOString();\n    \n    this.addComment(issueId, updatedBy, `Status updated to \${status}`);\n    return issue;\n  }\n  \n  // Assign reviewers to security issues\n  assignReviewers(issueId, reviewers) {\n    const issue = this.issues.find(i => i.id === issueId);\n    if (!issue) {\n      throw new Error(`Issue not found: \${issueId}`);\n    }\n    \n    issue.assignees = [...new Set([...issue.assignees, ...reviewers])];\n    issue.updatedAt = new Date().toISOString();\n    \n    this.addComment(issueId, 'system', `Reviewers assigned: \${reviewers.join(', ')}`);\n    return issue;\n  }\n  \n  // Get issues by severity\n  getIssuesBySeverity(severity) {\n    return this.issues.filter(issue => issue.severity === severity);\n  }\n  \n  // Get issues assigned to a reviewer\n  getIssuesForReviewer(reviewer) {\n    return this.issues.filter(issue => issue.assignees.includes(reviewer));\n  }\n}\n\n// 3. Automated Security Review Integration\nclass AutomatedSecurityReview {\n  constructor(gitProvider, ciProvider) {\n    this.gitProvider = gitProvider;\n    this.ciProvider = ciProvider;\n    this.reviewThresholds = {\n      critical: 0,\n      high: 5,\n      medium: 20\n    };\n  }\n  \n  // Analyze pull request for security issues\n  async analyzePullRequest(prNumber, repository) {\n    console.log(`Analyzing PR #\${prNumber} in \${repository} for security issues`);\n    \n    // In a real implementation, this would integrate with actual security tools\n    // For demo, we'll simulate analysis\n    const analysis = {\n      prNumber,\n      repository,\n      timestamp: new Date().toISOString(),\n      findings: [],\n      summary: {\n        critical: 0,\n        high: 0,\n        medium: 0,\n        low: 0\n      }\n    };\n    \n    // Simulate finding security issues\n    const issueTypes = [\n      'Hardcoded secrets',\n      'SQL injection risk',\n      'XSS vulnerability',\n      'Insecure dependencies',\n      'Weak cryptography',\n      'Missing input validation'\n    ];\n    \n    // Randomly generate findings\n    const issueCount = Math.floor(Math.random() * 10);\n    for (let i = 0; i < issueCount; i++) {\n      const severity = ['low', 'medium', 'high', 'critical'][Math.floor(Math.random() * 4)];\n      analysis.findings.push({\n        id: `FINDING-\${Date.now()}-\${i}`,\n        type: issueTypes[Math.floor(Math.random() * issueTypes.length)],\n        severity,\n        file: `src/file\${Math.floor(Math.random() * 20)}.js`,\n        line: Math.floor(Math.random() * 100) + 1,\n        description: 'Security issue detected during automated review',\n        recommendation: 'Implement proper security controls'\n      });\n      \n      analysis.summary[severity]++;\n    }\n    \n    return analysis;\n  }\n  \n  // Post security review comments to PR\n  async postReviewComments(prNumber, repository, analysis) {\n    console.log(`Posting \${analysis.findings.length} security comments to PR #\${prNumber}`);\n    \n    // In a real implementation, this would integrate with Git provider APIs\n    // For demo, we'll just log the actions\n    analysis.findings.forEach(finding => {\n      console.log(`Commenting on \${finding.file}:\${finding.line}: \${finding.type} (\${finding.severity})`);\n    });\n    \n    // Determine if PR should be blocked\n    const shouldBlock = (\n      analysis.summary.critical > this.reviewThresholds.critical ||\n      analysis.summary.high > this.reviewThresholds.high ||\n      analysis.summary.medium > this.reviewThresholds.medium\n    );\n    \n    return {\n      prNumber,\n      shouldBlock,\n      reason: shouldBlock ? 'Security issues exceed thresholds' : 'Security review passed'\n    };\n  }\n  \n  // Generate security review report\n  generateReviewReport(analysis) {\n    return {\n      title: `Security Review Report - PR #\${analysis.prNumber}`,\n      timestamp: analysis.timestamp,\n      summary: analysis.summary,\n      findings: analysis.findings,\n      recommendations: [\n        'Address all critical and high severity issues before merging',\n        'Review medium severity issues for potential improvements',\n        'Consider implementing additional security controls'\n      ]\n    };\n  }\n}\n\n// 4. Security Review Metrics and Analytics\nclass SecurityReviewMetrics {\n  constructor() {\n    this.reviews = [];\n  }\n  \n  // Record a completed security review\n  recordReview(review) {\n    this.reviews.push({\n      ...review,\n      recordedAt: new Date().toISOString()\n    });\n  }\n  \n  // Calculate review effectiveness metrics\n  calculateEffectivenessMetrics() {\n    if (this.reviews.length === 0) {\n      return {\n        reviewCount: 0,\n        avgFindingsPerReview: 0,\n        criticalIssueDetectionRate: 0,\n        reviewCompletionRate: 0\n      };\n    }\n    \n    const totalFindings = this.reviews.reduce((sum, review) => \n      sum + review.findings.length, 0);\n    \n    const criticalFindings = this.reviews\n      .flatMap(review => review.findings)\n      .filter(finding => finding.severity === 'critical').length;\n    \n    const completedReviews = this.reviews\n      .filter(review => review.status === 'completed').length;\n    \n    return {\n      reviewCount: this.reviews.length,\n      avgFindingsPerReview: totalFindings / this.reviews.length,\n      criticalIssueDetectionRate: (criticalFindings / totalFindings * 100) || 0,\n      reviewCompletionRate: (completedReviews / this.reviews.length * 100)\n    };\n  }\n  \n  // Get review trends over time\n  getReviewTrends(days = 30) {\n    const cutoffDate = new Date();\n    cutoffDate.setDate(cutoffDate.getDate() - days);\n    \n    const recentReviews = this.reviews.filter(review => \n      new Date(review.recordedAt) > cutoffDate);\n    \n    // Group reviews by week\n    const weeklyData = {};\n    recentReviews.forEach(review => {\n      const week = new Date(review.recordedAt);\n      week.setDate(week.getDate() - week.getDay()); // Start of week\n      const weekKey = week.toISOString().split('T')[0];\n      \n      if (!weeklyData[weekKey]) {\n        weeklyData[weekKey] = {\n          reviews: 0,\n          findings: 0,\n          critical: 0\n        };\n      }\n      \n      weeklyData[weekKey].reviews++;\n      weeklyData[weekKey].findings += review.findings.length;\n      weeklyData[weekKey].critical += review.findings\n        .filter(f => f.severity === 'critical').length;\n    });\n    \n    return weeklyData;\n  }\n}\n\n// Example usage\nasync function demonstrateSecurityReviewProcess() {\n  // Initialize security review framework\n  const reviewFramework = new SecurityReviewFramework();\n  \n  // Generate a code review template\n  const codeReviewTemplate = reviewFramework.generateReviewTemplate('code');\n  console.log('Code Review Template:', JSON.stringify(codeReviewTemplate, null, 2));\n  \n  // Conduct a sample architecture review\n  const archReview = await reviewFramework.conductReview(\n    'architecture',\n    'user-authentication-service',\n    ['security-architect', 'lead-developer']\n  );\n  console.log('Architecture Review:', JSON.stringify(archReview, null, 2));\n  \n  // Initialize collaboration platform\n  const collabPlatform = new SecurityCollaborationPlatform();\n  \n  // Create security issues\n  const issue1 = collabPlatform.createIssue(\n    'SQL Injection Vulnerability',\n    'User input is not properly sanitized in login endpoint',\n    'high',\n    ['backend-developer', 'security-engineer']\n  );\n  \n  const issue2 = collabPlatform.createIssue(\n    'Hardcoded API Key',\n    'Production API key found in source code',\n    'critical',\n    ['devops-engineer']\n  );\n  \n  // Add comments to issues\n  collabPlatform.addComment(issue1, 'security-engineer', 'This needs immediate attention');\n  collabPlatform.addComment(issue2, 'devops-engineer', 'Key has been rotated, removing from code');\n  \n  // Update issue statuses\n  collabPlatform.updateStatus(issue1, 'in_progress', 'project-manager');\n  collabPlatform.updateStatus(issue2, 'resolved', 'devops-engineer');\n  \n  console.log('Security issues:', collabPlatform.issues);\n  \n  // Initialize metrics tracking\n  const metrics = new SecurityReviewMetrics();\n  metrics.recordReview(archReview);\n  \n  // Calculate and display metrics\n  const effectiveness = metrics.calculateEffectivenessMetrics();\n  console.log('Review Effectiveness Metrics:', JSON.stringify(effectiveness, null, 2));\n  \n  return {\n    reviewFramework,\n    collabPlatform,\n    metrics,\n    archReview\n  };\n}\n\n// Example GitHub Actions integration for automated security reviews\n/*\nname: Security Review\non: [pull_request]\njobs:\n  security-review:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n        with:\n          fetch-depth: 0\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n      - name: Install dependencies\n        run: npm ci\n      - name: Run security analysis\n        run: node security-review.js\n      - name: Post security comments\n        if: always()\n        run: node post-security-comments.js\n        env:\n          GITHUB_TOKEN: \${{ secrets.GITHUB_TOKEN }}\n*/",
      "explanation": "This example demonstrates security review processes and collaboration including a structured security review framework with different review types and checklists, a security collaboration platform for issue tracking and team communication, automated security review integration with pull requests, and security review metrics and analytics for measuring effectiveness.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating security review processes that are too slow or bureaucratic",
        "solution": "Design streamlined review processes with clear criteria and integrate automated checks to handle routine issues, reserving human review for complex security decisions",
        "severity": "high"
      },
      {
        "mistake": "Not involving the right stakeholders in security reviews",
        "solution": "Identify key stakeholders for each type of review and ensure they're included in the process, providing appropriate context and training for effective participation",
        "severity": "medium"
      },
      {
        "mistake": "Failing to track and measure security review effectiveness",
        "solution": "Implement metrics to track review outcomes, issue resolution times, and security posture improvements to continuously refine the review process",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Security Review Process Implementation",
        "description": "Implement a comprehensive security review process including structured review frameworks, collaboration tools, and metrics tracking.",
        "checkpoints": [
          "Create security review templates for different review types",
          "Implement a security collaboration platform for issue tracking",
          "Set up automated security review integration with pull requests",
          "Establish security review metrics and reporting",
          "Test the end-to-end review process with sample code changes"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 90,
    "difficulty": "Advanced",
    "tags": [
      "Security Review",
      "Collaboration",
      "Code Review",
      "DevSecOps"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-8",
    "moduleSlug": "security-fundamentals",
    "title": "Security in Continuous Integration and Deployment",
    "order": 8,
    "objectives": [
      "Integrate security testing into CI/CD pipelines",
      "Implement security gates and quality checks",
      "Automate security validation for deployments",
      "Monitor and respond to security events in production"
    ],
    "intro": "Security in continuous integration and deployment (CI/CD) is essential for maintaining rapid development velocity while ensuring that security is not compromised. Modern DevOps practices require security to be integrated throughout the pipeline rather than treated as a separate phase. This approach, often called DevSecOps, enables organizations to deliver secure software quickly and reliably.\n\nIn this lesson, you'll learn how to integrate security testing into CI/CD pipelines effectively. You'll explore different types of security tests that can be automated, including static analysis, dependency scanning, and vulnerability assessments. You'll understand how to configure these tests to run at appropriate stages in your pipeline and how to interpret and act on their results.\n\nImplementing security gates and quality checks ensures that vulnerable code doesn't progress through the deployment pipeline. You'll learn how to establish security thresholds, configure automated gates that prevent insecure code from being deployed, and create feedback loops that help developers quickly address security issues. You'll also explore how to balance security requirements with development speed.\n\nAutomating security validation for deployments reduces the risk of security incidents in production environments. You'll learn techniques for validating security configurations, scanning container images, and verifying that security controls are properly implemented before code reaches production. You'll also explore infrastructure as code (IaC) security scanning and configuration validation.\n\nBy mastering security in CI/CD, you'll be able to build and deploy secure applications at scale, reduce the time and cost of addressing security issues, and create a culture where security is everyone's responsibility rather than a bottleneck.",
    "code": {
      "example": "// Security in Continuous Integration and Deployment Implementation\n\n// 1. CI/CD Security Pipeline Configuration\n/*\n# Example GitHub Actions workflow with security checks\nname: Security CI/CD Pipeline\non: [push, pull_request]\njobs:\n  security-analysis:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v2\n      - name: Setup Node.js\n        uses: actions/setup-node@v2\n        with:\n          node-version: '16'\n      - name: Install dependencies\n        run: npm ci\n      \n      # Security dependency scanning\n      - name: Run npm audit\n        run: npm audit || npm audit --audit-level=moderate\n      \n      # Static Application Security Testing (SAST)\n      - name: Run ESLint with security rules\n        run: npx eslint . --ext .js,.ts --quiet\n      \n      # Security unit tests\n      - name: Run security tests\n        run: npm run test:security\n      \n      # Security quality gate\n      - name: Run security quality gate\n        run: node security-gate.js\n      \n  build-and-scan:\n    runs-on: ubuntu-latest\n    needs: security-analysis\n    steps:\n      - uses: actions/checkout@v2\n      - name: Build application\n        run: npm run build\n      \n      # Container image scanning\n      - name: Build Docker image\n        run: docker build -t myapp:\${{ github.sha }} .\n      - name: Scan container image\n        run: trivy image --exit-code 1 --severity HIGH,CRITICAL myapp:\${{ github.sha }}\n      \n  deploy-to-staging:\n    runs-on: ubuntu-latest\n    needs: build-and-scan\n    environment: staging\n    steps:\n      - name: Deploy to staging\n        run: |\n          # Deployment commands here\n          echo \"Deploying to staging environment\"\n      \n      # Post-deployment security validation\n      - name: Validate security configuration\n        run: node validate-security-config.js\n*/\n\n// 2. Security Quality Gate Implementation\nclass SecurityQualityGate {\n  constructor(config = {}) {\n    this.config = {\n      maxCriticalVulnerabilities: config.maxCriticalVulnerabilities || 0,\n      maxHighVulnerabilities: config.maxHighVulnerabilities || 5,\n      maxMediumVulnerabilities: config.maxMediumVulnerabilities || 20,\n      failOnSecurityIssues: config.failOnSecurityIssues !== false\n    };\n  }\n  \n  async evaluatePipelineSecurity(analysisResults) {\n    const vulnerabilities = this.categorizeVulnerabilities(analysisResults);\n    \n    const gateResult = {\n      passed: true,\n      vulnerabilities,\n      violations: []\n    };\n    \n    // Check against configured thresholds\n    if (vulnerabilities.critical > this.config.maxCriticalVulnerabilities) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'critical',\n        count: vulnerabilities.critical,\n        threshold: this.config.maxCriticalVulnerabilities,\n        message: `Critical vulnerabilities (\${vulnerabilities.critical}) exceed threshold (\${this.config.maxCriticalVulnerabilities})`\n      });\n    }\n    \n    if (vulnerabilities.high > this.config.maxHighVulnerabilities) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'high',\n        count: vulnerabilities.high,\n        threshold: this.config.maxHighVulnerabilities,\n        message: `High severity vulnerabilities (\${vulnerabilities.high}) exceed threshold (\${this.config.maxHighVulnerabilities})`\n      });\n    }\n    \n    if (vulnerabilities.medium > this.config.maxMediumVulnerabilities) {\n      gateResult.passed = false;\n      gateResult.violations.push({\n        type: 'medium',\n        count: vulnerabilities.medium,\n        threshold: this.config.maxMediumVulnerabilities,\n        message: `Medium severity vulnerabilities (\${vulnerabilities.medium}) exceed threshold (\${this.config.maxMediumVulnerabilities})`\n      });\n    }\n    \n    return gateResult;\n  }\n  \n  categorizeVulnerabilities(analysisResults) {\n    // This would integrate with actual security tools\n    // For demo, we'll simulate based on analysis results\n    return {\n      critical: analysisResults.criticalVulnerabilities || 0,\n      high: analysisResults.highVulnerabilities || 0,\n      medium: analysisResults.mediumVulnerabilities || 0,\n      low: analysisResults.lowVulnerabilities || 0\n    };\n  }\n  \n  async runSecurityGate() {\n    console.log('Running security quality gate...');\n    \n    // In a real implementation, this would run actual security tools\n    // For demo, we'll simulate results\n    const analysisResults = {\n      criticalVulnerabilities: Math.floor(Math.random() * 3),\n      highVulnerabilities: Math.floor(Math.random() * 10),\n      mediumVulnerabilities: Math.floor(Math.random() * 25),\n      lowVulnerabilities: Math.floor(Math.random() * 50)\n    };\n    \n    const gateResult = await this.evaluatePipelineSecurity(analysisResults);\n    \n    console.log(`Security gate result: \${gateResult.passed ? 'PASSED' : 'FAILED'}`);\n    console.log(`Vulnerabilities found - Critical: \${analysisResults.criticalVulnerabilities}, High: \${analysisResults.highVulnerabilities}, Medium: \${analysisResults.mediumVulnerabilities}, Low: \${analysisResults.lowVulnerabilities}`);\n    \n    if (!gateResult.passed) {\n      console.error('Security gate violations:');\n      gateResult.violations.forEach(violation => {\n        console.error(`  - \${violation.message}`);\n      });\n      \n      if (this.config.failOnSecurityIssues) {\n        process.exit(1);\n      }\n    }\n    \n    return gateResult;\n  }\n}\n\n// 3. Automated Security Validation for Deployments\nclass DeploymentSecurityValidator {\n  constructor() {\n    this.validationChecks = [\n      {\n        name: 'Environment Variables',\n        check: this.validateEnvironmentVariables\n      },\n      {\n        name: 'Security Headers',\n        check: this.validateSecurityHeaders\n      },\n      {\n        name: 'TLS Configuration',\n        check: this.validateTLSConfiguration\n      },\n      {\n        name: 'Authentication',\n        check: this.validateAuthentication\n      },\n      {\n        name: 'Authorization',\n        check: this.validateAuthorization\n      }\n    ];\n  }\n  \n  async validateDeployment(environment) {\n    console.log(`Validating security for \${environment} deployment...`);\n    \n    const results = {\n      environment,\n      timestamp: new Date().toISOString(),\n      checks: [],\n      passed: true\n    };\n    \n    // Run all validation checks\n    for (const validation of this.validationChecks) {\n      try {\n        const checkResult = await validation.check(environment);\n        results.checks.push({\n          name: validation.name,\n          passed: checkResult.passed,\n          details: checkResult.details\n        });\n        \n        if (!checkResult.passed) {\n          results.passed = false;\n        }\n      } catch (error) {\n        results.checks.push({\n          name: validation.name,\n          passed: false,\n          details: `Validation failed: \${error.message}`\n        });\n        results.passed = false;\n      }\n    }\n    \n    return results;\n  }\n  \n  async validateEnvironmentVariables(environment) {\n    // In a real implementation, this would check actual environment\n    // For demo, we'll simulate validation\n    const issues = [];\n    \n    // Simulate finding issues\n    if (Math.random() < 0.3) {\n      issues.push('Hardcoded secrets detected in environment configuration');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      details: issues.length === 0 ? 'Environment variables properly configured' : issues\n    };\n  }\n  \n  async validateSecurityHeaders(environment) {\n    // Simulate security header validation\n    const issues = [];\n    \n    if (Math.random() < 0.2) {\n      issues.push('Missing Content-Security-Policy header');\n    }\n    \n    if (Math.random() < 0.1) {\n      issues.push('Missing X-Frame-Options header');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      details: issues.length === 0 ? 'Security headers properly configured' : issues\n    };\n  }\n  \n  async validateTLSConfiguration(environment) {\n    // Simulate TLS configuration validation\n    const issues = [];\n    \n    if (Math.random() < 0.15) {\n      issues.push('TLS certificate expires within 30 days');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      details: issues.length === 0 ? 'TLS configuration valid' : issues\n    };\n  }\n  \n  async validateAuthentication(environment) {\n    // Simulate authentication validation\n    const issues = [];\n    \n    if (Math.random() < 0.25) {\n      issues.push('Weak password policy detected');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      details: issues.length === 0 ? 'Authentication properly configured' : issues\n    };\n  }\n  \n  async validateAuthorization(environment) {\n    // Simulate authorization validation\n    const issues = [];\n    \n    if (Math.random() < 0.2) {\n      issues.push('Overly permissive role assignments detected');\n    }\n    \n    return {\n      passed: issues.length === 0,\n      details: issues.length === 0 ? 'Authorization properly configured' : issues\n    };\n  }\n}\n\n// 4. Security Monitoring and Alerting\nclass SecurityMonitor {\n  constructor(alertingSystem) {\n    this.alertingSystem = alertingSystem;\n    this.monitors = [\n      {\n        name: 'Failed Authentication Attempts',\n        check: this.checkFailedAuthAttempts,\n        threshold: 10,\n        window: 300 // 5 minutes\n      },\n      {\n        name: 'Suspicious File Access',\n        check: this.checkSuspiciousFileAccess,\n        threshold: 5,\n        window: 300\n      },\n      {\n        name: 'High Error Rates',\n        check: this.checkHighErrorRates,\n        threshold: 50,\n        window: 300\n      }\n    ];\n  }\n  \n  async runMonitoringChecks() {\n    console.log('Running security monitoring checks...');\n    \n    const alerts = [];\n    \n    for (const monitor of this.monitors) {\n      try {\n        const result = await monitor.check(monitor.window);\n        \n        if (result.count > monitor.threshold) {\n          const alert = {\n            monitor: monitor.name,\n            count: result.count,\n            threshold: monitor.threshold,\n            timestamp: new Date().toISOString(),\n            details: result.details\n          };\n          \n          alerts.push(alert);\n          await this.alertingSystem.sendAlert(alert);\n        }\n      } catch (error) {\n        console.error(`Monitoring check failed for \${monitor.name}: \${error.message}`);\n      }\n    }\n    \n    return alerts;\n  }\n  \n  async checkFailedAuthAttempts(windowSeconds) {\n    // In a real implementation, this would query actual logs/metrics\n    // For demo, we'll simulate results\n    return {\n      count: Math.floor(Math.random() * 20),\n      details: 'Failed authentication attempts detected'\n    };\n  }\n  \n  async checkSuspiciousFileAccess(windowSeconds) {\n    // Simulate suspicious file access detection\n    return {\n      count: Math.floor(Math.random() * 10),\n      details: 'Suspicious file access patterns detected'\n    };\n  }\n  \n  async checkHighErrorRates(windowSeconds) {\n    // Simulate high error rate detection\n    return {\n      count: Math.floor(Math.random() * 100),\n      details: 'High error rates detected'\n    };\n  }\n}\n\n// 5. CI/CD Security Metrics and Reporting\nclass CICDSecurityMetrics {\n  constructor() {\n    this.pipelineRuns = [];\n  }\n  \n  recordPipelineRun(runData) {\n    this.pipelineRuns.push({\n      ...runData,\n      timestamp: new Date().toISOString()\n    });\n  }\n  \n  calculateDeploymentFrequency() {\n    if (this.pipelineRuns.length === 0) return 0;\n    \n    // Calculate deployments per day\n    const earliest = new Date(Math.min(...this.pipelineRuns.map(r => new Date(r.timestamp))));\n    const latest = new Date();\n    const days = (latest - earliest) / (1000 * 60 * 60 * 24);\n    \n    const successfulDeployments = this.pipelineRuns\n      .filter(run => run.status === 'success' && run.type === 'deployment').length;\n    \n    return successfulDeployments / days;\n  }\n  \n  calculateMeanTimeToRecovery() {\n    // Calculate average time to recover from security incidents\n    const incidents = this.pipelineRuns.filter(run => run.incident);\n    if (incidents.length === 0) return 0;\n    \n    const totalRecoveryTime = incidents.reduce((sum, incident) => \n      sum + (incident.recoveryTime || 0), 0);\n    \n    return totalRecoveryTime / incidents.length;\n  }\n  \n  calculateChangeFailPercentage() {\n    const totalChanges = this.pipelineRuns.length;\n    if (totalChanges === 0) return 0;\n    \n    const failedChanges = this.pipelineRuns\n      .filter(run => run.status === 'failed').length;\n    \n    return (failedChanges / totalChanges) * 100;\n  }\n  \n  generateSecurityReport() {\n    return {\n      deploymentFrequency: this.calculateDeploymentFrequency(),\n      meanTimeToRecovery: this.calculateMeanTimeToRecovery(),\n      changeFailPercentage: this.calculateChangeFailPercentage(),\n      totalPipelineRuns: this.pipelineRuns.length,\n      securityIncidents: this.pipelineRuns.filter(run => run.incident).length\n    };\n  }\n}\n\n// Example usage\nasync function runCICDSecurityDemo() {\n  // Run security quality gate\n  const qualityGate = new SecurityQualityGate({\n    maxCriticalVulnerabilities: 0,\n    maxHighVulnerabilities: 5\n  });\n  \n  const gateResult = await qualityGate.runSecurityGate();\n  \n  // Validate deployment security\n  const validator = new DeploymentSecurityValidator();\n  const validationResults = await validator.validateDeployment('staging');\n  console.log('Deployment validation:', JSON.stringify(validationResults, null, 2));\n  \n  // Run security monitoring\n  const mockAlertingSystem = {\n    sendAlert: async (alert) => {\n      console.log(`ALERT: \${alert.monitor} - \${alert.details}`);\n    }\n  };\n  \n  const monitor = new SecurityMonitor(mockAlertingSystem);\n  const alerts = await monitor.runMonitoringChecks();\n  console.log(`Generated \${alerts.length} security alerts`);\n  \n  // Generate metrics report\n  const metrics = new CICDSecurityMetrics();\n  metrics.recordPipelineRun({\n    type: 'deployment',\n    status: 'success',\n    duration: 300\n  });\n  \n  metrics.recordPipelineRun({\n    type: 'deployment',\n    status: 'failed',\n    duration: 150\n  });\n  \n  const report = metrics.generateSecurityReport();\n  console.log('CI/CD Security Metrics:', JSON.stringify(report, null, 2));\n  \n  return {\n    qualityGate: gateResult,\n    validation: validationResults,\n    alerts,\n    metrics: report\n  };\n}\n\n// Example Jenkins pipeline integration\n/*\npipeline {\n  agent any\n  \n  stages {\n    stage('Security Analysis') {\n      steps {\n        sh 'npm audit'\n        sh 'npx eslint . --ext .js,.ts --quiet'\n        sh 'node security-gate.js'\n      }\n    }\n    \n    stage('Build and Test') {\n      steps {\n        sh 'npm run build'\n        sh 'npm test'\n      }\n    }\n    \n    stage('Container Scan') {\n      steps {\n        sh 'docker build -t myapp:$BUILD_NUMBER .'\n        sh 'trivy image --exit-code 1 --severity HIGH,CRITICAL myapp:$BUILD_NUMBER'\n      }\n    }\n    \n    stage('Deploy to Staging') {\n      steps {\n        sh 'kubectl apply -f k8s/staging'\n        sh 'node validate-security-config.js'\n      }\n    }\n  }\n  \n  post {\n    failure {\n      script {\n        // Notify security team on pipeline failure\n        sh 'curl -X POST -d \"Pipeline failed due to security issues\" https://chat.webhook/security-alerts'\n      }\n    }\n  }\n}*/",
      "explanation": "This example demonstrates security in CI/CD including CI/CD pipeline configuration with security checks, security quality gate implementation with configurable thresholds, automated security validation for deployments, security monitoring and alerting systems, and CI/CD security metrics and reporting.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Adding too many security checks which slow down the pipeline",
        "solution": "Prioritize security checks based on risk and implement them at appropriate stages in the pipeline, using fast feedback loops for critical issues and more thorough analysis for less critical ones",
        "severity": "high"
      },
      {
        "mistake": "Not properly configuring security tools for the pipeline environment",
        "solution": "Ensure security tools are properly configured for your technology stack and pipeline environment, with appropriate baselines and thresholds to minimize false positives",
        "severity": "medium"
      },
      {
        "mistake": "Failing to monitor security in production after deployment",
        "solution": "Implement continuous security monitoring with alerting for production environments, including anomaly detection, threat hunting, and incident response procedures",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "CI/CD Security Implementation",
        "description": "Implement a comprehensive CI/CD security pipeline including security gates, deployment validation, and monitoring.",
        "checkpoints": [
          "Configure security checks in a CI/CD pipeline",
          "Implement security quality gates with configurable thresholds",
          "Set up automated deployment security validation",
          "Create security monitoring and alerting for production",
          "Establish CI/CD security metrics and reporting"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 120,
    "difficulty": "Expert",
    "tags": [
      "CI/CD",
      "DevSecOps",
      "Pipeline Security",
      "Automation"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-9",
    "moduleSlug": "security-fundamentals",
    "title": "Security Monitoring and Incident Response",
    "order": 9,
    "objectives": [
      "Implement comprehensive security monitoring solutions",
      "Configure security alerts and notification systems",
      "Establish incident response procedures and playbooks",
      "Conduct security investigations and forensics"
    ],
    "intro": "Security monitoring and incident response are critical capabilities for detecting, responding to, and recovering from security threats. Effective monitoring provides visibility into security events across your systems, while well-defined incident response procedures ensure that security incidents are handled quickly and effectively to minimize impact.\n\nIn this lesson, you'll learn how to implement comprehensive security monitoring solutions that provide visibility into authentication events, authorization failures, system anomalies, and potential security breaches. You'll explore different types of security monitoring including network monitoring, host-based monitoring, application monitoring, and user behavior analytics. You'll understand how to select appropriate monitoring tools and configure them to detect relevant security events.\n\nConfiguring security alerts and notification systems ensures that security teams are promptly notified of potential threats. You'll learn how to design alerting systems that minimize false positives while ensuring that critical security events are not missed. You'll explore techniques for alert correlation, escalation procedures, and notification channels that ensure the right people are informed at the right time.\n\nEstablishing incident response procedures and playbooks creates a structured approach to handling security incidents. You'll learn how to develop incident response plans that cover different types of security events, establish clear roles and responsibilities, and create repeatable processes for investigation, containment, eradication, and recovery. You'll also explore how to maintain and test incident response capabilities to ensure they remain effective.\n\nBy mastering security monitoring and incident response, you'll be able to detect security threats early, respond to incidents effectively, and continuously improve your security posture based on lessons learned from real-world events.",
    "code": {
      "example": "// Security Monitoring and Incident Response Implementation\n\n// 1. Security Monitoring Framework\nclass SecurityMonitoringFramework {\n  constructor() {\n    this.monitors = new Map();\n    this.alerts = [];\n    this.incidents = [];\n  }\n  \n  // Register a security monitor\n  registerMonitor(name, monitor) {\n    this.monitors.set(name, monitor);\n  }\n  \n  // Run all registered monitors\n  async runAllMonitors() {\n    console.log('Running all security monitors...');\n    \n    const results = [];\n    for (const [name, monitor] of this.monitors) {\n      try {\n        const result = await monitor.check();\n        results.push({\n          monitor: name,\n          result\n        });\n        \n        // Generate alerts for any findings\n        if (result.findings && result.findings.length > 0) {\n          for (const finding of result.findings) {\n            await this.generateAlert(name, finding);\n          }\n        }\n      } catch (error) {\n        console.error(`Monitor \${name} failed: \${error.message}`);\n        results.push({\n          monitor: name,\n          error: error.message\n        });\n      }\n    }\n    \n    return results;\n  }\n  \n  // Generate a security alert\n  async generateAlert(monitorName, finding) {\n    const alert = {\n      id: `ALERT-\${Date.now()}-\${Math.floor(Math.random() * 1000)}`,\n      monitor: monitorName,\n      severity: finding.severity || 'medium',\n      timestamp: new Date().toISOString(),\n      finding,\n      status: 'open'\n    };\n    \n    this.alerts.push(alert);\n    \n    // Notify appropriate channels\n    await this.notify(alert);\n    \n    return alert.id;\n  }\n  \n  // Notify security team about alert\n  async notify(alert) {\n    console.log(`SECURITY ALERT: \${alert.monitor} - \${alert.finding.description}`);\n    \n    // In a real implementation, this would send notifications via:\n    // - Email\n    // - Slack/Discord\n    // - SMS\n    // - Incident management systems\n    \n    // Escalate high severity alerts\n    if (alert.severity === 'critical' || alert.severity === 'high') {\n      console.log(`ESCALATING \${alert.severity} severity alert to security team`);\n    }\n  }\n  \n  // Get alerts by severity\n  getAlertsBySeverity(severity) {\n    return this.alerts.filter(alert => alert.severity === severity);\n  }\n  \n  // Get open alerts\n  getOpenAlerts() {\n    return this.alerts.filter(alert => alert.status === 'open');\n  }\n}\n\n// 2. Specific Security Monitors\n\n// Authentication Monitor\nclass AuthenticationMonitor {\n  constructor(authService, threshold = 10) {\n    this.authService = authService;\n    this.threshold = threshold; // Failed attempts threshold\n  }\n  \n  async check() {\n    // In a real implementation, this would query auth logs\n    // For demo, we'll simulate checking for brute force attempts\n    \n    // Simulate failed login attempts\n    const failedAttempts = Math.floor(Math.random() * 20);\n    \n    const findings = [];\n    if (failedAttempts > this.threshold) {\n      findings.push({\n        type: 'brute_force_attempt',\n        description: `High number of failed login attempts detected: \${failedAttempts}`,
        severity: failedAttempts > this.threshold * 2 ? 'high' : 'medium',
        details: { failedAttempts, threshold: this.threshold }
      });
    }
    
    return {
      timestamp: new Date().toISOString(),
      findings
    };
  }
}

// File Integrity Monitor
class FileIntegrityMonitor {
  constructor(filePaths = []) {
    this.filePaths = filePaths;
    this.baselineHashes = new Map();
  }
  
  // Establish baseline file hashes
  async establishBaseline() {
    const crypto = require('crypto');
    const fs = require('fs').promises;
    
    for (const filePath of this.filePaths) {
      try {
        const content = await fs.readFile(filePath);
        const hash = crypto.createHash('sha256').update(content).digest('hex');
        this.baselineHashes.set(filePath, hash);
      } catch (error) {
        console.warn(`Failed to hash \${filePath}: \${error.message}`);
      }
    }
  }
  
  async check() {
    const crypto = require('crypto');
    const fs = require('fs').promises;
    
    const findings = [];
    
    for (const [filePath, baselineHash] of this.baselineHashes) {
      try {
        const content = await fs.readFile(filePath);
        const currentHash = crypto.createHash('sha256').update(content).digest('hex');
        
        if (currentHash !== baselineHash) {
          findings.push({
            type: 'file_integrity_violation',
            description: `File integrity violation detected: \${filePath}`,
            severity: 'high',
            details: { filePath, expectedHash: baselineHash, actualHash: currentHash }
          });
        }
      } catch (error) {
        findings.push({
          type: 'file_access_error',
          description: `Cannot access monitored file: \${filePath}`,
          severity: 'medium',
          details: { filePath, error: error.message }
        });
      }
    }
    
    return {
      timestamp: new Date().toISOString(),
      findings
    };
  }
}

// 3. Incident Response System
class IncidentResponseSystem {
  constructor(notificationSystem) {
    this.notificationSystem = notificationSystem;
    this.incidents = [];
    this.playbooks = new Map();
  }
  
  // Register an incident response playbook
  registerPlaybook(incidentType, playbook) {
    this.playbooks.set(incidentType, playbook);
  }
  
  // Create a new incident
  async createIncident(alert, assignee = null) {
    const incident = {
      id: `INC-\${Date.now()}-\${Math.floor(Math.random() * 1000)}`,
      alertId: alert.id,
      type: this.classifyIncident(alert.finding.type),
      severity: alert.severity,
      status: 'investigating',
      createdAt: new Date().toISOString(),
      assignee,
      timeline: [{
        action: 'incident_created',
        timestamp: new Date().toISOString(),
        description: 'Incident created from security alert'
      }],
      evidence: [],
      actions: []
    };
    
    this.incidents.push(incident);
    
    // Notify team
    await this.notificationSystem.notifyIncident(incident);
    
    // Execute playbook if available
    const playbook = this.playbooks.get(incident.type);
    if (playbook) {
      await this.executePlaybook(incident, playbook);
    }
    
    return incident.id;
  }
  
  // Classify incident type based on alert
  classifyIncident(alertType) {
    const classifications = {
      'brute_force_attempt': 'unauthorized_access',
      'file_integrity_violation': 'tampering',
      'suspicious_network_activity': 'exfiltration',
      'malware_detection': 'malware',
      'privilege_escalation': 'privilege_abuse'
    };
    
    return classifications[alertType] || 'unknown';
  }
  
  // Execute incident response playbook
  async executePlaybook(incident, playbook) {
    console.log(`Executing playbook for \${incident.type} incident`);
    
    for (const step of playbook.steps) {
      try {
        await this.executePlaybookStep(incident, step);
      } catch (error) {
        console.error(`Playbook step failed: \${error.message}`);
        await this.logIncidentAction(incident.id, 'playbook_step_failed', error.message);
      }
    }
  }
  
  // Execute a single playbook step
  async executePlaybookStep(incident, step) {
    console.log(`Executing playbook step: \${step.name}`);
    
    // Log the action
    await this.logIncidentAction(incident.id, 'playbook_step_executed', step.name);
    
    // In a real implementation, this would execute actual response actions
    // For demo, we'll just simulate the execution
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  
  // Log an action in incident timeline
  async logIncidentAction(incidentId, action, description) {
    const incident = this.incidents.find(i => i.id === incidentId);
    if (incident) {
      incident.timeline.push({
        action,
        timestamp: new Date().toISOString(),
        description
      });
    }
  }
  
  // Add evidence to incident
  async addEvidence(incidentId, evidence) {
    const incident = this.incidents.find(i => i.id === incidentId);
    if (incident) {
      incident.evidence.push({
        ...evidence,
        timestamp: new Date().toISOString()
      });
    }
  }
  
  // Update incident status
  async updateIncidentStatus(incidentId, status) {
    const incident = this.incidents.find(i => i.id === incidentId);
    if (incident) {
      incident.status = status;
      await this.logIncidentAction(incidentId, 'status_changed', `Status changed to \${status}`);
    }
  }
}

// 4. Notification System
class SecurityNotificationSystem {
  constructor() {
    this.channels = {
      email: [],
      slack: [],
      sms: []
    };
  }
  
  // Add notification channel
  addChannel(type, config) {
    if (this.channels[type]) {
      this.channels[type].push(config);
    }
  }
  
  // Send alert notification
  async notifyAlert(alert) {
    const message = `SECURITY ALERT: \${alert.monitor} - \${alert.finding.description}`;
    
    // Send to all configured channels
    for (const [channelType, configs] of Object.entries(this.channels)) {
      for (const config of configs) {
        await this.sendToChannel(channelType, config, message, alert);
      }
    }
  }
  
  // Send incident notification
  async notifyIncident(incident) {
    const message = `SECURITY INCIDENT: \${incident.id} (\${incident.type}) - Severity: \${incident.severity}`;
    
    // Send to all configured channels
    for (const [channelType, configs] of Object.entries(this.channels)) {
      for (const config of configs) {
        await this.sendToChannel(channelType, config, message, incident);
      }
    }
  }
  
  // Send message to specific channel
  async sendToChannel(channelType, config, message, context) {
    console.log(`Sending \${channelType} notification: \${message}`);
    
    // In a real implementation, this would integrate with actual notification services
    // For demo, we'll just log the intended actions
    switch (channelType) {
      case 'email':
        console.log(`Would send email to \${config.recipients}`);
        break;
      case 'slack':
        console.log(`Would send Slack message to \${config.webhookUrl}`);
        break;
      case 'sms':
        console.log(`Would send SMS to \${config.phoneNumber}`);
        break;
    }
  }
}

// 5. Security Monitoring Playbooks
const playbooks = {
  unauthorized_access: {
    name: 'Unauthorized Access Response',
    description: 'Response procedures for unauthorized access attempts',
    steps: [
      {
        name: 'Block attacker IP',
        action: 'network.block_ip',
        description: 'Block the source IP address of the attack'
      },
      {
        name: 'Reset compromised accounts',
        action: 'auth.reset_accounts',
        description: 'Force password reset for potentially compromised accounts'
      },
      {
        name: 'Review access logs',
        action: 'forensics.review_logs',
        description: 'Review authentication logs for additional suspicious activity'
      },
      {
        name: 'Notify affected users',
        action: 'communication.notify_users',
        description: 'Notify potentially affected users of the security event'
      }
    ]
  },
  tampering: {
    name: 'System Tampering Response',
    description: 'Response procedures for system/file tampering',
    steps: [
      {
        name: 'Isolate affected systems',
        action: 'network.isolate',
        description: 'Isolate affected systems from the network'
      },
      {
        name: 'Verify system integrity',
        action: 'forensics.verify_integrity',
        description: 'Run comprehensive integrity checks on affected systems'
      },
      {
        name: 'Restore from clean backups',
        action: 'recovery.restore',
        description: 'Restore affected systems from clean backups'
      },
      {
        name: 'Implement additional monitoring',
        action: 'monitoring.enhance',
        description: 'Implement additional monitoring for affected systems'
      }
    ]
  }
};

// Example usage
async function demonstrateSecurityMonitoring() {
  // Initialize notification system
  const notificationSystem = new SecurityNotificationSystem();
  notificationSystem.addChannel('slack', { webhookUrl: 'https://hooks.slack.com/services/XXX' });
  notificationSystem.addChannel('email', { recipients: ['security-team@company.com'] });
  
  // Initialize monitoring framework
  const monitoring = new SecurityMonitoringFramework();
  
  // Register monitors
  const authMonitor = new AuthenticationMonitor(null, 5);
  const fileMonitor = new FileIntegrityMonitor(['./config.json', './app.js']);
  
  monitoring.registerMonitor('authentication', authMonitor);
  monitoring.registerMonitor('file_integrity', fileMonitor);
  
  // Run monitors
  const results = await monitoring.runAllMonitors();
  console.log('Monitoring results:', JSON.stringify(results, null, 2));
  
  // Initialize incident response system
  const incidentResponse = new IncidentResponseSystem(notificationSystem);
  
  // Register playbooks
  incidentResponse.registerPlaybook('unauthorized_access', playbooks.unauthorized_access);
  incidentResponse.registerPlaybook('tampering', playbooks.tampering);
  
  // Create sample incident if alerts were generated
  if (monitoring.alerts.length > 0) {
    const sampleAlert = monitoring.alerts[0];
    const incidentId = await incidentResponse.createIncident(sampleAlert, 'security-analyst');
    console.log(`Created incident: \${incidentId}`);
  }
  
  return {
    monitoring,
    incidentResponse,
    notificationSystem
  };
}

// Example Prometheus metrics endpoint for security monitoring
/*
const express = require('express');
const app = express();

// Security metrics storage
const securityMetrics = {
  failedLogins: 0,
  successfulLogins: 0,
  securityAlerts: 0,
  blockedRequests: 0
};

// Middleware to track security metrics
app.use('/api', (req, res, next) => {
  if (req.method === 'POST' && req.path === '/login') {
    // Track login attempts
    securityMetrics.successfulLogins++;
  }
  next();
});

// Metrics endpoint for Prometheus
app.get('/metrics', (req, res) => {
  let metrics = '';
  
  metrics += '# HELP security_failed_logins Total number of failed login attempts\n';
  metrics += '# TYPE security_failed_logins counter\n';
  metrics += `security_failed_logins \${securityMetrics.failedLogins}\n\n`;
  
  metrics += '# HELP security_successful_logins Total number of successful login attempts\n';
  metrics += '# TYPE security_successful_logins counter\n';
  metrics += `security_successful_logins \${securityMetrics.successfulLogins}\n\n`;
  
  metrics += '# HELP security_alerts Total number of security alerts\n';
  metrics += '# TYPE security_alerts counter\n';
  metrics += `security_alerts \${securityMetrics.securityAlerts}\n\n`;
  
  metrics += '# HELP security_blocked_requests Total number of blocked requests\n';
  metrics += '# TYPE security_blocked_requests counter\n';
  metrics += `security_blocked_requests \${securityMetrics.blockedRequests}\n\n`;
  
  res.set('Content-Type', 'text/plain');
  res.send(metrics);
});

app.listen(9090, () => {
  console.log('Security metrics server running on port 9090');
});
*/",
      "explanation": "This example demonstrates security monitoring and incident response including a security monitoring framework with pluggable monitors, specific security monitors for authentication and file integrity, an incident response system with playbooks, a notification system for alerts and incidents, and security monitoring playbooks for common incident types.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating too many alerts which lead to alert fatigue",
        "solution": "Implement alert correlation and prioritization to reduce noise and ensure that critical alerts are not lost in a sea of low-priority notifications",
        "severity": "high"
      },
      {
        "mistake": "Not regularly testing and updating incident response playbooks",
        "solution": "Schedule regular incident response drills and update playbooks based on lessons learned from real incidents and changes in the threat landscape",
        "severity": "medium"
      },
      {
        "mistake": "Failing to maintain adequate forensic evidence during incident response",
        "solution": "Implement proper logging and retention policies, and ensure that incident response procedures include evidence preservation steps to support investigations and potential legal proceedings",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Security Monitoring Implementation",
        "description": "Implement a comprehensive security monitoring and incident response system including monitoring framework, alerting, and incident response playbooks.",
        "checkpoints": [
          "Create a security monitoring framework with pluggable monitors",
          "Implement specific security monitors for common threats",
          "Set up alerting and notification systems",
          "Develop incident response playbooks for different threat types",
          "Test the end-to-end monitoring and response workflow"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 120,
    "difficulty": "Expert",
    "tags": [
      "Security Monitoring",
      "Incident Response",
      "SIEM",
      "Forensics"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-10",
    "moduleSlug": "security-fundamentals",
    "title": "Security Debugging and Forensic Analysis",
    "order": 10,
    "objectives": [
      "Apply advanced security debugging techniques",
      "Conduct forensic analysis of security incidents",
      "Use specialized tools for security investigation",
      "Preserve evidence and maintain chain of custody"
    ],
    "intro": "Security debugging and forensic analysis are specialized skills that enable security professionals to investigate security incidents, understand attack vectors, and gather evidence for remediation and potential legal proceedings. Unlike traditional debugging, security debugging requires understanding attacker methodologies, recognizing signs of compromise, and preserving evidence in a forensically sound manner.\n\nIn this lesson, you'll learn how to apply advanced security debugging techniques to investigate potential security incidents. You'll explore methods for analyzing authentication failures, examining network traffic for signs of malicious activity, and identifying unauthorized access attempts. You'll understand how to use debugging tools effectively while ensuring that evidence is preserved and not inadvertently altered during the investigation process.\n\nConducting forensic analysis of security incidents requires systematic approaches to evidence collection, analysis, and interpretation. You'll learn how to examine log files, analyze system artifacts, and reconstruct attack timelines. You'll explore techniques for identifying persistence mechanisms, understanding attacker tools and techniques, and determining the scope and impact of security incidents.\n\nUsing specialized tools for security investigation enhances the effectiveness and efficiency of forensic analysis. You'll learn about tools for memory analysis, network traffic inspection, file system examination, and log analysis. You'll understand how to select appropriate tools for different types of investigations and how to interpret their output correctly.\n\nBy mastering security debugging and forensic analysis, you'll be able to investigate security incidents thoroughly, gather actionable intelligence about attack methods, and contribute to improving your organization's security posture based on lessons learned from real incidents.",
    "code": {
      "example": "// Security Debugging and Forensic Analysis Implementation\n\n// 1. Security Debugging Framework\nclass SecurityDebuggingFramework {\n  constructor() {\n    this.evidence = [];\n    this.timeline = [];\n    this.findings = [];\n  }\n  \n  // Start a forensic investigation\n  startInvestigation(incidentDetails) {\n    console.log('Starting security investigation...');\n    \n    const investigation = {\n      id: `INV-\${Date.now()}-\${Math.floor(Math.random() * 1000)}`,\n      startTime: new Date().toISOString(),\n      incident: incidentDetails,\n      status: 'active'\n    };\n    \n    this.timeline.push({\n      action: 'investigation_started',\n      timestamp: investigation.startTime,\n      details: incidentDetails\n    });\n    \n    return investigation;\n  }\n  \n  // Collect evidence in a forensically sound manner\n  collectEvidence(evidenceItem) {\n    const evidence = {\n      id: `EVID-\${Date.now()}-\${Math.floor(Math.random() * 1000)}`,\n      timestamp: new Date().toISOString(),\n      ...evidenceItem,\n      hash: this.calculateHash(evidenceItem.data || evidenceItem.description)\n    };\n    \n    this.evidence.push(evidence);\n    \n    this.timeline.push({\n      action: 'evidence_collected',\n      timestamp: evidence.timestamp,\n      details: { evidenceId: evidence.id, type: evidence.type }\n    });\n    \n    return evidence.id;\n  }\n  \n  // Calculate hash for evidence integrity\n  calculateHash(data) {\n    const crypto = require('crypto');\n    return crypto.createHash('sha256').update(JSON.stringify(data)).digest('hex');\n  }\n  \n  // Add finding to investigation\n  addFinding(finding) {\n    const findingRecord = {\n      id: `FIND-\${Date.now()}-\${Math.floor(Math.random() * 1000)}`,\n      timestamp: new Date().toISOString(),\n      ...finding\n    };\n    \n    this.findings.push(findingRecord);\n    \n    this.timeline.push({\n      action: 'finding_added',\n      timestamp: findingRecord.timestamp,\n      details: { findingId: findingRecord.id, severity: findingRecord.severity }\n    });\n    \n    return findingRecord.id;\n  }\n  \n  // Generate investigation report\n  generateReport(investigation) {\n    return {\n      investigationId: investigation.id,\n      incident: investigation.incident,\n      startTime: investigation.startTime,\n      endTime: new Date().toISOString(),\n      evidence: this.evidence,\n      findings: this.findings,\n      timeline: this.timeline,\n      summary: {\n        totalEvidence: this.evidence.length,\n        totalFindings: this.findings.length,\n        criticalFindings: this.findings.filter(f => f.severity === 'critical').length\n      }\n    };\n  }\n}\n\n// 2. Log Analysis Tools\nclass LogAnalyzer {\n  constructor(logSources = []) {\n    this.logSources = logSources;\n    this.suspiciousPatterns = [\n      /failed login/i,\n      /authentication failure/i,\n      /unauthorized access/i,\n      /SQL injection/i,\n      /XSS attack/i,\n      /brute force/i,\n      /malicious file/i\n    ];\n  }\n  \n  // Analyze logs for security events\n  async analyzeLogs() {\n    console.log('Analyzing logs for security events...');\n    \n    const findings = [];\n    \n    // In a real implementation, this would read actual log files\n    // For demo, we'll simulate log analysis\n    for (const source of this.logSources) {\n      // Simulate reading log entries\n      const logEntries = this.generateSampleLogs(50);\n      \n      for (const entry of logEntries) {\n        const suspicious = this.suspiciousPatterns.some(pattern => \n          pattern.test(entry.message));\n        \n        if (suspicious) {\n          findings.push({\n            source: source,\n            timestamp: entry.timestamp,\n            message: entry.message,\n            severity: this.assessSeverity(entry.message),\n            rawEntry: entry\n          });\n        }\n      }\n    }\n    \n    return findings;\n  }\n  \n  // Generate sample log entries for demo\n  generateSampleLogs(count) {\n    const logs = [];\n    const messages = [\n      'User login successful',\n      'Failed login attempt for user admin',\n      'Authentication failure for user guest',\n      'SQL injection attempt detected',\n      'File upload successful',\n      'Suspicious file access detected',\n      'Normal system operation'\n    ];\n    \n    for (let i = 0; i < count; i++) {\n      logs.push({\n        timestamp: new Date(Date.now() - Math.random() * 86400000).toISOString(),\n        message: messages[Math.floor(Math.random() * messages.length)],\n        level: ['info', 'warn', 'error'][Math.floor(Math.random() * 3)]\n      });\n    }\n    \n    return logs;\n  }\n  \n  // Assess severity of log entry\n  assessSeverity(message) {\n    if (message.includes('SQL injection') || message.includes('Failed login')) {\n      return 'high';\n    } else if (message.includes('suspicious') || message.includes('unauthorized')) {\n      return 'medium';\n    } else {\n      return 'low';\n    }\n  }\n}\n\n// 3. Memory Analysis Tools\nclass MemoryAnalyzer {\n  constructor() {\n    this.suspiciousIndicators = [\n      'mimikatz',\n      'lsass.exe',\n      'credential',\n      'password',\n      'token',\n      'reverse shell'\n    ];\n  }\n  \n  // Analyze process memory for suspicious content\n  async analyzeProcessMemory(processId) {\n    console.log(`Analyzing memory for process \${processId}...`);\n    \n    // In a real implementation, this would use tools like Volatility\n    // For demo, we'll simulate memory analysis\n    const findings = [];\n    \n    // Simulate finding suspicious strings in memory\n    const memoryStrings = this.generateSampleMemoryStrings(100);\n    \n    for (const str of memoryStrings) {\n      const suspicious = this.suspiciousIndicators.some(indicator => \n        str.toLowerCase().includes(indicator));\n      \n      if (suspicious) {\n        findings.push({\n          type: 'suspicious_memory_content',\n          content: str,\n          severity: 'high',\n          details: `Suspicious string found in process memory: \${str}`\n        });\n      }\n    }\n    \n    return findings;\n  }\n  \n  // Generate sample memory strings for demo\n  generateSampleMemoryStrings(count) {\n    const strings = [\n      'C:\\Windows\\System32\\cmd.exe',\n      'SELECT * FROM users WHERE id=1',\n      'admin:password123',\n      'mimikatz.exe',\n      'reverse shell connection',\n      'lsass.exe memory dump',\n      'Normal application data',\n      'User session token: abc123'\n    ];\n    \n    const result = [];\n    for (let i = 0; i < count; i++) {\n      result.push(strings[Math.floor(Math.random() * strings.length)]);\n    }\n    \n    return result;\n  }\n}\n\n// 4. Network Traffic Analysis\nclass NetworkAnalyzer {\n  constructor() {\n    this.suspiciousPatterns = [\n      { pattern: /\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b.*:\d{4,5}/, description: 'Suspicious outbound connection' },\n      { pattern: /POST.*\.php.*\b(?:union|select|insert|delete)\b/i, description: 'SQL injection attempt' },\n      { pattern: /<script.*>[^<]*<\/script>/i, description: 'XSS attempt' }\n    ];\n  }\n  \n  // Analyze network traffic captures\n  async analyzeTraffic(pcapFile) {\n    console.log(`Analyzing network traffic from \${pcapFile}...`);\n    \n    // In a real implementation, this would use tools like Wireshark/tshark\n    // For demo, we'll simulate traffic analysis\n    const findings = [];\n    \n    // Simulate analyzing packets\n    const packets = this.generateSamplePackets(50);\n    \n    for (const packet of packets) {\n      for (const { pattern, description } of this.suspiciousPatterns) {\n        if (pattern.test(packet.content)) {\n          findings.push({\n            type: 'suspicious_traffic',\n            description: description,\n            packet: packet,\n            severity: 'high'\n          });\n        }\n      }\n    }\n    \n    return findings;\n  }\n  \n  // Generate sample packets for demo\n  generateSamplePackets(count) {\n    const packets = [];\n    const contents = [\n      'GET /index.html HTTP/1.1',\n      'POST /login.php HTTP/1.1\nContent-Type: application/x-www-form-urlencoded\n\nusername=admin&password=test123',\n      'GET /admin.php?param=1 UNION SELECT * FROM users HTTP/1.1',\n      'POST /upload.php HTTP/1.1\nContent-Type: multipart/form-data\n\nfile content here',\n      '<script>alert(\"XSS\")</script>'\n    ];\n    \n    for (let i = 0; i < count; i++) {\n      packets.push({\n        id: Math.floor(Math.random() * 10000),\n        timestamp: new Date(Date.now() - Math.random() * 3600000).toISOString(),\n        source: `192.168.1.\${Math.floor(Math.random() * 255)}`,\n        destination: `10.0.0.\${Math.floor(Math.random() * 255)}`,\n        content: contents[Math.floor(Math.random() * contents.length)]\n      });\n    }\n    \n    return packets;\n  }\n}\n\n// 5. File System Analysis\nclass FileSystemAnalyzer {\n  constructor(suspiciousPaths = []) {\n    this.suspiciousPaths = suspiciousPaths;\n    this.suspiciousExtensions = ['.exe', '.dll', '.scr', '.bat', '.cmd', '.ps1'];\n    this.tempDirectories = ['/tmp', '/var/tmp', 'C:\\Windows\\Temp'];\n  }\n  \n  // Analyze file system for suspicious files\n  async analyzeFileSystem() {\n    console.log('Analyzing file system for suspicious files...');\n    \n    // In a real implementation, this would scan actual file systems\n    // For demo, we'll simulate file system analysis\n    const findings = [];\n    \n    // Simulate scanning directories\n    for (const path of this.suspiciousPaths) {\n      const files = this.generateSampleFiles(20);\n      \n      for (const file of files) {\n        // Check for suspicious extensions\n        const hasSuspiciousExt = this.suspiciousExtensions.some(ext => \n          file.name.toLowerCase().endsWith(ext));\n        \n        // Check for suspicious locations\n        const inTempDir = this.tempDirectories.some(dir => \n          path.includes(dir));\n        \n        if (hasSuspiciousExt || inTempDir) {\n          findings.push({\n            type: 'suspicious_file',\n            file: file,\n            path: path,\n            severity: hasSuspiciousExt ? 'high' : 'medium',\n            details: `Suspicious file found: \${file.name}`\n          });\n        }\n      }\n    }\n    \n    return findings;\n  }\n  \n  // Generate sample files for demo\n  generateSampleFiles(count) {\n    const files = [];\n    const names = [\n      'document.pdf',\n      'image.jpg',\n      'malware.exe',\n      'script.ps1',\n      'backup.bat',\n      'normal.txt'\n    ];\n    \n    for (let i = 0; i < count; i++) {\n      files.push({\n        name: names[Math.floor(Math.random() * names.length)],\n        size: Math.floor(Math.random() * 1000000),\n        modified: new Date(Date.now() - Math.random() * 86400000).toISOString(),\n        permissions: 'rw-r--r--'\n      });\n    }\n    \n    return files;\n  }\n}\n\n// Example usage\nasync function demonstrateSecurityDebugging() {\n  // Initialize debugging framework\n  const debuggerFramework = new SecurityDebuggingFramework();\n  \n  // Start investigation\n  const investigation = debuggerFramework.startInvestigation({\n    type: 'unauthorized_access',\n    description: 'Multiple failed login attempts detected',\n    affectedSystem: 'web-server-01'\n  });\n  \n  // Collect evidence\n  debuggerFramework.collectEvidence({\n    type: 'log_file',\n    source: '/var/log/auth.log',\n    description: 'Authentication log showing failed login attempts',\n    data: '2023-01-01 12:00:00 - Failed login for user admin from 192.168.1.100'\n  });\n  \n  debuggerFramework.collectEvidence({\n    type: 'network_capture',\n    source: '/captures/attack.pcap',\n    description: 'Network capture during attack window'\n  });\n  \n  // Analyze logs\n  const logAnalyzer = new LogAnalyzer(['/var/log/auth.log', '/var/log/app.log']);\n  const logFindings = await logAnalyzer.analyzeLogs();\n  \n  for (const finding of logFindings) {\n    debuggerFramework.addFinding({\n      type: 'log_analysis',\n      severity: finding.severity,\n      details: finding.message,\n      source: finding.source\n    });\n  }\n  \n  // Analyze memory\n  const memoryAnalyzer = new MemoryAnalyzer();\n  const memoryFindings = await memoryAnalyzer.analyzeProcessMemory(1234);\n  \n  for (const finding of memoryFindings) {\n    debuggerFramework.addFinding({\n      type: 'memory_analysis',\n      severity: finding.severity,\n      details: finding.details\n    });\n  }\n  \n  // Analyze network traffic\n  const networkAnalyzer = new NetworkAnalyzer();\n  const networkFindings = await networkAnalyzer.analyzeTraffic('attack.pcap');\n  \n  for (const finding of networkFindings) {\n    debuggerFramework.addFinding({\n      type: 'network_analysis',\n      severity: finding.severity,\n      details: finding.description\n    });\n  }\n  \n  // Generate report\n  const report = debuggerFramework.generateReport(investigation);\n  console.log('Investigation Report:', JSON.stringify(report, null, 2));\n  \n  return {\n    debuggerFramework,\n    investigation,\n    report\n  };\n}\n\n// Example debug configuration for Node.js security debugging\n/*\n{\n  \"name\": \"Security Debugging\",\n  \"type\": \"node\",\n  \"request\": \"launch\",\n  \"program\": \"\${workspaceFolder}/app.js\",\n  \"env\": {\n    \"DEBUG\": \"security*,auth*,crypto*\",\n    \"NODE_OPTIONS\": \"--inspect=0.0.0.0:9229\"\n  },\n  \"console\": \"integratedTerminal\",\n  \"internalConsoleOptions\": \"neverOpen\",\n  \"skipFiles\": [\n    \"<node_internals>/**\"\n  ]\n}*/\n\n// Example debug logging for security events\n/*\nconst winston = require('winston');\nconst { format, transports } = winston;\n\nconst securityLogger = winston.createLogger({\n  level: 'info',\n  format: format.combine(\n    format.timestamp(),\n    format.errors({ stack: true }),\n    format.json()\n  ),\n  defaultMeta: { service: 'security-service' },\n  transports: [\n    new transports.File({\n      filename: 'security-info.log',\n      level: 'info'\n    }),\n    new transports.File({\n      filename: 'security-warn.log',\n      level: 'warn'\n    }),\n    new transports.File({\n      filename: 'security-error.log',\n      level: 'error'\n    }),\n    new transports.File({\n      filename: 'security-combined.log'\n    })\n  ]\n});\n\n// Security event logging examples\nsecurityLogger.info('User authentication successful', {\n  userId: 'user123',\n  ip: '192.168.1.100',\n  userAgent: 'Mozilla/5.0...'\n});\n\nsecurityLogger.warn('Failed login attempt', {\n  username: 'admin',\n  ip: '192.168.1.101',\n  attempts: 3\n});\n\nsecurityLogger.error('Security violation detected', {\n  type: 'SQL injection',\n  payload: 'UNION SELECT *',\n  ip: '192.168.1.102'\n});*/", "explanation": "This example demonstrates security debugging and forensic analysis including a security debugging framework for evidence collection, log analysis tools for detecting security events, memory analysis tools for finding suspicious content, network traffic analysis for identifying malicious activity, and file system analysis for detecting suspicious files.", "language": "javascript" }, "pitfalls": [ { "mistake": "Altering evidence during the debugging process", "solution": "Use read-only analysis techniques and create bit-for-bit copies of evidence before analysis to maintain forensic integrity", "severity": "high" }, { "mistake": "Not documenting analysis steps and findings properly", "solution": "Maintain detailed logs of all analysis activities, use standardized reporting templates, and ensure chain of custody documentation for all evidence", "severity": "medium" }, { "mistake": "Focusing only on obvious signs of compromise", "solution": "Use systematic analysis approaches that examine multiple data sources and look for subtle indicators of compromise that might be missed with cursory examination", "severity": "high" } ], "exercises": [ { "title": "Security Debugging Implementation", "description": "Implement a comprehensive security debugging and forensic analysis system including evidence collection, log analysis, and reporting capabilities.", "checkpoints": [ "Create a security debugging framework for evidence collection", "Implement log analysis tools for security event detection", "Set up memory analysis capabilities for suspicious content", "Develop network traffic analysis for malicious activity", "Generate comprehensive forensic analysis reports" ] } ], "next": [], "estimatedMinutes": 120, "difficulty": "Expert", "tags": [ "Security Debugging", "Forensics", "Incident Analysis", "Evidence Collection" ], "lastUpdated": "2025-10-03T15:30:00.000Z", "version": "1.1.0" },
  {
    "id": "security-fundamentals-lesson-11",
    "moduleSlug": "security-fundamentals",
    "title": "Security Architecture Optimization",
    "order": 11,
    "objectives": [
      "Optimize security architectures for performance and scalability",
      "Implement efficient cryptographic operations",
      "Design scalable authentication and authorization systems",
      "Balance security controls with system performance"
    ],
    "intro": "Security architecture optimization involves designing and implementing security controls that provide robust protection while maintaining system performance and scalability. Well-optimized security architectures can handle increasing loads without compromising security effectiveness, while poorly optimized architectures can become bottlenecks that impact user experience and system reliability.\n\nIn this lesson, you'll learn how to optimize security architectures for performance and scalability. You'll explore techniques for designing security systems that can grow with your organization's needs, including horizontal scaling strategies, caching mechanisms, and load distribution patterns. You'll understand how to architect security controls to minimize performance impact while maintaining strong protection.\n\nImplementing efficient cryptographic operations is critical for maintaining both security and performance. You'll learn about cryptographic algorithm selection, key management optimization, and implementation techniques that reduce computational overhead. You'll explore how to balance security strength with performance requirements and understand when to use hardware acceleration for cryptographic operations.\n\nDesigning scalable authentication and authorization systems ensures that security controls can handle growing user bases and increasing transaction volumes. You'll learn about token-based authentication patterns, session management strategies, and access control implementations that scale effectively. You'll explore distributed authentication architectures and federation patterns that maintain security while supporting growth.\n\nBy mastering security architecture optimization, you'll be able to design and implement security systems that provide strong protection without sacrificing performance, scale effectively to meet growing demands, and maintain consistent security posture across all system components.",
    "code": {
      "example": "// Security Architecture Optimization Implementation\n\n// 1. Scalable Authentication System\nclass ScalableAuthSystem {\n  constructor(redisClient, jwtSecret, cacheTtl = 3600) {\n    this.redis = redisClient;\n    this.jwtSecret = jwtSecret;\n    this.cacheTtl = cacheTtl;\n    this.rateLimiter = new DistributedRateLimiter(redisClient);\n  }\n  \n  // Generate JWT token with caching\n  async generateToken(user, permissions) {\n    const payload = {\n      userId: user.id,\n      email: user.email,\n      permissions,\n      issuedAt: Math.floor(Date.now() / 1000)\n    };\n    \n    // Cache user permissions to avoid DB lookups\n    const cacheKey = `user_perms:\${user.id}`;\n    await this.redis.setex(cacheKey, this.cacheTtl, JSON.stringify(permissions));\n    \n    // Generate JWT token\n    const jwt = require('jsonwebtoken');\n    return jwt.sign(payload, this.jwtSecret, {\n      expiresIn: '1h',\n      issuer: 'secure-app'\n    });\n  }\n  \n  // Validate token with caching\n  async validateToken(token) {\n    const jwt = require('jsonwebtoken');\n    \n    try {\n      const decoded = jwt.verify(token, this.jwtSecret, {\n        issuer: 'secure-app'\n      });\n      \n      // Check if permissions are cached\n      const cacheKey = `user_perms:\${decoded.userId}`;\n      const cachedPerms = await this.redis.get(cacheKey);\n      \n      if (cachedPerms) {\n        decoded.permissions = JSON.parse(cachedPerms);\n      }\n      \n      return decoded;\n    } catch (error) {\n      throw new Error('Invalid token');\n    }\n  }\n  \n  // Distributed rate limiting\n  async checkRateLimit(identifier, maxRequests = 100, windowSeconds = 60) {\n    return await this.rateLimiter.isAllowed(identifier, maxRequests, windowSeconds);\n  }\n}\n\n// Distributed Rate Limiter\nclass DistributedRateLimiter {\n  constructor(redisClient) {\n    this.redis = redisClient;\n  }\n  \n  async isAllowed(identifier, maxRequests = 100, windowSeconds = 60) {\n    const key = `rate_limit:\${identifier}`;\n    const now = Math.floor(Date.now() / 1000);\n    const windowStart = now - windowSeconds;\n    \n    // Use Redis pipeline for atomic operations\n    const pipeline = this.redis.multi();\n    \n    // Remove expired entries\n    pipeline.zremrangebyscore(key, 0, windowStart);\n    \n    // Add current request\n    pipeline.zadd(key, now, `\${now}-\${Math.random()}`);\n    \n    // Set expiration\n    pipeline.expire(key, windowSeconds);\n    \n    // Get count\n    pipeline.zcard(key);\n    \n    const results = await pipeline.exec();\n    const requestCount = results[3][1]; // Result of zcard\n    \n    return {\n      allowed: requestCount <= maxRequests,\n      count: requestCount,\n      remaining: Math.max(0, maxRequests - requestCount)\n    };\n  }\n}\n\n// 2. Efficient Cryptographic Operations\nclass CryptoOptimizer {\n  constructor() {\n    this.bcryptRounds = 12;\n    this.cache = new Map();\n  }\n  \n  // Benchmark bcrypt cost factors\n  async benchmarkBcryptCost(password, minCost = 10, maxCost = 14) {\n    const bcrypt = require('bcrypt');\n    const results = [];\n    \n    for (let cost = minCost; cost <= maxCost; cost++) {\n      const startTime = process.hrtime.bigint();\n      await bcrypt.hash(password, cost);\n      const endTime = process.hrtime.bigint();\n      \n      const durationMs = Number(endTime - startTime) / 1000000;\n      results.push({\n        cost,\n        durationMs,\n        recommendation: durationMs < 100 ? 'Acceptable' : \n                       durationMs < 250 ? 'Consider optimization' : 'Too slow for interactive use'\n      });\n    }\n    \n    return results;\n  }\n  \n  // Optimized password hashing with caching\n  async hashPassword(password, userId) {\n    const bcrypt = require('bcrypt');\n    \n    // Check cache first\n    const cacheKey = `pw_hash:\${userId}`;\n    if (this.cache.has(cacheKey)) {\n      return this.cache.get(cacheKey);\n    }\n    \n    // Hash password\n    const hash = await bcrypt.hash(password, this.bcryptRounds);\n    \n    // Cache result\n    this.cache.set(cacheKey, hash);\n    \n    // Set cache expiration\n    setTimeout(() => {\n      this.cache.delete(cacheKey);\n    }, 300000); // 5 minutes\n    \n    return hash;\n  }\n  \n  // Optimized password verification\n  async verifyPassword(password, hash, userId) {\n    const bcrypt = require('bcrypt');\n    \n    // Use cached hash if available\n    const cacheKey = `pw_hash:\${userId}`;\n    const cachedHash = this.cache.get(cacheKey);\n    \n    if (cachedHash && cachedHash === hash) {\n      // For demo, we'll still verify but in practice you might optimize further\n      return await bcrypt.compare(password, hash);\n    }\n    \n    const isValid = await bcrypt.compare(password, hash);\n    \n    // Cache successful verifications\n    if (isValid) {\n      this.cache.set(cacheKey, hash);\n      setTimeout(() => {\n        this.cache.delete(cacheKey);\n      }, 300000); // 5 minutes\n    }\n    \n    return isValid;\n  }\n  \n  // Hardware-accelerated encryption (conceptual)\n  async hardwareEncrypt(data, key) {\n    // In a real implementation, this would interface with HSM or crypto accelerator\n    // For demo, we'll use standard Node.js crypto but show the pattern\n    \n    const crypto = require('crypto');\n    const algorithm = 'aes-256-gcm';\n    const iv = crypto.randomBytes(16);\n    \n    const cipher = crypto.createCipher(algorithm, key);\n    let encrypted = cipher.update(data, 'utf8', 'hex');\n    encrypted += cipher.final('hex');\n    \n    const authTag = cipher.getAuthTag();\n    \n    return {\n      encryptedData: encrypted,\n      iv: iv.toString('hex'),\n      authTag: authTag.toString('hex')\n    };\n  }\n}\n\n// 3. Scalable Access Control\nclass ScalableAccessControl {\n  constructor(redisClient, db) {\n    this.redis = redisClient;\n    this.db = db;\n    this.cacheTtl = 300; // 5 minutes\n  }\n  \n  // Check permissions with caching\n  async hasPermission(userId, resource, action) {\n    const cacheKey = `perm:\${userId}:\${resource}:\${action}`;\n    \n    // Try cache first\n    const cachedResult = await this.redis.get(cacheKey);\n    if (cachedResult !== null) {\n      return cachedResult === 'true';\n    }\n    \n    // Check database if not in cache\n    const hasPermission = await this.db.checkPermission(userId, resource, action);\n    \n    // Cache result\n    await this.redis.setex(\n      cacheKey, \n      this.cacheTtl, \n      hasPermission ? 'true' : 'false'\n    );\n    \n    return hasPermission;\n  }\n  \n  // Batch permission check for efficiency\n  async checkPermissionsBatch(userId, permissions) {\n    const results = {};\n    const uncached = [];\n    \n    // Check cache for each permission\n    for (const { resource, action } of permissions) {\n      const cacheKey = `perm:\${userId}:\${resource}:\${action}`;\n      const cachedResult = await this.redis.get(cacheKey);\n      \n      if (cachedResult !== null) {\n        results[\`\${resource}:\${action}\`] = cachedResult === 'true';\n      } else {\n        uncached.push({ resource, action });\n      }\n    }\n    \n    // Check uncached permissions in batch\n    if (uncached.length > 0) {\n      const dbResults = await this.db.checkPermissionsBatch(userId, uncached);\n      \n      // Cache results and add to return object\n      for (const [key, hasPermission] of Object.entries(dbResults)) {\n        results[key] = hasPermission;\n        \n        const [resource, action] = key.split(':');\n        const cacheKey = `perm:\${userId}:\${resource}:\${action}`;\n        await this.redis.setex(\n          cacheKey, \n          this.cacheTtl, \n          hasPermission ? 'true' : 'false'\n        );\n      }\n    }\n    \n    return results;\n  }\n  \n  // Invalidate cache when permissions change\n  async invalidateUserPermissions(userId) {\n    const pattern = `perm:\${userId}:*`;
    const keys = await this.redis.keys(pattern);
    if (keys.length > 0) {
      await this.redis.del(...keys);
    }
  }
}

// 4. Security Performance Monitoring
class SecurityPerformanceMonitor {
  constructor() {
    this.metrics = {
      authLatency: [],
      cryptoLatency: [],
      permissionChecks: [],
      rateLimitHits: 0
    };
  }
  
  // Record authentication latency
  recordAuthLatency(durationMs) {
    this.metrics.authLatency.push(durationMs);
    this.trimMetrics(this.metrics.authLatency);
  }
  
  // Record cryptographic operation latency
  recordCryptoLatency(durationMs) {
    this.metrics.cryptoLatency.push(durationMs);
    this.trimMetrics(this.metrics.cryptoLatency);
  }
  
  // Record permission check latency
  recordPermissionCheck(durationMs) {
    this.metrics.permissionChecks.push(durationMs);
    this.trimMetrics(this.metrics.permissionChecks);
  }
  
  // Record rate limit hit
  recordRateLimitHit() {
    this.metrics.rateLimitHits++;
  }
  
  // Trim metrics arrays to prevent memory issues
  trimMetrics(array) {
    if (array.length > 1000) {
      array.splice(0, array.length - 1000);
    }
  }
  
  // Get performance statistics
  getStats() {
    return {
      authLatency: this.calculateStats(this.metrics.authLatency),
      cryptoLatency: this.calculateStats(this.metrics.cryptoLatency),
      permissionChecks: this.calculateStats(this.metrics.permissionChecks),
      rateLimitHits: this.metrics.rateLimitHits
    };
  }
  
  // Calculate statistics for metric array
  calculateStats(array) {
    if (array.length === 0) return { count: 0 };
    
    const sorted = [...array].sort((a, b) => a - b);
    const sum = array.reduce((a, b) => a + b, 0);
    const avg = sum / array.length;
    
    return {
      count: array.length,
      avg: Math.round(avg * 100) / 100,
      min: sorted[0],
      max: sorted[sorted.length - 1],
      p50: sorted[Math.floor(sorted.length * 0.5)],
      p95: sorted[Math.floor(sorted.length * 0.95)],
      p99: sorted[Math.floor(sorted.length * 0.99)]
    };
  }
}

// Example usage
async function demonstrateSecurityOptimization() {
  // Mock Redis client
  const mockRedis = {
    setex: async (key, ttl, value) => console.log(`SET \${key} with TTL \${ttl}`),
    get: async (key) => null,
    keys: async (pattern) => [],
    del: async (...keys) => console.log(`DEL \${keys.join(', ')}`),
    multi: () => ({
      zremrangebyscore: () => this,
      zadd: () => this,
      expire: () => this,
      zcard: () => this,
      exec: async () => [[null, 1], [null, 1], [null, 1], [null, 5]]
    })
  };
  
  // Initialize components
  const authSystem = new ScalableAuthSystem(mockRedis, 'secret-key');
  const cryptoOptimizer = new CryptoOptimizer();
  const accessControl = new ScalableAccessControl(mockRedis, {});
  const perfMonitor = new SecurityPerformanceMonitor();
  
  // Benchmark bcrypt costs
  const bcryptResults = await cryptoOptimizer.benchmarkBcryptCost('testpassword');
  console.log('Bcrypt benchmark results:', bcryptResults);
  
  // Check rate limit
  const rateLimit = await authSystem.checkRateLimit('user123');
  console.log('Rate limit check:', rateLimit);
  
  // Batch permission check
  const permissions = [
    { resource: 'users', action: 'read' },
    { resource: 'users', action: 'write' },
    { resource: 'admin', action: 'access' }
  ];
  
  const permissionResults = await accessControl.checkPermissionsBatch('user123', permissions);
  console.log('Permission check results:', permissionResults);
  
  // Record some metrics
  perfMonitor.recordAuthLatency(45);
  perfMonitor.recordCryptoLatency(120);
  perfMonitor.recordPermissionCheck(12);
  
  const stats = perfMonitor.getStats();
  console.log('Performance stats:', JSON.stringify(stats, null, 2));
  
  return {
    authSystem,
    cryptoOptimizer,
    accessControl,
    perfMonitor
  };
}

// Example load testing configuration
/*
const autocannon = require('autocannon');

async function loadTestSecurityEndpoints() {
  const authTest = await autocannon({
    url: 'http://localhost:3000/api/login',
    connections: 100,
    duration: 30,
    requests: [
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          email: 'test@example.com',
          password: 'password123'
        })
      }
    ]
  });
  
  console.log('Authentication Load Test Results:');
  console.log(`Requests per second: \${authTest.requests.average}`);
  console.log(`Latency (ms): \${authTest.latency.average}`);
  
  return authTest;
}*/",
      "explanation": "This example demonstrates security architecture optimization including a scalable authentication system with caching and rate limiting, efficient cryptographic operations with benchmarking and caching, scalable access control with batch permission checking, and security performance monitoring for measuring optimization effectiveness.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Over-caching security data leading to stale permissions",
        "solution": "Implement appropriate cache invalidation strategies and use short cache TTLs for critical security data to balance performance with security accuracy",
        "severity": "high"
      },
      {
        "mistake": "Choosing cryptographic algorithms based solely on security without considering performance",
        "solution": "Benchmark different cryptographic algorithms and parameters for your specific use cases, and consider hardware acceleration options for computationally intensive operations",
        "severity": "medium"
      },
      {
        "mistake": "Not monitoring security performance metrics in production",
        "solution": "Implement comprehensive security performance monitoring with alerts for degradation, and regularly review metrics to identify optimization opportunities",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Security Architecture Optimization",
        "description": "Implement a comprehensive security architecture optimization solution including scalable authentication, efficient cryptography, and performance monitoring.",
        "checkpoints": [
          "Create a scalable authentication system with caching and rate limiting",
          "Implement efficient cryptographic operations with benchmarking",
          "Design scalable access control with batch permission checking",
          "Set up security performance monitoring and metrics collection",
          "Test the optimized system under load conditions"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 120,
    "difficulty": "Expert",
    "tags": [
      "Security Architecture",
      "Performance Optimization",
      "Scalability",
      "Cryptography"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-12",
    "moduleSlug": "security-fundamentals",
    "title": "Zero Trust Security Architecture",
    "order": 12,
    "objectives": [
      "Understand Zero Trust security principles and implementation",
      "Implement continuous verification and least privilege access",
      "Design secure network segmentation and micro-perimeters",
      "Apply Zero Trust to cloud and hybrid environments"
    ],
    "intro": "Zero Trust security architecture represents a fundamental shift from traditional perimeter-based security models to a model where no user or device is trusted by default, regardless of their location inside or outside the network perimeter. This approach assumes that breaches are inevitable and focuses on minimizing the impact of potential compromises through continuous verification and strict access controls.\n\nIn this lesson, you'll learn the core principles of Zero Trust security including continuous verification, least privilege access, and micro-perimeters. You'll understand how these principles differ from traditional security models and why they're essential in today's threat landscape where perimeter defenses are increasingly ineffective against sophisticated attacks.\n\nImplementing continuous verification and least privilege access requires rethinking how authentication and authorization work in your systems. You'll explore techniques for implementing just-in-time access, adaptive authentication based on risk factors, and dynamic access controls that adjust based on user behavior and context.\n\nDesigning secure network segmentation and micro-perimeters involves breaking down monolithic network architectures into smaller, isolated segments that limit lateral movement by attackers. You'll learn about software-defined perimeters, network micro-segmentation, and how to implement secure communication between micro-perimeters using encryption and mutual authentication.\n\nBy mastering Zero Trust security architecture, you'll be able to design and implement security systems that are resilient to both external and internal threats, reduce the attack surface of your applications, and maintain strong security controls even when parts of your infrastructure are compromised.",
    "code": {
      "example": "// Zero Trust Security Architecture Implementation\n\n// 1. Continuous Verification Service\nclass ContinuousVerificationService {\n  constructor(authService, riskEngine, sessionManager) {\n    this.authService = authService;\n    this.riskEngine = riskEngine;\n    this.sessionManager = sessionManager;\n  }\n  \n  // Verify user context and risk level\n  async verifyContext(userId, context) {\n    // Get current session\n    const session = await this.sessionManager.getSession(userId);\n    \n    // Assess risk based on context changes\n    const riskScore = await this.riskEngine.assessRisk({\n      userId,\n      previousContext: session.context,\n      currentContext: context,\n      timeSinceLastAuth: Date.now() - session.lastAuthTime\n    });\n    \n    // Determine if re-authentication is needed\n    if (riskScore > 0.7) {\n      return {\n        action: 'reauthenticate',\n        reason: 'High risk detected',\n        requiredFactors: ['password', 'mfa']\n      };\n    } else if (riskScore > 0.4) {\n      return {\n        action: 'step_up_auth',\n        reason: 'Moderate risk detected',\n        requiredFactors: ['mfa']\n      };\n    } else {\n      return {\n        action: 'continue',\n        reason: 'Risk level acceptable'\n      };\n    }\n  }\n  \n  // Validate session continuously\n  async validateSession(sessionId) {\n    const session = await this.sessionManager.getSessionById(sessionId);\n    \n    if (!session) {\n      throw new Error('Invalid session');\n    }\n    \n    // Check session age\n    if (Date.now() - session.createdAt > session.maxAge) {\n      await this.sessionManager.destroySession(sessionId);\n      throw new Error('Session expired');\n    }\n    \n    // Reassess risk periodically\n    if (Date.now() - session.lastRiskCheck > 300000) { // 5 minutes\n      const riskResult = await this.verifyContext(session.userId, session.context);\n      session.lastRiskCheck = Date.now();\n      \n      if (riskResult.action !== 'continue') {\n        session.needsReauth = true;\n      }\n      \n      await this.sessionManager.updateSession(sessionId, session);\n    }\n    \n    return session;\n  }\n}\n\n// 2. Least Privilege Access Manager\nclass LeastPrivilegeAccessManager {\n  constructor(permissionStore, auditLogger) {\n    this.permissionStore = permissionStore;\n    this.auditLogger = auditLogger;\n  }\n  \n  // Grant just-in-time access\n  async grantJITAccess(userId, resource, action, duration = 3600000) { // 1 hour default\n    // Validate user exists and is authorized to request access\n    const user = await this.getUser(userId);\n    if (!user) {\n      throw new Error('User not found');\n    }\n    \n    // Check if user already has this access\n    const existingAccess = await this.permissionStore.hasPermission(userId, resource, action);\n    if (existingAccess) {\n      return {\n        status: 'already_granted',\n        expiresAt: existingAccess.expiresAt\n      };\n    }\n    \n    // Check if user is authorized to request this access\n    const canRequest = await this.canRequestAccess(userId, resource, action);\n    if (!canRequest) {\n      throw new Error('User not authorized to request this access');\n    }\n    \n    // Grant temporary access\n    const accessId = await this.permissionStore.grantPermission(userId, resource, action, {\n      expiresAt: Date.now() + duration,\n      grantedBy: 'jit_system',\n      reason: 'Just-in-time access request'\n    });\n    \n    // Log access grant\n    await this.auditLogger.log({\n      event: 'access_granted',\n      userId,\n      resource,\n      action,\n      accessId,\n      duration,\n      timestamp: new Date().toISOString()\n    });\n    \n    return {\n      status: 'granted',\n      accessId,\n      expiresAt: Date.now() + duration\n    };\n  }\n  \n  // Validate access based on least privilege principles\n  async validateAccess(userId, resource, action) {\n    // Check if user has explicit permission\n    const hasPermission = await this.permissionStore.hasPermission(userId, resource, action);\n    if (!hasPermission) {\n      return false;\n    }\n    \n    // Check if permission is still valid\n    if (hasPermission.expiresAt && Date.now() > hasPermission.expiresAt) {\n      // Revoke expired permission\n      await this.permissionStore.revokePermission(userId, resource, action);\n      await this.auditLogger.log({\n        event: 'access_expired',\n        userId,\n        resource,\n        action,\n        permissionId: hasPermission.id,\n        timestamp: new Date().toISOString()\n      });\n      return false;\n    }\n    \n    return true;\n  }\n  \n  // Revoke access\n  async revokeAccess(userId, resource, action) {\n    await this.permissionStore.revokePermission(userId, resource, action);\n    \n    await this.auditLogger.log({\n      event: 'access_revoked',\n      userId,\n      resource,\n      action,\n      timestamp: new Date().toISOString()\n    });\n  }\n}\n\n// 3. Micro-Perimeter Security\nclass MicroPerimeterSecurity {\n  constructor(tlsManager, authzService, metricsCollector) {\n    this.tlsManager = tlsManager;\n    this.authzService = authzService;\n    this.metricsCollector = metricsCollector;\n  }\n  \n  // Secure service-to-service communication\n  async secureServiceCall(callerService, targetService, payload) {\n    // Verify caller identity\n    const callerCert = await this.tlsManager.verifyServiceCertificate(callerService);\n    if (!callerCert) {\n      throw new Error('Invalid caller certificate');\n    }\n    \n    // Check authorization\n    const isAuthorized = await this.authzService.isServiceAuthorized(callerService, targetService, 'call');\n    if (!isAuthorized) {\n      throw new Error('Service not authorized to call target');\n    }\n    \n    // Encrypt payload with target's public key\n    const encryptedPayload = await this.tlsManager.encryptForService(payload, targetService);\n    \n    // Make secure call\n    const response = await this.makeSecureCall(targetService, encryptedPayload, callerService);\n    \n    // Log metrics\n    await this.metricsCollector.recordSecureCall({\n      caller: callerService,\n      target: targetService,\n      timestamp: new Date().toISOString(),\n      success: true\n    });\n    \n    return response;\n  }\n  \n  // Validate micro-perimeter boundaries\n  async validatePerimeter(service, context) {\n    // Check if service is running in approved environment\n    const isApprovedEnv = await this.tlsManager.validateServiceEnvironment(service, context);\n    if (!isApprovedEnv) {\n      throw new Error('Service running in unapproved environment');\n    }\n    \n    // Verify service integrity\n    const isIntact = await this.tlsManager.verifyServiceIntegrity(service);\n    if (!isIntact) {\n      throw new Error('Service integrity check failed');\n    }\n    \n    // Check network isolation\n    const isIsolated = await this.validateNetworkIsolation(service);\n    if (!isIsolated) {\n      throw new Error('Service not properly isolated');\n    }\n    \n    return true;\n  }\n  \n  // Validate network isolation\n  async validateNetworkIsolation(service) {\n    // This would integrate with network policies and SDN\n    // For demo, we'll simulate validation\n    return Math.random() > 0.1; // 90% chance of being properly isolated\n  }\n}\n\n// 4. Zero Trust Policy Engine\nclass ZeroTrustPolicyEngine {\n  constructor(policyStore, complianceChecker) {\n    this.policyStore = policyStore;\n    this.complianceChecker = complianceChecker;\n  }\n  \n  // Evaluate access request against Zero Trust policies\n  async evaluateAccessRequest(request) {\n    // Get applicable policies\n    const policies = await this.policyStore.getApplicablePolicies(request);\n    \n    // Evaluate each policy\n    const results = [];
    for (const policy of policies) {
      const result = await this.evaluatePolicy(policy, request);
      results.push({
        policy: policy.id,
        result,
        timestamp: new Date().toISOString()
      });
      
      // If any policy explicitly denies, stop evaluation
      if (result.decision === 'deny') {
        await this.logPolicyDecision(request, policy, result, 'denied');
        return {
          decision: 'deny',
          reason: result.reason,
          policy: policy.id
        };
      }
    }
    
    // Check compliance requirements
    const complianceResult = await this.complianceChecker.checkCompliance(request);
    if (!complianceResult.passed) {
      await this.logPolicyDecision(request, 'compliance', complianceResult, 'denied');
      return {
        decision: 'deny',
        reason: 'Compliance requirements not met',
        details: complianceResult.failures
      };
    }
    
    // If no explicit deny and compliance passed, allow
    await this.logPolicyDecision(request, 'default', { decision: 'allow' }, 'allowed');
    return {
      decision: 'allow',
      reason: 'All policies and compliance requirements satisfied'
    };
  }
  
  // Evaluate a specific policy
  async evaluatePolicy(policy, request) {
    // This would implement the actual policy evaluation logic
    // For demo, we'll simulate different policy types
    
    switch (policy.type) {
      case 'time_based':
        const now = new Date();
        const hour = now.getHours();
        if (hour >= policy.restrictions.startHour && hour <= policy.restrictions.endHour) {
          return {
            decision: 'allow',
            reason: 'Within allowed time window'
          };
        } else {
          return {
            decision: 'deny',
            reason: 'Outside allowed time window'
          };
        }
      
      case 'location_based':
        if (policy.restrictions.allowedLocations.includes(request.location)) {
          return {
            decision: 'allow',
            reason: 'Location is approved'
          };
        } else {
          return {
            decision: 'deny',
            reason: 'Location not approved'
          };
        }
      
      case 'device_based':
        if (request.device.trustLevel >= policy.restrictions.minTrustLevel) {
          return {
            decision: 'allow',
            reason: 'Device trust level sufficient'
          };
        } else {
          return {
            decision: 'deny',
            reason: 'Device trust level insufficient'
          };
        }
      
      default:
        return {
          decision: 'allow',
          reason: 'Policy type not implemented, defaulting to allow'
        };
    }
  }
  
  // Log policy decisions
  async logPolicyDecision(request, policy, result, outcome) {
    console.log(`Policy decision: ${outcome} for request ${request.id} based on policy ${typeof policy === 'string' ? policy : policy.id}`);
    // In a real implementation, this would log to a security information and event management (SIEM) system
  }
}

// Example usage
async function demonstrateZeroTrust() {
  // Initialize services
  const cvService = new ContinuousVerificationService();
  const lpAccessManager = new LeastPrivilegeAccessManager();
  const perimeterSecurity = new MicroPerimeterSecurity();
  const policyEngine = new ZeroTrustPolicyEngine();
  
  // Example: Validate a user session
  try {
    const session = await cvService.validateSession('session123');
    console.log('Session validated successfully');
  } catch (error) {
    console.log(`Session validation failed: ${error.message}`);
  }
  
  // Example: Grant just-in-time access
  try {
    const jitResult = await lpAccessManager.grantJITAccess('user123', 'database', 'read', 1800000); // 30 minutes
    console.log(`JIT access granted: ${jitResult.status}`);
  } catch (error) {
    console.log(`JIT access failed: ${error.message}`);
  }
  
  // Example: Secure service-to-service communication
  try {
    const response = await perimeterSecurity.secureServiceCall('frontend', 'backend', { data: 'request' });
    console.log('Secure service call completed successfully');
  } catch (error) {
    console.log(`Secure service call failed: ${error.message}`);
  }
  
  // Example: Evaluate access request
  const accessRequest = {
    id: 'req456',
    userId: 'user123',
    resource: 'admin_panel',
    action: 'access',
    location: 'office',
    device: { trustLevel: 0.9 },
    time: new Date().toISOString()
  };
  
  try {
    const decision = await policyEngine.evaluateAccessRequest(accessRequest);
    console.log(`Access decision: ${decision.decision} - ${decision.reason}`);
  } catch (error) {
    console.log(`Policy evaluation failed: ${error.message}`);
  }
  
  return {
    cvService,
    lpAccessManager,
    perimeterSecurity,
    policyEngine
  };
}",
      "explanation": "This example demonstrates Zero Trust security architecture implementation including continuous verification services for ongoing authentication, least privilege access management with just-in-time access grants, micro-perimeter security for service-to-service communication, and a policy engine for evaluating access requests against Zero Trust principles.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Implementing Zero Trust as a simple network segmentation project",
        "solution": "Zero Trust is a holistic security philosophy that requires changes to identity, access management, network architecture, and application design - not just network segmentation",
        "severity": "high"
      },
      {
        "mistake": "Trying to implement Zero Trust everywhere at once",
        "solution": "Start with a pilot project focusing on high-value assets or high-risk users, then gradually expand the Zero Trust approach across the organization",
        "severity": "medium"
      },
      {
        "mistake": "Not considering user experience impact",
        "solution": "Implement adaptive authentication and risk-based access controls to minimize friction for legitimate users while maintaining security",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Zero Trust Architecture Implementation",
        "description": "Design and implement a Zero Trust security architecture for a cloud-based application including continuous verification, least privilege access, and micro-perimeter security.",
        "checkpoints": [
          "Implement continuous verification service with risk-based authentication",
          "Create least privilege access manager with just-in-time access",
          "Design micro-perimeter security for service-to-service communication",
          "Build policy engine for Zero Trust access decisions",
          "Test the integrated Zero Trust architecture with various scenarios"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 120,
    "difficulty": "Expert",
    "tags": [
      "Zero Trust",
      "Security Architecture",
      "Continuous Verification",
      "Least Privilege"
    ],
    "lastUpdated": "2025-10-03T15:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "security-fundamentals-lesson-13",
    "moduleSlug": "security-fundamentals",
    "title": "Security Operations and Incident Response",
    "order": 13,
    "objectives": [
      "Establish comprehensive security operations centers (SOCs)",
      "Implement security information and event management (SIEM) systems",
      "Develop effective incident response procedures and playbooks",
      "Conduct threat hunting and advanced persistent threat (APT) detection"
    ],
    "intro": "Security operations and incident response are critical capabilities for organizations to detect, respond to, and recover from security threats effectively. A well-functioning security operations center (SOC) serves as the nerve center for monitoring, detecting, and responding to security incidents across an organization's infrastructure.\n\nIn this lesson, you'll learn how to establish comprehensive security operations centers including staffing models, operational procedures, and technology stacks. You'll understand the roles and responsibilities of SOC analysts, incident responders, and threat hunters, and how they work together to maintain security posture.\n\nImplementing security information and event management (SIEM) systems enables organizations to collect, correlate, and analyze security events from across their infrastructure. You'll explore SIEM architecture, log collection strategies, correlation rule development, and dashboard creation for effective security monitoring.\n\nDeveloping effective incident response procedures and playbooks ensures that security incidents are handled quickly and consistently. You'll learn the incident response lifecycle including preparation, identification, containment, eradication, recovery, and lessons learned. You'll also explore how to create actionable playbooks for different types of security incidents.\n\nBy mastering security operations and incident response, you'll be able to build and operate security monitoring capabilities that detect threats early, respond to incidents effectively, and continuously improve security posture based on lessons learned from real-world events.",
    "code": {
      "example": "// Security Operations and Incident Response Implementation\n\n// 1. Security Operations Center (SOC) Framework\nclass SecurityOperationsCenter {\n  constructor(tools, team, procedures) {\n    this.tools = tools; // SIEM, EDR, NDR, etc.\n    this.team = team; // Analysts, incident responders, threat hunters\n    this.procedures = procedures; // SOPs, playbooks, escalation paths\n    this.shifts = [];\n    this.metrics = {\n      alerts: 0,\n      incidents: 0,\n      falsePositives: 0,\n      responseTime: []\n    };\n  }\n  \n  // Manage SOC shifts\n  scheduleShift(analyst, startTime, endTime, role) {\n    const shift = {\n      id: `shift_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
      analyst,
      startTime,
      endTime,
      role,
      status: 'scheduled'
    };
    
    this.shifts.push(shift);
    return shift.id;
  }
  
  // Escalate alert to appropriate tier
  escalateAlert(alert, currentTier) {
    const escalationPath = {
      'tier1': 'tier2',
      'tier2': 'tier3',
      'tier3': 'management'
    };
    
    const nextTier = escalationPath[currentTier];
    if (!nextTier) {
      throw new Error('No further escalation path');
    }
    
    alert.escalationTier = nextTier;
    alert.escalationTime = new Date().toISOString();
    
    // Notify next tier
    this.notifyTier(nextTier, alert);
    
    return nextTier;
  }
  
  // Notify appropriate team members
  notifyTier(tier, alert) {
    const teamMembers = this.team.filter(member => member.tier === tier);
    
    teamMembers.forEach(member => {
      console.log(`Notifying ${member.name} (${member.role}) about alert: ${alert.id}`);
      // In practice, this would send notifications via email, Slack, SMS, etc.
    });
  }
  
  // Track SOC metrics
  recordMetric(metric, value) {
    if (this.metrics[metric] !== undefined) {
      if (Array.isArray(this.metrics[metric])) {
        this.metrics[metric].push(value);
      } else {
        this.metrics[metric] += value;
      }
    }
  }
  
  // Generate SOC performance report
  generatePerformanceReport() {
    const totalAlerts = this.metrics.alerts;
    const falsePositiveRate = totalAlerts > 0 ? (this.metrics.falsePositives / totalAlerts) * 100 : 0;
    
    const avgResponseTime = this.metrics.responseTime.length > 0 ? 
      this.metrics.responseTime.reduce((sum, time) => sum + time, 0) / this.metrics.responseTime.length : 0;
    
    return {
      totalAlerts,
      totalIncidents: this.metrics.incidents,
      falsePositiveRate: `${falsePositiveRate.toFixed(2)}%`,
      averageResponseTime: `${avgResponseTime.toFixed(2)} minutes`,
      mttr: this.calculateMTTR() // Mean Time to Resolution
    };
  }
  
  calculateMTTR() {
    // Simplified MTTR calculation
    // In practice, this would be more complex
    return '2.5 hours';
  }
}

// 2. SIEM System Implementation
class SIEMSystem {
  constructor(logSources, correlationRules, alertingSystem) {
    this.logSources = logSources; // Firewalls, servers, applications, etc.
    this.correlationRules = correlationRules;
    this.alertingSystem = alertingSystem;
    this.events = [];
    this.alerts = [];
  }
  
  // Collect logs from sources
  async collectLogs() {
    console.log('Collecting logs from sources...');
    
    for (const source of this.logSources) {
      try {
        const logs = await source.getLogs();
        this.processLogs(logs, source.type);
      } catch (error) {
        console.error(`Failed to collect logs from ${source.type}: ${error.message}`);
      }
    }
  }
  
  // Process and normalize logs
  processLogs(logs, sourceType) {
    const normalizedLogs = logs.map(log => ({
      ...log,
      normalized: this.normalizeLog(log, sourceType),
      timestamp: new Date().toISOString(),
      source: sourceType
    }));
    
    this.events.push(...normalizedLogs);
    
    // Apply correlation rules
    this.applyCorrelationRules(normalizedLogs);
  }
  
  // Normalize log format
  normalizeLog(log, sourceType) {
    // Different systems have different log formats
    // This function would convert them to a common format
    switch (sourceType) {
      case 'firewall':
        return {
          eventType: 'network',
          sourceIP: log.src_ip,
          destinationIP: log.dst_ip,
          port: log.dst_port,
          action: log.action,
          protocol: log.protocol
        };
      case 'server':
        return {
          eventType: 'system',
          user: log.user,
          process: log.process,
          action: log.action,
          result: log.result
        };
      case 'application':
        return {
          eventType: 'application',
          user: log.userId,
          resource: log.resource,
          action: log.action,
          result: log.result,
          ipAddress: log.ipAddress
        };
      default:
        return log;
    }
  }
  
  // Apply correlation rules to detect threats
  applyCorrelationRules(events) {
    for (const rule of this.correlationRules) {
      const matches = rule.apply(events);
      
      if (matches.length > 0) {
        for (const match of matches) {
          const alert = this.createAlert(rule, match);
          this.alerts.push(alert);
          
          // Send alert
          this.alertingSystem.sendAlert(alert);
        }
      }
    }
  }
  
  // Create alert from correlation rule match
  createAlert(rule, match) {
    return {
      id: `alert_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
      ruleId: rule.id,
      ruleName: rule.name,
      severity: rule.severity,
      timestamp: new Date().toISOString(),
      events: match.events,
      description: rule.generateDescription(match),
      status: 'open'
    };
  }
}

// 3. Incident Response System
class IncidentResponseSystem {
  constructor(notificationSystem, playbookManager) {
    this.notificationSystem = notificationSystem;
    this.playbookManager = playbookManager;
    this.incidents = [];
  }
  
  // Create new incident from alert
  createIncident(alert) {
    const incident = {
      id: `INC-${Date.now()}-${Math.floor(Math.random() * 1000)}`,
      alertId: alert.id,\n      title: `Security Incident: ${alert.ruleName}`,
      description: alert.description,
      severity: alert.severity,
      status: 'detected',
      createdAt: new Date().toISOString(),
      timeline: [{
        action: 'incident_created',
        timestamp: new Date().toISOString(),
        description: 'Incident created from security alert'
      }],
      assignedTo: null,
      evidence: [],
      actions: []
    };
    
    this.incidents.push(incident);
    
    // Notify appropriate team
    this.notificationSystem.notifyIncident(incident);
    
    return incident.id;
  }
  
  // Assign incident to responder
  assignIncident(incidentId, responder) {
    const incident = this.incidents.find(i => i.id === incidentId);
    if (!incident) {
      throw new Error(`Incident ${incidentId} not found`);
    }
    
    incident.assignedTo = responder;
    incident.status = 'assigned';
    
    this.logAction(incidentId, 'assigned', `Incident assigned to ${responder}`);
    
    return incident;
  }
  
  // Execute incident response playbook
  async executePlaybook(incidentId, playbookName) {
    const incident = this.incidents.find(i => i.id === incidentId);
    if (!incident) {
      throw new Error(`Incident ${incidentId} not found`);
    }
    
    const playbook = this.playbookManager.getPlaybook(playbookName);
    if (!playbook) {
      throw new Error(`Playbook ${playbookName} not found`);
    }
    
    this.logAction(incidentId, 'playbook_started', `Executing playbook: ${playbookName}`);
    
    // Execute playbook steps
    for (const step of playbook.steps) {
      try {
        await this.executeStep(incidentId, step);
      } catch (error) {
        this.logAction(incidentId, 'playbook_step_failed', `Step ${step.name} failed: ${error.message}`);
        // Continue with other steps or handle error based on playbook logic
      }
    }
    
    this.logAction(incidentId, 'playbook_completed', `Playbook ${playbookName} completed`);
  }
  
  // Execute a playbook step
  async executeStep(incidentId, step) {
    this.logAction(incidentId, 'step_started', `Executing step: ${step.name}`);
    
    // In a real implementation, this would execute actual response actions
    // For demo, we'll just simulate execution
    await new Promise(resolve => setTimeout(resolve, Math.random() * 1000));
    
    this.logAction(incidentId, 'step_completed', `Step ${step.name} completed`);
  }
  
  // Log incident action
  logAction(incidentId, action, description) {
    const incident = this.incidents.find(i => i.id === incidentId);
    if (incident) {
      incident.timeline.push({
        action,
        timestamp: new Date().toISOString(),
        description
      });
    }
  }
  
  // Add evidence to incident
  addEvidence(incidentId, evidence) {
    const incident = this.incidents.find(i => i.id === incidentId);
    if (incident) {
      incident.evidence.push({
        ...evidence,
        timestamp: new Date().toISOString()
      });
    }
  }
  
  // Update incident status
  updateStatus(incidentId, status) {
    const incident = this.incidents.find(i => i.id === incidentId);
    if (incident) {
      const previousStatus = incident.status;
      incident.status = status;
      
      this.logAction(incidentId, 'status_changed', `Status changed from ${previousStatus} to ${status}`);
      
      // If closing incident, conduct lessons learned
      if (status === 'closed') {
        this.conductLessonsLearned(incidentId);
      }
    }
  }
  
  // Conduct lessons learned
  conductLessonsLearned(incidentId) {
    const incident = this.incidents.find(i => i.id === incidentId);
    if (incident) {
      console.log(`Conducting lessons learned for incident ${incidentId}`);
      // In practice, this would involve a formal review process
      this.logAction(incidentId, 'lessons_learned', 'Lessons learned session completed');
    }
  }
}

// 4. Threat Hunting Framework
class ThreatHuntingFramework {
  constructor(iocDatabase, analyticsEngine, huntingTeam) {
    this.iocDatabase = iocDatabase; // Indicators of Compromise
    this.analyticsEngine = analyticsEngine;
    this.huntingTeam = huntingTeam;
    this.hunts = [];
  }
  
  // Create threat hunt
  createHunt(name, hypothesis, dataSources, techniques) {
    const hunt = {
      id: `hunt_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
      name,
      hypothesis,
      dataSources,
      techniques,
      status: 'planned',
      createdAt: new Date().toISOString(),
      results: [],
      assignedTo: null
    };
    
    this.hunts.push(hunt);
    return hunt.id;
  }
  
  // Assign hunt to team member
  assignHunt(huntId, hunter) {
    const hunt = this.hunts.find(h => h.id === huntId);
    if (!hunt) {
      throw new Error(`Hunt ${huntId} not found`);
    }
    
    hunt.assignedTo = hunter;
    hunt.status = 'in_progress';
    
    return hunt;
  }
  
  // Execute threat hunt
  async executeHunt(huntId) {
    const hunt = this.hunts.find(h => h.id === huntId);
    if (!hunt) {
      throw new Error(`Hunt ${huntId} not found`);
    }
    
    console.log(`Executing threat hunt: ${hunt.name}`);
    
    // Collect data from sources
    const data = await this.collectData(hunt.dataSources);
    
    // Apply hunting techniques
    const findings = await this.applyTechniques(data, hunt.techniques);
    
    // Check against IOCs
    const iocMatches = await this.checkIOCs(findings);
    
    // Record results
    hunt.results = {
      findings,
      iocMatches,
      timestamp: new Date().toISOString()
    };
    
    hunt.status = 'completed';
    
    // If threats found, create incidents
    if (iocMatches.length > 0) {
      this.createIncidentsFromFindings(hunt, iocMatches);
    }
    
    return hunt.results;
  }
  
  // Collect data for hunting
  async collectData(sources) {
    console.log('Collecting data for threat hunting...');
    
    // In practice, this would collect data from various sources
    // For demo, we'll simulate data collection
    return {
      timestamp: new Date().toISOString(),
      data: Array.from({length: 100}, (_, i) => ({
        id: i,
        type: ['network', 'file', 'process', 'registry'][Math.floor(Math.random() * 4)],
        content: `Sample data ${i}`
      }))
    };
  }
  
  // Apply hunting techniques
  async applyTechniques(data, techniques) {
    console.log('Applying hunting techniques...');
    
    // In practice, this would apply various analytical techniques
    // For demo, we'll simulate findings
    return Array.from({length: Math.floor(Math.random() * 10)}, (_, i) => ({
      id: `finding_${i}`,
      technique: techniques[Math.floor(Math.random() * techniques.length)],
      confidence: Math.random(),
      details: `Potential suspicious activity ${i}`
    }));
  }
  
  // Check findings against IOCs
  async checkIOCs(findings) {
    console.log('Checking findings against IOCs...');
    
    // In practice, this would check against a database of known IOCs
    // For demo, we'll simulate matches
    return findings.filter(finding => finding.confidence > 0.7);
  }
  
  // Create incidents from hunting findings
  createIncidentsFromFindings(hunt, matches) {
    console.log(`Creating ${matches.length} incidents from hunting findings`);
    
    // In practice, this would create actual incidents in the IR system
    matches.forEach((match, index) => {
      console.log(`Would create incident for finding: ${match.id}`);
    });
  }
}

// Example usage
async function demonstrateSecurityOperations() {
  // Initialize SOC
  const soc = new SecurityOperationsCenter([], [], []);
  
  // Initialize SIEM
  const siem = new SIEMSystem([], [], {
    sendAlert: (alert) => console.log(`SIEM Alert: ${alert.description}`)
  });
  
  // Initialize Incident Response
  const irSystem = new IncidentResponseSystem({
    notifyIncident: (incident) => console.log(`IR Notification: ${incident.title}`)
  }, {
    getPlaybook: (name) => ({
      id: name,
      name,
      steps: [
        { name: 'Containment' },
        { name: 'Eradication' },
        { name: 'Recovery' }
      ]
    })
  });
  
  // Initialize Threat Hunting
  const huntingFramework = new ThreatHuntingFramework([], {}, []);
  
  // Example: Create and execute a threat hunt
  const huntId = huntingFramework.createHunt(
    'Suspicious Network Activity',
    'Looking for potential data exfiltration',
    ['firewall', 'dns'],
    ['network_analysis', 'traffic_pattern_analysis']
  );
  
  console.log(`Created threat hunt: ${huntId}`);
  
  // Example: Create incident from alert
  const sampleAlert = {
    id: 'alert_123',
    ruleName: 'Multiple Failed Logins',
    description: 'Detected 15 failed login attempts in 5 minutes',
    severity: 'high'
  };
  
  const incidentId = irSystem.createIncident(sampleAlert);
  console.log(`Created incident: ${incidentId}`);
  
  // Example: Execute incident response playbook
  try {
    await irSystem.executePlaybook(incidentId, 'credential_compromise');
    console.log('Incident response playbook executed successfully');
  } catch (error) {
    console.log(`Playbook execution failed: ${error.message}`);
  }
  
  return {
    soc,
    siem,
    irSystem,
    huntingFramework
  };
}"}
    ],
    "explanation": "This example demonstrates security operations and incident response implementation including a security operations center framework with shift management and metrics tracking, a SIEM system for log collection and correlation, an incident response system with playbooks and workflow management, and a threat hunting framework for proactive threat detection.",
    "language": "javascript"
  },
  "pitfalls": [
    {
      "mistake": "Creating too many alerts which lead to alert fatigue",
      "solution": "Implement alert correlation and prioritization to reduce noise and ensure that critical alerts are not lost in a sea of low-priority notifications",
      "severity": "high"
    },
    {
      "mistake": "Not regularly testing and updating incident response playbooks",
      "solution": "Schedule regular incident response drills and update playbooks based on lessons learned from real incidents and changes in the threat landscape",
      "severity": "medium"
    },
    {
      "mistake": "Failing to maintain adequate forensic evidence during incident response",
      "solution": "Implement proper logging and retention policies, and ensure that incident response procedures include evidence preservation steps to support investigations and potential legal proceedings",
      "severity": "high"
    }
  ],
  "exercises": [
    {
      "title": "Security Operations Center Implementation",
      "description": "Design and implement a security operations center including shift management, alert escalation, and performance metrics.",
      "checkpoints": [
        "Create SOC framework with shift scheduling and team management",
        "Implement SIEM system with log collection and correlation rules",
        "Develop incident response system with playbooks and workflow",
        "Build threat hunting framework for proactive threat detection",
        "Test integrated security operations with simulated incidents"
      ]
    }
  ],
  "next": [],
  "estimatedMinutes": 150,
  "difficulty": "Expert",
  "tags": [
    "Security Operations",
    "Incident Response",
    "SIEM",
    "Threat Hunting"
  ],
  "lastUpdated": "2025-10-03T15:30:00.000Z",
  "version": "1.1.0"
},
  {
    "id": "security-fundamentals-lesson-14",
    "moduleSlug": "security-fundamentals",
    "title": "Cloud Security and Infrastructure Protection",
    "order": 14,
    "objectives": [
      "Implement cloud security best practices and shared responsibility models",
      "Secure containerized applications and orchestration platforms",
      "Protect infrastructure as code (IaC) and deployment pipelines",
      "Monitor and audit cloud environments for security compliance"
    ],
    "intro": "Cloud security requires a fundamentally different approach than traditional on-premises security, with unique challenges and opportunities arising from shared responsibility models, dynamic infrastructure, and distributed architectures. Organizations must understand their security responsibilities in cloud environments while leveraging cloud-native security tools and services effectively.\n\nIn this lesson, you'll learn cloud security best practices including the shared responsibility model, identity and access management in cloud environments, network security controls, and data protection strategies. You'll understand how security responsibilities are divided between cloud providers and customers, and how to implement appropriate controls in each domain.\n\nSecuring containerized applications and orchestration platforms like Kubernetes requires specialized knowledge of container security principles, image scanning, runtime protection, and network policies. You'll explore techniques for securing the container lifecycle from build to runtime, implementing pod security standards, and protecting container registries.\n\nProtecting infrastructure as code (IaC) and deployment pipelines is critical for maintaining security throughout the development lifecycle. You'll learn how to implement security scanning for IaC templates, secure CI/CD pipelines with security gates, and prevent misconfigurations that could lead to security vulnerabilities.\n\nBy mastering cloud security and infrastructure protection, you'll be able to design and implement secure cloud architectures, protect containerized workloads, and maintain security compliance in dynamic cloud environments while leveraging the scalability and flexibility that cloud platforms provide.",
    "code": {
      "example": "// Cloud Security and Infrastructure Protection Implementation\n\n// 1. Cloud Security Configuration Validator\nclass CloudSecurityValidator {\n  constructor(cloudProvider, securityPolicies) {\n    this.cloudProvider = cloudProvider;\n    this.securityPolicies = securityPolicies;\n    this.findings = [];\n  }\n  \n  // Validate cloud resource configurations\n  async validateResources(resources) {\n    console.log('Validating cloud resources against security policies...');\n    \n    const findings = [];\n    \n    for (const resource of resources) {\n      const resourceFindings = await this.validateResource(resource);\n      findings.push(...resourceFindings);\n    }\n    \n    this.findings = findings;\n    return findings;\n  }\n  \n  // Validate a single resource\n  async validateResource(resource) {\n    const findings = [];\n    \n    // Check against each security policy\n    for (const policy of this.securityPolicies) {\n      const policyResult = await policy.evaluate(resource);\n      \n      if (!policyResult.passed) {\n        findings.push({\n          resourceId: resource.id,\n          resourceType: resource.type,\n          policy: policy.id,\n          severity: policy.severity,\n          description: policyResult.description,\n          recommendation: policy.recommendation\n        });\n      }\n    }\n    \n    return findings;\n  }\n  \n  // Generate compliance report\n  generateComplianceReport() {\n    const summary = {\n      totalResources: 0,\n      totalFindings: this.findings.length,\n      critical: 0,\n      high: 0,\n      medium: 0,\n      low: 0\n    };\n    \n    // Count findings by severity\n    this.findings.forEach(finding => {\n      summary[finding.severity]++;\n      // Count unique resources\n      if (!summary.resources) summary.resources = new Set();\n      summary.resources.add(finding.resourceId);\n    });\n    \n    summary.totalResources = summary.resources ? summary.resources.size : 0;\n    delete summary.resources;\n    \n    return {\n      timestamp: new Date().toISOString(),\n      summary,\n      findings: this.findings\n    };\n  }\n}\n\n// 2. Container Security Scanner\nclass ContainerSecurityScanner {\n  constructor(imageRegistry, vulnerabilityDatabase) {\n    this.imageRegistry = imageRegistry;\n    this.vulnerabilityDatabase = vulnerabilityDatabase;\n  }\n  \n  // Scan container image for vulnerabilities\n  async scanImage(imageName, imageTag) {\n    console.log(`Scanning image ${imageName}:${imageTag} for vulnerabilities...`);\n    \n    // Pull image metadata\n    const imageMetadata = await this.imageRegistry.getImageMetadata(imageName, imageTag);\n    \n    // Scan base image layers\n    const layerVulnerabilities = await this.scanImageLayers(imageMetadata.layers);\n    \n    // Scan application dependencies\n    const dependencyVulnerabilities = await this.scanDependencies(imageMetadata.dependencies);\n    \n    // Check for configuration issues\n    const configIssues = await this.checkConfiguration(imageMetadata.config);\n    \n    // Combine all findings\n    const findings = [\n      ...layerVulnerabilities,\n      ...dependencyVulnerabilities,\n      ...configIssues\n    ];\n    \n    return {\n      image: `${imageName}:${imageTag}`,
      timestamp: new Date().toISOString(),
      findings,
      summary: this.summarizeFindings(findings)
    };
  }
  
  // Scan image layers for OS vulnerabilities
  async scanImageLayers(layers) {
    const vulnerabilities = [];
    
    for (const layer of layers) {
      // Check layer against vulnerability database
      const layerVulns = await this.vulnerabilityDatabase.checkLayer(layer);
      vulnerabilities.push(...layerVulns.map(vuln => ({
        type: 'os_vulnerability',
        layer: layer.id,
        ...vuln
      })));
    }
    
    return vulnerabilities;
  }
  
  // Scan application dependencies
  async scanDependencies(dependencies) {
    const vulnerabilities = [];
    
    for (const dependency of dependencies) {
      // Check dependency against vulnerability databases
      const depVulns = await this.checkDependencyVulnerabilities(dependency);
      vulnerabilities.push(...depVulns.map(vuln => ({
        type: 'dependency_vulnerability',
        dependency: dependency.name,
        ...vuln
      })));
    }
    
    return vulnerabilities;
  }
  
  // Check dependency vulnerabilities
  async checkDependencyVulnerabilities(dependency) {
    // This would integrate with vulnerability databases like NVD, Snyk, etc.
    // For demo, we'll simulate findings
    if (Math.random() > 0.8) {
      return [{
        id: `CVE-${Math.floor(Math.random() * 10000)}`,
        severity: ['critical', 'high', 'medium'][Math.floor(Math.random() * 3)],
        description: `Vulnerability in ${dependency.name}`,
        cvssScore: (Math.random() * 10).toFixed(1)
      }];
    }
    return [];
  }
  
  // Check container configuration
  async checkConfiguration(config) {
    const issues = [];
    
    // Check for running as root
    if (config.runAsRoot) {
      issues.push({
        type: 'configuration_issue',
        id: 'ROOT_CONTAINER',
        severity: 'high',
        description: 'Container is configured to run as root user',
        recommendation: 'Run container with non-root user'
      });
    }
    
    // Check for privileged mode
    if (config.privileged) {
      issues.push({
        type: 'configuration_issue',
        id: 'PRIVILEGED_CONTAINER',
        severity: 'critical',
        description: 'Container is running in privileged mode',
        recommendation: 'Remove privileged flag unless absolutely necessary'
      });
    }
    
    // Check for excessive capabilities
    if (config.capabilities && config.capabilities.length > 5) {
      issues.push({
        type: 'configuration_issue',
        id: 'EXCESSIVE_CAPABILITIES',
        severity: 'medium',
        description: 'Container has excessive Linux capabilities',
        recommendation: 'Reduce capabilities to minimum required'
      });
    }
    
    return issues;
  }
  
  // Summarize findings
  summarizeFindings(findings) {
    const summary = {
      total: findings.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };
    
    findings.forEach(finding => {
      summary[finding.severity]++;
    });
    
    return summary;
  }
}

// 3. Infrastructure as Code (IaC) Security Scanner
class IaCScanner {
  constructor(policyEngine, templateParsers) {
    this.policyEngine = policyEngine;
    this.templateParsers = templateParsers;
    this.supportedFormats = Object.keys(templateParsers);
  }
  
  // Scan IaC template for security issues
  async scanTemplate(templateContent, format) {
    console.log(`Scanning ${format} template for security issues...`);
    
    // Validate format support
    if (!this.supportedFormats.includes(format)) {
      throw new Error(`Unsupported IaC format: ${format}`);
    }
    
    // Parse template
    const parsedTemplate = this.templateParsers[format](templateContent);
    
    // Extract resources
    const resources = this.extractResources(parsedTemplate);
    
    // Evaluate policies against resources
    const findings = [];
    for (const resource of resources) {
      const policyResults = await this.policyEngine.evaluateResource(resource);
      findings.push(...policyResults.map(result => ({
        resource: resource.id,
        resourceType: resource.type,
        ...result
      })));
    }
    
    return {
      format,
      timestamp: new Date().toISOString(),
      findings,
      summary: this.summarizeFindings(findings)
    };
  }
  
  // Extract resources from parsed template
  extractResources(parsedTemplate) {
    // This would be format-specific
    // For demo, we'll simulate resource extraction
    return [
      { id: 'web-server', type: 'ec2_instance', properties: { publicIp: true } },
      { id: 'db-server', type: 'rds_instance', properties: { encryption: false } },
      { id: 's3-bucket', type: 's3_bucket', properties: { publicRead: true } }
    ];
  }
  
  // Summarize findings
  summarizeFindings(findings) {
    const summary = {
      total: findings.length,
      critical: 0,
      high: 0,
      medium: 0,
      low: 0
    };
    
    findings.forEach(finding => {
      summary[finding.severity]++;
    });
    
    return summary;
  }
}

// 4. Cloud Security Monitor
class CloudSecurityMonitor {
  constructor(cloudProvider, monitoringRules) {
    this.cloudProvider = cloudProvider;
    this.monitoringRules = monitoringRules;
    this.alerts = [];
  }
  
  // Monitor cloud environment
  async monitorEnvironment() {
    console.log('Monitoring cloud environment for security events...');
    
    const alerts = [];
    
    // Apply monitoring rules
    for (const rule of this.monitoringRules) {
      const ruleAlerts = await this.applyRule(rule);
      alerts.push(...ruleAlerts);
    }
    
    this.alerts = alerts;
    return alerts;
  }
  
  // Apply a monitoring rule
  async applyRule(rule) {
    // Get data based on rule type
    const data = await this.getDataForRule(rule);
    
    // Apply rule logic
    const matches = rule.apply(data);
    
    // Generate alerts for matches
    const alerts = matches.map(match => ({
      id: `alert_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
      rule: rule.id,
      ruleName: rule.name,
      severity: rule.severity,
      timestamp: new Date().toISOString(),
      match,
      description: rule.generateDescription(match)
    }));
    
    return alerts;
  }
  
  // Get data for rule evaluation
  async getDataForRule(rule) {
    // This would integrate with cloud provider APIs
    // For demo, we'll simulate data retrieval
    switch (rule.type) {
      case 'network_activity':
        return await this.getNetworkActivity();
      case 'authentication':
        return await this.getAuthEvents();
      case 'data_access':
        return await this.getDataAccessEvents();
      default:
        return [];
    }
  }
  
  // Get network activity data
  async getNetworkActivity() {
    // Simulate network activity data
    return Array.from({length: 50}, (_, i) => ({
      id: i,
      sourceIp: `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
      destinationIp: `10.0.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
      bytes: Math.floor(Math.random() * 1000000),
      timestamp: new Date(Date.now() - Math.random() * 3600000).toISOString()
    }));
  }
  
  // Get authentication events
  async getAuthEvents() {
    // Simulate authentication events
    return Array.from({length: 30}, (_, i) => ({
      id: i,
      userId: `user${Math.floor(Math.random() * 100)}`,
      success: Math.random() > 0.2,
      ip: `192.168.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`,
      timestamp: new Date(Date.now() - Math.random() * 3600000).toISOString()
    }));
  }
  
  // Get data access events
  async getDataAccessEvents() {
    // Simulate data access events
    return Array.from({length: 20}, (_, i) => ({
      id: i,
      userId: `user${Math.floor(Math.random() * 100)}`,
      resource: `resource${Math.floor(Math.random() * 50)}`,
      action: ['read', 'write', 'delete'][Math.floor(Math.random() * 3)],
      timestamp: new Date(Date.now() - Math.random() * 3600000).toISOString()
    }));
  }
}

// Example usage
async function demonstrateCloudSecurity() {
  // Initialize security validator
  const securityValidator = new CloudSecurityValidator('aws', [
    {
      id: 'public_bucket_policy',
      severity: 'critical',
      evaluate: async (resource) => ({
        passed: resource.type !== 's3_bucket' || !resource.properties.publicRead,
        description: resource.type === 's3_bucket' && resource.properties.publicRead ? 
          'S3 bucket allows public read access' : 'Resource configuration is secure'
      }),
      recommendation: 'Restrict S3 bucket permissions to authorized users only'
    }
  ]);
  
  // Initialize container scanner
  const containerScanner = new ContainerSecurityScanner({}, {});
  
  // Initialize IaC scanner
  const iacScanner = new IaCScanner({}, {
    terraform: (content) => ({ parsed: true, type: 'terraform' }),
    cloudformation: (content) => ({ parsed: true, type: 'cloudformation' })
  });
  
  // Initialize cloud monitor
  const cloudMonitor = new CloudSecurityMonitor('aws', [
    {
      id: 'failed_auth_rule',
      name: 'Multiple Failed Authentications',
      type: 'authentication',
      severity: 'high',
      apply: (data) => data.filter(event => !event.success),
      generateDescription: (match) => `Failed authentication attempt from ${match.ip}`
    }
  ]);
  
  // Example: Validate cloud resources
  const resources = [
    { id: 'web-server-01', type: 'ec2_instance', properties: { publicIp: true } },
    { id: 'data-bucket', type: 's3_bucket', properties: { publicRead: true } }
  ];
  
  try {
    const findings = await securityValidator.validateResources(resources);
    console.log(`Found ${findings.length} security issues`);
    
    const report = securityValidator.generateComplianceReport();
    console.log('Compliance report generated');
  } catch (error) {
    console.log(`Security validation failed: ${error.message}`);
  }
  
  // Example: Scan container image
  try {
    const scanResult = await containerScanner.scanImage('myapp', 'v1.2.3');
    console.log(`Container scan completed with ${scanResult.summary.total} findings`);
  } catch (error) {
    console.log(`Container scan failed: ${error.message}`);
  }
  
  // Example: Monitor cloud environment
  try {
    const alerts = await cloudMonitor.monitorEnvironment();
    console.log(`Generated ${alerts.length} security alerts`);
  } catch (error) {
    console.log(`Cloud monitoring failed: ${error.message}`);
  }
  
  return {
    securityValidator,
    containerScanner,
    iacScanner,
    cloudMonitor
  };
},
  {
    "id": "security-fundamentals-lesson-15",
    "moduleSlug": "security-fundamentals",
    "title": "Privacy by Design and Data Protection",
    "order": 15,
    "objectives": [
      "Implement Privacy by Design principles in system architecture",
      "Ensure compliance with data protection regulations (GDPR, CCPA)",
      "Design systems for data minimization and purpose limitation",
      "Implement privacy-preserving technologies and techniques"
    ],
    "intro": "Privacy by Design represents a proactive approach to privacy that promotes privacy as a fundamental consideration throughout the entire engineering process, rather than as an afterthought. This methodology requires organizations to embed privacy into their systems, processes, and business practices from the inception stage, ensuring that personal data is protected by default and by design.\n\nIn this lesson, you'll learn Privacy by Design principles including proactive not reactive approaches, privacy as the default setting, and end-to-end security lifecycle protection. You'll understand how to integrate these principles into system architecture and development processes to create privacy-enhancing technologies that protect user data while maintaining functionality.\n\nEnsuring compliance with data protection regulations such as GDPR, CCPA, and other privacy laws requires a comprehensive understanding of legal requirements and technical implementation strategies. You'll explore concepts like data subject rights, lawful basis for processing, data protection impact assessments, and privacy governance frameworks that help organizations maintain compliance.\n\nDesigning systems for data minimization and purpose limitation ensures that organizations only collect and process the minimum amount of personal data necessary for specific, legitimate purposes. You'll learn techniques for implementing data retention policies, anonymization and pseudonymization strategies, and consent management systems that give users control over their personal data.\n\nBy mastering Privacy by Design and data protection, you'll be able to create systems that respect user privacy, maintain regulatory compliance, and build trust with users while still delivering valuable services and functionality.",
    "code": {
      "example": "// Privacy by Design and Data Protection Implementation\n\n// 1. Privacy by Design Framework\nclass PrivacyByDesignFramework {\n  constructor(privacyPolicies, dataCatalog) {\n    this.privacyPolicies = privacyPolicies;\n    this.dataCatalog = dataCatalog; // Catalog of all data processing activities\n    this.privacyControls = [];\n  }\n  \n  // Assess privacy impact of a system or process\n  async assessPrivacyImpact(system, processData) {\n    console.log(`Assessing privacy impact for ${system.name}...`);\n    \n    const assessment = {\n      system: system.name,\n      timestamp: new Date().toISOString(),\n      dataFlows: [],\n      privacyRisks: [],\n      recommendations: []\n    };\n    \n    // Identify data flows\n    assessment.dataFlows = this.identifyDataFlows(processData);\n    \n    // Assess privacy risks\n    assessment.privacyRisks = await this.assessPrivacyRisks(assessment.dataFlows);\n    \n    // Generate recommendations\n    assessment.recommendations = this.generatePrivacyRecommendations(assessment.privacyRisks);\n    \n    return assessment;\n  }\n  \n  // Identify data flows in a system\n  identifyDataFlows(processData) {\n    // This would analyze the system to identify all data flows\n    // For demo, we'll simulate data flow identification\n    return [\n      {\n        id: 'flow_1',\n        source: 'user_input',\n        destination: 'database',\n        dataTypes: ['personal_identifiers', 'contact_info'],\n        purpose: 'user_account_creation',\n        retention: '5 years'\n      },\n      {\n        id: 'flow_2',\n        source: 'database',\n        destination: 'analytics_service',\n        dataTypes: ['usage_data'],\n        purpose: 'improve_user_experience',\n        retention: '2 years'\n      }\n    ];\n  }\n  \n  // Assess privacy risks for data flows\n  async assessPrivacyRisks(dataFlows) {\n    const risks = [];\n    \n    for (const flow of dataFlows) {\n      // Check against privacy policies\n      for (const policy of this.privacyPolicies) {\n        const policyResult = await policy.evaluate(flow);\n        \n        if (!policyResult.compliant) {\n          risks.push({\n            flowId: flow.id,\n            policy: policy.id,\n            riskLevel: policyResult.riskLevel || 'medium',\n            description: policyResult.description,\n            mitigation: policyResult.recommendation\n          });\n        }\n      }\n    }\n    \n    return risks;\n  }\n  \n  // Generate privacy recommendations\n  generatePrivacyRecommendations(privacyRisks) {\n    const recommendations = [];\n    \n    // Group risks by flow and generate consolidated recommendations\n    const risksByFlow = {};\n    privacyRisks.forEach(risk => {\n      if (!risksByFlow[risk.flowId]) {\n        risksByFlow[risk.flowId] = [];\n      }\n      risksByFlow[risk.flowId].push(risk);\n    });\n    \n    for (const [flowId, risks] of Object.entries(risksByFlow)) {\n      const highRisks = risks.filter(risk => risk.riskLevel === 'high' || risk.riskLevel === 'critical');\n      \n      if (highRisks.length > 0) {\n        recommendations.push({\n          flowId,\n          priority: 'high',\n          actions: highRisks.map(risk => risk.mitigation)\n        });\n      }\n      \n      const mediumRisks = risks.filter(risk => risk.riskLevel === 'medium');\n      if (mediumRisks.length > 0) {\n        recommendations.push({\n          flowId,\n          priority: 'medium',\n          actions: mediumRisks.map(risk => risk.mitigation)\n        });\n      }\n    }\n    \n    return recommendations;\n  }\n  \n  // Implement privacy control\n  implementPrivacyControl(control) {\n    this.privacyControls.push({\n      ...control,\n      implementedAt: new Date().toISOString(),\n      status: 'active'\n    });\n    \n    console.log(`Implemented privacy control: ${control.name}`);\n  }\n}\n\n// 2. Data Protection Compliance Manager\nclass DataProtectionComplianceManager {\n  constructor(regulations, consentManager) {\n    this.regulations = regulations; // GDPR, CCPA, etc.\n    this.consentManager = consentManager;\n    this.dataProcessingRecords = [];\n  }\n  \n  // Create data processing record\n  createDataProcessingRecord(processor, purpose, dataTypes, legalBasis) {\n    const record = {\n      id: `dpr_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
      processor,
      purpose,
      dataTypes,
      legalBasis,
      createdAt: new Date().toISOString(),
      retentionPeriod: this.calculateRetentionPeriod(purpose),
      dataSubjects: [],
      status: 'active'
    };
    
    this.dataProcessingRecords.push(record);
    return record.id;
  }
  
  // Calculate appropriate retention period
  calculateRetentionPeriod(purpose) {
    // Different purposes have different retention requirements
    const retentionPeriods = {
      'user_account': '5 years',
      'marketing': '2 years',
      'analytics': '1 year',
      'legal_obligation': '7 years'
    };
    
    return retentionPeriods[purpose] || '1 year';
  }
  
  // Handle data subject request
  async handleDataSubjectRequest(requestType, userId, requestData) {
    console.log(`Handling ${requestType} request for user ${userId}`);
    
    switch (requestType) {
      case 'access':
        return await this.handleAccessRequest(userId, requestData);
      case 'rectification':
        return await this.handleRectificationRequest(userId, requestData);
      case 'erasure':
        return await this.handleErasureRequest(userId, requestData);
      case 'portability':
        return await this.handlePortabilityRequest(userId, requestData);
      case 'objection':
        return await this.handleObjectionRequest(userId, requestData);
      default:
        throw new Error(`Unsupported request type: ${requestType}`);
    }
  }
  
  // Handle access request
  async handleAccessRequest(userId, requestData) {
    // Retrieve user's personal data
    const userData = await this.retrieveUserData(userId);
    
    // Log the access request
    await this.logDataSubjectRequest('access', userId, requestData);
    
    return {
      userId,
      data: userData,
      timestamp: new Date().toISOString()
    };
  }
  
  // Handle rectification request
  async handleRectificationRequest(userId, requestData) {
    // Update user's personal data
    const updated = await this.updateUserData(userId, requestData.changes);
    \n    // Log the rectification request\n    await this.logDataSubjectRequest('rectification', userId, requestData);
    
    return {
      userId,
      updated,
      timestamp: new Date().toISOString()
    };
  }
  
  // Handle erasure request
  async handleErasureRequest(userId, requestData) {
    // Delete user's personal data
    const deleted = await this.deleteUserData(userId);
    \n    // Log the erasure request\n    await this.logDataSubjectRequest('erasure', userId, requestData);
    
    return {
      userId,
      deleted,
      timestamp: new Date().toISOString()
    };
  }
  
  // Handle portability request
  async handlePortabilityRequest(userId, requestData) {
    // Retrieve user's personal data in portable format
    const userData = await this.retrieveUserData(userId);
    \n    // Convert to portable format (e.g., JSON)\n    const portableData = this.convertToPortableFormat(userData);
    \n    // Log the portability request\n    await this.logDataSubjectRequest('portability', userId, requestData);
    
    return {
      userId,
      data: portableData,
      format: 'json',
      timestamp: new Date().toISOString()
    };
  }
  
  // Handle objection request
  async handleObjectionRequest(userId, requestData) {
    // Process user's objection (e.g., to marketing)
    const processed = await this.processObjection(userId, requestData.objectionType);
    \n    // Log the objection request\n    await this.logDataSubjectRequest('objection', userId, requestData);
    
    return {
      userId,
      processed,
      timestamp: new Date().toISOString()
    };
  }
  
  // Log data subject request
  async logDataSubjectRequest(requestType, userId, requestData) {
    console.log(`Logged ${requestType} request for user ${userId}`);
    // In practice, this would store in a compliance log\n  }\n  \n  // Check compliance with regulations\n  async checkCompliance() {\n    const complianceReport = {\n      timestamp: new Date().toISOString(),\n      regulations: {},\n      overallCompliance: 'compliant'\n    };\n    \n    for (const regulation of this.regulations) {\n      const regulationCompliance = await this.checkRegulationCompliance(regulation);\n      complianceReport.regulations[regulation.name] = regulationCompliance;
      \n      if (regulationCompliance.status !== 'compliant') {\n        complianceReport.overallCompliance = 'non-compliant';
      }\n    }\n    \n    return complianceReport;
  }
  
  // Check compliance with a specific regulation
  async checkRegulationCompliance(regulation) {
    // This would check specific requirements of the regulation
    // For demo, we'll simulate compliance checking
    return {
      status: Math.random() > 0.1 ? 'compliant' : 'non-compliant',
      issues: Math.random() > 0.8 ? ['Missing consent records', 'Incomplete DPIA'] : [],
      lastAudit: new Date().toISOString()
    };
  }
}

// 3. Privacy-Preserving Data Processing
class PrivacyPreservingProcessor {
  constructor(encryptionService, anonymizationService) {
    this.encryptionService = encryptionService;
    this.anonymizationService = anonymizationService;
  }
  
  // Process data with privacy preservation
  async processWithPrivacy(data, privacyLevel) {
    console.log(`Processing data with privacy level: ${privacyLevel}`);
    \n    switch (privacyLevel) {\n      case 'encrypted':\n        return await this.encryptData(data);
      case 'pseudonymized':\n        return await this.pseudonymizeData(data);
      case 'anonymized':\n        return await this.anonymizeData(data);
      case 'aggregated':\n        return await this.aggregateData(data);
      default:\n        throw new Error(`Unsupported privacy level: ${privacyLevel}`);
    }
  }
  
  // Encrypt data
  async encryptData(data) {
    const encryptedData = {};
    
    for (const [key, value] of Object.entries(data)) {
      // Encrypt sensitive fields
      if (this.isSensitiveField(key)) {
        encryptedData[key] = await this.encryptionService.encrypt(value);
      } else {\n        encryptedData[key] = value;
      }
    }
    
    return {
      ...encryptedData,
      privacyLevel: 'encrypted'
    };
  }
  
  // Pseudonymize data
  async pseudonymizeData(data) {
    const pseudonymizedData = {};
    
    for (const [key, value] of Object.entries(data)) {
      // Replace identifiers with pseudonyms
      if (this.isIdentifierField(key)) {
        pseudonymizedData[key] = this.anonymizationService.generatePseudonym(value);
      } else {\n        pseudonymizedData[key] = value;
      }
    }
    
    return {
      ...pseudonymizedData,
      privacyLevel: 'pseudonymized'
    };
  }
  
  // Anonymize data
  async anonymizeData(data) {
    const anonymizedData = {};
    
    for (const [key, value] of Object.entries(data)) {
      // Remove or generalize identifiers
      if (this.isIdentifierField(key)) {
        anonymizedData[key] = this.anonymizationService.anonymize(value);
      } else if (this.isSensitiveField(key)) {\n        // Apply k-anonymity or other techniques\n        anonymizedData[key] = this.applyAnonymizationTechnique(value);
      } else {\n        anonymizedData[key] = value;
      }
    }
    
    return {
      ...anonymizedData,
      privacyLevel: 'anonymized'
    };
  }
  
  // Aggregate data
  async aggregateData(data) {
    // Group and aggregate data to prevent individual identification
    // This is a simplified example
    const aggregated = {};
    
    // Count occurrences of values
    for (const [key, value] of Object.entries(data)) {
      if (!aggregated[key]) {
        aggregated[key] = {};
      }\n      \n      if (!aggregated[key][value]) {\n        aggregated[key][value] = 0;
      }\n      \n      aggregated[key][value]++;
    }
    
    // Apply differential privacy or other techniques
    return {
      aggregatedData: aggregated,
      privacyLevel: 'aggregated',
      technique: 'counting_with_thresholds'
    };
  }
  
  // Check if field is sensitive
  isSensitiveField(fieldName) {
    const sensitiveFields = ['ssn', 'credit_card', 'password', 'health_info', 'biometric'];
    return sensitiveFields.some(field => fieldName.includes(field));
  }
  
  // Check if field is identifier
  isIdentifierField(fieldName) {
    const identifierFields = ['name', 'email', 'phone', 'address', 'id', 'username'];
    return identifierFields.some(field => fieldName.includes(field));
  }
  
  // Apply anonymization technique
  applyAnonymizationTechnique(value) {
    // Simplified example - in practice, this would use more sophisticated techniques
    if (typeof value === 'string') {
      return value.length > 3 ? value.substring(0, 2) + '***' : '**';
    } else if (typeof value === 'number') {
      // Generalize numbers
      return Math.floor(value / 10) * 10; // Round to nearest 10
    }
    return value;
  }
}

// 4. Consent Management System
class ConsentManagementSystem {
  constructor(notificationService, auditLogger) {
    this.notificationService = notificationService;
    this.auditLogger = auditLogger;
    this.consents = new Map();
  }
  
  // Obtain consent from user
  async obtainConsent(userId, consentType, purpose, dataTypes) {
    const consent = {
      id: `consent_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
      userId,
      type: consentType,
      purpose,
      dataTypes,
      grantedAt: new Date().toISOString(),
      expiresAt: this.calculateExpiration(consentType),
      status: 'granted'
    };
    \n    this.consents.set(consent.id, consent);
    \n    // Store consent record\n    await this.storeConsentRecord(consent);
    \n    // Notify user\n    await this.notificationService.sendConsentNotification(userId, consent);
    \n    // Log consent action\n    await this.auditLogger.logConsentAction('granted', consent);
    \n    return consent.id;
  }
  
  // Calculate consent expiration
  calculateExpiration(consentType) {
    const expirations = {
      'marketing': new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 year
      'analytics': new Date(Date.now() + 180 * 24 * 60 * 60 * 1000), // 6 months
      'essential': new Date(Date.now() + 10 * 365 * 24 * 60 * 60 * 1000) // 10 years
    };
    \n    return expirations[consentType] || new Date(Date.now() + 365 * 24 * 60 * 60 * 1000);
  }
  
  // Check if consent is granted
  isConsentGranted(userId, consentType, purpose) {
    for (const [id, consent] of this.consents) {
      if (consent.userId === userId &&
          consent.type === consentType &&
          consent.purpose === purpose &&
          consent.status === 'granted' &&
          new Date(consent.expiresAt) > new Date()) {
        return true;
      }
    }\n    return false;
  }
  
  // Withdraw consent
  async withdrawConsent(consentId, userId) {
    const consent = this.consents.get(consentId);
    
    if (!consent) {
      throw new Error('Consent not found');
    }
    
    if (consent.userId !== userId) {
      throw new Error('Unauthorized to withdraw this consent');
    }\n    \n    consent.status = 'withdrawn';
    consent.withdrawnAt = new Date().toISOString();
    \n    // Update consent record\n    await this.updateConsentRecord(consent);
    \n    // Notify user\n    await this.notificationService.sendConsentNotification(userId, consent);
    \n    // Log consent action\n    await this.auditLogger.logConsentAction('withdrawn', consent);
    \n    return consent;
  }
  
  // Get user's consents
  getUserConsents(userId) {
    const userConsents = [];
    \n    for (const [id, consent] of this.consents) {\n      if (consent.userId === userId) {\n        userConsents.push(consent);
      }
    }\n    \n    return userConsents;
  }
  
  // Store consent record
  async storeConsentRecord(consent) {
    console.log(`Storing consent record ${consent.id}`);
    // In practice, this would store in a database\n  }\n  \n  // Update consent record\n  async updateConsentRecord(consent) {\n    console.log(`Updating consent record ${consent.id}`);
    // In practice, this would update in a database\n  }\n}\n\n// Example usage\nasync function demonstratePrivacyProtection() {\n  // Initialize privacy framework\n  const privacyFramework = new PrivacyByDesignFramework([\n    {\n      id: 'data_minimization',\n      evaluate: async (dataFlow) => ({\n        compliant: dataFlow.dataTypes.length <= 3,\n        riskLevel: dataFlow.dataTypes.length > 3 ? 'high' : 'low',\n        description: dataFlow.dataTypes.length > 3 ? \n          'Excessive data types collected' : 'Data minimization principle followed',\n        recommendation: dataFlow.dataTypes.length > 3 ? \n          'Reduce data types to minimum necessary' : 'Continue current practice'\n      })\n    }\n  ], {});
  
  // Initialize compliance manager
  const complianceManager = new DataProtectionComplianceManager([
    { name: 'GDPR' },
    { name: 'CCPA' }
  ], {});
  \n  // Initialize privacy processor\n  const privacyProcessor = new PrivacyPreservingProcessor({}, {});
  \n  // Initialize consent management\n  const consentManager = new ConsentManagementSystem({}, {});
  \n  // Example: Assess privacy impact\n  const system = { name: 'user_profile_service' };
  const processData = { description: 'Handles user profile data' };
  \n  try {\n    const assessment = await privacyFramework.assessPrivacyImpact(system, processData);
    console.log(`Privacy impact assessment completed with ${assessment.privacyRisks.length} risks identified`);
  } catch (error) {\n    console.log(`Privacy impact assessment failed: ${error.message}`);
  }
  
  // Example: Handle data subject request
  try {
    const accessResult = await complianceManager.handleDataSubjectRequest('access', 'user123', {});
    console.log('Data subject access request handled successfully');\n  } catch (error) {\n    console.log(`Data subject request failed: ${error.message}`);
  }
  
  // Example: Process data with privacy preservation
  const userData = {
    name: 'John Doe',
    email: 'john@example.com',
    ssn: '123-45-6789',
    purchaseHistory: [100, 250, 75]
  };
  \n  try {\n    const pseudonymizedData = await privacyProcessor.processWithPrivacy(userData, 'pseudonymized');
    console.log('Data pseudonymized successfully');\n  } catch (error) {\n    console.log(`Data pseudonymization failed: ${error.message}`);
  }
  
  // Example: Obtain consent
  try {
    const consentId = await consentManager.obtainConsent('user123', 'marketing', 'personalized_ads', ['email', 'purchase_history']);
    console.log(`Consent obtained with ID: ${consentId}`);
  } catch (error) {\n    console.log(`Consent obtaining failed: ${error.message}`);
  }
  
  return {
    privacyFramework,
    complianceManager,
    privacyProcessor,
    consentManager
  };
}"}
    ],
    "explanation": "This example demonstrates Privacy by Design and data protection implementation including a privacy by design framework for privacy impact assessments, a data protection compliance manager for handling data subject requests, privacy-preserving data processing techniques like encryption and anonymization, and a consent management system for obtaining and managing user consent.",
    "language": "javascript"
  },
  "pitfalls": [
    {
      "mistake": "Treating privacy as a compliance checkbox rather than a design principle",
      "solution": "Integrate privacy considerations into every stage of system design and development, making privacy a core architectural principle rather than an afterthought",
      "severity": "high"
    },
    {
      "mistake": "Collecting more data than necessary for business purposes",
      "solution": "Implement data minimization principles by only collecting data that is necessary for specific, legitimate purposes and regularly reviewing data collection practices",
      "severity": "high"
    },
    {
      "mistake": "Not providing users with meaningful control over their personal data",
      "solution": "Implement comprehensive consent management systems that give users granular control over how their data is used, and make it easy for users to exercise their data rights",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Privacy by Design Implementation",
      "description": "Design and implement a privacy-by-design system including privacy impact assessment, data protection compliance, privacy-preserving processing, and consent management.",
      "checkpoints": [
        "Create privacy by design framework with impact assessment capabilities",
        "Implement data protection compliance manager for regulation adherence",
        "Build privacy-preserving data processing with encryption and anonymization",
        "Develop consent management system with user control features",
        "Test integrated privacy system with various data processing scenarios"
      ]
    }
  ],
  "next": [],
  "estimatedMinutes": 150,
  "difficulty": "Expert",
  "tags": [
    "Privacy by Design",
    "Data Protection",
    "GDPR",
    "CCPA",
    "Consent Management"
  ],
  "lastUpdated": "2025-10-03T15:30:00.000Z",
  "version": "1.1.0"
}
]