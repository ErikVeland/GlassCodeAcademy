[
  {
    "id": 1,
    "moduleSlug": "vue-advanced",
    "title": "Vue Instance and Lifecycle",
    "order": 1,
    "objectives": [
      "Master component creation and usage",
      "Understand state management and lifecycle",
      "Implement practical solutions"
    ],
    "intro": "Welcome to this comprehensive lesson on Core Concepts.\n\nLearn about the Vue instance and its lifecycle hooks, which control the behavior of components throughout their existence.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "const app = Vue.createApp({\n  data() {\n    return {\n      message: 'Hello Vue!'\n    }\n  },\n  // Lifecycle hooks\n  beforeCreate() {\n    console.log('Before create - data and events are not set up yet')\n  },\n  created() {\n    console.log('Created - data and events are active, but DOM not mounted')\n    // Good place for API calls\n  },\n  beforeMount() {\n    console.log('Before mount - template and render functions about to be compiled')\n  },\n  mounted() {\n    console.log('Component is mounted!')\n    // Good place for DOM manipulation\n  },\n  beforeUpdate() {\n    console.log('Before update - called when data changes, before DOM update')\n  },\n  updated() {\n    console.log('Updated - called after DOM update')\n  },\n  beforeUnmount() {\n    console.log('Before unmount - called before component is destroyed')\n  },\n  unmounted() {\n    console.log('Unmounted - called after component is destroyed')\n  }\n})\n\napp.mount('#app')",
      "explanation": "This example produces: Hello Vue!\nComponent lifecycle logs in console showing the order of execution\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Vue Instance and Lifecycle",
        "description": "Apply the concepts from this lesson on Core Concepts",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Core Concepts",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 2,
    "moduleSlug": "vue-advanced",
    "title": "Template Syntax and Directives",
    "order": 2,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Core Concepts.\n\nLearn how to use Vue's powerful template syntax for data binding, conditional rendering, and list rendering with built-in directives.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<div id=\"app\">\n  <!-- Text interpolation -->\n  <p>{{ message }}</p>\n  \n  <!-- Raw HTML (be careful with XSS) -->\n  <p v-html=\"rawHtml\"></p>\n  \n  <!-- Attribute binding -->\n  <div v-bind:id=\"dynamicId\">Bound ID</div>\n  <button v-bind:disabled=\"isButtonDisabled\">Button</button>\n  \n  <!-- Conditional rendering -->\n  <p v-if=\"seen\">Now you see me</p>\n  <p v-else>Now you don't</p>\n  \n  <!-- List rendering -->\n  <ul>\n    <li v-for=\"item in items\" :key=\"item.id\">\n      {{ item.text }}\n    </li>\n  </ul>\n  \n  <!-- Event handling -->\n  <button v-on:click=\"reverseMessage\">Reverse Message</button>\n  <button @click=\"counter += 1\">Count: {{ counter }}</button>\n  \n  <!-- Two-way binding -->\n  <input v-model=\"userInput\" placeholder=\"Type something\">\n  <p>You typed: {{ userInput }}</p>\n</div>\n\nconst app = Vue.createApp({\n  data() {\n    return {\n      message: 'Hello Vue!',\n      rawHtml: '<span style=\"color: red\">This is red</span>',\n      dynamicId: 'dynamic-id',\n      isButtonDisabled: false,\n      seen: true,\n      counter: 0,\n      userInput: '',\n      items: [\n        { id: 1, text: 'Item 1' },\n        { id: 2, text: 'Item 2' },\n        { id: 3, text: 'Item 3' }\n      ]\n    }\n  },\n  methods: {\n    reverseMessage() {\n      this.message = this.message.split('').reverse().join('')\n    }\n  }\n})",
      "explanation": "This example produces: Interactive component with text interpolation, attribute binding, conditional rendering, list rendering, event handling, and two-way binding\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Template Syntax and Directives",
        "description": "Apply the concepts from this lesson on Core Concepts",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Core Concepts",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 3,
    "moduleSlug": "vue-advanced",
    "title": "Component Basics and Communication",
    "order": 3,
    "objectives": [
      "Master component creation and usage",
      "Implement practical solutions"
    ],
    "intro": "Welcome to this comprehensive lesson on Components.\n\nLearn how to create and use Vue components with props for parent-to-child communication and events for child-to-parent communication.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Define a child component\nconst BlogPost = {\n  template: `\n    <div class=\"blog-post\">\n      <h3>{{ title }}</h3>\n      <p>{{ content }}</p>\n      <button @click=\"$emit('enlarge-text', 0.1)\">Enlarge text</button>\n      <button @click=\"$emit('delete-post')\">Delete</button>\n    </div>\n  `,\n  // Declare props\n  props: ['title', 'content'],\n  // Emits declaration (optional but recommended)\n  emits: ['enlarge-text', 'delete-post']\n}\n\nconst app = Vue.createApp({\n  data() {\n    return {\n      posts: [\n        { id: 1, title: 'My Journey with Vue', content: 'Content of post 1...' },\n        { id: 2, title: 'Blogging with Vue', content: 'Content of post 2...' },\n        { id: 3, title: 'Why Vue is Great', content: 'Content of post 3...' }\n      ],\n      postFontSize: 1\n    }\n  },\n  components: {\n    BlogPost\n  },\n  methods: {\n    onEnlargeText(enlargeAmount) {\n      this.postFontSize += enlargeAmount\n    },\n    onDeletePost() {\n      // Handle delete logic\n      console.log('Post deleted')\n    }\n  }\n})\n\n// In template:\n// <div :style=\"{ fontSize: postFontSize + 'em' }\">\n//   <blog-post\n//     v-for=\"post in posts\"\n//     :key=\"post.id\"\n//     :title=\"post.title\"\n//     :content=\"post.content\"\n//     @enlarge-text=\"onEnlargeText\"\n//     @delete-post=\"onDeletePost\"\n//   ></blog-post>\n// </div>",
      "explanation": "This example produces: A list of blog posts with interactive buttons to enlarge text or delete posts, demonstrating component communication\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not using keys in lists",
        "solution": "Always provide unique keys for list items",
        "severity": "high"
      },
      {
        "mistake": "Mutating props directly",
        "solution": "Props are read-only, create new objects for updates",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Component Basics and Communication",
        "description": "Apply the concepts from this lesson on Components",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Beginner",
    "tags": [
      "Components",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 4,
    "moduleSlug": "vue-advanced",
    "title": "Slots and Dynamic Components",
    "order": 4,
    "objectives": [
      "Master component creation and usage",
      "Implement practical solutions"
    ],
    "intro": "Welcome to this comprehensive lesson on Components.\n\nLearn how to use slots for content distribution and dynamic components for flexible UI composition.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Component with slots\nconst BaseLayout = {\n  template: `\n    <div class=\"container\">\n      <header>\n        <slot name=\"header\">Default header</slot>\n      </header>\n      <main>\n        <slot></slot>\n      </main>\n      <footer>\n        <slot name=\"footer\">Default footer</slot>\n      </footer>\n    </div>\n  `\n}\n\n// Dynamic component example\nconst Home = {\n  template: `<div>Home Component</div>`\n}\n\nconst About = {\n  template: `<div>About Component</div>`\n}\n\nconst Contact = {\n  template: `<div>Contact Component</div>`\n}\n\nconst app = Vue.createApp({\n  data() {\n    return {\n      currentComponent: 'Home'\n    }\n  },\n  components: {\n    BaseLayout,\n    Home,\n    About,\n    Contact\n  }\n})\n\n// In template:\n// <base-layout>\n//   <template #header>\n//     <h1>Here might be a page title</h1>\n//   </template>\n// \n//   <p>A paragraph for the main content.</p>\n//   <p>And another one.</p>\n// \n//   <template #footer>\n//     <p>Here's some contact info</p>\n//   </template>\n// </base-layout>\n// \n// <!-- Dynamic component -->\n// <component :is=\"currentComponent\"></component>\n// <button @click=\"currentComponent = 'Home'\">Home</button>\n// <button @click=\"currentComponent = 'About'\">About</button>\n// <button @click=\"currentComponent = 'Contact'\">Contact</button>",
      "explanation": "This example produces: Flexible layout component with named slots and dynamic component switching\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not using keys in lists",
        "solution": "Always provide unique keys for list items",
        "severity": "high"
      },
      {
        "mistake": "Mutating props directly",
        "solution": "Props are read-only, create new objects for updates",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Slots and Dynamic Components",
        "description": "Apply the concepts from this lesson on Components",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Components",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 5,
    "moduleSlug": "vue-advanced",
    "title": "Reactive References and Composables",
    "order": 5,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Composition API.\n\nLearn how to use reactive references with the Composition API and create reusable composables for complex logic.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "const { createApp, ref, reactive, computed, watch, onMounted } = Vue\n\n// Reusable composable function\nfunction useCounter(initialValue = 0) {\n  const count = ref(initialValue)\n  const increment = () => count.value++\n  const decrement = () => count.value--\n  const reset = () => count.value = initialValue\n  \n  const isEven = computed(() => count.value % 2 === 0)\n  \n  watch(count, (newVal, oldVal) => {\n    console.log(`Count changed from ${oldVal} to ${newVal}`)\n  })\n  \n  return { count, increment, decrement, reset, isEven }\n}\n\nconst app = createApp({\n  setup() {\n    // Using reactive references\n    const message = ref('Hello Vue 3!')\n    const user = reactive({\n      name: 'John Doe',\n      age: 30,\n      email: 'john@example.com'\n    })\n    \n    // Using computed property\n    const userInfo = computed(() => {\n      return `${user.name} (${user.age}) - ${user.email}`\n    })\n    \n    // Using composable\n    const { count, increment, decrement, reset, isEven } = useCounter(10)\n    \n    // Lifecycle hook\n    onMounted(() => {\n      console.log('Component mounted!')\n    })\n    \n    // Methods\n    const updateUser = () => {\n      user.name = 'Jane Doe'\n      user.age = 25\n    }\n    \n    return {\n      message,\n      user,\n      userInfo,\n      count,\n      increment,\n      decrement,\n      reset,\n      isEven,\n      updateUser\n    }\n  }\n})",
      "explanation": "This example produces: Reactive component with computed properties, watchers, and reusable composable functions\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Reactive References and Composables",
        "description": "Apply the concepts from this lesson on Composition API",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Advanced",
    "tags": [
      "Composition API",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 6,
    "moduleSlug": "vue-advanced",
    "title": "Pinia State Management",
    "order": 6,
    "objectives": [
      "Understand state management and lifecycle",
      "Implement practical solutions"
    ],
    "intro": "Welcome to this comprehensive lesson on State Management.\n\nLearn modern state management with Pinia for Vue 3 applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// stores/counter.js\nimport { defineStore } from 'pinia'\n\nexport const useCounterStore = defineStore('counter', {\n  state: () => ({\n    count: 0,\n    name: 'Eduardo'\n  }),\n  getters: {\n    doubleCount: (state) => state.count * 2\n  },\n  actions: {\n    increment() {\n      this.count++\n    }\n  }\n})\n\n// Component usage\nimport { useCounterStore } from '@/stores/counter'\n\nexport default {\n  setup() {\n    const counter = useCounterStore()\n    return { counter }\n  }\n}",
      "explanation": "This example produces: Centralized state management with reactive stores\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Pinia State Management",
        "description": "Apply the concepts from this lesson on State Management",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "State Management",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 7,
    "moduleSlug": "vue-advanced",
    "title": "Vue Router Navigation",
    "order": 7,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Routing.\n\nLearn client-side routing with Vue Router for single-page applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "import { createRouter, createWebHistory } from 'vue-router'\nimport Home from './views/Home.vue'\nimport About from './views/About.vue'\n\nconst routes = [\n  { path: '/', component: Home },\n  { path: '/about', component: About },\n  { path: '/user/:id', component: UserProfile, props: true }\n]\n\nconst router = createRouter({\n  history: createWebHistory(),\n  routes\n})\n\n// Navigation guards\nrouter.beforeEach((to, from, next) => {\n  console.log('Navigating to:', to.path)\n  next()\n})\n\nexport default router",
      "explanation": "This example produces: Single-page application with dynamic routing and navigation guards\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Vue Router Navigation",
        "description": "Apply the concepts from this lesson on Routing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Routing",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 8,
    "moduleSlug": "vue-advanced",
    "title": "Form Handling and Validation",
    "order": 8,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Forms.\n\nLearn comprehensive form handling with validation in Vue applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<template>\n  <form @submit.prevent=\"submitForm\">\n    <input v-model=\"form.email\" :class=\"{ error: errors.email }\" />\n    <span v-if=\"errors.email\">{{ errors.email }}</span>\n    <button type=\"submit\" :disabled=\"!isValid\">Submit</button>\n  </form>\n</template>\n\n<script setup>\nimport { reactive, computed } from 'vue'\n\nconst form = reactive({\n  email: '',\n  password: ''\n})\n\nconst errors = reactive({})\n\nconst isValid = computed(() => {\n  return form.email && form.password && !Object.keys(errors).length\n})\n\nconst validateEmail = () => {\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/\n  errors.email = emailRegex.test(form.email) ? '' : 'Invalid email'\n}\n</script>",
      "explanation": "This example produces: Reactive form with real-time validation and error handling\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Form Handling and Validation",
        "description": "Apply the concepts from this lesson on Forms",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Forms",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 9,
    "moduleSlug": "vue-advanced",
    "title": "Performance Optimization",
    "order": 9,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Performance.\n\nLearn techniques to optimize Vue application performance.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Lazy loading components\nconst AsyncComponent = defineAsyncComponent(() => import('./HeavyComponent.vue'))\n\n// Memoization with computed\nconst expensiveValue = computed(() => {\n  return heavyCalculation(props.data)\n})\n\n// Virtual scrolling for large lists\n<template>\n  <RecycleScroller\n    class=\"scroller\"\n    :items=\"items\"\n    :item-size=\"32\"\n    key-field=\"id\"\n    v-slot=\"{ item }\"\n  >\n    <div class=\"user\">{{ item.name }}</div>\n  </RecycleScroller>\n</template>",
      "explanation": "This example produces: Optimized application with lazy loading and virtual scrolling\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Performance Optimization",
        "description": "Apply the concepts from this lesson on Performance",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 10,
    "moduleSlug": "vue-advanced",
    "title": "Component Testing",
    "order": 10,
    "objectives": [
      "Master component creation and usage",
      "Implement practical solutions"
    ],
    "intro": "Welcome to this comprehensive lesson on Testing.\n\nLearn how to test Vue components using Vue Test Utils and Vitest.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Counter.test.js\nimport { mount } from '@vue/test-utils'\nimport Counter from '@/components/Counter.vue'\n\ndescribe('Counter', () => {\n  test('increments count when button is clicked', async () => {\n    const wrapper = mount(Counter)\n    \n    expect(wrapper.text()).toContain('0')\n    \n    await wrapper.find('button').trigger('click')\n    \n    expect(wrapper.text()).toContain('1')\n  })\n  \n  test('accepts initial count prop', () => {\n    const wrapper = mount(Counter, {\n      props: { initialCount: 5 }\n    })\n    \n    expect(wrapper.text()).toContain('5')\n  })\n})",
      "explanation": "This example produces: ✓ increments count when button is clicked\n✓ accepts initial count prop\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Component Testing",
        "description": "Apply the concepts from this lesson on Testing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Testing",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 11,
    "moduleSlug": "vue-advanced",
    "title": "Teleport and Portal Patterns",
    "order": 11,
    "objectives": [
      "Master component creation and usage",
      "Implement practical solutions"
    ],
    "intro": "Welcome to this comprehensive lesson on Teleport.\n\nLearn how to use Teleport for rendering components outside the normal DOM hierarchy.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<template>\n  <div>\n    <button @click=\"showModal = true\">Open Modal</button>\n    \n    <Teleport to=\"body\">\n      <div v-if=\"showModal\" class=\"modal\">\n        <div class=\"modal-content\">\n          <h2>Modal Title</h2>\n          <p>Modal content here</p>\n          <button @click=\"showModal = false\">Close</button>\n        </div>\n      </div>\n    </Teleport>\n  </div>\n</template>\n\n<script setup>\nimport { ref } from 'vue'\nconst showModal = ref(false)\n</script>",
      "explanation": "This example produces: Modal component rendered outside component hierarchy using Teleport\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Teleport and Portal Patterns",
        "description": "Apply the concepts from this lesson on Teleport",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Teleport",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 12,
    "moduleSlug": "vue-advanced",
    "title": "Custom Directives and Plugins",
    "order": 12,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Advanced.\n\nLearn how to create custom directives and plugins to extend Vue functionality.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Custom directive\nconst vFocus = {\n  mounted(el) {\n    el.focus()\n  }\n}\n\n// Plugin\nconst myPlugin = {\n  install(app, options) {\n    app.config.globalProperties.$translate = (key) => {\n      return key.split('.').reduce((o, i) => o[i], options)\n    }\n    \n    app.provide('i18n', options)\n    \n    app.directive('focus', vFocus)\n  }\n}\n\n// Usage\napp.use(myPlugin, { hello: 'Bonjour!' })\n\n// In component\n<input v-focus />\n<p>{{ $translate('hello') }}</p>",
      "explanation": "This example produces: Custom functionality with directives and plugins extending Vue capabilities\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Custom Directives and Plugins",
        "description": "Apply the concepts from this lesson on Advanced",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Advanced",
    "tags": [
      "Advanced",
      "vue"
    ],
    "lastUpdated": "2025-10-01T06:41:13.488Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 13,
    "moduleSlug": "vue-advanced",
    "title": "Advanced Component Patterns",
    "order": 13,
    "objectives": [
      "Master advanced component composition patterns",
      "Implement render functions and JSX",
      "Create flexible component APIs with provide/inject"
    ],
    "intro": "Advanced component patterns in Vue enable the creation of highly flexible and reusable components that can adapt to various use cases while maintaining clean APIs. This lesson explores sophisticated techniques that go beyond basic component composition to create powerful, developer-friendly component libraries.\n\nYou'll learn to implement render functions for maximum flexibility, leverage provide/inject for dependency injection, and create component patterns that solve complex UI challenges. These patterns are essential for building design systems, component libraries, and applications with complex component hierarchies.\n\nWe'll explore practical examples including compound components, renderless components, and higher-order components that demonstrate real-world applications of these patterns. You'll also learn when to use each pattern and how to balance flexibility with simplicity.\n\nMastering these advanced patterns will enable you to create components that are not only reusable but also maintainable and easy to work with, even as your application grows in complexity.",
    "code": {
      "example": "// Render function component\nconst DynamicHeading = {\n  props: ['level', 'text'],\n  render() {\n    const tag = `h${this.level}`\n    return h(tag, {\n      class: `heading-${this.level}`\n    }, this.text)\n  }\n}\n\n// Renderless component pattern\nconst DataProvider = {\n  props: ['url'],\n  setup(props, { slots }) {\n    const data = ref(null)\n    const loading = ref(false)\n    const error = ref(null)\n\n    const fetchData = async () => {\n      loading.value = true\n      try {\n        const response = await fetch(props.url)\n        data.value = await response.json()\n      } catch (err) {\n        error.value = err.message\n      } finally {\n        loading.value = false\n      }\n    }\n\n    onMounted(fetchData)\n\n    return () => slots.default({\n      data: data.value,\n      loading: loading.value,\n      error: error.value,\n      refetch: fetchData\n    })\n  }\n}\n\n// Provide/Inject pattern for theme\nconst ThemeProvider = {\n  setup(props, { slots }) {\n    const theme = reactive({\n      primaryColor: '#007bff',\n      secondaryColor: '#6c757d',\n      spacing: {\n        sm: '0.5rem',\n        md: '1rem',\n        lg: '1.5rem'\n      }\n    })\n\n    provide('theme', theme)\n\n    return () => slots.default()\n  }\n}\n\n// Consumer component\nconst ThemedButton = {\n  setup() {\n    const theme = inject('theme')\n\n    const buttonStyle = computed(() => ({\n      backgroundColor: theme.primaryColor,\n      padding: theme.spacing.md,\n      border: 'none',\n      borderRadius: '4px',\n      color: 'white',\n      cursor: 'pointer'\n    }))\n\n    return { buttonStyle }\n  },\n  template: `\n    <button :style=\"buttonStyle\">\n      <slot></slot>\n    </button>\n  `\n}\n\n// Compound component pattern\nconst Card = {\n  name: 'Card',\n  template: `\n    <div class=\"card\">\n      <slot></slot>\n    </div>\n  `\n}\n\nconst CardHeader = {\n  name: 'CardHeader',\n  template: `\n    <div class=\"card-header\">\n      <slot></slot>\n    </div>\n  `\n}\n\nconst CardBody = {\n  name: 'CardBody',\n  template: `\n    <div class=\"card-body\">\n      <slot></slot>\n    </div>\n  `\n}\n\nconst CardFooter = {\n  name: 'CardFooter',\n  template: `\n    <div class=\"card-footer\">\n      <slot></slot>\n    </div>\n  `\n}\n\n// Higher-order component for loading state\nconst withLoading = (WrappedComponent) => {\n  return {\n    props: ['loading', ...Object.keys(WrappedComponent.props || {})],\n    setup(props, context) {\n      const wrappedProps = computed(() => {\n        const { loading, ...rest } = props\n        return rest\n      })\n\n      return () => {\n        if (props.loading) {\n          return h('div', { class: 'loading-spinner' }, 'Loading...')\n        }\n        return h(WrappedComponent, wrappedProps.value, context.slots)\n      }\n    }\n  }\n}\n\n// Usage examples:\n// <theme-provider>\n//   <themed-button>Click me</themed-button>\n// </theme-provider>\n\n// <data-provider url=\"/api/users\" v-slot=\"{ data, loading, error }\">\n//   <div v-if=\"loading\">Loading...</div>\n//   <div v-else-if=\"error\">Error: {{ error }}</div>\n//   <ul v-else>\n//     <li v-for=\"user in data\" :key=\"user.id\">{{ user.name }}</li>\n//   </ul>\n// </data-provider>\n\n// <card>\n//   <card-header>Card Title</card-header>\n//   <card-body>Card content goes here</card-body>\n//   <card-footer>Card footer</card-footer>\n// </card>",
      "explanation": "This example demonstrates advanced Vue component patterns including render functions for dynamic HTML generation, renderless components for logic reuse, provide/inject for dependency injection, compound components for flexible APIs, and higher-order components for cross-cutting concerns like loading states.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Overusing render functions when templates would suffice",
        "solution": "Use render functions only when you need dynamic tag names or complex conditional rendering",
        "severity": "medium"
      },
      {
        "mistake": "Creating overly complex component APIs",
        "solution": "Balance flexibility with simplicity, provide sensible defaults",
        "severity": "medium"
      },
      {
        "mistake": "Not properly typing provide/inject with TypeScript",
        "solution": "Use injection keys and type definitions for better type safety",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Build a Flexible Data Table Component",
        "description": "Create a reusable data table using advanced patterns including compound components for header/body/footer, renderless logic for sorting/filtering, and provide/inject for configuration",
        "checkpoints": [
          "Implement compound component pattern for table structure",
          "Create renderless component for data logic",
          "Use provide/inject for table configuration",
          "Add render function for dynamic cell rendering"
        ]
      }
    ],
    "next": [
      "vue-advanced-lesson-14"
    ],
    "estimatedMinutes": 45,
    "difficulty": "Advanced",
    "tags": [
      "Advanced Patterns",
      "Render Functions",
      "Provide/Inject",
      "Component Design",
      "vue"
    ],
    "lastUpdated": "2025-01-27T10:15:00.000Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 14,
    "moduleSlug": "vue-advanced",
    "title": "Vue 3 Ecosystem and Production Deployment",
    "order": 14,
    "objectives": [
      "Master Vue 3 ecosystem tools and libraries",
      "Implement production-ready build and deployment strategies",
      "Optimize applications for performance and SEO"
    ],
    "intro": "Building production-ready Vue applications requires mastery of the Vue ecosystem and deployment best practices. This comprehensive lesson covers the essential tools, libraries, and strategies needed to take your Vue applications from development to production successfully.\n\nYou'll explore the modern Vue ecosystem including Vite for lightning-fast development and building, Vue Router for sophisticated routing needs, Pinia for state management, and various UI libraries. We'll also cover testing strategies, performance optimization techniques, and SEO considerations for Vue applications.\n\nDeployment strategies vary significantly based on your application needs, from static site generation with Nuxt.js to server-side rendering and traditional SPA deployments. You'll learn to choose the right approach and implement it effectively with proper monitoring and error handling.\n\nBy the end of this lesson, you'll have the knowledge to architect, build, and deploy robust Vue applications that perform well in production environments and provide excellent user experiences across different devices and network conditions.",
    "code": {
      "example": "// vite.config.js - Production optimization\nimport { defineConfig } from 'vite'\nimport vue from '@vitejs/plugin-vue'\nimport { resolve } from 'path'\n\nexport default defineConfig({\n  plugins: [vue()],\n  resolve: {\n    alias: {\n      '@': resolve(__dirname, 'src')\n    }\n  },\n  build: {\n    target: 'esnext',\n    minify: 'terser',\n    terserOptions: {\n      compress: {\n        drop_console: true,\n        drop_debugger: true\n      }\n    },\n    rollupOptions: {\n      output: {\n        manualChunks: {\n          'vendor': ['vue', 'vue-router', 'pinia'],\n          'ui': ['@headlessui/vue', '@heroicons/vue']\n        }\n      }\n    },\n    chunkSizeWarningLimit: 1000\n  },\n  server: {\n    port: 3000,\n    proxy: {\n      '/api': {\n        target: 'http://localhost:8000',\n        changeOrigin: true\n      }\n    }\n  }\n})\n\n// Production-ready router configuration\n// router/index.js\nimport { createRouter, createWebHistory } from 'vue-router'\nimport { useAuthStore } from '@/stores/auth'\n\nconst router = createRouter({\n  history: createWebHistory(import.meta.env.BASE_URL),\n  routes: [\n    {\n      path: '/',\n      name: 'Home',\n      component: () => import('@/views/HomeView.vue'),\n      meta: { requiresAuth: false }\n    },\n    {\n      path: '/dashboard',\n      name: 'Dashboard',\n      component: () => import('@/views/DashboardView.vue'),\n      meta: { requiresAuth: true }\n    },\n    {\n      path: '/login',\n      name: 'Login',\n      component: () => import('@/views/LoginView.vue'),\n      meta: { guest: true }\n    },\n    {\n      path: '/:pathMatch(.*)*',\n      name: 'NotFound',\n      component: () => import('@/views/NotFoundView.vue')\n    }\n  ],\n  scrollBehavior(to, from, savedPosition) {\n    if (savedPosition) {\n      return savedPosition\n    } else {\n      return { top: 0 }\n    }\n  }\n})\n\n// Global navigation guard\nrouter.beforeEach(async (to, from, next) => {\n  const authStore = useAuthStore()\n  \n  // Check if route requires authentication\n  if (to.meta.requiresAuth && !authStore.isAuthenticated) {\n    next({ name: 'Login', query: { redirect: to.fullPath } })\n    return\n  }\n  \n  // Redirect authenticated users away from guest-only pages\n  if (to.meta.guest && authStore.isAuthenticated) {\n    next({ name: 'Dashboard' })\n    return\n  }\n  \n  next()\n})\n\nexport default router\n\n// Production-ready Pinia store\n// stores/auth.js\nimport { defineStore } from 'pinia'\nimport { ref, computed } from 'vue'\nimport api from '@/services/api'\n\nexport const useAuthStore = defineStore('auth', () => {\n  const user = ref(null)\n  const token = ref(localStorage.getItem('token'))\n  const isLoading = ref(false)\n  const error = ref(null)\n\n  const isAuthenticated = computed(() => !!token.value && !!user.value)\n\n  const login = async (credentials) => {\n    isLoading.value = true\n    error.value = null\n    \n    try {\n      const response = await api.post('/auth/login', credentials)\n      const { token: authToken, user: userData } = response.data\n      \n      token.value = authToken\n      user.value = userData\n      localStorage.setItem('token', authToken)\n      \n      return { success: true }\n    } catch (err) {\n      error.value = err.response?.data?.message || 'Login failed'\n      return { success: false, error: error.value }\n    } finally {\n      isLoading.value = false\n    }\n  }\n\n  const logout = () => {\n    user.value = null\n    token.value = null\n    localStorage.removeItem('token')\n  }\n\n  const checkAuth = async () => {\n    if (!token.value) return\n\n    try {\n      const response = await api.get('/auth/me')\n      user.value = response.data\n    } catch (err) {\n      logout()\n    }\n  }\n\n  return {\n    user: readonly(user),\n    token: readonly(token),\n    isLoading: readonly(isLoading),\n    error: readonly(error),\n    isAuthenticated,\n    login,\n    logout,\n    checkAuth\n  }\n})\n\n// Error boundary composable\n// composables/useErrorHandler.js\nimport { ref, onErrorCaptured } from 'vue'\n\nexport function useErrorHandler() {\n  const error = ref(null)\n  const isError = ref(false)\n\n  const handleError = (err) => {\n    error.value = err\n    isError.value = true\n    \n    // Log to external service\n    if (import.meta.env.PROD) {\n      console.error('Production error:', err)\n      // Send to error tracking service\n      // Sentry.captureException(err)\n    }\n  }\n\n  const clearError = () => {\n    error.value = null\n    isError.value = false\n  }\n\n  onErrorCaptured((err) => {\n    handleError(err)\n    return false\n  })\n\n  return {\n    error: readonly(error),\n    isError: readonly(isError),\n    handleError,\n    clearError\n  }\n}\n\n// Docker deployment configuration\n# Dockerfile\nFROM node:18-alpine AS build\n\nWORKDIR /app\nCOPY package*.json ./\nRUN npm ci --only=production\n\nCOPY . .\nRUN npm run build\n\nFROM nginx:alpine AS production\nCOPY --from=build /app/dist /usr/share/nginx/html\nCOPY nginx.conf /etc/nginx/nginx.conf\n\nEXPOSE 80\nCMD [\"nginx\", \"-g\", \"daemon off;\"]",
      "explanation": "This comprehensive example shows production-ready Vue 3 application setup including Vite configuration for optimized builds, router with authentication guards, Pinia store with error handling, error boundary composable, and Docker deployment configuration for scalable production deployment.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not implementing proper error boundaries",
        "solution": "Use error boundaries and global error handlers to gracefully handle runtime errors",
        "severity": "high"
      },
      {
        "mistake": "Ignoring bundle size optimization",
        "solution": "Implement code splitting, tree shaking, and analyze bundle sizes regularly",
        "severity": "medium"
      },
      {
        "mistake": "Not setting up proper monitoring and logging",
        "solution": "Implement error tracking, performance monitoring, and user analytics",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Deploy a Production-Ready Vue Application",
        "description": "Create a complete Vue application with authentication, error handling, performance optimization, and deploy it using modern CI/CD practices",
        "checkpoints": [
          "Set up Vite with production optimizations",
          "Implement authentication with Pinia",
          "Add error boundaries and monitoring",
          "Configure Docker deployment with Nginx",
          "Set up CI/CD pipeline for automated deployment"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 50,
    "difficulty": "Advanced",
    "tags": [
      "Ecosystem",
      "Deployment",
      "Production",
      "Vite",
      "Performance",
      "vue"
    ],
    "lastUpdated": "2025-01-27T10:15:00.000Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 15,
    "moduleSlug": "vue-advanced",
    "title": "Advanced Composition API Patterns",
    "order": 15,
    "objectives": [
      "Master advanced Composition API patterns and best practices",
      "Implement reactive patterns with ref, reactive, and computed",
      "Create reusable composables for complex logic",
      "Optimize performance with proper reactivity management"
    ],
    "intro": "The Composition API in Vue 3 provides powerful tools for organizing and reusing component logic, but mastering its advanced patterns requires understanding the underlying reactivity system and best practices. This comprehensive lesson explores sophisticated Composition API techniques that enable developers to create highly maintainable and performant Vue applications.\n\nYou'll learn to implement complex reactive patterns using ref, reactive, and computed properties effectively, create reusable composables that encapsulate sophisticated logic, and optimize performance through proper reactivity management. We'll explore advanced patterns for handling asynchronous operations, managing complex state, and creating flexible APIs.\n\nThe lesson covers practical implementation strategies for organizing large-scale applications, managing side effects, and creating type-safe composables with TypeScript. You'll discover how to balance reusability with specificity, implement proper error handling, and optimize composables for performance.\n\nBy mastering advanced Composition API patterns, you'll be able to create Vue applications with clean, organized code that scales effectively and provides excellent developer experience.",
    "code": {
      "example": "// Advanced Composition API Patterns\n\n// Reusable composable for complex async operations\n// composables/useAsyncOperation.js\nimport { ref, computed, watch } from 'vue'\n\nexport function useAsyncOperation(operation, options = {}) {\n  const { \n    immediate = false, \n    resetOnExecute = true,\n    defaultData = null \n  } = options\n  \n  const data = ref(defaultData)\n  const loading = ref(false)\n  const error = ref(null)\n  const executed = ref(false)\n  \n  const isSuccess = computed(() => executed.value && !loading.value && !error.value)\n  const isError = computed(() => executed.value && !loading.value && error.value)\n  \n  let abortController = null\n  \n  const execute = async (...args) => {\n    if (loading.value && abortController) {\n      abortController.abort()\n    }\n    \n    if (resetOnExecute) {\n      data.value = defaultData\n      error.value = null\n    }\n    \n    loading.value = true\n    executed.value = true\n    abortController = new AbortController()\n    \n    try {\n      const result = await operation(...args, { signal: abortController.signal })\n      data.value = result\n      return result\n    } catch (err) {\n      if (err.name !== 'AbortError') {\n        error.value = err\n        console.error('Async operation failed:', err)\n      }\n      throw err\n    } finally {\n      loading.value = false\n      abortController = null\n    }\n  }\n  \n  const reset = () => {\n    data.value = defaultData\n    loading.value = false\n    error.value = null\n    executed.value = false\n  }\n  \n  // Execute immediately if requested\n  if (immediate) {\n    execute()\n  }\n  \n  // Cleanup on unmount\n  const cleanup = () => {\n    if (abortController) {\n      abortController.abort()\n    }\n  }\n  \n  return {\n    data: readonly(data),\n    loading: readonly(loading),\n    error: readonly(error),\n    executed: readonly(executed),\n    isSuccess: readonly(isSuccess),\n    isError: readonly(isError),\n    execute,\n    reset,\n    cleanup\n  }\n}\n\n// Composable for managing complex form state\n// composables/useForm.js\nimport { reactive, computed, watch } from 'vue'\n\nexport function useForm(initialValues = {}, validationRules = {}) {\n  const form = reactive({\n    values: { ...initialValues },\n    errors: {},\n    touched: {},\n    isSubmitting: false,\n    submitCount: 0\n  })\n  \n  const isValid = computed(() => {\n    return Object.keys(form.errors).length === 0 && \n           Object.keys(validationRules).every(field => !form.errors[field])\n  })\n  \n  const isDirty = computed(() => {\n    return Object.keys(form.values).some(key => \n      form.values[key] !== initialValues[key]\n    )\n  })\n  \n  const setFieldValue = (field, value) => {\n    form.values[field] = value\n    form.touched[field] = true\n    \n    // Validate field if rules exist\n    if (validationRules[field]) {\n      const error = validationRules[field](value, form.values)\n      if (error) {\n        form.errors[field] = error\n      } else {\n        delete form.errors[field]\n      }\n    }\n  }\n  \n  const setFieldError = (field, error) => {\n    if (error) {\n      form.errors[field] = error\n    } else {\n      delete form.errors[field]\n    }\n  }\n  \n  const validateField = (field) => {\n    if (validationRules[field]) {\n      const error = validationRules[field](form.values[field], form.values)\n      setFieldError(field, error)\n      return !error\n    }\n    return true\n  }\n  \n  const validateForm = () => {\n    let isValid = true\n    Object.keys(validationRules).forEach(field => {\n      const isFieldValid = validateField(field)\n      if (!isFieldValid) isValid = false\n    })\n    return isValid\n  }\n  \n  const handleSubmit = async (onSubmit) => {\n    form.submitCount++\n    \n    // Mark all fields as touched\n    Object.keys(form.values).forEach(field => {\n      form.touched[field] = true\n    })\n    \n    // Validate form\n    const isFormValid = validateForm()\n    if (!isFormValid) return false\n    \n    form.isSubmitting = true\n    \n    try {\n      await onSubmit(form.values)\n      return true\n    } catch (error) {\n      console.error('Form submission error:', error)\n      return false\n    } finally {\n      form.isSubmitting = false\n    }\n  }\n  \n  const resetForm = () => {\n    Object.keys(form.values).forEach(key => {\n      form.values[key] = initialValues[key]\n    })\n    form.errors = {}\n    form.touched = {}\n    form.isSubmitting = false\n    form.submitCount = 0\n  }\n  \n  return {\n    form: readonly(form),\n    isValid: readonly(isValid),\n    isDirty: readonly(isDirty),\n    setFieldValue,\n    setFieldError,\n    validateField,\n    validateForm,\n    handleSubmit,\n    resetForm\n  }\n}\n\n// Usage examples:\n// In a component\n// import { useAsyncOperation, useForm } from '@/composables'\n// \n// const { data, loading, error, execute } = useAsyncOperation(\n//   (id) => fetch(`/api/users/${id}`),\n//   { immediate: true, defaultData: {} }\n// )\n// \n// const { form, isValid, handleSubmit } = useForm(\n//   { name: '', email: '', age: '' },\n//   {\n//     name: (value) => !value ? 'Name is required' : null,\n//     email: (value) => !value ? 'Email is required' : \n//             !/^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value) ? 'Invalid email' : null,\n//     age: (value) => value && (value < 18 || value > 120) ? 'Age must be between 18 and 120' : null\n//   }\n// )\n// \n// const onSubmit = async (values) => {\n//   const success = await handleSubmit(async (formData) => {\n//     await fetch('/api/users', {\n//       method: 'POST',\n//       headers: { 'Content-Type': 'application/json' },\n//       body: JSON.stringify(formData)\n//     })\n//   })\n//   \n//   if (success) {\n//     console.log('Form submitted successfully')\n//   }\n// }",
      "explanation": "This example demonstrates advanced Composition API patterns including:\n\n1. A reusable composable for complex async operations with abort capability\n2. A comprehensive form management composable with validation\n3. Proper reactivity management with readonly returns\n4. Cleanup functions for proper resource management\n5. TypeScript-friendly APIs with clear return types\n\nThese patterns enable developers to create highly reusable, maintainable logic that can be shared across components while maintaining proper reactivity and performance.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating overly generic composables that are hard to use",
        "solution": "Balance reusability with specificity, provide clear documentation and examples",
        "severity": "medium"
      },
      {
        "mistake": "Not properly managing reactivity which leads to performance issues",
        "solution": "Use readonly returns, avoid unnecessary reactivity, and optimize computed properties",
        "severity": "high"
      },
      {
        "mistake": "Forgetting to clean up side effects like event listeners or intervals",
        "solution": "Implement cleanup functions and use onUnmounted lifecycle hook",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build Advanced Composables",
        "description": "Create sophisticated composables for common patterns like pagination, search, and data synchronization",
        "checkpoints": [
          "Implement a pagination composable with loading states",
          "Create a search composable with debouncing and caching",
          "Build a data synchronization composable with offline support",
          "Optimize composables for performance and memory usage"
        ]
      }
    ],
    "next": [
      "vue-lesson-16-state-management"
    ],
    "estimatedMinutes": 50,
    "difficulty": "Advanced",
    "tags": [
      "Composition API",
      "Composables",
      "Reactivity",
      "Performance",
      "Vue 3"
    ],
    "lastUpdated": "2025-10-03T10:00:00Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 16,
    "moduleSlug": "vue-advanced",
    "title": "Advanced State Management with Pinia",
    "order": 16,
    "objectives": [
      "Master advanced Pinia patterns for complex state management",
      "Implement modular store architectures with proper separation of concerns",
      "Create type-safe stores with TypeScript integration",
      "Optimize store performance and handle large-scale state"
    ],
    "intro": "Advanced state management with Pinia goes beyond basic store creation to encompass sophisticated patterns for managing complex application state at scale. This comprehensive lesson explores advanced techniques for organizing stores, handling asynchronous operations, and optimizing performance in large Vue applications.\n\nYou'll learn to implement modular store architectures that maintain clear separation of concerns, create type-safe stores with comprehensive TypeScript integration, and optimize store performance for large-scale applications. We'll explore advanced patterns for handling complex state transitions, managing side effects, and creating reusable store logic.\n\nThe lesson covers practical implementation strategies for organizing large store hierarchies, implementing proper error handling, and creating stores that integrate seamlessly with Vue's reactivity system. You'll discover how to balance centralized state management with component-local state, implement proper store testing strategies, and optimize stores for performance.\n\nBy mastering advanced state management patterns, you'll be able to create Vue applications with predictable state management that scales effectively and provides excellent developer experience.",
    "code": {
      "example": "// Advanced Pinia State Management Patterns\n\n// Modular store with namespaced modules\n// stores/user.js\nimport { defineStore } from 'pinia'\nimport { ref, computed, reactive } from 'vue'\nimport api from '@/services/api'\n\nexport const useUserStore = defineStore('user', () => {\n  // State\n  const currentUser = ref(null)\n  const users = ref([])\n  const loading = reactive({\n    fetch: false,\n    create: false,\n    update: false,\n    delete: false\n  })\n  const error = ref(null)\n  \n  // Getters\n  const isAuthenticated = computed(() => !!currentUser.value)\n  const userCount = computed(() => users.value.length)\n  const getUserById = computed(() => (id) => {\n    return users.value.find(user => user.id === id)\n  })\n  \n  // Actions\n  const fetchUsers = async () => {\n    loading.fetch = true\n    error.value = null\n    \n    try {\n      const response = await api.get('/users')\n      users.value = response.data\n    } catch (err) {\n      error.value = err.message\n      console.error('Failed to fetch users:', err)\n    } finally {\n      loading.fetch = false\n    }\n  }\n  \n  const fetchUser = async (id) => {\n    loading.fetch = true\n    error.value = null\n    \n    try {\n      const response = await api.get(`/users/${id}`)\n      const user = response.data\n      \n      // Update or add user to list\n      const index = users.value.findIndex(u => u.id === id)\n      if (index !== -1) {\n        users.value[index] = user\n      } else {\n        users.value.push(user)\n      }\n      \n      return user\n    } catch (err) {\n      error.value = err.message\n      console.error(`Failed to fetch user ${id}:`, err)\n      throw err\n    } finally {\n      loading.fetch = false\n    }\n  }\n  \n  const createUser = async (userData) => {\n    loading.create = true\n    error.value = null\n    \n    try {\n      const response = await api.post('/users', userData)\n      const newUser = response.data\n      users.value.push(newUser)\n      \n      // If this is the first user or we're registering, set as current\n      if (!currentUser.value || userData.isRegistering) {\n        currentUser.value = newUser\n      }\n      \n      return newUser\n    } catch (err) {\n      error.value = err.message\n      console.error('Failed to create user:', err)\n      throw err\n    } finally {\n      loading.create = false\n    }\n  }\n  \n  const updateUser = async (id, userData) => {\n    loading.update = true\n    error.value = null\n    \n    try {\n      const response = await api.put(`/users/${id}`, userData)\n      const updatedUser = response.data\n      \n      // Update in list\n      const index = users.value.findIndex(u => u.id === id)\n      if (index !== -1) {\n        users.value[index] = updatedUser\n      }\n      \n      // Update current user if it's the same\n      if (currentUser.value && currentUser.value.id === id) {\n        currentUser.value = updatedUser\n      }\n      \n      return updatedUser\n    } catch (err) {\n      error.value = err.message\n      console.error(`Failed to update user ${id}:`, err)\n      throw err\n    } finally {\n      loading.update = false\n    }\n  }\n  \n  const deleteUser = async (id) => {\n    loading.delete = true\n    error.value = null\n    \n    try {\n      await api.delete(`/users/${id}`)\n      \n      // Remove from list\n      const index = users.value.findIndex(u => u.id === id)\n      if (index !== -1) {\n        users.value.splice(index, 1)\n      }\n      \n      // Clear current user if it's the same\n      if (currentUser.value && currentUser.value.id === id) {\n        currentUser.value = null\n      }\n    } catch (err) {\n      error.value = err.message\n      console.error(`Failed to delete user ${id}:`, err)\n      throw err\n    } finally {\n      loading.delete = false\n    }\n  }\n  \n  const login = async (credentials) => {\n    try {\n      const response = await api.post('/auth/login', credentials)\n      const { user, token } = response.data\n      \n      currentUser.value = user\n      localStorage.setItem('authToken', token)\n      \n      return user\n    } catch (err) {\n      error.value = err.message\n      console.error('Login failed:', err)\n      throw err\n    }\n  }\n  \n  const logout = () => {\n    currentUser.value = null\n    localStorage.removeItem('authToken')\n    \n    // Optionally clear other user-related data\n    users.value = []\n  }\n  \n  const $reset = () => {\n    currentUser.value = null\n    users.value = []\n    Object.keys(loading).forEach(key => loading[key] = false)\n    error.value = null\n  }\n  \n  return {\n    // State\n    currentUser: readonly(currentUser),\n    users: readonly(users),\n    loading: readonly(loading),\n    error: readonly(error),\n    \n    // Getters\n    isAuthenticated: readonly(isAuthenticated),\n    userCount: readonly(userCount),\n    getUserById: readonly(getUserById),\n    \n    // Actions\n    fetchUsers,\n    fetchUser,\n    createUser,\n    updateUser,\n    deleteUser,\n    login,\n    logout,\n    $reset\n  }\n})\n\n// Store with persistence plugin\n// stores/settings.js\nimport { defineStore } from 'pinia'\nimport { ref, watch } from 'vue'\n\nexport const useSettingsStore = defineStore('settings', () => {\n  // State\n  const theme = ref(localStorage.getItem('theme') || 'light')\n  const language = ref(localStorage.getItem('language') || 'en')\n  const notifications = ref(JSON.parse(localStorage.getItem('notifications') || 'true'))\n  \n  // Persist settings to localStorage\n  watch(theme, (newTheme) => {\n    localStorage.setItem('theme', newTheme)\n    document.documentElement.setAttribute('data-theme', newTheme)\n  })\n  \n  watch(language, (newLanguage) => {\n    localStorage.setItem('language', newLanguage)\n  })\n  \n  watch(notifications, (newNotifications) => {\n    localStorage.setItem('notifications', JSON.stringify(newNotifications))\n  })\n  \n  // Actions\n  const setTheme = (newTheme) => {\n    theme.value = newTheme\n  }\n  \n  const setLanguage = (newLanguage) => {\n    language.value = newLanguage\n  }\n  \n  const setNotifications = (enabled) => {\n    notifications.value = enabled\n  }\n  \n  const $reset = () => {\n    theme.value = 'light'\n    language.value = 'en'\n    notifications.value = true\n  }\n  \n  return {\n    // State\n    theme: readonly(theme),\n    language: readonly(language),\n    notifications: readonly(notifications),\n    \n    // Actions\n    setTheme,\n    setLanguage,\n    setNotifications,\n    $reset\n  }\n})\n\n// Usage examples:\n// In a component\n// import { useUserStore, useSettingsStore } from '@/stores'\n// \n// const userStore = useUserStore()\n// const settingsStore = useSettingsStore()\n// \n// // Fetch users on component mount\n// onMounted(() => {\n//   userStore.fetchUsers()\n// })\n// \n// // Reactive computed properties\n// const users = computed(() => userStore.users)\n// const isLoading = computed(() => userStore.loading.fetch)\n// const currentUser = computed(() => userStore.currentUser)\n// \n// // Actions\n// const handleLogin = async (credentials) => {\n//   try {\n//     await userStore.login(credentials)\n//     router.push('/dashboard')\n//   } catch (error) {\n//     // Handle login error\n//     console.error('Login failed:', error)\n//   }\n// }\n// \n// const handleThemeChange = (newTheme) => {\n//   settingsStore.setTheme(newTheme)\n// }",
      "explanation": "This example demonstrates advanced Pinia state management patterns including:\n\n1. A comprehensive user store with CRUD operations and loading states\n2. A settings store with automatic persistence to localStorage\n3. Proper error handling and state management\n4. Reactive getters and computed properties\n5. TypeScript-friendly APIs with clear return types\n6. Store reset functionality for testing and cleanup\n\nThese patterns enable developers to create robust, scalable state management solutions that integrate seamlessly with Vue's reactivity system.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Putting too much logic in stores instead of keeping them focused on state management",
        "solution": "Keep stores focused on state, use composables for complex logic, and implement proper separation of concerns",
        "severity": "medium"
      },
      {
        "mistake": "Not handling asynchronous operations properly in stores",
        "solution": "Implement proper loading states, error handling, and cancellation patterns for async operations",
        "severity": "high"
      },
      {
        "mistake": "Creating stores that are too large and hard to maintain",
        "solution": "Break large stores into smaller, focused modules and use store composition patterns",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build a Comprehensive Store Architecture",
        "description": "Create a modular store architecture with proper separation of concerns and advanced features",
        "checkpoints": [
          "Implement a user store with authentication and CRUD operations",
          "Create a settings store with persistence and reactive updates",
          "Build a cart store with complex state management",
          "Implement proper error handling and loading states",
          "Add store testing and reset functionality"
        ]
      }
    ],
    "next": [
      "vue-lesson-17-routing-navigation"
    ],
    "estimatedMinutes": 55,
    "difficulty": "Advanced",
    "tags": [
      "Pinia",
      "State Management",
      "Stores",
      "Persistence",
      "Vue 3"
    ],
    "lastUpdated": "2025-10-03T10:00:00Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 17,
    "moduleSlug": "vue-advanced",
    "title": "Advanced Routing and Navigation Patterns",
    "order": 17,
    "objectives": [
      "Master advanced Vue Router patterns for complex applications",
      "Implement sophisticated route guards and navigation controls",
      "Create dynamic route configurations with nested routes",
      "Optimize routing performance and handle route transitions"
    ],
    "intro": "Advanced routing and navigation patterns in Vue Router enable developers to create sophisticated single-page applications with complex navigation flows and precise route control. This comprehensive lesson explores advanced techniques for managing route transitions, implementing sophisticated authentication flows, and optimizing routing performance.\n\nYou'll learn to implement complex route guard patterns that handle authentication, authorization, and data loading requirements, create dynamic route configurations with nested routes and route metadata, and optimize routing performance through lazy loading and route splitting. We'll explore advanced patterns for handling route transitions, managing scroll behavior, and creating accessible navigation experiences.\n\nThe lesson covers practical implementation strategies for organizing large route hierarchies, implementing proper error handling for routing failures, and creating routes that integrate seamlessly with state management systems. You'll discover how to balance client-side routing with server-side requirements, implement proper route testing strategies, and optimize routes for performance and SEO.\n\nBy mastering advanced routing and navigation patterns, you'll be able to create Vue applications with sophisticated navigation flows that provide excellent user experience and maintain clean, organized code.",
    "code": {
      "example": "// Advanced Vue Router Patterns\n\n// Router configuration with advanced features\n// router/index.js\nimport { createRouter, createWebHistory } from 'vue-router'\nimport { useAuthStore } from '@/stores/auth'\nimport { useLayoutStore } from '@/stores/layout'\n\n// Dynamic route imports for code splitting\nconst HomeView = () => import('@/views/HomeView.vue')\nconst DashboardView = () => import('@/views/DashboardView.vue')\nconst ProfileView = () => import('@/views/ProfileView.vue')\nconst SettingsView = () => import('@/views/SettingsView.vue')\nconst AdminView = () => import('@/views/AdminView.vue')\nconst NotFoundView = () => import('@/views/NotFoundView.vue')\nconst LoginView = () => import('@/views/LoginView.vue')\n\n// Route metadata for advanced control\nconst routes = [\n  {\n    path: '/',\n    name: 'Home',\n    component: HomeView,\n    meta: {\n      title: 'Home',\n      layout: 'default',\n      requiresAuth: false,\n      transition: 'fade'\n    }\n  },\n  {\n    path: '/dashboard',\n    name: 'Dashboard',\n    component: DashboardView,\n    meta: {\n      title: 'Dashboard',\n      layout: 'dashboard',\n      requiresAuth: true,\n      roles: ['user', 'admin'],\n      transition: 'slide-left',\n      breadcrumb: 'Dashboard'\n    },\n    children: [\n      {\n        path: 'profile',\n        name: 'Profile',\n        component: ProfileView,\n        meta: {\n          title: 'Profile',\n          layout: 'dashboard',\n          requiresAuth: true,\n          roles: ['user', 'admin'],\n          transition: 'slide-up',\n          breadcrumb: 'Profile'\n        }\n      },\n      {\n        path: 'settings',\n        name: 'Settings',\n        component: SettingsView,\n        meta: {\n          title: 'Settings',\n          layout: 'dashboard',\n          requiresAuth: true,\n          roles: ['user', 'admin'],\n          transition: 'slide-up',\n          breadcrumb: 'Settings'\n        }\n      }\n    ]\n  },\n  {\n    path: '/admin',\n    name: 'Admin',\n    component: AdminView,\n    meta: {\n      title: 'Admin Panel',\n      layout: 'admin',\n      requiresAuth: true,\n      roles: ['admin'],\n      transition: 'slide-left',\n      breadcrumb: 'Admin'\n    },\n    beforeEnter: (to, from, next) => {\n      // Route-specific guard\n      const authStore = useAuthStore()\n      if (authStore.user?.role === 'admin') {\n        next()\n      } else {\n        next({ name: 'Home' })\n      }\n    }\n  },\n  {\n    path: '/login',\n    name: 'Login',\n    component: LoginView,\n    meta: {\n      title: 'Login',\n      layout: 'auth',\n      requiresAuth: false,\n      guestOnly: true,\n      transition: 'fade'\n    },\n    beforeEnter: (to, from, next) => {\n      // Redirect if already logged in\n      const authStore = useAuthStore()\n      if (authStore.isAuthenticated) {\n        const redirect = from.query.redirect || '/dashboard'\n        next(redirect)\n      } else {\n        next()\n      }\n    }\n  },\n  {\n    path: '/:pathMatch(.*)*',\n    name: 'NotFound',\n    component: NotFoundView,\n    meta: {\n      title: 'Page Not Found',\n      layout: 'default',\n      requiresAuth: false,\n      transition: 'fade'\n    }\n  }\n]\n\nconst router = createRouter({\n  history: createWebHistory(import.meta.env.BASE_URL),\n  routes,\n  scrollBehavior(to, from, savedPosition) {\n    // Handle scroll behavior\n    if (savedPosition) {\n      return savedPosition\n    } else if (to.hash) {\n      return {\n        el: to.hash,\n        behavior: 'smooth'\n      }\n    } else {\n      return { top: 0 }\n    }\n  }\n})\n\n// Global before guard\nrouter.beforeEach(async (to, from, next) => {\n  // Update loading state\n  const layoutStore = useLayoutStore()\n  layoutStore.setLoading(true)\n  \n  try {\n    // Check authentication requirements\n    const authStore = useAuthStore()\n    \n    // Redirect logged-in users away from guest-only pages\n    if (to.meta.guestOnly && authStore.isAuthenticated) {\n      next({ name: 'Dashboard' })\n      return\n    }\n    \n    // Check authentication for protected routes\n    if (to.meta.requiresAuth && !authStore.isAuthenticated) {\n      next({\n        name: 'Login',\n        query: { redirect: to.fullPath }\n      })\n      return\n    }\n    \n    // Check role-based access\n    if (to.meta.roles && authStore.user) {\n      const userRole = authStore.user.role\n      if (!to.meta.roles.includes(userRole)) {\n        next({ name: 'Home' })\n        return\n      }\n    }\n    \n    // Load required data\n    if (to.meta.loadData) {\n      await to.meta.loadData(to, from)\n    }\n    \n    next()\n  } catch (error) {\n    console.error('Navigation guard error:', error)\n    next({ name: 'Home' })\n  }\n})\n\n// Global after guard\nrouter.afterEach((to, from) => {\n  // Update page title\n  document.title = to.meta.title ? `${to.meta.title} - MyApp` : 'MyApp'\n  \n  // Update loading state\n  const layoutStore = useLayoutStore()\n  layoutStore.setLoading(false)\n  \n  // Track page view\n  if (import.meta.env.PROD) {\n    // Analytics tracking\n    // analytics.trackPageView(to.path, to.meta.title)\n  }\n  \n  // Update layout\n  const layoutStore = useLayoutStore()\n  layoutStore.setLayout(to.meta.layout || 'default')\n})\n\n// Global error handler\nrouter.onError((error) => {\n  console.error('Router error:', error)\n  \n  // Handle chunk loading errors (useful for hot reloading)\n  if (error.name === 'ChunkLoadError') {\n    window.location.reload()\n  }\n})\n\nexport default router\n\n// Composable for route management\n// composables/useRouteManager.js\nimport { useRouter, useRoute } from 'vue-router'\nimport { computed, ref } from 'vue'\n\nexport function useRouteManager() {\n  const router = useRouter()\n  const route = useRoute()\n  \n  // Breadcrumb navigation\n  const breadcrumbs = computed(() => {\n    const breadcrumbs = []\n    let matched = route.matched\n    \n    for (let i = 0; i < matched.length; i++) {\n      const record = matched[i]\n      if (record.meta.breadcrumb) {\n        breadcrumbs.push({\n          title: record.meta.breadcrumb,\n          path: record.path,\n          active: i === matched.length - 1\n        })\n      }\n    }\n    \n    return breadcrumbs\n  })\n  \n  // Navigation history\n  const navigationHistory = ref([])\n  \n  const navigateTo = async (location, options = {}) {\n    try {\n      // Add to history\n      navigationHistory.value.push({\n        path: route.path,\n        timestamp: Date.now()\n      })\n      \n      // Navigate\n      await router.push(location)\n      \n      // Limit history size\n      if (navigationHistory.value.length > 50) {\n        navigationHistory.value.shift()\n      }\n    } catch (error) {\n      console.error('Navigation failed:', error)\n      throw error\n    }\n  }\n  \n  const goBack = () => {\n    if (navigationHistory.value.length > 0) {\n      const lastRoute = navigationHistory.value.pop()\n      router.push(lastRoute.path)\n    } else {\n      router.back()\n    }\n  }\n  \n  const canGoBack = computed(() => navigationHistory.value.length > 0)\n  \n  return {\n    breadcrumbs: readonly(breadcrumbs),\n    navigationHistory: readonly(navigationHistory),\n    navigateTo,\n    goBack,\n    canGoBack\n  }\n}\n\n// Usage examples:\n// In a component\n// import { useRouteManager } from '@/composables'\n// \n// const { breadcrumbs, navigateTo, goBack, canGoBack } = useRouteManager()\n// \n// const handleNavigation = async (path) => {\n//   try {\n//     await navigateTo(path)\n//   } catch (error) {\n//     console.error('Navigation failed:', error)\n//   }\n// }\n// \n// // In template\n// // <nav>\n// //   <ol class=\"breadcrumb\">\n// //     <li v-for=\"crumb in breadcrumbs\" :key=\"crumb.path\">\n// //       <router-link v-if=\"!crumb.active\" :to=\"crumb.path\">\n// //         {{ crumb.title }}\n// //       </router-link>\n// //       <span v-else>{{ crumb.title }}</span>\n// //     </li>\n// //   </ol>\n// // </nav>",
      "explanation": "This example demonstrates advanced Vue Router patterns including:\n\n1. Dynamic route imports for code splitting and lazy loading\n2. Comprehensive route metadata for advanced control\n3. Nested routes with proper hierarchy\n4. Global and route-specific navigation guards\n5. Scroll behavior management\n6. Route error handling\n7. Breadcrumb navigation composable\n8. Navigation history management\n\nThese patterns enable developers to create sophisticated routing solutions that provide excellent user experience while maintaining clean, organized code.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating overly complex route configurations that are hard to maintain",
        "solution": "Organize routes logically, use route metadata for control, and implement proper documentation",
        "severity": "medium"
      },
      {
        "mistake": "Not handling navigation failures gracefully",
        "solution": "Implement proper error handling in navigation guards and provide user feedback",
        "severity": "high"
      },
      {
        "mistake": "Ignoring SEO and accessibility considerations in routing",
        "solution": "Implement proper page titles, meta tags, and accessible navigation patterns",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Advanced Routing Patterns",
        "description": "Create a comprehensive routing system with advanced features and proper error handling",
        "checkpoints": [
          "Implement dynamic route imports and code splitting",
          "Create nested routes with proper metadata",
          "Build sophisticated navigation guards",
          "Add breadcrumb navigation and history management",
          "Implement proper error handling and SEO optimization"
        ]
      }
    ],
    "next": [
      "vue-lesson-18-testing-strategies"
    ],
    "estimatedMinutes": 55,
    "difficulty": "Advanced",
    "tags": [
      "Vue Router",
      "Routing",
      "Navigation",
      "Guards",
      "Performance",
      "Vue 3"
    ],
    "lastUpdated": "2025-10-03T10:00:00Z",
    "version": "1.0.0",
    "sources": []
  },
  {
    "id": 18,
    "moduleSlug": "vue-advanced",
    "title": "Advanced Testing Strategies",
    "order": 18,
    "objectives": [
      "Master advanced testing patterns for Vue components and composables",
      "Implement comprehensive test coverage with Vitest and Vue Test Utils",
      "Create effective mocking strategies for complex dependencies",
      "Optimize test performance and maintainability"
    ],
    "intro": "Advanced testing strategies in Vue applications go beyond basic component testing to encompass comprehensive coverage of complex application logic, state management, and integration scenarios. This comprehensive lesson explores sophisticated testing techniques that ensure application reliability and maintainability at scale.\n\nYou'll learn to implement advanced testing patterns for Vue components, composables, and stores, create effective mocking strategies for complex dependencies like APIs and third-party libraries, and optimize test performance and maintainability through proper organization and tooling. We'll explore advanced patterns for testing asynchronous operations, handling complex state transitions, and ensuring proper integration between application layers.\n\nThe lesson covers practical implementation strategies for organizing large test suites, implementing proper test data management, and creating tests that provide meaningful coverage while remaining maintainable. You'll discover how to balance test coverage with development velocity, implement proper continuous integration testing, and optimize tests for performance.\n\nBy mastering advanced testing strategies, you'll be able to create Vue applications with high confidence in their correctness and reliability, enabling faster development cycles and reduced bug rates.",
    "code": {
      "example": "// Advanced Testing Strategies for Vue Applications\n\n// Comprehensive component testing with complex interactions\n// tests/components/UserProfile.test.js\nimport { mount, flushPromises } from '@vue/test-utils'\nimport { createTestingPinia } from '@pinia/testing'\nimport { useUserStore } from '@/stores/user'\nimport UserProfile from '@/components/UserProfile.vue'\n\ndescribe('UserProfile', () => {\n  let wrapper\n  let userStore\n  \n  // Setup testing environment\n  beforeEach(() => {\n    wrapper = mount(UserProfile, {\n      global: {\n        plugins: [\n          createTestingPinia({\n            initialState: {\n              user: {\n                currentUser: {\n                  id: 1,\n                  name: 'John Doe',\n                  email: 'john@example.com',\n                  role: 'user'\n                }\n              }\n            },\n            stubActions: false // Allow actions to be called\n          })\n        ]\n      },\n      props: {\n        userId: 1\n      }\n    })\n    \n    userStore = useUserStore()\n  })\n  \n  afterEach(() => {\n    wrapper.unmount()\n    vi.restoreAllMocks()\n  })\n  \n  it('renders user profile correctly', () => {\n    expect(wrapper.find('[data-testid=\"user-name\"]').text()).toBe('John Doe')\n    expect(wrapper.find('[data-testid=\"user-email\"]').text()).toBe('john@example.com')\n  })\n  \n  it('handles user update correctly', async () => {\n    // Mock API call\n    const updateUserSpy = vi.spyOn(userStore, 'updateUser').mockResolvedValue({\n      id: 1,\n      name: 'Jane Doe',\n      email: 'jane@example.com',\n      role: 'user'\n    })\n    \n    // Simulate user input\n    await wrapper.find('[data-testid=\"name-input\"]').setValue('Jane Doe')\n    await wrapper.find('[data-testid=\"email-input\"]').setValue('jane@example.com')\n    \n    // Trigger form submission\n    await wrapper.find('[data-testid=\"save-button\"]').trigger('click')\n    \n    // Wait for async operations\n    await flushPromises()\n    \n    // Assert API call was made\n    expect(updateUserSpy).toHaveBeenCalledWith(1, {\n      name: 'Jane Doe',\n      email: 'jane@example.com'\n    })\n    \n    // Assert UI updates\n    expect(wrapper.find('[data-testid=\"user-name\"]').text()).toBe('Jane Doe')\n  })\n  \n  it('handles API errors gracefully', async () => {\n    // Mock API error\n    vi.spyOn(userStore, 'updateUser').mockRejectedValue(new Error('Network error'))\n    \n    // Trigger form submission\n    await wrapper.find('[data-testid=\"save-button\"]').trigger('click')\n    await flushPromises()\n    \n    // Assert error message is displayed\n    expect(wrapper.find('[data-testid=\"error-message\"]').exists()).toBe(true)\n    expect(wrapper.find('[data-testid=\"error-message\"]').text()).toContain('Network error')\n  })\n  \n  it('disables save button when form is invalid', async () => {\n    // Clear required field\n    await wrapper.find('[data-testid=\"name-input\"]').setValue('')\n    \n    // Assert button is disabled\n    expect(wrapper.find('[data-testid=\"save-button\"]').attributes('disabled')).toBeDefined()\n  })\n})\n\n// Advanced composable testing\n// tests/composables/useAsyncOperation.test.js\nimport { ref } from 'vue'\nimport { useAsyncOperation } from '@/composables/useAsyncOperation'\n\ndescribe('useAsyncOperation', () => {\n  beforeEach(() => {\n    vi.useFakeTimers()\n  })\n  \n  afterEach(() => {\n    vi.useRealTimers()\n    vi.restoreAllMocks()\n  })\n  \n  it('executes operation successfully', async () => {\n    const mockOperation = vi.fn().mockResolvedValue('success')\n    const { data, loading, error, execute } = useAsyncOperation(mockOperation)\n    \n    const promise = execute('param1', 'param2')\n    \n    // Assert loading state\n    expect(loading.value).toBe(true)\n    expect(error.value).toBeNull()\n    \n    await promise\n    \n    // Assert final state\n    expect(loading.value).toBe(false)\n    expect(data.value).toBe('success')\n    expect(error.value).toBeNull()\n    expect(mockOperation).toHaveBeenCalledWith('param1', 'param2', expect.any(Object))\n  })\n  \n  it('handles operation errors', async () => {\n    const mockError = new Error('Operation failed')\n    const mockOperation = vi.fn().mockRejectedValue(mockError)\n    const { data, loading, error, execute } = useAsyncOperation(mockOperation)\n    \n    try {\n      await execute()\n    } catch (e) {\n      // Expected error\n    }\n    \n    // Assert final state\n    expect(loading.value).toBe(false)\n    expect(data.value).toBeNull()\n    expect(error.value).toBe(mockError)\n  })\n  \n  it('supports operation abortion', async () => {\n    let abortSignal\n    const mockOperation = vi.fn((param, options) => {\n      abortSignal = options.signal\n      return new Promise((resolve) => {\n        setTimeout(() => resolve('success'), 100)\n      })\n    })\n    \n    const { loading, execute, cleanup } = useAsyncOperation(mockOperation)\n    \n    const promise = execute()\n    \n    // Abort operation\n    cleanup()\n    \n    await expect(promise).rejects.toThrow('AbortError')\n    expect(abortSignal.aborted).toBe(true)\n    expect(loading.value).toBe(false)\n  })\n})\n\n// Store testing with complex state management\n// tests/stores/userStore.test.js\nimport { createPinia, setActivePinia } from 'pinia'\nimport { useUserStore } from '@/stores/user'\n\ndescribe('User Store', () => {\n  let userStore\n  \n  beforeEach(() => {\n    // Create new pinia instance for each test\n    setActivePinia(createPinia())\n    userStore = useUserStore()\n  })\n  \n  describe('fetchUsers', () => {\n    it('fetches users successfully', async () => {\n      // Mock API response\n      global.fetch = vi.fn().mockResolvedValue({\n        json: () => Promise.resolve([\n          { id: 1, name: 'John Doe', email: 'john@example.com' },\n          { id: 2, name: 'Jane Smith', email: 'jane@example.com' }\n        ])\n      })\n      \n      await userStore.fetchUsers()\n      \n      expect(userStore.users).toHaveLength(2)\n      expect(userStore.users[0].name).toBe('John Doe')\n      expect(userStore.loading.fetch).toBe(false)\n      expect(userStore.error).toBeNull()\n    })\n    \n    it('handles fetch errors', async () => {\n      global.fetch = vi.fn().mockRejectedValue(new Error('Network error'))\n      \n      await userStore.fetchUsers()\n      \n      expect(userStore.users).toHaveLength(0)\n      expect(userStore.loading.fetch).toBe(false)\n      expect(userStore.error).toBe('Network error')\n    })\n  })\n  \n  describe('CRUD operations', () => {\n    const testUser = { id: 1, name: 'John Doe', email: 'john@example.com' }\n    \n    beforeEach(() => {\n      userStore.users = [testUser]\n      userStore.currentUser = testUser\n    })\n    \n    it('creates user successfully', async () => {\n      const newUser = { name: 'Jane Smith', email: 'jane@example.com' }\n      const createdUser = { id: 2, ...newUser }\n      \n      global.fetch = vi.fn().mockResolvedValue({\n        json: () => Promise.resolve(createdUser)\n      })\n      \n      await userStore.createUser(newUser)\n      \n      expect(userStore.users).toHaveLength(2)\n      expect(userStore.users[1]).toEqual(createdUser)\n    })\n    \n    it('updates user successfully', async () => {\n      const updatedUser = { ...testUser, name: 'John Smith' }\n      \n      global.fetch = vi.fn().mockResolvedValue({\n        json: () => Promise.resolve(updatedUser)\n      })\n      \n      await userStore.updateUser(1, { name: 'John Smith' })\n      \n      expect(userStore.users[0].name).toBe('John Smith')\n      expect(userStore.currentUser.name).toBe('John Smith')\n    })\n    \n    it('deletes user successfully', async () => {\n      global.fetch = vi.fn().mockResolvedValue({})\n      \n      await userStore.deleteUser(1)\n      \n      expect(userStore.users).toHaveLength(0)\n      expect(userStore.currentUser).toBeNull()\n    })\n  })\n})\n\n// Integration test for complex workflows\n// tests/integration/userManagement.test.js\nimport { mount } from '@vue/test-utils'\nimport { createTestingPinia } from '@pinia/testing'\nimport { useUserStore } from '@/stores/user'\nimport UserManagement from '@/views/UserManagement.vue'\n\ndescribe('User Management Integration', () => {\n  let wrapper\n  let userStore\n  \n  beforeEach(() => {\n    wrapper = mount(UserManagement, {\n      global: {\n        plugins: [\n          createTestingPinia({\n            stubActions: false\n          })\n        ]\n      }\n    })\n    \n    userStore = useUserStore()\n  })\n  \n  it('completes full user management workflow', async () => {\n    // Mock initial data fetch\n    vi.spyOn(userStore, 'fetchUsers').mockResolvedValue([\n      { id: 1, name: 'John Doe', email: 'john@example.com' }\n    ])\n    \n    // Mock create operation\n    vi.spyOn(userStore, 'createUser').mockResolvedValue({\n      id: 2, name: 'Jane Smith', email: 'jane@example.com'\n    })\n    \n    // Load initial data\n    await wrapper.vm.loadUsers()\n    \n    // Add new user\n    await wrapper.vm.addUser({\n      name: 'Jane Smith',\n      email: 'jane@example.com'\n    })\n    \n    // Assert final state\n    expect(userStore.users).toHaveLength(2)\n    expect(userStore.users[1].name).toBe('Jane Smith')\n  })\n})",
      "explanation": "This example demonstrates advanced testing strategies including:\n\n1. Comprehensive component testing with complex interactions\n2. Advanced composable testing with async operations and abortion\n3. Store testing with complex state management scenarios\n4. Integration testing for complex workflows\n5. Proper mocking strategies for APIs and dependencies\n6. Test organization and setup patterns\n7. Error handling and edge case testing\n\nThese patterns enable developers to create comprehensive test suites that provide high confidence in application correctness while remaining maintainable and performant.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating tests that are too brittle and break with minor changes",
        "solution": "Use data-testid attributes, test behavior over implementation, and focus on user-facing functionality",
        "severity": "medium"
      },
      {
        "mistake": "Not testing edge cases and error conditions",
        "solution": "Test error states, boundary conditions, and unexpected inputs thoroughly",
        "severity": "high"
      },
      {
        "mistake": "Ignoring test performance which slows down development",
        "solution": "Use proper mocking, avoid unnecessary async operations, and organize tests efficiently",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Comprehensive Testing Strategies",
        "description": "Create a complete testing suite with advanced patterns for components, composables, and stores",
        "checkpoints": [
          "Implement component tests with complex interactions",
          "Create composable tests with async operations",
          "Build store tests with complex state management",
          "Add integration tests for workflows",
          "Implement proper mocking and error handling tests"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Testing",
      "Vitest",
      "Vue Test Utils",
      "Pinia",
      "Mocking",
      "Vue 3"
    ],
    "lastUpdated": "2025-10-03T10:00:00Z",
    "version": "1.0.0",
    "sources": []
  }
]