[
  {
    "id": "1",
    "moduleSlug": "performance-optimization",
    "title": "Performance Fundamentals and Profiling",
    "order": 1,
    "objectives": [
      "Understand performance metrics and why they matter",
      "Learn to use browser DevTools for performance profiling",
      "Identify common performance bottlenecks in web applications"
    ],
    "intro": "Performance optimization is crucial for creating successful web applications that provide excellent user experiences. Even small improvements in load times can significantly impact user engagement and business metrics.\n\nIn this lesson, you'll learn about Core Web Vitals - Google's metrics for measuring user experience including Largest Contentful Paint (LCP), First Input Delay (FID), and Cumulative Layout Shift (CLS). These metrics directly affect search rankings and user satisfaction.\n\nBrowser DevTools provide powerful profiling capabilities that help identify performance bottlenecks. You'll master the Performance tab, Network tab, and Lighthouse audits to diagnose issues ranging from slow JavaScript execution to inefficient asset loading.\n\nCommon performance issues include blocking JavaScript, large bundle sizes, inefficient CSS, and poor image optimization. Understanding these patterns helps you proactively design performant applications rather than fixing issues after deployment.\n\nBy the end of this lesson, you'll confidently use profiling tools to measure performance, identify bottlenecks, and understand the relationship between code quality and user experience. This foundation is essential for building fast, responsive web applications.",
    "code": {
      "example": "// Performance monitoring and profiling techniques\n\n// 1. Measuring Core Web Vitals\nfunction measurePerformance() {\n  // Largest Contentful Paint (LCP)\n  new PerformanceObserver((entryList) => {\n    for (const entry of entryList.getEntries()) {\n      console.log('LCP:', entry.startTime);\n    }\n  }).observe({ entryTypes: ['largest-contentful-paint'] });\n\n  // First Input Delay (FID)\n  new PerformanceObserver((entryList) => {\n    for (const entry of entryList.getEntries()) {\n      console.log('FID:', entry.processingStart - entry.startTime);\n    }\n  }).observe({ entryTypes: ['first-input'] });\n\n  // Cumulative Layout Shift (CLS)\n  new PerformanceObserver((entryList) => {\n    for (const entry of entryList.getEntries()) {\n      console.log('Layout shift:', entry.value);\n    }\n  }).observe({ entryTypes: ['layout-shift'] });\n}\n\n// 2. Performance timing API\nfunction analyzePageLoad() {\n  const timing = performance.timing;\n  const navigation = performance.navigation;\n\n  const loadTime = timing.loadEventEnd - timing.navigationStart;\n  const domReady = timing.domContentLoadedEventEnd - timing.navigationStart;\n  const firstByte = timing.responseStart - timing.navigationStart;\n\n  console.log({\n    loadTime: loadTime + 'ms',\n    domReady: domReady + 'ms',\n    timeToFirstByte: firstByte + 'ms',\n    navigationType: navigation.type\n  });\n}\n\n// 3. Resource timing analysis\nfunction analyzeResources() {\n  const resources = performance.getEntriesByType('resource');\n  \n  resources.forEach(resource => {\n    const loadTime = resource.responseEnd - resource.startTime;\n    const resourceSize = resource.transferSize;\n    \n    if (loadTime > 1000) { // Slow resources\n      console.warn(`Slow resource: ${resource.name}`, {\n        loadTime: loadTime + 'ms',\n        size: (resourceSize / 1024).toFixed(2) + 'KB',\n        type: resource.initiatorType\n      });\n    }\n  });\n}\n\n// 4. Memory usage monitoring\nfunction monitorMemory() {\n  if ('memory' in performance) {\n    const memory = performance.memory;\n    console.log({\n      usedHeap: (memory.usedJSHeapSize / 1048576).toFixed(2) + 'MB',\n      totalHeap: (memory.totalJSHeapSize / 1048576).toFixed(2) + 'MB',\n      heapLimit: (memory.jsHeapSizeLimit / 1048576).toFixed(2) + 'MB'\n    });\n  }\n}\n\n// 5. Long task detection\nif ('PerformanceObserver' in window) {\n  const observer = new PerformanceObserver((list) => {\n    for (const entry of list.getEntries()) {\n      console.warn('Long task detected:', {\n        duration: entry.duration + 'ms',\n        startTime: entry.startTime,\n        name: entry.name\n      });\n    }\n  });\n  observer.observe({ entryTypes: ['longtask'] });\n}\n\n// Initialize monitoring\nmeasurePerformance();\nwindow.addEventListener('load', () => {\n  setTimeout(() => {\n    analyzePageLoad();\n    analyzeResources();\n    monitorMemory();\n  }, 1000);\n});",
      "explanation": "This example demonstrates comprehensive performance monitoring including Core Web Vitals measurement, page load analysis, resource timing, memory monitoring, and long task detection using modern browser APIs.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Optimizing based on assumptions rather than measurements",
        "solution": "Always measure performance before and after optimizations using proper profiling tools",
        "severity": "high"
      },
      {
        "mistake": "Focusing only on initial page load and ignoring runtime performance",
        "solution": "Monitor ongoing performance including user interactions, animations, and memory usage",
        "severity": "medium"
      },
      {
        "mistake": "Testing performance only on high-end devices and fast networks",
        "solution": "Test on various devices and network conditions, especially slower connections and mobile devices",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Performance Audit and Optimization",
        "description": "Conduct a comprehensive performance audit of a web application and implement optimizations.",
        "checkpoints": [
          "Use Lighthouse to audit Core Web Vitals and performance metrics",
          "Profile JavaScript execution and identify long tasks",
          "Analyze network waterfall and optimize resource loading",
          "Implement performance monitoring code to track real user metrics"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "2",
    "moduleSlug": "performance-optimization",
    "title": "Performance Optimization Techniques",
    "order": 2,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Real Performance Optimization Example\n// Web Performance API for measuring Core Web Vitals\n\n// Measure First Contentful Paint (FCP)\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (entry.name === 'first-contentful-paint') {\n      console.log('FCP:', entry.startTime);\n      \n      // Send to analytics\n      if ('sendBeacon' in navigator) {\n        navigator.sendBeacon('/analytics', JSON.stringify({\n          metric: 'FCP',\n          value: entry.startTime,\n          timestamp: Date.now()\n        }));\n      }\n    }\n  }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// Optimize bundle loading with dynamic imports\nasync function loadExpensiveFeature() {\n  const { expensiveFeature } = await import('./expensive-feature.js');\n  return expensiveFeature();\n}\n\n// Implement requestIdleCallback for non-critical work\nfunction scheduleNonCriticalWork() {\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      // Perform analytics, logging, or other non-critical tasks\n      console.log('Running non-critical work during idle time');\n    }, { timeout: 2000 });\n  } else {\n    // Fallback for older browsers\n    setTimeout(() => {\n      console.log('Running non-critical work with setTimeout fallback');\n    }, 1);\n  }\n}\n\n// Virtualize long lists for better rendering performance\nclass VirtualList {\n  constructor(container, items, itemHeight) {\n    this.container = container;\n    this.items = items;\n    this.itemHeight = itemHeight;\n    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;\n    this.startIndex = 0;\n    \n    this.render();\n    this.addScrollListener();\n  }\n  \n  addScrollListener() {\n    this.container.addEventListener('scroll', () => {\n      const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);\n      if (newStartIndex !== this.startIndex) {\n        this.startIndex = newStartIndex;\n        this.render();\n      }\n    });\n  }\n  \n  render() {\n    const fragment = document.createDocumentFragment();\n    const endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);\n    \n    for (let i = this.startIndex; i < endIndex; i++) {\n      const itemElement = document.createElement('div');\n      itemElement.style.height = `${this.itemHeight}px`;\n      itemElement.textContent = this.items[i];\n      fragment.appendChild(itemElement);\n    }\n    \n    this.container.innerHTML = '';\n    this.container.appendChild(fragment);\n  }\n}\n\n// Usage\nconst container = document.getElementById('virtual-list-container');\nconst items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);\nnew VirtualList(container, items, 50);",
      "explanation": "This example demonstrates key performance optimization techniques including Core Web Vitals measurement with the Performance API, dynamic imports for code splitting, requestIdleCallback for scheduling non-critical work during browser idle time, and virtual scrolling for efficiently rendering large lists. These techniques help improve loading performance, runtime responsiveness, and overall user experience.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Quality Assurance",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "3",
    "moduleSlug": "performance-optimization",
    "title": "Automated Testing",
    "order": 3,
    "objectives": [
      "Apply advanced Performance techniques",
      "Optimize performance and efficiency",
      "Integrate with external systems"
    ],
    "intro": "Welcome to Automated Testing in the Performance Optimization module. \n\nThis lesson is part of the quality tier, designed for advanced level learners. Throughout this lesson, you'll explore essential concepts and practical applications that form the foundation of modern performance development.\n\nProfiling, monitoring, and optimization techniques This lesson builds upon previous concepts while introducing new techniques that will enhance your understanding and practical skills.\n\nBy the end of this lesson, you'll have hands-on experience with Performance and Profiling, along with best practices for implementing these technologies in real-world scenarios. The knowledge gained here will prepare you for more advanced topics in subsequent lessons.\n\nKey areas we'll cover include practical implementation techniques, common challenges developers face, and proven solutions that industry professionals use daily. This lesson balances theoretical understanding with practical application, ensuring you can immediately apply what you learn.",
    "code": {
      "example": "// Automated Performance Testing with Lighthouse CI\n\n// package.json\n{\n  \"devDependencies\": {\n    \"@lhci/cli\": \"^0.12.0\",\n    \"puppeteer\": \"^21.0.0\"\n  },\n  \"scripts\": {\n    \"perf:test\": \"lhci autorun\",\n    \"perf:analyze\": \"node scripts/performance-test.js\"\n  }\n}\n\n// .lighthouserc.js\nmodule.exports = {\n  ci: {\n    collect: {\n      url: ['http://localhost:3000'],\n      numberOfRuns: 3\n    },\n    assert: {\n      assertions: {\n        'categories:performance': ['error', { minScore: 0.8 }],\n        'categories:accessibility': ['error', { minScore: 0.9 }],\n        'first-contentful-paint': ['error', { maxNumericValue: 2000 }],\n        'largest-contentful-paint': ['error', { maxNumericValue: 2500 }]\n      }\n    }\n  }\n};\n\n// scripts/performance-test.js\nconst { performance } = require('perf_hooks');\nconst puppeteer = require('puppeteer');\n\nasync function measurePagePerformance(url) {\n  const browser = await puppeteer.launch();\n  const page = await browser.newPage();\n  \n  // Enable performance monitoring\n  await page.setCacheEnabled(false);\n  \n  const startTime = performance.now();\n  await page.goto(url, { waitUntil: 'networkidle0' });\n  const loadTime = performance.now() - startTime;\n  \n  // Measure Core Web Vitals\n  const metrics = await page.evaluate(() => {\n    return new Promise((resolve) => {\n      new PerformanceObserver((list) => {\n        const entries = list.getEntries();\n        resolve(entries.map(entry => ({\n          name: entry.name,\n          value: entry.value,\n          rating: entry.value < 2500 ? 'good' : 'poor'\n        })));\n      }).observe({ entryTypes: ['largest-contentful-paint'] });\n    });\n  });\n  \n  await browser.close();\n  \n  return {\n    loadTime: Math.round(loadTime),\n    metrics,\n    url\n  };\n}\n\n// Usage\nmeasurePagePerformance('http://localhost:3000')\n  .then(results => {\n    console.log('Performance Results:', results);\n    if (results.loadTime > 3000) {\n      console.error('❌ Page load time exceeds threshold');\n      process.exit(1);\n    }\n    console.log('✅ Performance test passed');\n  });",
      "explanation": "This example demonstrates automated performance testing using Lighthouse CI and Puppeteer. The setup includes configuration for continuous integration testing with performance thresholds, automated Core Web Vitals measurement, and practical scripts for monitoring page load times and rendering metrics in development workflows.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Automated Testing",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "4",
    "moduleSlug": "performance-optimization",
    "title": "Performance Testing",
    "order": 4,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Performance Testing with Web Performance API\n\n// Basic performance measurement\nconst perfObserver = new PerformanceObserver((list) => {\n  const entries = list.getEntries();\n  entries.forEach((entry) => {\n    console.log(`${entry.name}: ${entry.duration}ms`);\n  });\n});\n\nperfObserver.observe({ entryTypes: ['measure', 'navigation'] });\n\n// Function performance testing\nfunction measureFunction(fn, ...args) {\n  const start = performance.now();\n  const result = fn(...args);\n  const end = performance.now();\n  \n  console.log(`Function executed in ${end - start}ms`);\n  return result;\n}\n\n// Memory usage monitoring\nfunction measureMemoryUsage() {\n  if ('memory' in performance) {\n    const memory = performance.memory;\n    return {\n      usedJSHeapSize: memory.usedJSHeapSize,\n      totalJSHeapSize: memory.totalJSHeapSize,\n      jsHeapSizeLimit: memory.jsHeapSizeLimit\n    };\n  }\n  return null;\n}\n\n// Load testing simulation\nasync function loadTest(url, concurrentUsers = 10, duration = 30000) {\n  const results = [];\n  const startTime = Date.now();\n  \n  const promises = Array.from({ length: concurrentUsers }, async (_, i) => {\n    const userResults = [];\n    \n    while (Date.now() - startTime < duration) {\n      const requestStart = performance.now();\n      \n      try {\n        const response = await fetch(url);\n        const requestEnd = performance.now();\n        \n        userResults.push({\n          user: i,\n          responseTime: requestEnd - requestStart,\n          status: response.status,\n          timestamp: Date.now()\n        });\n      } catch (error) {\n        userResults.push({\n          user: i,\n          error: error.message,\n          timestamp: Date.now()\n        });\n      }\n      \n      // Random delay between requests\n      await new Promise(resolve => setTimeout(resolve, Math.random() * 1000));\n    }\n    \n    return userResults;\n  });\n  \n  const allResults = await Promise.all(promises);\n  return allResults.flat();\n}\n\n// Performance budget validation\nfunction validatePerformanceBudget(metrics, budget) {\n  const violations = [];\n  \n  Object.keys(budget).forEach(metric => {\n    if (metrics[metric] > budget[metric]) {\n      violations.push({\n        metric,\n        actual: metrics[metric],\n        budget: budget[metric],\n        exceeded: metrics[metric] - budget[metric]\n      });\n    }\n  });\n  \n  return {\n    passed: violations.length === 0,\n    violations\n  };\n}\n\n// Usage example\nconst budget = {\n  'first-contentful-paint': 1500,\n  'largest-contentful-paint': 2500,\n  'cumulative-layout-shift': 0.1\n};\n\n// Measure current page performance\nsetTimeout(() => {\n  const navigation = performance.getEntriesByType('navigation')[0];\n  const metrics = {\n    'first-contentful-paint': navigation.domContentLoadedEventEnd - navigation.navigationStart,\n    'largest-contentful-paint': 2000, // Example value\n    'cumulative-layout-shift': 0.05 // Example value\n  };\n  \n  const result = validatePerformanceBudget(metrics, budget);\n  console.log('Performance Budget Check:', result);\n}, 1000);",
      "explanation": "This example demonstrates comprehensive performance testing techniques including function timing, memory monitoring, load testing simulation, and performance budget validation. The code shows practical approaches for measuring Web Performance API metrics, conducting concurrent user simulations, and validating against performance thresholds in real applications.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Performance Testing",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "5",
    "moduleSlug": "performance-optimization",
    "title": "Performance Optimization Techniques",
    "order": 5,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Real Performance Optimization Example\n// Web Performance API for measuring Core Web Vitals\n\n// Measure First Contentful Paint (FCP)\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (entry.name === 'first-contentful-paint') {\n      console.log('FCP:', entry.startTime);\n      \n      // Send to analytics\n      if ('sendBeacon' in navigator) {\n        navigator.sendBeacon('/analytics', JSON.stringify({\n          metric: 'FCP',\n          value: entry.startTime,\n          timestamp: Date.now()\n        }));\n      }\n    }\n  }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// Optimize bundle loading with dynamic imports\nasync function loadExpensiveFeature() {\n  const { expensiveFeature } = await import('./expensive-feature.js');\n  return expensiveFeature();\n}\n\n// Implement requestIdleCallback for non-critical work\nfunction scheduleNonCriticalWork() {\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      // Perform analytics, logging, or other non-critical tasks\n      console.log('Running non-critical work during idle time');\n    }, { timeout: 2000 });\n  } else {\n    // Fallback for older browsers\n    setTimeout(() => {\n      console.log('Running non-critical work with setTimeout fallback');\n    }, 1);\n  }\n}\n\n// Virtualize long lists for better rendering performance\nclass VirtualList {\n  constructor(container, items, itemHeight) {\n    this.container = container;\n    this.items = items;\n    this.itemHeight = itemHeight;\n    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;\n    this.startIndex = 0;\n    \n    this.render();\n    this.addScrollListener();\n  }\n  \n  addScrollListener() {\n    this.container.addEventListener('scroll', () => {\n      const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);\n      if (newStartIndex !== this.startIndex) {\n        this.startIndex = newStartIndex;\n        this.render();\n      }\n    });\n  }\n  \n  render() {\n    const fragment = document.createDocumentFragment();\n    const endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);\n    \n    for (let i = this.startIndex; i < endIndex; i++) {\n      const itemElement = document.createElement('div');\n      itemElement.style.height = `${this.itemHeight}px`;\n      itemElement.textContent = this.items[i];\n      fragment.appendChild(itemElement);\n    }\n    \n    this.container.innerHTML = '';\n    this.container.appendChild(fragment);\n  }\n}\n\n// Usage\nconst container = document.getElementById('virtual-list-container');\nconst items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);\nnew VirtualList(container, items, 50);",
      "explanation": "This example demonstrates key performance optimization techniques including Core Web Vitals measurement with the Performance API, dynamic imports for code splitting, requestIdleCallback for scheduling non-critical work during browser idle time, and virtual scrolling for efficiently rendering large lists. These techniques help improve loading performance, runtime responsiveness, and overall user experience.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Security Testing",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "6",
    "moduleSlug": "performance-optimization",
    "title": "Performance Optimization Techniques",
    "order": 6,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Real Performance Optimization Example\n// Web Performance API for measuring Core Web Vitals\n\n// Measure First Contentful Paint (FCP)\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (entry.name === 'first-contentful-paint') {\n      console.log('FCP:', entry.startTime);\n      \n      // Send to analytics\n      if ('sendBeacon' in navigator) {\n        navigator.sendBeacon('/analytics', JSON.stringify({\n          metric: 'FCP',\n          value: entry.startTime,\n          timestamp: Date.now()\n        }));\n      }\n    }\n  }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// Optimize bundle loading with dynamic imports\nasync function loadExpensiveFeature() {\n  const { expensiveFeature } = await import('./expensive-feature.js');\n  return expensiveFeature();\n}\n\n// Implement requestIdleCallback for non-critical work\nfunction scheduleNonCriticalWork() {\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      // Perform analytics, logging, or other non-critical tasks\n      console.log('Running non-critical work during idle time');\n    }, { timeout: 2000 });\n  } else {\n    // Fallback for older browsers\n    setTimeout(() => {\n      console.log('Running non-critical work with setTimeout fallback');\n    }, 1);\n  }\n}\n\n// Virtualize long lists for better rendering performance\nclass VirtualList {\n  constructor(container, items, itemHeight) {\n    this.container = container;\n    this.items = items;\n    this.itemHeight = itemHeight;\n    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;\n    this.startIndex = 0;\n    \n    this.render();\n    this.addScrollListener();\n  }\n  \n  addScrollListener() {\n    this.container.addEventListener('scroll', () => {\n      const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);\n      if (newStartIndex !== this.startIndex) {\n        this.startIndex = newStartIndex;\n        this.render();\n      }\n    });\n  }\n  \n  render() {\n    const fragment = document.createDocumentFragment();\n    const endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);\n    \n    for (let i = this.startIndex; i < endIndex; i++) {\n      const itemElement = document.createElement('div');\n      itemElement.style.height = `${this.itemHeight}px`;\n      itemElement.textContent = this.items[i];\n      fragment.appendChild(itemElement);\n    }\n    \n    this.container.innerHTML = '';\n    this.container.appendChild(fragment);\n  }\n}\n\n// Usage\nconst container = document.getElementById('virtual-list-container');\nconst items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);\nnew VirtualList(container, items, 50);",
      "explanation": "This example demonstrates key performance optimization techniques including Core Web Vitals measurement with the Performance API, dynamic imports for code splitting, requestIdleCallback for scheduling non-critical work during browser idle time, and virtual scrolling for efficiently rendering large lists. These techniques help improve loading performance, runtime responsiveness, and overall user experience.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Code Quality",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "7",
    "moduleSlug": "performance-optimization",
    "title": "Performance Optimization Techniques",
    "order": 7,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Real Performance Optimization Example\n// Web Performance API for measuring Core Web Vitals\n\n// Measure First Contentful Paint (FCP)\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (entry.name === 'first-contentful-paint') {\n      console.log('FCP:', entry.startTime);\n      \n      // Send to analytics\n      if ('sendBeacon' in navigator) {\n        navigator.sendBeacon('/analytics', JSON.stringify({\n          metric: 'FCP',\n          value: entry.startTime,\n          timestamp: Date.now()\n        }));\n      }\n    }\n  }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// Optimize bundle loading with dynamic imports\nasync function loadExpensiveFeature() {\n  const { expensiveFeature } = await import('./expensive-feature.js');\n  return expensiveFeature();\n}\n\n// Implement requestIdleCallback for non-critical work\nfunction scheduleNonCriticalWork() {\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      // Perform analytics, logging, or other non-critical tasks\n      console.log('Running non-critical work during idle time');\n    }, { timeout: 2000 });\n  } else {\n    // Fallback for older browsers\n    setTimeout(() => {\n      console.log('Running non-critical work with setTimeout fallback');\n    }, 1);\n  }\n}\n\n// Virtualize long lists for better rendering performance\nclass VirtualList {\n  constructor(container, items, itemHeight) {\n    this.container = container;\n    this.items = items;\n    this.itemHeight = itemHeight;\n    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;\n    this.startIndex = 0;\n    \n    this.render();\n    this.addScrollListener();\n  }\n  \n  addScrollListener() {\n    this.container.addEventListener('scroll', () => {\n      const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);\n      if (newStartIndex !== this.startIndex) {\n        this.startIndex = newStartIndex;\n        this.render();\n      }\n    });\n  }\n  \n  render() {\n    const fragment = document.createDocumentFragment();\n    const endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);\n    \n    for (let i = this.startIndex; i < endIndex; i++) {\n      const itemElement = document.createElement('div');\n      itemElement.style.height = `${this.itemHeight}px`;\n      itemElement.textContent = this.items[i];\n      fragment.appendChild(itemElement);\n    }\n    \n    this.container.innerHTML = '';\n    this.container.appendChild(fragment);\n  }\n}\n\n// Usage\nconst container = document.getElementById('virtual-list-container');\nconst items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);\nnew VirtualList(container, items, 50);",
      "explanation": "This example demonstrates key performance optimization techniques including Core Web Vitals measurement with the Performance API, dynamic imports for code splitting, requestIdleCallback for scheduling non-critical work during browser idle time, and virtual scrolling for efficiently rendering large lists. These techniques help improve loading performance, runtime responsiveness, and overall user experience.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Review Processes",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "8",
    "moduleSlug": "performance-optimization",
    "title": "Performance Optimization Techniques",
    "order": 8,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Real Performance Optimization Example\n// Web Performance API for measuring Core Web Vitals\n\n// Measure First Contentful Paint (FCP)\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (entry.name === 'first-contentful-paint') {\n      console.log('FCP:', entry.startTime);\n      \n      // Send to analytics\n      if ('sendBeacon' in navigator) {\n        navigator.sendBeacon('/analytics', JSON.stringify({\n          metric: 'FCP',\n          value: entry.startTime,\n          timestamp: Date.now()\n        }));\n      }\n    }\n  }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// Optimize bundle loading with dynamic imports\nasync function loadExpensiveFeature() {\n  const { expensiveFeature } = await import('./expensive-feature.js');\n  return expensiveFeature();\n}\n\n// Implement requestIdleCallback for non-critical work\nfunction scheduleNonCriticalWork() {\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      // Perform analytics, logging, or other non-critical tasks\n      console.log('Running non-critical work during idle time');\n    }, { timeout: 2000 });\n  } else {\n    // Fallback for older browsers\n    setTimeout(() => {\n      console.log('Running non-critical work with setTimeout fallback');\n    }, 1);\n  }\n}\n\n// Virtualize long lists for better rendering performance\nclass VirtualList {\n  constructor(container, items, itemHeight) {\n    this.container = container;\n    this.items = items;\n    this.itemHeight = itemHeight;\n    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;\n    this.startIndex = 0;\n    \n    this.render();\n    this.addScrollListener();\n  }\n  \n  addScrollListener() {\n    this.container.addEventListener('scroll', () => {\n      const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);\n      if (newStartIndex !== this.startIndex) {\n        this.startIndex = newStartIndex;\n        this.render();\n      }\n    });\n  }\n  \n  render() {\n    const fragment = document.createDocumentFragment();\n    const endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);\n    \n    for (let i = this.startIndex; i < endIndex; i++) {\n      const itemElement = document.createElement('div');\n      itemElement.style.height = `${this.itemHeight}px`;\n      itemElement.textContent = this.items[i];\n      fragment.appendChild(itemElement);\n    }\n    \n    this.container.innerHTML = '';\n    this.container.appendChild(fragment);\n  }\n}\n\n// Usage\nconst container = document.getElementById('virtual-list-container');\nconst items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);\nnew VirtualList(container, items, 50);",
      "explanation": "This example demonstrates key performance optimization techniques including Core Web Vitals measurement with the Performance API, dynamic imports for code splitting, requestIdleCallback for scheduling non-critical work during browser idle time, and virtual scrolling for efficiently rendering large lists. These techniques help improve loading performance, runtime responsiveness, and overall user experience.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Continuous Integration",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "9",
    "moduleSlug": "performance-optimization",
    "title": "Performance Optimization Techniques",
    "order": 9,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Real Performance Optimization Example\n// Web Performance API for measuring Core Web Vitals\n\n// Measure First Contentful Paint (FCP)\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (entry.name === 'first-contentful-paint') {\n      console.log('FCP:', entry.startTime);\n      \n      // Send to analytics\n      if ('sendBeacon' in navigator) {\n        navigator.sendBeacon('/analytics', JSON.stringify({\n          metric: 'FCP',\n          value: entry.startTime,\n          timestamp: Date.now()\n        }));\n      }\n    }\n  }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// Optimize bundle loading with dynamic imports\nasync function loadExpensiveFeature() {\n  const { expensiveFeature } = await import('./expensive-feature.js');\n  return expensiveFeature();\n}\n\n// Implement requestIdleCallback for non-critical work\nfunction scheduleNonCriticalWork() {\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      // Perform analytics, logging, or other non-critical tasks\n      console.log('Running non-critical work during idle time');\n    }, { timeout: 2000 });\n  } else {\n    // Fallback for older browsers\n    setTimeout(() => {\n      console.log('Running non-critical work with setTimeout fallback');\n    }, 1);\n  }\n}\n\n// Virtualize long lists for better rendering performance\nclass VirtualList {\n  constructor(container, items, itemHeight) {\n    this.container = container;\n    this.items = items;\n    this.itemHeight = itemHeight;\n    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;\n    this.startIndex = 0;\n    \n    this.render();\n    this.addScrollListener();\n  }\n  \n  addScrollListener() {\n    this.container.addEventListener('scroll', () => {\n      const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);\n      if (newStartIndex !== this.startIndex) {\n        this.startIndex = newStartIndex;\n        this.render();\n      }\n    });\n  }\n  \n  render() {\n    const fragment = document.createDocumentFragment();\n    const endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);\n    \n    for (let i = this.startIndex; i < endIndex; i++) {\n      const itemElement = document.createElement('div');\n      itemElement.style.height = `${this.itemHeight}px`;\n      itemElement.textContent = this.items[i];\n      fragment.appendChild(itemElement);\n    }\n    \n    this.container.innerHTML = '';\n    this.container.appendChild(fragment);\n  }\n}\n\n// Usage\nconst container = document.getElementById('virtual-list-container');\nconst items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);\nnew VirtualList(container, items, 50);",
      "explanation": "This example demonstrates key performance optimization techniques including Core Web Vitals measurement with the Performance API, dynamic imports for code splitting, requestIdleCallback for scheduling non-critical work during browser idle time, and virtual scrolling for efficiently rendering large lists. These techniques help improve loading performance, runtime responsiveness, and overall user experience.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Monitoring Setup",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "10",
    "moduleSlug": "performance-optimization",
    "title": "Performance Optimization Techniques",
    "order": 10,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Real Performance Optimization Example\n// Web Performance API for measuring Core Web Vitals\n\n// Measure First Contentful Paint (FCP)\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (entry.name === 'first-contentful-paint') {\n      console.log('FCP:', entry.startTime);\n      \n      // Send to analytics\n      if ('sendBeacon' in navigator) {\n        navigator.sendBeacon('/analytics', JSON.stringify({\n          metric: 'FCP',\n          value: entry.startTime,\n          timestamp: Date.now()\n        }));\n      }\n    }\n  }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// Optimize bundle loading with dynamic imports\nasync function loadExpensiveFeature() {\n  const { expensiveFeature } = await import('./expensive-feature.js');\n  return expensiveFeature();\n}\n\n// Implement requestIdleCallback for non-critical work\nfunction scheduleNonCriticalWork() {\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      // Perform analytics, logging, or other non-critical tasks\n      console.log('Running non-critical work during idle time');\n    }, { timeout: 2000 });\n  } else {\n    // Fallback for older browsers\n    setTimeout(() => {\n      console.log('Running non-critical work with setTimeout fallback');\n    }, 1);\n  }\n}\n\n// Virtualize long lists for better rendering performance\nclass VirtualList {\n  constructor(container, items, itemHeight) {\n    this.container = container;\n    this.items = items;\n    this.itemHeight = itemHeight;\n    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;\n    this.startIndex = 0;\n    \n    this.render();\n    this.addScrollListener();\n  }\n  \n  addScrollListener() {\n    this.container.addEventListener('scroll', () => {\n      const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);\n      if (newStartIndex !== this.startIndex) {\n        this.startIndex = newStartIndex;\n        this.render();\n      }\n    });\n  }\n  \n  render() {\n    const fragment = document.createDocumentFragment();\n    const endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);\n    \n    for (let i = this.startIndex; i < endIndex; i++) {\n      const itemElement = document.createElement('div');\n      itemElement.style.height = `${this.itemHeight}px`;\n      itemElement.textContent = this.items[i];\n      fragment.appendChild(itemElement);\n    }\n    \n    this.container.innerHTML = '';\n    this.container.appendChild(fragment);\n  }\n}\n\n// Usage\nconst container = document.getElementById('virtual-list-container');\nconst items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);\nnew VirtualList(container, items, 50);",
      "explanation": "This example demonstrates key performance optimization techniques including Core Web Vitals measurement with the Performance API, dynamic imports for code splitting, requestIdleCallback for scheduling non-critical work during browser idle time, and virtual scrolling for efficiently rendering large lists. These techniques help improve loading performance, runtime responsiveness, and overall user experience.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Debugging Techniques",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "11",
    "moduleSlug": "performance-optimization",
    "title": "Performance Optimization Techniques",
    "order": 11,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Real Performance Optimization Example\n// Web Performance API for measuring Core Web Vitals\n\n// Measure First Contentful Paint (FCP)\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (entry.name === 'first-contentful-paint') {\n      console.log('FCP:', entry.startTime);\n      \n      // Send to analytics\n      if ('sendBeacon' in navigator) {\n        navigator.sendBeacon('/analytics', JSON.stringify({\n          metric: 'FCP',\n          value: entry.startTime,\n          timestamp: Date.now()\n        }));\n      }\n    }\n  }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// Optimize bundle loading with dynamic imports\nasync function loadExpensiveFeature() {\n  const { expensiveFeature } = await import('./expensive-feature.js');\n  return expensiveFeature();\n}\n\n// Implement requestIdleCallback for non-critical work\nfunction scheduleNonCriticalWork() {\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      // Perform analytics, logging, or other non-critical tasks\n      console.log('Running non-critical work during idle time');\n    }, { timeout: 2000 });\n  } else {\n    // Fallback for older browsers\n    setTimeout(() => {\n      console.log('Running non-critical work with setTimeout fallback');\n    }, 1);\n  }\n}\n\n// Virtualize long lists for better rendering performance\nclass VirtualList {\n  constructor(container, items, itemHeight) {\n    this.container = container;\n    this.items = items;\n    this.itemHeight = itemHeight;\n    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;\n    this.startIndex = 0;\n    \n    this.render();\n    this.addScrollListener();\n  }\n  \n  addScrollListener() {\n    this.container.addEventListener('scroll', () => {\n      const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);\n      if (newStartIndex !== this.startIndex) {\n        this.startIndex = newStartIndex;\n        this.render();\n      }\n    });\n  }\n  \n  render() {\n    const fragment = document.createDocumentFragment();\n    const endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);\n    \n    for (let i = this.startIndex; i < endIndex; i++) {\n      const itemElement = document.createElement('div');\n      itemElement.style.height = `${this.itemHeight}px`;\n      itemElement.textContent = this.items[i];\n      fragment.appendChild(itemElement);\n    }\n    \n    this.container.innerHTML = '';\n    this.container.appendChild(fragment);\n  }\n}\n\n// Usage\nconst container = document.getElementById('virtual-list-container');\nconst items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);\nnew VirtualList(container, items, 50);",
      "explanation": "This example demonstrates key performance optimization techniques including Core Web Vitals measurement with the Performance API, dynamic imports for code splitting, requestIdleCallback for scheduling non-critical work during browser idle time, and virtual scrolling for efficiently rendering large lists. These techniques help improve loading performance, runtime responsiveness, and overall user experience.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Optimization Methods",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "12",
    "moduleSlug": "performance-optimization",
    "title": "Performance Optimization Techniques",
    "order": 12,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Real Performance Optimization Example\n// Web Performance API for measuring Core Web Vitals\n\n// Measure First Contentful Paint (FCP)\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (entry.name === 'first-contentful-paint') {\n      console.log('FCP:', entry.startTime);\n      \n      // Send to analytics\n      if ('sendBeacon' in navigator) {\n        navigator.sendBeacon('/analytics', JSON.stringify({\n          metric: 'FCP',\n          value: entry.startTime,\n          timestamp: Date.now()\n        }));\n      }\n    }\n  }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// Optimize bundle loading with dynamic imports\nasync function loadExpensiveFeature() {\n  const { expensiveFeature } = await import('./expensive-feature.js');\n  return expensiveFeature();\n}\n\n// Implement requestIdleCallback for non-critical work\nfunction scheduleNonCriticalWork() {\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      // Perform analytics, logging, or other non-critical tasks\n      console.log('Running non-critical work during idle time');\n    }, { timeout: 2000 });\n  } else {\n    // Fallback for older browsers\n    setTimeout(() => {\n      console.log('Running non-critical work with setTimeout fallback');\n    }, 1);\n  }\n}\n\n// Virtualize long lists for better rendering performance\nclass VirtualList {\n  constructor(container, items, itemHeight) {\n    this.container = container;\n    this.items = items;\n    this.itemHeight = itemHeight;\n    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;\n    this.startIndex = 0;\n    \n    this.render();\n    this.addScrollListener();\n  }\n  \n  addScrollListener() {\n    this.container.addEventListener('scroll', () => {\n      const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);\n      if (newStartIndex !== this.startIndex) {\n        this.startIndex = newStartIndex;\n        this.render();\n      }\n    });\n  }\n  \n  render() {\n    const fragment = document.createDocumentFragment();\n    const endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);\n    \n    for (let i = this.startIndex; i < endIndex; i++) {\n      const itemElement = document.createElement('div');\n      itemElement.style.height = `${this.itemHeight}px`;\n      itemElement.textContent = this.items[i];\n      fragment.appendChild(itemElement);\n    }\n    \n    this.container.innerHTML = '';\n    this.container.appendChild(fragment);\n  }\n}\n\n// Usage\nconst container = document.getElementById('virtual-list-container');\nconst items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);\nnew VirtualList(container, items, 50);",
      "explanation": "This example demonstrates key performance optimization techniques including Core Web Vitals measurement with the Performance API, dynamic imports for code splitting, requestIdleCallback for scheduling non-critical work during browser idle time, and virtual scrolling for efficiently rendering large lists. These techniques help improve loading performance, runtime responsiveness, and overall user experience.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Quality Standards",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "13",
    "moduleSlug": "performance-optimization",
    "title": "Performance Optimization Techniques",
    "order": 13,
    "objectives": [
      "Measure and analyze Core Web Vitals using Performance API",
      "Implement code splitting with dynamic imports for better loading performance",
      "Optimize runtime performance with virtual scrolling and requestIdleCallback"
    ],
    "intro": "Performance optimization is critical for creating fast, responsive web applications that provide excellent user experiences. In this lesson, you'll learn how to measure key performance metrics using the Web Performance API, implement code splitting with dynamic imports, and optimize runtime performance with techniques like virtual scrolling and idle callback scheduling.\n\nCore Web Vitals have become essential metrics for measuring user experience quality, directly impacting SEO rankings and user engagement. You'll discover how to measure First Contentful Paint (FCP), Largest Contentful Paint (LCP), and Cumulative Layout Shift (CLS) to understand your application's performance characteristics.\n\nCode splitting allows you to load only the necessary JavaScript for the current view, reducing initial bundle sizes and improving loading times. You'll learn how to implement dynamic imports and route-based code splitting in modern JavaScript applications.\n\nRuntime performance optimization techniques like virtual scrolling help maintain smooth interactions even with large datasets, while requestIdleCallback enables you to perform non-critical work during browser idle periods without impacting user experience.\n\nBy the end of this lesson, you'll be able to identify performance bottlenecks, implement targeted optimizations, and measure the impact of your improvements to ensure optimal user experiences.",
    "code": {
      "example": "// Real Performance Optimization Example\n// Web Performance API for measuring Core Web Vitals\n\n// Measure First Contentful Paint (FCP)\nconst observer = new PerformanceObserver((list) => {\n  for (const entry of list.getEntries()) {\n    if (entry.name === 'first-contentful-paint') {\n      console.log('FCP:', entry.startTime);\n      \n      // Send to analytics\n      if ('sendBeacon' in navigator) {\n        navigator.sendBeacon('/analytics', JSON.stringify({\n          metric: 'FCP',\n          value: entry.startTime,\n          timestamp: Date.now()\n        }));\n      }\n    }\n  }\n});\n\nobserver.observe({ entryTypes: ['paint'] });\n\n// Optimize bundle loading with dynamic imports\nasync function loadExpensiveFeature() {\n  const { expensiveFeature } = await import('./expensive-feature.js');\n  return expensiveFeature();\n}\n\n// Implement requestIdleCallback for non-critical work\nfunction scheduleNonCriticalWork() {\n  if ('requestIdleCallback' in window) {\n    requestIdleCallback(() => {\n      // Perform analytics, logging, or other non-critical tasks\n      console.log('Running non-critical work during idle time');\n    }, { timeout: 2000 });\n  } else {\n    // Fallback for older browsers\n    setTimeout(() => {\n      console.log('Running non-critical work with setTimeout fallback');\n    }, 1);\n  }\n}\n\n// Virtualize long lists for better rendering performance\nclass VirtualList {\n  constructor(container, items, itemHeight) {\n    this.container = container;\n    this.items = items;\n    this.itemHeight = itemHeight;\n    this.visibleItems = Math.ceil(container.clientHeight / itemHeight) + 2;\n    this.startIndex = 0;\n    \n    this.render();\n    this.addScrollListener();\n  }\n  \n  addScrollListener() {\n    this.container.addEventListener('scroll', () => {\n      const newStartIndex = Math.floor(this.container.scrollTop / this.itemHeight);\n      if (newStartIndex !== this.startIndex) {\n        this.startIndex = newStartIndex;\n        this.render();\n      }\n    });\n  }\n  \n  render() {\n    const fragment = document.createDocumentFragment();\n    const endIndex = Math.min(this.startIndex + this.visibleItems, this.items.length);\n    \n    for (let i = this.startIndex; i < endIndex; i++) {\n      const itemElement = document.createElement('div');\n      itemElement.style.height = `${this.itemHeight}px`;\n      itemElement.textContent = this.items[i];\n      fragment.appendChild(itemElement);\n    }\n    \n    this.container.innerHTML = '';\n    this.container.appendChild(fragment);\n  }\n}\n\n// Usage\nconst container = document.getElementById('virtual-list-container');\nconst items = Array.from({ length: 10000 }, (_, i) => `Item ${i}`);\nnew VirtualList(container, items, 50);",
      "explanation": "This example demonstrates key performance optimization techniques including Core Web Vitals measurement with the Performance API, dynamic imports for code splitting, requestIdleCallback for scheduling non-critical work during browser idle time, and virtual scrolling for efficiently rendering large lists. These techniques help improve loading performance, runtime responsiveness, and overall user experience.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not following Performance best practices",
        "solution": "Review official documentation and established patterns for Performance",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling in implementation",
        "solution": "Always implement proper error handling and validation",
        "severity": "high"
      },
      {
        "mistake": "Ignoring performance implications",
        "solution": "Consider performance impact of your implementation choices",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice Lesson 13",
        "description": "Apply the concepts learned in this lesson through hands-on practice.",
        "checkpoints": [
          "Complete the basic implementation",
          "Test your solution",
          "Identify areas for improvement"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Performance",
      "Profiling",
      "Optimization"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  }
]