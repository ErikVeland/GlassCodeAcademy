[
  {
    "id": "e2e-testing-lesson-1",
    "moduleSlug": "e2e-testing",
    "title": "Introduction to End-to-End Testing",
    "order": 1,
    "objectives": [
      "Understand the purpose and benefits of end-to-end testing",
      "Learn the difference between E2E, integration, and unit testing",
      "Set up Cypress for automated browser testing"
    ],
    "intro": "End-to-end testing validates complete user workflows by testing applications from the user's perspective, ensuring all components work together correctly in real-world scenarios.\n\nIn this lesson, you'll learn why E2E testing is crucial for catching integration issues that unit tests miss. E2E tests simulate real user interactions, testing the entire application stack from frontend to backend and database.\n\nCypress and Playwright are leading tools for modern E2E testing, providing powerful APIs for browser automation, debugging capabilities, and excellent developer experience. These tools make writing reliable, maintainable tests much easier.\n\nYou'll understand the testing pyramid concept, where E2E tests form the top layer providing high-confidence validation of critical user journeys. While E2E tests are slower and more complex than unit tests, they catch issues that other testing levels miss.\n\nBy the end of this lesson, you'll have Cypress set up and understand when to use E2E testing versus other testing strategies. You'll know how to identify the most important user flows to test and create a solid foundation for building comprehensive test suites.",
    "code": {
      "example": "// cypress/e2e/user-login.cy.js\n// Basic Cypress E2E test for user login flow\n\ndescribe('User Authentication', () => {\n  beforeEach(() => {\n    // Visit the application before each test\n    cy.visit('/login');\n  });\n\n  it('should successfully log in with valid credentials', () => {\n    // Enter username\n    cy.get('[data-testid=\"username-input\"]')\n      .type('john.doe@example.com');\n    \n    // Enter password\n    cy.get('[data-testid=\"password-input\"]')\n      .type('securePassword123');\n    \n    // Submit the form\n    cy.get('[data-testid=\"login-button\"]')\n      .click();\n    \n    // Verify successful login\n    cy.url().should('include', '/dashboard');\n    cy.get('[data-testid=\"user-menu\"]')\n      .should('contain', 'Welcome, John');\n    \n    // Check that auth token is stored\n    cy.window()\n      .its('localStorage')\n      .invoke('getItem', 'authToken')\n      .should('exist');\n  });\n\n  it('should show error message for invalid credentials', () => {\n    cy.get('[data-testid=\"username-input\"]')\n      .type('invalid@example.com');\n    \n    cy.get('[data-testid=\"password-input\"]')\n      .type('wrongpassword');\n    \n    cy.get('[data-testid=\"login-button\"]')\n      .click();\n    \n    // Should remain on login page\n    cy.url().should('include', '/login');\n    \n    // Error message should appear\n    cy.get('[data-testid=\"error-message\"]')\n      .should('be.visible')\n      .and('contain', 'Invalid credentials');\n  });\n\n  it('should handle empty form submission', () => {\n    cy.get('[data-testid=\"login-button\"]')\n      .click();\n    \n    // Validation errors should appear\n    cy.get('[data-testid=\"username-error\"]')\n      .should('contain', 'Username is required');\n    \n    cy.get('[data-testid=\"password-error\"]')\n      .should('contain', 'Password is required');\n  });\n});\n\n// cypress.config.js - Basic Cypress configuration\nmodule.exports = {\n  e2e: {\n    baseUrl: 'http://localhost:3000',\n    viewportWidth: 1280,\n    viewportHeight: 720,\n    defaultCommandTimeout: 10000,\n    video: false,\n    screenshotOnRunFailure: true,\n    setupNodeEvents(on, config) {\n      // implement node event listeners here\n    },\n  },\n};",
      "explanation": "This example shows a complete Cypress E2E test for user authentication, including setup, positive and negative test cases, and proper element selection using data-testid attributes for reliable testing.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Testing implementation details instead of user behavior",
        "solution": "Focus on testing what users actually do, not internal component methods or state",
        "severity": "high"
      },
      {
        "mistake": "Creating overly complex E2E tests that are brittle and hard to maintain",
        "solution": "Keep tests simple, focused on critical paths, and use page object models for reusability",
        "severity": "medium"
      },
      {
        "mistake": "Not using proper selectors and relying on CSS classes or text content",
        "solution": "Use data-testid attributes or role-based selectors for stable, accessible test targeting",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build Your First E2E Test Suite",
        "description": "Create a comprehensive E2E test suite for a simple todo application covering key user workflows.",
        "checkpoints": [
          "Set up Cypress and configure it for your application",
          "Write tests for adding, editing, and deleting todos",
          "Test filtering functionality (all, active, completed)",
          "Implement proper assertions and error handling"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Cypress",
      "Playwright",
      "E2E Testing"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-2",
    "moduleSlug": "e2e-testing",
    "title": "Playwright for Cross-Browser Testing",
    "order": 2,
    "objectives": [
      "Set up Playwright for multi-browser E2E testing",
      "Understand Playwright's advantages over other testing tools",
      "Implement advanced testing patterns with Playwright"
    ],
    "intro": "Playwright is a powerful end-to-end testing framework that enables reliable testing across Chromium, Firefox, and WebKit browsers with a single API. It provides superior performance and debugging capabilities compared to traditional tools.\n\nIn this lesson, you'll learn why Playwright has become the preferred choice for modern E2E testing. Its auto-wait functionality eliminates flaky tests, while built-in browser automation provides more reliable and faster test execution.\n\nPlaywright's unique features include network interception, mobile device emulation, and native support for modern web features like service workers and web components. These capabilities make it ideal for testing complex, modern web applications.\n\nYou'll discover Playwright's powerful debugging tools including trace viewer, inspector, and codegen for automatically generating test code. These features significantly speed up test development and troubleshooting processes.\n\nBy mastering Playwright, you'll be able to create robust, cross-browser test suites that run consistently across different environments, catch browser-specific bugs, and provide confidence in your application's compatibility across the web ecosystem.",
    "code": {
      "example": "// tests/e2e/shopping-cart.spec.js\n// Playwright E2E test for e-commerce shopping cart\n\nconst { test, expect } = require('@playwright/test');\n\ntest.describe('Shopping Cart Functionality', () => {\n  test.beforeEach(async ({ page }) => {\n    // Navigate to the products page\n    await page.goto('/products');\n    \n    // Wait for products to load\n    await page.waitForSelector('[data-testid=\"product-grid\"]');\n  });\n\n  test('should add product to cart and proceed to checkout', async ({ page }) => {\n    // Add first product to cart\n    await page.click('[data-testid=\"product-1\"] [data-testid=\"add-to-cart\"]');\n    \n    // Verify cart badge updates\n    await expect(page.locator('[data-testid=\"cart-badge\"]')).toContainText('1');\n    \n    // Open cart\n    await page.click('[data-testid=\"cart-icon\"]');\n    \n    // Verify product in cart\n    await expect(page.locator('[data-testid=\"cart-item\"]')).toBeVisible();\n    await expect(page.locator('[data-testid=\"cart-total\"]')).toContainText('$29.99');\n    \n    // Proceed to checkout\n    await page.click('[data-testid=\"checkout-button\"]');\n    \n    // Verify on checkout page\n    await expect(page).toHaveURL(/.*checkout/);\n    await expect(page.locator('h1')).toContainText('Checkout');\n  });\n\n  test('should handle empty cart scenario', async ({ page }) => {\n    // Go directly to cart\n    await page.click('[data-testid=\"cart-icon\"]');\n    \n    // Verify empty cart message\n    await expect(page.locator('[data-testid=\"empty-cart-message\"]'))\n      .toContainText('Your cart is empty');\n    \n    // Checkout button should be disabled\n    await expect(page.locator('[data-testid=\"checkout-button\"]'))\n      .toBeDisabled();\n  });\n\n  test('should work across different browsers', async ({ browserName, page }) => {\n    console.log(`Running on ${browserName}`);\n    \n    // Test core functionality\n    await page.click('[data-testid=\"product-1\"] [data-testid=\"add-to-cart\"]');\n    await expect(page.locator('[data-testid=\"cart-badge\"]')).toContainText('1');\n    \n    // Browser-specific behavior could be tested here\n    if (browserName === 'webkit') {\n      // Safari-specific tests\n    }\n  });\n\n  test('should handle network failures gracefully', async ({ page }) => {\n    // Intercept and block network request\n    await page.route('**/api/cart', route => {\n      route.abort();\n    });\n    \n    // Try to add to cart\n    await page.click('[data-testid=\"product-1\"] [data-testid=\"add-to-cart\"]');\n    \n    // Verify error handling\n    await expect(page.locator('[data-testid=\"error-toast\"]'))\n      .toContainText('Failed to add item to cart');\n  });\n});\n\n// playwright.config.js\nmodule.exports = {\n  testDir: './tests/e2e',\n  timeout: 30000,\n  fullyParallel: true,\n  forbidOnly: !!process.env.CI,\n  retries: process.env.CI ? 2 : 0,\n  workers: process.env.CI ? 1 : undefined,\n  reporter: 'html',\n  use: {\n    baseURL: 'http://localhost:3000',\n    trace: 'on-first-retry',\n    video: 'retain-on-failure',\n    screenshot: 'only-on-failure',\n  },\n  projects: [\n    {\n      name: 'chromium',\n      use: { ...devices['Desktop Chrome'] },\n    },\n    {\n      name: 'firefox',\n      use: { ...devices['Desktop Firefox'] },\n    },\n    {\n      name: 'webkit',\n      use: { ...devices['Desktop Safari'] },\n    },\n  ],\n};",
      "explanation": "This example demonstrates Playwright's capabilities including cross-browser testing, network interception, auto-waiting, and robust selectors. Notice the configuration for running tests across multiple browsers.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not configuring proper timeouts for different browsers",
        "solution": "Set appropriate timeouts and retries in playwright.config.js for browser differences",
        "severity": "medium"
      },
      {
        "mistake": "Ignoring browser-specific behavior and edge cases",
        "solution": "Test critical functionality across all target browsers and handle browser-specific issues",
        "severity": "high"
      },
      {
        "mistake": "Not using Playwright's auto-waiting features effectively",
        "solution": "Rely on Playwright's built-in waiting instead of arbitrary delays or manual waits",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Cross-Browser E-commerce Testing",
        "description": "Build a comprehensive Playwright test suite for an e-commerce application that runs across multiple browsers.",
        "checkpoints": [
          "Set up Playwright with Chromium, Firefox, and WebKit browsers",
          "Create tests for product search, cart functionality, and checkout process",
          "Implement network interception to test offline scenarios",
          "Add visual regression testing with screenshot comparisons"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 30,
    "difficulty": "Advanced",
    "tags": [
      "Cypress",
      "Playwright",
      "E2E Testing"
    ],
    "lastUpdated": "2025-10-01T06:42:16.317Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-3",
    "moduleSlug": "e2e-testing",
    "title": "Advanced Cypress Patterns and Best Practices",
    "order": 3,
    "objectives": [
      "Master advanced Cypress patterns including custom commands and page objects",
      "Implement best practices for reliable, maintainable end-to-end tests",
      "Utilize Cypress's powerful features like intercept, clock, and fixture management"
    ],
    "intro": "Cypress is a powerful end-to-end testing framework that provides developers with the tools to write reliable, fast, and maintainable tests for modern web applications. While basic Cypress tests can cover simple scenarios, advanced patterns and best practices are essential for creating robust test suites that scale with your application.\n\nIn this lesson, you'll learn about custom commands that allow you to encapsulate common actions and assertions into reusable functions, reducing code duplication and improving test readability. Page objects provide a structured approach to modeling your application's UI, making tests more maintainable and less brittle when UI elements change.\n\nCypress's intercept feature enables powerful network request mocking and response manipulation, allowing you to test various scenarios including error conditions, loading states, and edge cases without relying on actual backend services. Time manipulation with cy.clock() enables testing of time-dependent functionality like timers, intervals, and scheduled events.\n\nBy mastering these advanced Cypress patterns and best practices, you'll be able to create comprehensive end-to-end tests that simulate real user interactions, handle complex scenarios, and provide valuable feedback throughout your development process.",
    "code": {
      "example": "// Advanced Cypress patterns with custom commands and page objects\n\ndescribe('E-Commerce Application Tests', () => {\n  beforeEach(() => {\n    // Reset database and seed test data before each test\n    cy.task('seedDatabase');\n    cy.visit('/');\n  });\n  \n  afterEach(() => {\n    // Take screenshot on test failure for debugging\n    if (Cypress.currentTest.state === 'failed') {\n      cy.screenshot(`failure-${Cypress.currentTest.title}`);\n    }\n  });\n  \n  it('allows users to complete a purchase flow', () => {\n    // Using custom commands for common actions\n    cy.login('user@example.com', 'password123');\n    \n    // Navigate to products page\n    cy.get('[data-cy=nav-products]').click();\n    \n    // Search for a product\n    cy.searchProduct('laptop');\n    \n    // Add product to cart\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    \n    // Go to cart\n    cy.get('[data-cy=cart-link]').click();\n    \n    // Verify cart contents\n    cy.get('[data-cy=cart-items]').should('have.length', 1);\n    cy.get('[data-cy=cart-total]').should('contain', '$999.99');\n    \n    // Proceed to checkout\n    cy.get('[data-cy=checkout-button]').click();\n    \n    // Fill shipping information using page object\n    const checkoutPage = new CheckoutPage();\n    checkoutPage.fillShippingInfo({\n      firstName: 'John',\n      lastName: 'Doe',\n      address: '123 Main St',\n      city: 'New York',\n      zipCode: '10001'\n    });\n    \n    // Confirm order\n    cy.get('[data-cy=order-summary]').should('be.visible');\n    cy.get('[data-cy=confirm-order]').click();\n    \n    // Verify success message\n    cy.get('[data-cy=order-success]').should('contain', 'Order placed successfully');\n    cy.get('[data-cy=order-number]').should('contain', 'ORD-');\n  });\n  \n  it('shows error for invalid coupon code', () => {\n    cy.login('user@example.com', 'password123');\n    \n    // Add item to cart\n    cy.get('[data-cy=nav-products]').click();\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    \n    // Go to cart\n    cy.get('[data-cy=cart-link]').click();\n    \n    // Apply invalid coupon using custom command\n    cy.applyCoupon('INVALID');\n    \n    // Verify error message\n    cy.get('[data-cy=coupon-error]').should('be.visible')\n      .and('contain', 'Invalid coupon code');\n  });\n  \n  it('handles network errors gracefully', () => {\n    // Intercept API calls and simulate network failure\n    cy.intercept('POST', '/api/checkout', {\n      statusCode: 500,\n      body: { error: 'Internal server error' }\n    }).as('checkoutRequest');\n    \n    cy.login('user@example.com', 'password123');\n    \n    // Add item to cart and proceed to checkout\n    cy.get('[data-cy=nav-products]').click();\n    cy.get('[data-cy=product-item]').first().within(() => {\n      cy.get('[data-cy=add-to-cart]').click();\n    });\n    cy.get('[data-cy=cart-link]').click();\n    cy.get('[data-cy=checkout-button]').click();\n    \n    // Fill shipping information\n    const checkoutPage = new CheckoutPage();\n    checkoutPage.fillShippingInfo({\n      firstName: 'John',\n      lastName: 'Doe',\n      address: '123 Main St',\n      city: 'New York',\n      zipCode: '10001'\n    });\n    \n    // Confirm order (will fail due to network error)\n    cy.get('[data-cy=confirm-order]').click();\n    \n    // Verify error handling\n    cy.get('[data-cy=error-message]').should('be.visible')\n      .and('contain', 'Unable to process your order');\n  });\n});\n\n// Page Object pattern for Checkout page\nclass CheckoutPage {\n  constructor() {\n    this.elements = {\n      firstName: () => cy.get('[data-cy=first-name]'),\n      lastName: () => cy.get('[data-cy=last-name]'),\n      address: () => cy.get('[data-cy=address]'),\n      city: () => cy.get('[data-cy=city]'),\n      zipCode: () => cy.get('[data-cy=zip-code]'),\n      submitButton: () => cy.get('[data-cy=submit]')\n    };\n  }\n  \n  fillShippingInfo(shippingData) {\n    this.elements.firstName().type(shippingData.firstName);\n    this.elements.lastName().type(shippingData.lastName);\n    this.elements.address().type(shippingData.address);\n    this.elements.city().type(shippingData.city);\n    this.elements.zipCode().type(shippingData.zipCode);\n    this.elements.submitButton().click();\n    return this;\n  }\n  \n  fillPaymentInfo(paymentData) {\n    // Implementation for payment form\n    return this;\n  }\n}\n\n// Custom Cypress commands (in cypress/support/commands.js)\nCypress.Commands.add('login', (email, password) => {\n  cy.visit('/login');\n  cy.get('[data-cy=email]').type(email);\n  cy.get('[data-cy=password]').type(password);\n  cy.get('[data-cy=submit]').click();\n  cy.get('[data-cy=dashboard]').should('be.visible');\n});\n\nCypress.Commands.add('searchProduct', (searchTerm) => {\n  cy.get('[data-cy=search-input]').type(searchTerm);\n  cy.get('[data-cy=search-button]').click();\n});\n\nCypress.Commands.add('applyCoupon', (couponCode) => {\n  cy.get('[data-cy=coupon-input]').type(couponCode);\n  cy.get('[data-cy=apply-coupon]').click();\n});\n\n// Custom tasks for database operations (in cypress/plugins/index.js)\nmodule.exports = (on, config) => {\n  on('task', {\n    seedDatabase() {\n      // Reset database and insert test data\n      // Implementation would depend on your specific database setup\n      console.log('Seeding test database');\n      return null;\n    },\n    \n    resetDatabase() {\n      // Clear all data\n      console.log('Resetting database');\n      return null;\n    },\n    \n    queryDatabase(query, params = []) {\n      // Execute database query and return results\n      // This would connect to your test database\n      console.log('Executing database query:', query);\n      return [];
    }
  });
};

// Advanced network interception examples
describe('Network Interception Tests', () => {
  it('tests loading states with delayed responses', () => {
    // Intercept and delay the response
    cy.intercept('/api/products', (req) => {
      req.reply((res) => {
        res.delay(2000); // Delay response by 2 seconds
      });
    }).as('getProducts');
    
    cy.visit('/products');
    
    // Verify loading state is shown
    cy.get('[data-cy=loading-spinner]').should('be.visible');
    
    // Wait for response and verify content loads
    cy.wait('@getProducts');
    cy.get('[data-cy=product-list]').should('be.visible');
    cy.get('[data-cy=loading-spinner]').should('not.exist');
  });
  
  it('tests error handling with network failures', () => {
    // Intercept and force network error
    cy.intercept('/api/products', { forceNetworkError: true }).as('failedRequest');
    
    cy.visit('/products');
    
    // Verify error message is displayed
    cy.wait('@failedRequest');
    cy.get('[data-cy=error-message]').should('contain', 'Failed to load products');
    cy.get('[data-cy=retry-button]').should('be.visible');
  });
  
  it('tests different response scenarios', () => {
    // Test with empty response
    cy.intercept('GET', '/api/products', []).as('emptyProducts');
    
    cy.visit('/products');
    cy.wait('@emptyProducts');
    cy.get('[data-cy=empty-state]').should('be.visible');
    
    // Test with error response
    cy.intercept('GET', '/api/products', {
      statusCode: 500,
      body: { error: 'Server error' }
    }).as('serverError');
    
    cy.reload();
    cy.wait('@serverError');
    cy.get('[data-cy=error-message]').should('contain', 'Server error');
  });
});

// Time manipulation tests
describe('Time-based Functionality Tests', () => {
  it('tests auto-logout functionality', () => {
    // Freeze time
    cy.clock();
    
    cy.login('user@example.com', 'password123');
    
    // Advance time by 30 minutes (assuming 30-minute timeout)
    cy.tick(30 * 60 * 1000);
    
    // Verify user is logged out
    cy.get('[data-cy=login-form]').should('be.visible');
    cy.get('[data-cy=toast-message]').should('contain', 'Session expired');
  });
  
  it('tests countdown timers', () => {
    cy.visit('/auction/123');
    
    // Freeze time at a specific point
    const now = new Date(2023, 0, 1, 12, 0, 0);
    cy.clock(now);
    
    // Advance time and verify countdown updates
    cy.get('[data-cy=countdown]').should('contain', '24:00:00');
    
    cy.tick(5 * 60 * 1000); // Advance 5 minutes
    cy.get('[data-cy=countdown]').should('contain', '23:55:00');
  });
});

// Fixture management examples
describe('Fixture-based Tests', () => {
  it('loads user data from fixture', () => {
    // Load user data from fixture file
    cy.fixture('users/admin.json').then((adminUser) => {
      cy.login(adminUser.email, adminUser.password);
      cy.get('[data-cy=user-name]').should('contain', adminUser.name);
    });
  });
  
  it('tests with dynamic fixture data', () => {
    // Generate dynamic test data
    const testData = {
      productName: `Test Product ${Date.now()}`,
      price: Math.floor(Math.random() * 100) + 1
    };
    
    // Create product via API
    cy.request('POST', '/api/products', testData);
    
    // Verify product appears in UI
    cy.visit('/products');
    cy.contains(testData.productName).should('be.visible');
  });
});",
      "explanation": "This example demonstrates advanced Cypress testing patterns including custom commands for reusable actions, page objects for UI modeling, network interception for API mocking, time manipulation for testing time-dependent functionality, and fixture management for test data.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating overly complex page objects that are difficult to maintain",
        "solution": "Keep page objects focused on specific pages or components, and avoid deep nesting or overly complex abstractions",
        "severity": "medium"
      },
      {
        "mistake": "Not properly cleaning up interceptors between tests",
        "solution": "Use aliases and proper teardown to ensure network interceptors don't leak between tests",
        "severity": "high"
      },
      {
        "mistake": "Overusing custom commands for simple actions",
        "solution": "Reserve custom commands for complex, frequently used actions; simple actions should be explicit in tests",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Advanced Cypress Tests for a Social Media Platform",
        "description": "Create comprehensive end-to-end tests for a social media application using advanced Cypress patterns.",
        "checkpoints": [
          "Implement page objects for key application pages (feed, profile, settings)",
          "Create custom commands for common user actions (posting, commenting, liking)",
          "Test network error handling with intercept for API failures",
          "Implement time-based tests for features like story expiration",
          "Use fixtures to manage test user data and content",
          "Test authentication flows including session timeout"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Expert",
    "tags": [
      "Cypress",
      "End-to-End Testing",
      "Page Objects",
      "Custom Commands",
      "Network Interception"
    ],
    "lastUpdated": "2025-10-03T16:00:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "e2e-testing-lesson-4",
    "moduleSlug": "e2e-testing",
    "title": "Performance and Load Testing for E2E Tests",
    "order": 4,
    "objectives": [
      "Implement performance testing strategies for end-to-end test suites",
      "Measure and analyze application performance under various conditions",
      "Optimize test execution speed and resource utilization"
    ],
    "intro": "Performance and load testing are critical aspects of end-to-end testing that ensure your application can handle expected user loads and respond within acceptable timeframes. While functional correctness is essential, performance characteristics directly impact user experience and business outcomes.\n\nIn this lesson, you'll learn how to measure test execution performance, identify bottlenecks in your test suite, and optimize test runs for faster feedback cycles. You'll explore techniques for simulating concurrent user loads, measuring response times, and analyzing performance metrics to identify areas for improvement.\n\nCypress and Playwright both provide mechanisms for performance testing, though they serve different purposes. Cypress excels at measuring UI interaction performance and identifying client-side bottlenecks, while Playwright's multi-browser support makes it ideal for cross-browser performance comparisons.\n\nYou'll also learn about load testing tools that integrate with your E2E testing workflow, enabling you to simulate realistic user scenarios at scale. Understanding how to balance comprehensive testing with performance constraints is crucial for maintaining efficient development workflows.\n\nBy mastering performance and load testing for E2E tests, you'll be able to create test suites that not only verify functionality but also ensure your application performs well under real-world conditions.",
    "code": {
      "example": "// Performance and Load Testing for E2E Tests\n\n// 1. Measuring Test Performance\ndescribe('Performance Monitoring Tests', () => {\n  it('measures page load performance', () => {\n    const startTime = performance.now();\n    \n    cy.visit('/dashboard')\n      .then(() => {\n        const endTime = performance.now();\n        const loadTime = endTime - startTime;\n        \n        // Assert page loads within acceptable time\n        expect(loadTime).to.be.lessThan(3000); // 3 seconds\n        \n        // Log performance metrics\n        cy.task('logPerformance', {\n          testName: 'Dashboard Load Time',\n          duration: loadTime,\n          timestamp: new Date().toISOString()\n        });\n      });\n  });\n  \n  it('measures API response times', () => {\n    cy.intercept('GET', '/api/users').as('getUsers');\n    \n    cy.visit('/users');\n    cy.wait('@getUsers').then((interception) => {\n      const responseTime = interception.response.headers['response-time'];\n      expect(responseTime).to.be.lessThan(500); // 500ms\n      \n      cy.task('logPerformance', {\n        testName: 'Users API Response Time',\n        duration: responseTime,\n        timestamp: new Date().toISOString()\n      });\n    });\n  });\n});\n\n// 2. Concurrent User Simulation\ndescribe('Concurrent User Load Testing', () => {\n  // This would typically be run with a load testing tool like Artillery or k6\n  // Example using Cypress with parallel execution\n  \n  const users = [\n    { email: 'user1@example.com', password: 'password123' },\n    { email: 'user2@example.com', password: 'password123' },\n    { email: 'user3@example.com', password: 'password123' }\n  ];\n  \n  users.forEach((user, index) => {\n    it(`User ${index + 1} performs shopping workflow`, () => {\n      // Each user performs the same workflow concurrently\n      cy.login(user.email, user.password);\n      cy.visit('/products');\n      cy.get('[data-cy=product-item]').first().click();\n      cy.get('[data-cy=add-to-cart]').click();\n      cy.get('[data-cy=cart-link]').click();\n      cy.get('[data-cy=checkout-button]').click();\n      \n      // Measure workflow completion time\n      const startTime = Date.now();\n      cy.get('[data-cy=confirm-order]').click();\n      cy.get('[data-cy=order-success]').should('be.visible');\n      const endTime = Date.now();\n      \n      const workflowTime = endTime - startTime;\n      expect(workflowTime).to.be.lessThan(10000); // 10 seconds\n      \n      cy.task('logPerformance', {\n        testName: `User ${index + 1} Shopping Workflow`,\n        duration: workflowTime,\n        timestamp: new Date().toISOString()\n      });\n    });\n  });\n});\n\n// 3. Resource Utilization Monitoring\ndescribe('Resource Utilization Tests', () => {\n  it('monitors memory usage during complex interactions', () => {\n    // Visit a complex page\n    cy.visit('/dashboard');\n    \n    // Perform memory-intensive actions\n    cy.get('[data-cy=refresh-data]').click();\n    cy.get('[data-cy=refresh-data]').click();\n    cy.get('[data-cy=refresh-data]').click();\n    \n    // Check for memory leaks\n    cy.window().then((win) => {\n      const memoryUsage = win.performance.memory;\n      const usedMemory = memoryUsage.usedJSHeapSize;\n      const totalMemory = memoryUsage.jsHeapSizeLimit;\n      \n      // Log memory usage\n      cy.task('logMemoryUsage', {\n        used: usedMemory,\n        total: totalMemory,\n        percentage: (usedMemory / totalMemory) * 100\n      });\n      \n      // Assert memory usage is reasonable\n      expect(usedMemory).to.be.lessThan(totalMemory * 0.8); // Less than 80%\n    });\n  });\n  \n  it('checks for DOM node leaks', () => {\n    cy.visit('/list');\n    \n    // Count DOM nodes before\n    cy.document().then((doc) => {\n      const initialNodeCount = doc.querySelectorAll('*').length;\n      \n      // Perform actions that might create node leaks\n      cy.get('[data-cy=refresh]').click();\n      cy.get('[data-cy=refresh]').click();\n      \n      // Count DOM nodes after\n      cy.document().then((doc) => {\n        const finalNodeCount = doc.querySelectorAll('*').length;\n        \n        // Assert no significant increase in DOM nodes\n        expect(finalNodeCount - initialNodeCount).to.be.lessThan(100);\n      });\n    });\n  });\n});\n\n// 4. Test Suite Optimization\ndescribe('Optimized Test Suite', () => {\n  // Shared setup for multiple tests\n  before(() => {\n    // Expensive setup done once\n    cy.task('seedDatabase');\n    cy.task('startMockServer');\n  });\n  \n  // Setup for each test group\n  beforeEach(() => {\n    // Lightweight setup for each test\n    cy.visit('/');\n  });\n  \n  // Teardown\n  after(() => {\n    cy.task('stopMockServer');\n  });\n  \n  it('performs user registration quickly', () => {\n    cy.get('[data-cy=register-link]').click();\n    cy.get('[data-cy=email]').type(`test${Date.now()}@example.com`);\n    cy.get('[data-cy=password]').type('securePassword123');\n    cy.get('[data-cy=submit]').click();\n    cy.get('[data-cy=welcome]').should('be.visible');\n  });\n  \n  it('performs user login quickly', () => {\n    cy.get('[data-cy=login-link]').click();\n    cy.get('[data-cy=email]').type('user@example.com');\n    cy.get('[data-cy=password]').type('securePassword123');\n    cy.get('[data-cy=submit]').click();\n    cy.get('[data-cy=dashboard]').should('be.visible');\n  });\n});\n\n// 5. Performance Reporting\n// Custom task implementation (cypress/plugins/index.js)\nmodule.exports = (on, config) => {\n  let performanceData = [];\n  \n  on('task', {\n    logPerformance(data) {\n      performanceData.push(data);\n      console.log(`Performance: ${data.testName} took ${data.duration}ms`);\n      return null;\n    },\n    \n    logMemoryUsage(data) {\n      console.log(`Memory Usage: ${data.percentage.toFixed(2)}%`);\n      return null;\n    },\n    \n    generatePerformanceReport() {\n      // Generate performance report\n      const report = {\n        timestamp: new Date().toISOString(),\n        tests: performanceData,\n        summary: {\n          averageDuration: performanceData.reduce((sum, test) => sum + test.duration, 0) / performanceData.length,\n          slowestTest: performanceData.reduce((slowest, test) => test.duration > slowest.duration ? test : slowest, { duration: 0 }),\n          fastestTest: performanceData.reduce((fastest, test) => test.duration < fastest.duration ? test : fastest, { duration: Infinity })\n        }\n      };\n      \n      // Save report to file\n      const fs = require('fs');\n      fs.writeFileSync('performance-report.json', JSON.stringify(report, null, 2));\n      \n      return report;\n    }\n  });\n  \n  // Generate report after all tests\n  on('after:run', (results) => {\n    if (results) {\n      return cy.task('generatePerformanceReport');\n    }\n  });\n};",
      "explanation": "This example demonstrates performance and load testing techniques for E2E tests including measuring page load times, API response times, concurrent user simulation, resource utilization monitoring, test suite optimization, and performance reporting.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Running performance tests in uncontrolled environments",
        "solution": "Use dedicated test environments with consistent hardware and network conditions for reliable performance measurements",
        "severity": "high"
      },
      {
        "mistake": "Not distinguishing between test performance and application performance",
        "solution": "Separate infrastructure performance from application performance to identify true bottlenecks",
        "severity": "medium"
      },
      {
        "mistake": "Overloading systems during performance testing",
        "solution": "Gradually increase load and monitor system health to avoid overwhelming test environments",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement Performance Monitoring for an E-Commerce Application",
        "description": "Create performance tests for a shopping application that measure page load times, API response times, and resource utilization.",
        "checkpoints": [
          "Measure and log page load performance for key application pages",
          "Monitor API response times and identify slow endpoints",
          "Implement concurrent user simulation for critical workflows",
          "Check for memory leaks and DOM node accumulation",
          "Optimize test suite execution with shared setup and teardown",
          "Generate performance reports with summary statistics"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 75,
    "difficulty": "Expert",
    "tags": [
      "Performance Testing",
      "Load Testing",
      "E2E Testing",
      "Cypress",
      "Playwright"
    ],
    "lastUpdated": "2025-10-03T16:00:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "e2e-testing-lesson-5",
    "moduleSlug": "e2e-testing",
    "title": "Security Testing in E2E Test Suites",
    "order": 5,
    "objectives": [
      "Identify and test for common web application security vulnerabilities",
      "Implement security-focused end-to-end tests for authentication and authorization",
      "Validate input sanitization and secure data handling in UI workflows"
    ],
    "intro": "Security testing within end-to-end test suites is essential for identifying vulnerabilities that could be exploited through user interactions with your application. While unit tests can verify individual security controls, E2E tests validate that security measures work correctly when components are integrated and used as real users would interact with them.\n\nIn this lesson, you'll learn to test for common web security vulnerabilities such as cross-site scripting (XSS), cross-site request forgery (CSRF), injection attacks, and broken authentication mechanisms. You'll understand how to simulate malicious user behavior and verify that your application's defenses are effective.\n\nAuthentication and authorization testing in E2E scenarios requires careful consideration of session management, privilege escalation, and access control enforcement. You'll learn techniques for testing login workflows, session timeout handling, and permission-based UI restrictions.\n\nInput validation and sanitization testing ensures that user-provided data is properly handled throughout your application. You'll discover how to test form submissions with malicious payloads and verify that your application prevents harmful data from affecting system behavior.\n\nBy incorporating security testing into your E2E test suites, you'll be able to catch security vulnerabilities early in the development process and ensure that your application maintains a strong security posture when used in real-world scenarios.",
    "code": {
      "example": "// Security Testing in E2E Test Suites\n\n// 1. Testing for Cross-Site Scripting (XSS) Vulnerabilities\ndescribe('XSS Security Tests', () => {\n  it('prevents XSS in user input fields', () => {\n    const xssPayload = '<script>alert(\"XSS\")</script>';
    
    cy.visit('/profile');
    cy.get('[data-cy=edit-bio]').click();
    cy.get('[data-cy=bio-input]').type(xssPayload);
    cy.get('[data-cy=save]').click();
    
    // Verify payload is sanitized (not executed)
    cy.get('[data-cy=user-bio]').should('not.contain', '<script>');
    cy.get('[data-cy=user-bio]').should('contain', 'alert(\"XSS\")');
    
    // Alternative: Check that script tags are escaped
    cy.get('[data-cy=user-bio]').should('contain', '&lt;script&gt;');
  });\n  \n  it('prevents XSS in URL parameters', () => {\n    const xssPayload = 'javascript:alert(\"XSS\")';
    \n    // Visit page with malicious URL parameter\n    cy.visit(`/search?q=${encodeURIComponent(xssPayload)}`);
    \n    // Verify payload is not executed\n    cy.get('[data-cy=search-results]').should('be.visible');\n    cy.get('body').should('not.have.attr', 'onload');
  });
});

// 2. Testing Authentication and Session Security
describe('Authentication Security Tests', () => {
  it('prevents session fixation attacks', () => {
    // Start with a known session ID
    cy.visit('/login');
    cy.getCookie('sessionid').then((cookie) => {
      const initialSessionId = cookie.value;
      
      // Login with valid credentials
      cy.get('[data-cy=email]').type('user@example.com');
      cy.get('[data-cy=password]').type('securePassword123');
      cy.get('[data-cy=login-button]').click();
      
      // Verify session ID has changed (prevents fixation)
      cy.getCookie('sessionid').should((newCookie) => {
        expect(newCookie.value).to.not.eq(initialSessionId);
      });
    });
  });
  
  it('implements proper session timeout', () => {
    cy.login('user@example.com', 'securePassword123');
    
    // Simulate session timeout
    cy.clock();
    cy.tick(30 * 60 * 1000); // Advance 30 minutes
    
    // Try to access protected resource
    cy.visit('/dashboard');
    
    // Should be redirected to login
    cy.url().should('include', '/login');
    cy.get('[data-cy=login-form]').should('be.visible');
  });
  
  it('prevents brute force login attempts', () => {
    // Attempt multiple failed logins
    for (let i = 0; i < 6; i++) {
      cy.visit('/login');
      cy.get('[data-cy=email]').type('user@example.com');
      cy.get('[data-cy=password]').type(`wrongpassword${i}`);
      cy.get('[data-cy=login-button]').click();
    }
    
    // Verify account is locked or CAPTCHA is required
    cy.get('[data-cy=account-locked]').should('be.visible')
      .and('contain', 'Account temporarily locked');
  });
});

// 3. Testing Authorization and Access Control
describe('Authorization Security Tests', () => {
  it('prevents privilege escalation', () => {
    // Login as regular user
    cy.login('user@example.com', 'securePassword123');
    \n    // Try to access admin-only page\n    cy.visit('/admin');
    \n    // Should be denied access\n    cy.get('[data-cy=access-denied]').should('be.visible')\n      .and('contain', 'Insufficient permissions');
    \n    // Alternative: Should be redirected to user dashboard\n    cy.url().should('not.include', '/admin');
  });
  
  it('implements proper CSRF protection', () => {
    // Login and get CSRF token
    cy.login('user@example.com', 'securePassword123');
    \n    // Try to make request without CSRF token\n    cy.request({
      method: 'POST',
      url: '/api/settings',
      body: { theme: 'dark' },
      failOnStatusCode: false
    }).then((response) => {\n      // Should be rejected\n      expect(response.status).to.eq(403);
    });
  });
  
  it('prevents direct object reference attacks', () => {
    // Login as user who should only access their own data
    cy.login('user@example.com', 'securePassword123');
    \n    // Try to access another user's data\n    cy.visit('/profile/12345'); // ID of another user
    \n    // Should be denied access\n    cy.get('[data-cy=access-denied]').should('be.visible')
      .and('contain', 'Access denied');
  });
});

// 4. Testing Input Validation and Sanitization
describe('Input Validation Security Tests', () => {
  it('prevents SQL injection in form submissions', () => {
    const sqlInjectionPayload = "'; DROP TABLE users; --";
    \n    cy.visit('/search');
    cy.get('[data-cy=search-input]').type(sqlInjectionPayload);
    cy.get('[data-cy=search-button]').click();
    \n    // Should handle gracefully, not crash\n    cy.get('[data-cy=search-results]').should('be.visible');
    cy.get('[data-cy=error-message]').should('not.exist');
  });\n  \n  it('validates file uploads for malicious content', () => {\n    cy.login('user@example.com', 'securePassword123');
    cy.visit('/upload');
    \n    // Try to upload suspicious file\n    cy.get('[data-cy=file-input]').selectFile({
      contents: 'malicious script content',
      fileName: 'malicious.js',
      mimeType: 'application/javascript'
    });
    \n    cy.get('[data-cy=upload-button]').click();
    \n    // Should reject or sanitize file\n    cy.get('[data-cy=error-message]').should('be.visible')
      .and('contain', 'Invalid file type');
  });
  
  it('implements proper rate limiting', () => {
    // Make multiple rapid requests
    for (let i = 0; i < 11; i++) {
      cy.request({
        method: 'GET',
        url: '/api/public-data',
        failOnStatusCode: false
      });
    }\n    \n    // Should eventually be rate limited\n    cy.request({
      method: 'GET',
      url: '/api/public-data',
      failOnStatusCode: false
    }).then((response) => {\n      expect(response.status).to.eq(429); // Too Many Requests
    });
  });
});

// 5. Security Test Utilities and Helpers
// Custom command for security testing
Cypress.Commands.add('testXSS', (selector, payload) => {
  cy.get(selector).type(payload);
  cy.get('[data-cy=submit]').click();
  \n  // Verify payload is not executed\n  cy.get('body').should('not.contain', '<script>');
  cy.get('body').should('not.contain', 'alert(');
});

// Security-focused assertions
Cypress.Commands.add('assertSecureRedirect', (url) => {
  cy.url().should('not.include', url);
  cy.get('[data-cy=access-denied]').should('be.visible');
});

// Security test setup
beforeEach(() => {
  // Reset security test state
  cy.task('resetSecurityTestEnvironment');
  cy.clearCookies();
  cy.clearLocalStorage();
});",
      "explanation": "This example demonstrates security testing techniques for E2E test suites including XSS prevention testing, authentication and session security validation, authorization and access control verification, input validation testing, and security-focused test utilities.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Testing security in isolation without considering integrated attack vectors",
        "solution": "Design security tests that simulate realistic attack scenarios involving multiple components and user interactions",
        "severity": "high"
      },
      {
        "mistake": "Relying solely on automated security scanning tools",
        "solution": "Combine automated tools with manual E2E tests that verify security controls in realistic user workflows",
        "severity": "medium"
      },
      {
        "mistake": "Not testing both positive and negative security scenarios",
        "solution": "Test both valid use cases and malicious attempts to ensure comprehensive security coverage",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Implement Security Tests for a Banking Application",
        "description": "Create comprehensive security tests for a financial application that validate authentication, authorization, input validation, and session management.",
        "checkpoints": [
          "Test for XSS vulnerabilities in all user input fields and display areas",
          "Verify proper session management including timeout and fixation prevention",
          "Validate authorization controls for different user roles and permissions",
          "Test input validation for SQL injection and other injection attacks",
          "Implement rate limiting tests for API endpoints",
          "Create custom security-focused Cypress commands and assertions"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 75,
    "difficulty": "Expert",
    "tags": [
      "Security Testing",
      "E2E Testing",
      "Cypress",
      "XSS",
      "Authentication",
      "Authorization"
    ],
    "lastUpdated": "2025-10-03T16:00:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "e2e-testing-lesson-6",
    "moduleSlug": "e2e-testing",
    "title": "Maintaining Code Quality in E2E Test Suites",
    "order": 6,
    "objectives": [
      "Implement best practices for organizing and structuring E2E test code",
      "Apply design patterns that improve test maintainability and readability",
      "Utilize linting, formatting, and static analysis tools for test code quality"
    ],
    "intro": "Maintaining high code quality in end-to-end test suites is crucial for ensuring tests remain reliable, maintainable, and valuable over time. Poorly structured test code can become a burden rather than an asset, leading to flaky tests, difficult debugging, and reduced confidence in the test suite.\n\nIn this lesson, you'll learn about organizing test code using page objects, custom commands, and reusable utilities that make tests more readable and maintainable. You'll discover design patterns that help manage test complexity and reduce duplication while improving test clarity.\n\nCode quality tools and practices for E2E tests include linting rules specific to testing frameworks, formatting standards that improve readability, and static analysis that catches potential issues before they cause test failures. You'll learn how to configure these tools for your test suite.\n\nTest data management strategies help maintain clean, predictable test environments while avoiding data pollution between tests. You'll explore techniques for creating, using, and cleaning up test data effectively.\n\nBy applying code quality principles to your E2E test suites, you'll create tests that are easier to write, debug, and maintain, ultimately providing more value to your development process and improving overall software quality.",
    "code": {
      "example": "// Maintaining Code Quality in E2E Test Suites\n\n// 1. Page Object Model Implementation\n// Page objects centralize element selectors and actions for each page\nclass LoginPage {\n  constructor() {\n    this.url = '/login';\n    this.elements = {\n      emailInput: '[data-cy=email]',\n      passwordInput: '[data-cy=password]',\n      submitButton: '[data-cy=submit]',\n      errorMessage: '[data-cy=error-message]',\n      successMessage: '[data-cy=success-message]'\n    };\n  }\n  \n  visit() {\n    cy.visit(this.url);\n    return this;\n  }\n  \n  fillEmail(email) {\n    cy.get(this.elements.emailInput).type(email);\n    return this;\n  }\n  \n  fillPassword(password) {\n    cy.get(this.elements.passwordInput).type(password);\n    return this;\n  }\n  \n  submit() {\n    cy.get(this.elements.submitButton).click();\n    return this;\n  }\n  \n  login(email, password) {\n    this.fillEmail(email)\n        .fillPassword(password)\n        .submit();\n    return this;\n  }\n  \n  assertErrorMessage(message) {\n    cy.get(this.elements.errorMessage)\n      .should('be.visible')\n      .and('contain', message);\n    return this;\n  }\n  \n  assertSuccessMessage(message) {\n    cy.get(this.elements.successMessage)\n      .should('be.visible')\n      .and('contain', message);\n    return this;\n  }\n}\n\n// Usage of page object\ndescribe('Login Functionality', () => {\n  const loginPage = new LoginPage();\n  \n  beforeEach(() => {\n    loginPage.visit();\n  });\n  \n  it('shows error for invalid credentials', () => {\n    loginPage\n      .login('invalid@example.com', 'wrongpassword')\n      .assertErrorMessage('Invalid credentials');\n  });\n  \n  it('logs in successfully with valid credentials', () => {\n    loginPage\n      .login('user@example.com', 'correctpassword')\n      .assertSuccessMessage('Welcome');\n  });\n});\n\n// 2. Custom Commands for Reusability\n// Custom commands reduce duplication and improve readability\nCypress.Commands.add('login', (email, password) => {\n  cy.visit('/login');\n  cy.get('[data-cy=email]').type(email);\n  cy.get('[data-cy=password]').type(password);\n  cy.get('[data-cy=submit]').click();\n  cy.get('[data-cy=dashboard]').should('be.visible');\n});\n\nCypress.Commands.add('logout', () => {\n  cy.get('[data-cy=user-menu]').click();\n  cy.get('[data-cy=logout]').click();\n  cy.get('[data-cy=login-form]').should('be.visible');\n});\n\nCypress.Commands.add('resetDatabase', () => {\n  cy.task('resetDatabase');\n});\n\n// 3. Test Data Factories\n// Factories create consistent, realistic test data\nclass UserFactory {\n  static create(overrides = {}) {\n    const timestamp = Date.now();\n    return {\n      id: `user-${timestamp}`,\n      email: `test${timestamp}@example.com`,\n      password: 'securePassword123',\n      name: `Test User ${timestamp}`,\n      role: 'user',\n      ...overrides\n    };\n  }\n  \n  static createAdmin(overrides = {}) {\n    return this.create({\n      role: 'admin',\n      ...overrides\n    });\n  }\n}\n\n// Usage in tests\ndescribe('User Management', () => {\n  let testUser;\n  \n  beforeEach(() => {\n    cy.resetDatabase();\n    testUser = UserFactory.create();\n    cy.task('createUser', testUser);\n  });\n  \n  it('allows admin to delete user', () => {\n    const adminUser = UserFactory.createAdmin();\n    cy.task('createUser', adminUser);\n    \n    cy.login(adminUser.email, adminUser.password);\n    cy.visit('/admin/users');\n    cy.contains(testUser.name).parent().find('[data-cy=delete]').click();\n    cy.get('[data-cy=confirm-delete]').click();\n    cy.contains(testUser.name).should('not.exist');\n  });\n});\n\n// 4. Configuration and Linting\n// cypress.config.js with quality settings\nconst { defineConfig } = require('cypress');\n\nmodule.exports = defineConfig({\n  e2e: {\n    baseUrl: 'http://localhost:3000',\n    specPattern: 'cypress/e2e/**/*.cy.{js,jsx,ts,tsx}',\n    supportFile: 'cypress/support/e2e.js',\n    fixturesFolder: 'cypress/fixtures',\n    screenshotsFolder: 'cypress/screenshots',\n    videosFolder: 'cypress/videos',\n    viewportWidth: 1280,\n    viewportHeight: 720,\n    defaultCommandTimeout: 10000,\n    pageLoadTimeout: 60000,\n    requestTimeout: 15000,\n    responseTimeout: 30000,\n    retries: {\n      runMode: 2,\n      openMode: 0\n    },\n    setupNodeEvents(on, config) {\n      // Implement plugins\n      return require('./cypress/plugins/index.js')(on, config);\n    }\n  },\n  env: {\n    TEST_ENV: 'development'\n  }\n});\n\n// 5. ESLint Configuration for Cypress Tests\n// .eslintrc.js\nmodule.exports = {\n  extends: [\n    'eslint:recommended',\n    'plugin:cypress/recommended'\n  ],\n  plugins: [\n    'cypress'\n  ],\n  env: {\n    'cypress/globals': true\n  },\n  rules: {\n    'cypress/no-assigning-return-values': 'error',\n    'cypress/no-unnecessary-waiting': 'error',\n    'cypress/assertion-before-screenshot': 'warn',\n    'cypress/no-force': 'warn',\n    'cypress/no-async-tests': 'error',\n    'cypress/no-pause': 'error',\n    'no-unused-vars': 'warn',\n    'prefer-arrow-callback': 'error'\n  }\n};\n\n// 6. Test Structure Best Practices\ndescribe('Shopping Cart Functionality', () => {\n  // Use before for expensive setup that doesn't change\n  before(() => {\n    cy.task('seedDatabase');\n  });\n  \n  // Use beforeEach for test-specific setup\n  beforeEach(() => {\n    cy.visit('/');\n    cy.login('user@example.com', 'password123');\n  });\n  \n  // Group related tests\n  describe('Adding Items', () => {\n    it('adds item to cart from product page', () => {\n      // Test implementation\n    });\n    \n    it('adds multiple items to cart', () => {\n      // Test implementation\n    });\n  });\n  \n  describe('Removing Items', () => {\n    it('removes item from cart', () => {\n      // Test implementation\n    });\n  });\n  \n  // Use afterEach for cleanup if needed\n  afterEach(() => {\n    // Screenshot on failure\n    if (Cypress.currentTest.state === 'failed') {\n      cy.screenshot(`failure-${Cypress.currentTest.title}`);
    }
  });
  
  // Use after for final cleanup
  after(() => {
    cy.task('cleanupTestEnvironment');
  });
});",
      "explanation": "This example demonstrates code quality practices for E2E test suites including page object models for organizing element selectors and actions, custom commands for reusable functionality, test data factories for consistent data creation, configuration best practices, linting rules, and test structure patterns.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating overly complex page objects that are hard to maintain",
        "solution": "Keep page objects focused on specific pages or components and avoid deep inheritance hierarchies",
        "severity": "medium"
      },
      {
        "mistake": "Not using consistent naming conventions across the test suite",
        "solution": "Establish and enforce naming conventions for files, functions, variables, and selectors throughout the team",
        "severity": "medium"
      },
      {
        "mistake": "Ignoring code duplication in test implementations",
        "solution": "Refactor common patterns into reusable utilities, custom commands, or page object methods",
        "severity": "high"
      }
    ],
    "exercises": [
      {
        "title": "Refactor a Legacy E2E Test Suite for Better Code Quality",
        "description": "Take an existing E2E test suite with poor code quality and refactor it using page objects, custom commands, and improved organization.",
        "checkpoints": [
          "Implement page objects for all major application pages",
          "Create custom commands for repeated actions and workflows",
          "Establish consistent naming conventions and folder structure",
          "Configure ESLint with Cypress-specific rules",
          "Organize tests with proper describe/it structure and grouping",
          "Implement test data factories for consistent test data creation"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 90,
    "difficulty": "Expert",
    "tags": [
      "Code Quality",
      "E2E Testing",
      "Cypress",
      "Page Objects",
      "Test Organization"
    ],
    "lastUpdated": "2025-10-03T16:00:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "e2e-testing-lesson-7",
    "moduleSlug": "e2e-testing",
    "title": "Test Review and Collaboration Processes",
    "order": 7,
    "objectives": [
      "Implement effective test review processes for E2E test suites",
      "Establish collaborative workflows for test development and maintenance",
      "Apply peer review techniques to improve test quality and reliability",
      "Utilize version control and documentation strategies for test assets"
    ],
    "intro": "Test review and collaboration processes are essential for maintaining high-quality end-to-end test suites in team environments. As E2E tests become more complex and critical to development workflows, establishing robust review processes ensures tests remain reliable, maintainable, and aligned with application requirements.\n\nIn this lesson, you'll learn about peer review techniques specifically tailored for E2E tests, including what to look for when reviewing test code, how to provide constructive feedback, and how to ensure tests follow established patterns and best practices. You'll understand the importance of reviewing not just the test implementation but also the test scenarios, data setup, and assertions.\n\nCollaborative workflows for test development involve more than just code reviews. You'll explore strategies for involving different team members in the testing process, from product owners who can validate test scenarios to developers who can provide insights on implementation details.\n\nDocumentation and knowledge sharing play a crucial role in collaborative testing environments. You'll learn how to create effective test documentation, maintain test inventories, and share knowledge across teams to ensure everyone understands the test coverage and can contribute effectively.\n\nBy mastering test review and collaboration processes, you'll be able to build and maintain E2E test suites that serve as reliable quality gates for your applications while fostering a culture of shared responsibility for quality.",
    "code": {
      "example": "// Test Review and Collaboration Processes for E2E Tests\n\n// 1. Pull Request Template for E2E Tests\n/*\n## E2E Test Changes\n\n### Test Coverage\n- [ ] New feature tests added\n- [ ] Existing tests updated for breaking changes\n- [ ] Edge cases covered\n- [ ] Error scenarios tested\n\n### Test Quality\n- [ ] Page objects used appropriately\n- [ ] Custom commands follow naming conventions\n- [ ] Test data properly managed\n- [ ] Assertions are specific and meaningful\n- [ ] Tests are independent and isolated\n\n### Performance Considerations\n- [ ] Tests run within acceptable time limits\n- [ ] Network interception used for external dependencies\n- [ ] Database cleanup implemented\n\n### Review Comments\nPlease provide specific feedback on:\n1. Test scenario coverage\n2. Code quality and maintainability\n3. Performance implications\n4. Security considerations\n*/\n\n// 2. Test Review Checklist Implementation\nclass E2ETestReviewer {\n  static reviewTest(testCode) {\n    const issues = [];\n    \n    // Check for proper test structure\n    if (!this.hasProperStructure(testCode)) {\n      issues.push({\n        severity: 'high',\n        message: 'Test lacks proper structure (describe/it blocks)',\n        suggestion: 'Use consistent describe/it structure with clear naming'\n      });\n    }\n    \n    // Check for page object usage\n    if (!this.usesPageObjects(testCode)) {\n      issues.push({\n        severity: 'medium',\n        message: 'Direct element selectors found instead of page objects',\n        suggestion: 'Implement page objects for better maintainability'\n      });\n    }\n    \n    // Check for proper assertions\n    if (!this.hasMeaningfulAssertions(testCode)) {\n      issues.push({\n        severity: 'medium',\n        message: 'Assertions are too generic or missing',\n        suggestion: 'Add specific, meaningful assertions that verify business outcomes'\n      });\n    }\n    \n    // Check for test isolation\n    if (!this.hasProperSetupTeardown(testCode)) {\n      issues.push({\n        severity: 'high',\n        message: 'Missing proper setup/teardown for test isolation',\n        suggestion: 'Implement beforeEach/afterEach for test state management'\n      });\n    }\n    \n    // Check for error handling\n    if (!this.handlesErrors(testCode)) {\n      issues.push({\n        severity: 'medium',\n        message: 'Error scenarios not adequately tested',\n        suggestion: 'Add tests for error conditions and edge cases'\n      });\n    }\n    \n    return issues;\n  }\n  \n  static hasProperStructure(testCode) {\n    // Check for describe/it structure\n    return /describe\s*\(/.test(testCode) && /it\s*\(/.test(testCode);\n  }\n  \n  static usesPageObjects(testCode) {\n    // Check if test uses page objects instead of direct selectors\n    const directSelectors = /cy\.get\s*\(\s*['\"]\.[^\"']*['\"]\s*\)/.test(testCode);\n    const pageObjectUsage = /new [A-Z][a-zA-Z]*Page\s*\(/.test(testCode);\n    return pageObjectUsage || !directSelectors;\n  }\n  \n  static hasMeaningfulAssertions(testCode) {\n    // Check for specific assertions rather than generic ones\n    return /should\s*\(.*\)/.test(testCode) || /expect\s*\(.*\)\.to/.test(testCode);\n  }\n  \n  static hasProperSetupTeardown(testCode) {\n    return /beforeEach\s*\(/.test(testCode) || /afterEach\s*\(/.test(testCode);\n  }\n  \n  static handlesErrors(testCode) {\n    // Check for error scenario testing\n    return /catch\s*\(/.test(testCode) || /should.*error/.test(testCode) || /should.*fail/.test(testCode);\n  }\n}\n\n// 3. Collaborative Test Development Workflow\ndescribe('User Registration Feature', () => {\n  let testUser;\n  \n  before(() => {\n    // Team collaboration: Use shared test data factories\n    cy.task('seedTestEnvironment');\n  });\n  \n  beforeEach(() => {\n    // Generate unique test data for isolation\n    testUser = {\n      email: `test-${Date.now()}@example.com`,\n      password: 'SecurePass123!',\n      name: 'Test User'\n    };\n    \n    cy.visit('/');\n  });\n  \n  afterEach(() => {\n    // Clean up test data\n    if (testUser && testUser.email) {\n      cy.task('cleanupTestUser', testUser.email);\n    }\n    \n    // Capture screenshots for failed tests\n    if (Cypress.currentTest.state === 'failed') {\n      cy.screenshot(`test-failure-${Cypress.currentTest.title}`);\n    }\n  });\n  \n  it('allows new users to register successfully', () => {\n    // Clear documentation of test steps\n    // Step 1: Navigate to registration page\n    const registrationPage = new RegistrationPage();\n    registrationPage.visit();\n    \n    // Step 2: Fill registration form\n    registrationPage.fillForm(testUser);\n    \n    // Step 3: Submit form and verify success\n    registrationPage.submit();\n    registrationPage.assertSuccessMessage('Welcome! Your account has been created.');\n    \n    // Step 4: Verify user can log in with new credentials\n    const loginPage = new LoginPage();\n    loginPage.visit();\n    loginPage.login(testUser.email, testUser.password);\n    loginPage.assertDashboardVisible();\n  });\n  \n  it('shows appropriate errors for invalid email format', () => {\n    const registrationPage = new RegistrationPage();\n    registrationPage.visit();\n    \n    // Test collaboration: Cover edge cases identified by team\n    const invalidEmails = [\n      'not-an-email',\n      '@example.com',\n      'user@',\n      'user@.com'\n    ];\n    \n    invalidEmails.forEach(invalidEmail => {\n      registrationPage.fillForm({ ...testUser, email: invalidEmail });\n      registrationPage.submit();\n      registrationPage.assertErrorMessage('Please enter a valid email address.');\n      \n      // Reset form for next iteration\n      registrationPage.clearForm();\n    });\n  });\n  \n  it('prevents registration with existing email', () => {\n    // Team collaboration: Use pre-existing test data\n    cy.task('createUser', {\n      email: testUser.email,\n      password: 'existingPass123!',\n      name: 'Existing User'\n    });\n    \n    const registrationPage = new RegistrationPage();\n    registrationPage.visit();\n    registrationPage.fillForm(testUser);\n    registrationPage.submit();\n    registrationPage.assertErrorMessage('An account with this email already exists.');\n  });\n});\n\n// 4. Documentation and Knowledge Sharing\n/*\nTest Suite Documentation Template:\n\n# User Authentication E2E Tests\n\n## Overview\nThis test suite covers the complete user authentication flow including registration, login, logout, and password reset functionality.\n\n## Test Environment\n- Base URL: https://test.example.com\n- Supported browsers: Chrome, Firefox, Safari\n- Test data: Generated dynamically with cleanup\n\n## Key Test Scenarios\n1. Successful user registration\n2. Registration with invalid data\n3. Registration with duplicate email\n4. Successful login\n5. Login with invalid credentials\n6. Session management and timeout\n7. Password reset flow\n8. Account security features\n\n## Page Objects Used\n- LoginPage: Handles login form interactions\n- RegistrationPage: Manages user registration flow\n- DashboardPage: Verifies post-login state\n\n## Custom Commands\n- cy.login(): Authenticates user and sets session\n- cy.logout(): Clears user session\n- cy.resetAuthState(): Resets authentication for test isolation\n\n## Team Collaboration Guidelines\n- All new tests must be reviewed by at least one team member\n- Test failures should be investigated within 24 hours\n- Performance regressions should be reported immediately\n- Documentation should be updated with each significant change\n*/\n\n// 5. Version Control Best Practices for E2E Tests\n// Example git commit message format:\n// feat(e2e): Add user registration validation tests\n//\n// - Add tests for invalid email formats\n// - Add tests for weak passwords\n// - Add tests for duplicate email handling\n// - Update RegistrationPage object with new selectors\n//\n// Resolves: #1247\n// See also: AUTH-001 in test documentation\n\n// Example branch naming convention:\n// e2e/user-auth-validation-enhancements\n// e2e/performance-improvements-Q1\n// e2e/security-testing-OWASP-A01\n\n// 6. Continuous Integration Integration\nmodule.exports = {\n  // CI configuration that supports collaborative workflows\n  e2e: {\n    // Parallel execution for faster feedback\n    parallel: true,\n    \n    // Retry flaky tests to reduce false negatives\n    retries: {\n      runMode: 2,\n      openMode: 0\n    },\n    \n    // Generate artifacts for collaboration\n    screenshotsFolder: 'cypress/screenshots',\n    videosFolder: 'cypress/videos',\n    reporter: 'junit',\n    reporterOptions: {\n      mochaFile: 'results/test-output-[hash].xml'\n    },\n    \n    // Notify team of test results\n    setupNodeEvents(on, config) {\n      on('after:run', (results) => {\n        // Send notifications to team chat\n        if (results.totalFailed > 0) {\n          // Implementation would integrate with Slack, Teams, etc.\n          console.log(`E2E tests failed: ${results.totalFailed} of ${results.totalTests} tests`);\n        }\n      });\n    }\n  }\n};",
      "explanation": "This example demonstrates comprehensive test review and collaboration processes including pull request templates, automated review checklists, collaborative test development workflows, documentation practices, version control best practices, and CI integration for team notifications.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Skipping peer reviews for E2E tests",
        "solution": "Establish mandatory review processes for all E2E test changes, using structured checklists to ensure consistency",
        "severity": "high"
      },
      {
        "mistake": "Not documenting test scenarios and coverage",
        "solution": "Maintain clear documentation of test scenarios, edge cases, and coverage areas to facilitate team understanding and collaboration",
        "severity": "medium"
      },
      {
        "mistake": "Ignoring test performance in reviews",
        "solution": "Include performance considerations in review criteria, ensuring new tests don't significantly slow down the test suite",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement a Test Review Process for a Shopping Cart Application",
        "description": "Create a comprehensive test review process for an e-commerce application's shopping cart functionality, including review checklists, documentation templates, and collaboration workflows.",
        "checkpoints": [
          "Develop a pull request template for E2E test changes",
          "Create an automated test review checklist implementation",
          "Design collaborative workflows for test development and maintenance",
          "Establish documentation standards for test scenarios and coverage",
          "Implement version control best practices for test assets"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 45,
    "difficulty": "Intermediate",
    "tags": [
      "Test Review",
      "Collaboration",
      "E2E Testing",
      "Code Quality"
    ],
    "lastUpdated": "2025-10-03T16:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "e2e-testing-lesson-8",
    "moduleSlug": "e2e-testing",
    "title": "Continuous Integration and Deployment Testing",
    "order": 8,
    "objectives": [
      "Integrate E2E tests into continuous integration pipelines effectively",
      "Implement strategies for test parallelization and execution optimization",
      "Configure test reporting and failure analysis for CI environments",
      "Establish deployment verification and rollback testing procedures"
    ],
    "intro": "Continuous integration and deployment testing ensures that end-to-end tests provide reliable feedback throughout the software delivery pipeline. As applications evolve rapidly through automated deployment processes, E2E tests must be carefully integrated to validate functionality without creating bottlenecks or false failures.\n\nIn this lesson, you'll learn how to configure E2E tests for CI environments, including setting up appropriate test execution strategies, managing test dependencies, and handling environment-specific configurations. You'll understand how to optimize test execution for parallel processing while maintaining test isolation and reliability.\n\nTest reporting and failure analysis are critical components of CI testing. You'll explore techniques for generating meaningful test reports, capturing relevant debugging information, and implementing automated notifications that help teams quickly identify and resolve issues.\n\nDeployment verification testing ensures that applications function correctly after deployment to different environments. You'll learn strategies for verifying deployments, implementing rollback testing procedures, and creating environment-specific test configurations that validate application behavior across staging, production, and other deployment targets.\n\nBy mastering continuous integration and deployment testing, you'll be able to create robust E2E testing pipelines that provide fast, reliable feedback and help ensure successful deployments with confidence.",
    "code": {
      "example": "// Continuous Integration and Deployment Testing Configuration\n\n// 1. GitHub Actions CI Pipeline for E2E Tests\n/*\nname: E2E Tests\n\non:\n  push:\n    branches: [main, develop]\n  pull_request:\n    branches: [main]\n\njobs:\n  e2e-tests:\n    runs-on: ubuntu-latest\n    \n    # Use matrix strategy for cross-browser testing\n    strategy:\n      matrix:\n        browser: [chrome, firefox, webkit]\n        node-version: [16.x, 18.x]\n      fail-fast: false\n    \n    # Services needed for testing\n    services:\n      postgres:\n        image: postgres:13\n        env:\n          POSTGRES_PASSWORD: postgres\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Use Node.js ${{ matrix.node-version }}\n      uses: actions/setup-node@v3\n      with:\n        node-version: ${{ matrix.node-version }}\n        cache: 'npm'\n    \n    - name: Install dependencies\n      run: npm ci\n    \n    - name: Start test services\n      run: npm run start:test:services &\n    \n    - name: Wait for services\n      run: npm run wait-for-services\n    \n    - name: Run E2E tests\n      run: npm run test:e2e -- --browser ${{ matrix.browser }}\n      env:\n        CYPRESS_BASE_URL: http://localhost:3000\n        DATABASE_URL: postgres://postgres:postgres@localhost:5432/test\n    \n    - name: Upload test results\n      uses: actions/upload-artifact@v3\n      if: always()\n      with:\n        name: test-results-${{ matrix.browser }}-${{ matrix.node-version }}\n        path: |\n          cypress/screenshots/\n          cypress/videos/\n          reports/\n    \n    - name: Notify on failure\n      if: failure()\n      uses: slackapi/slack-github-action@v1.23.0\n      with:\n        payload: |\n          {\n            \"text\": \"E2E tests failed for ${{ github.repository }} on ${{ matrix.browser }}\",\n            \"blocks\": [\n              {\n                \"type\": \"section\",\n                \n                \"text\": {\n                  \"type\": \"mrkdwn\",\n                  \"text\": \"*:rotating_light: E2E Tests Failed* for ${{ github.repository }}\"\n                }\n              }\n            ]\n          }\n      env:\n        SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}\n*/\n\n// 2. Cypress Configuration for CI Environments\nconst { defineConfig } = require('cypress');\n\nmodule.exports = defineConfig({\n  e2e: {\n    // Base URL configured via environment variable\n    baseUrl: process.env.CYPRESS_BASE_URL || 'http://localhost:3000',\n    \n    // CI-specific settings\n    video: true, // Always record videos in CI\n    screenshotOnRunFailure: true,\n    \n    // Adjust timeouts for CI environments\n    defaultCommandTimeout: 10000,\n    pageLoadTimeout: 60000,\n    requestTimeout: 15000,\n    responseTimeout: 30000,\n    \n    // Retries for flaky tests in CI\n    retries: {\n      runMode: 2, // Retry twice in CI\n      openMode: 0  // No retries in interactive mode\n    },\n    \n    // Parallelization settings\n    experimentalInteractiveRunEvents: true,\n    \n    // Reporter configuration for CI\n    reporter: 'junit',\n    reporterOptions: {\n      mochaFile: 'reports/junit-[hash].xml',\n      toConsole: true\n    },\n    \n    // Environment-specific configuration\n    env: {\n      TEST_ENV: process.env.TEST_ENV || 'development',\n      API_BASE_URL: process.env.API_BASE_URL || 'http://localhost:4000',\n      // Feature flags for testing\n      ENABLE_NEW_FEATURES: process.env.ENABLE_NEW_FEATURES || false\n    },\n    \n    setupNodeEvents(on, config) {\n      // Plugin configuration for CI\n      on('before:run', (details) => {\n        console.log('Starting E2E test run:', details);\n      });\n      \n      on('after:run', (results) => {\n        console.log(`Test run completed. ${results.totalPassed} passed, ${results.totalFailed} failed`);\n        \n        // Generate custom reports\n        if (results.totalFailed > 0) {\n          // Send failure notifications\n          require('./scripts/notify-failures')(results);\n        }\n      });\n      \n      // Task for CI-specific operations\n      on('task', {\n        log(message) {\n          console.log(message);\n          return null;\n        },\n        \n        table(data) {\n          console.table(data);\n          return null;\n        },\n        \n        // Database operations for test isolation\n        resetTestDatabase() {\n          // Implementation depends on your database setup\n          return require('./scripts/reset-database')();\n        }\n      });\n      \n      return config;\n    }\n  }\n});\n\n// 3. Parallel Test Execution Strategy\ndescribe('Parallel E2E Tests', () => {\n  // Group tests by feature to optimize parallelization\n  describe('User Authentication', () => {\n    beforeEach(() => {\n      // Ensure test isolation in parallel execution\n      cy.task('resetTestDatabase');\n      cy.visit('/');\n    });\n    \n    it('allows user registration', () => {\n      // Test implementation\n    });\n    \n    it('prevents duplicate registrations', () => {\n      // Test implementation\n    });\n  });\n  \n  describe('Shopping Cart', () => {\n    beforeEach(() => {\n      cy.task('resetTestDatabase');\n      cy.visit('/');\n    });\n    \n    it('allows adding items to cart', () => {\n      // Test implementation\n    });\n    \n    it('calculates totals correctly', () => {\n      // Test implementation\n    });\n  });\n});\n\n// 4. Deployment Verification Testing\n// Test configuration for different environments\nconst environmentConfig = {\n  development: {\n    baseUrl: 'http://localhost:3000',\n    apiBaseUrl: 'http://localhost:4000',\n    testUsers: require('./fixtures/dev-users.json')\n  },\n  \n  staging: {\n    baseUrl: 'https://staging.example.com',\n    apiBaseUrl: 'https://api-staging.example.com',\n    testUsers: require('./fixtures/staging-users.json')\n  },\n  \n  production: {\n    baseUrl: 'https://example.com',\n    apiBaseUrl: 'https://api.example.com',\n    testUsers: require('./fixtures/prod-users.json'),\n    // Production tests are more conservative\n    runSmokeTestsOnly: true\n  }\n};\n\n// Deployment verification test suite\ndescribe('Deployment Verification', () => {\n  const env = process.env.TEST_ENV || 'development';\n  const config = environmentConfig[env];\n  \n  before(() => {\n    // Verify environment is accessible\n    cy.request(config.baseUrl).then((response) => {\n      expect(response.status).to.eq(200);\n    });\n    \n    // Verify API is accessible\n    cy.request(config.apiBaseUrl + '/health').then((response) => {\n      expect(response.status).to.eq(200);\n      expect(response.body.status).to.eq('healthy');\n    });\n  });\n  \n  it('loads homepage successfully', () => {\n    cy.visit(config.baseUrl);\n    cy.get('[data-cy=app-header]').should('be.visible');\n    cy.get('[data-cy=app-footer]').should('be.visible');\n  });\n  \n  it('allows user login', () => {\n    const testUser = config.testUsers.basicUser;\n    cy.visit(config.baseUrl + '/login');\n    cy.get('[data-cy=email]').type(testUser.email);\n    cy.get('[data-cy=password]').type(testUser.password);\n    cy.get('[data-cy=login-button]').click();\n    cy.get('[data-cy=dashboard]').should('be.visible');\n  });\n  \n  // Smoke tests only for production\n  if (!config.runSmokeTestsOnly) {\n    it('allows product search', () => {\n      cy.visit(config.baseUrl);\n      cy.get('[data-cy=search-input]').type('laptop');\n      cy.get('[data-cy=search-button]').click();\n      cy.get('[data-cy=search-results]').should('be.visible');\n    });\n  }\n});\n\n// 5. Rollback Testing Procedures\n// Test script to verify rollback functionality\n/*\n#!/bin/bash\n# rollback-test.sh\n\nset -e\n\necho \"Starting rollback verification test\"\n\n# Deploy previous version\necho \"Deploying previous version...\"\nkubectl rollout undo deployment/my-app\n\n# Wait for deployment\necho \"Waiting for deployment to stabilize...\"\nkubectl rollout status deployment/my-app --timeout=300s\n\n# Run verification tests\necho \"Running rollback verification tests...\"\nnpm run test:e2e:smoke\n\nif [ $? -eq 0 ]; then\n  echo \"Rollback verification PASSED\"\n  exit 0\nelse\n  echo \"Rollback verification FAILED\"\n  # Alert team and potentially rollback the rollback\n  exit 1\nfi\n*/",
      "explanation": "This example demonstrates continuous integration and deployment testing configurations including GitHub Actions pipelines, Cypress CI-specific settings, parallel test execution strategies, deployment verification testing for different environments, and rollback testing procedures.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not configuring appropriate timeouts for CI environments",
        "solution": "Adjust command, page load, and request timeouts to account for CI environment variability while maintaining reasonable test execution times",
        "severity": "high"
      },
      {
        "mistake": "Ignoring test isolation in parallel execution",
        "solution": "Implement proper beforeEach/afterEach hooks and database reset tasks to ensure tests don't interfere with each other when running in parallel",
        "severity": "high"
      },
      {
        "mistake": "Failing to capture debugging information in CI",
        "solution": "Enable video recording, screenshots on failure, and detailed logging to facilitate debugging failed tests in CI environments",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement CI/CD Testing for a Blog Application",
        "description": "Create a comprehensive CI/CD testing pipeline for a blog application that includes parallel test execution, environment-specific configurations, deployment verification, and rollback testing procedures.",
        "checkpoints": [
          "Configure GitHub Actions pipeline with matrix testing",
          "Implement Cypress configuration optimized for CI environments",
          "Create deployment verification tests for staging and production",
          "Establish rollback testing procedures with automated verification",
          "Set up test reporting and failure notifications"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Continuous Integration",
      "Deployment Testing",
      "CI/CD",
      "E2E Testing"
    ],
    "lastUpdated": "2025-10-03T16:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "e2e-testing-lesson-9",
    "moduleSlug": "e2e-testing",
    "title": "Test Monitoring and Observability",
    "order": 9,
    "objectives": [
      "Implement comprehensive monitoring for E2E test execution and performance",
      "Configure alerting systems for test failures and performance degradation",
      "Utilize observability tools to debug test issues and identify bottlenecks",
      "Establish metrics collection and reporting for test suite health"
    ],
    "intro": "Test monitoring and observability provide critical insights into the health and performance of end-to-end test suites. As E2E tests become integral to development workflows, understanding their behavior, identifying issues quickly, and maintaining optimal performance becomes essential for team productivity and application quality.\n\nIn this lesson, you'll learn how to implement comprehensive monitoring for test execution, including tracking pass/fail rates, execution times, and resource utilization. You'll understand how to configure alerting systems that notify teams of failures, performance degradation, or infrastructure issues that could impact test reliability.\n\nObservability tools help debug test issues and identify bottlenecks in test execution. You'll explore techniques for capturing detailed logs, metrics, and traces that provide visibility into test behavior, making it easier to diagnose failures and optimize performance.\n\nMetrics collection and reporting establish a foundation for understanding test suite health over time. You'll learn how to collect meaningful metrics, create informative dashboards, and generate reports that help teams make data-driven decisions about test maintenance and optimization.\n\nBy mastering test monitoring and observability, you'll be able to maintain healthy, performant E2E test suites that provide reliable feedback and support rapid development cycles.",
    "code": {
      "example": "// Test Monitoring and Observability Implementation\n\n// 1. Custom Test Monitoring with Prometheus and Grafana\n/*\n# prometheus.yml\n\nscrape_configs:\n  - job_name: 'e2e-tests'\n    static_configs:\n      - targets: ['localhost:9090']\n    metrics_path: '/metrics/e2e'\n    scrape_interval: 5m\n\n# grafana dashboard configuration\n{\n  \"dashboard\": {\n    \"title\": \"E2E Test Monitoring\",\n    \"panels\": [\n      {\n        \"title\": \"Test Execution Rate\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(e2e_test_executions_total[5m])\",\n            \"legendFormat\": \"{{status}}\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Average Test Duration\",\n        \"type\": \"graph\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(e2e_test_duration_seconds_sum[5m]) / rate(e2e_test_duration_seconds_count[5m])\",\n            \"legendFormat\": \"Average Duration\"\n          }\n        ]\n      },\n      {\n        \"title\": \"Test Failure Rate\",\n        \"type\": \"stat\",\n        \"targets\": [\n          {\n            \"expr\": \"rate(e2e_test_executions_total{status=\"failed\"}[1h]) / rate(e2e_test_executions_total[1h]) * 100\",\n            \"legendFormat\": \"Failure Rate %\"\n          }\n        ]\n      }\n    ]\n  }\n}\n*/\n\n// 2. Cypress Custom Task for Metrics Collection\nmodule.exports = (on, config) => {\n  let testMetrics = {\n    totalTests: 0,\n    passedTests: 0,\n    failedTests: 0,\n    totalDuration: 0,\n    testDurations: []\n  };\n  \n  on('task', {\n    // Record test metrics\n    recordTestResult({ testName, status, duration }) {\n      testMetrics.totalTests++;\n      \n      if (status === 'passed') {\n        testMetrics.passedTests++;\n      } else if (status === 'failed') {\n        testMetrics.failedTests++;\n      }\n      \n      testMetrics.totalDuration += duration;\n      testMetrics.testDurations.push({\n        testName,\n        duration,\n        timestamp: new Date().toISOString()\n      });\n      \n      // Log to console for immediate feedback\n      console.log(`Test ${testName}: ${status} (${duration}ms)`);\n      \n      return null;\n    },\n    \n    // Generate metrics report\n    generateMetricsReport() {\n      const report = {\n        summary: {\n          totalTests: testMetrics.totalTests,\n          passedTests: testMetrics.passedTests,\n          failedTests: testMetrics.failedTests,\n          passRate: (testMetrics.passedTests / testMetrics.totalTests * 100).toFixed(2) + '%',\n          averageDuration: (testMetrics.totalDuration / testMetrics.totalTests).toFixed(2) + 'ms',\n          timestamp: new Date().toISOString()\n        },\n        slowestTests: testMetrics.testDurations\n          .sort((a, b) => b.duration - a.duration)\n          .slice(0, 5)\n      };\n      \n      // Save to file\n      const fs = require('fs');\n      fs.writeFileSync('test-metrics-report.json', JSON.stringify(report, null, 2));\n      \n      // Log summary\n      console.log(`Test Metrics Report: ${report.summary.passRate} pass rate, ${report.summary.averageDuration} average duration`);\n      \n      return report;\n    },\n    \n    // Reset metrics between test runs\n    resetMetrics() {\n      testMetrics = {\n        totalTests: 0,\n        passedTests: 0,\n        failedTests: 0,\n        totalDuration: 0,\n        testDurations: []\n      };\n      return null;\n    }\n  });\n  \n  // Collect metrics after each test\n  on('after:spec', (spec, results) => {\n    results.tests.forEach(test => {\n      const duration = test.attempts.reduce((sum, attempt) => sum + attempt.wallClockDuration, 0);\n      cy.task('recordTestResult', {\n        testName: test.title.join(' > '),\n        status: test.state,\n        duration: duration\n      });\n    });\n  });\n  \n  // Generate final report after run\n  on('after:run', (results) => {\n    if (results) {\n      return cy.task('generateMetricsReport');\n    }\n  });\n};\n\n// 3. Test Implementation with Monitoring\ndescribe('Monitored E2E Tests', () => {\n  before(() => {\n    // Reset metrics at start of test run\n    cy.task('resetMetrics');\n  });\n  \n  beforeEach(() => {\n    // Mark test start time\n    cy.wrap(Date.now()).as('startTime');\n  });\n  \n  afterEach(function() {\n    // Calculate and record test duration\n    const endTime = Date.now();\n    const startTime = this.startTime;\n    const duration = endTime - startTime;\n    \n    cy.task('recordTestResult', {\n      testName: Cypress.currentTest.title,\n      status: Cypress.currentTest.state,\n      duration: duration\n    });\n  });\n  \n  it('monitors user login performance', function() {\n    cy.visit('/login');\n    cy.get('[data-cy=email]').type('user@example.com');\n    cy.get('[data-cy=password]').type('password123');\n    \n    // Measure login performance\n    const loginStart = Date.now();\n    cy.get('[data-cy=login-button]').click();\n    cy.get('[data-cy=dashboard]').should('be.visible').then(() => {\n      const loginDuration = Date.now() - loginStart;\n      \n      // Assert performance requirement\n      expect(loginDuration).to.be.lessThan(3000); // 3 seconds\n      \n      // Record performance metric\n      cy.task('recordTestResult', {\n        testName: 'User Login Performance',\n        status: 'passed',\n        duration: loginDuration\n      });\n    });\n  });\n  \n  it('monitors page load times', () => {\n    const pageLoadStart = performance.now();\n    cy.visit('/dashboard').then(() => {\n      const pageLoadEnd = performance.now();\n      const loadTime = pageLoadEnd - pageLoadStart;\n      \n      // Assert page load performance\n      expect(loadTime).to.be.lessThan(2000); // 2 seconds\n      \n      // Record metric\n      cy.task('recordTestResult', {\n        testName: 'Dashboard Page Load',\n        status: 'passed',\n        duration: loadTime\n      });\n    });\n  });\n});\n\n// 4. Alerting Configuration\n/*\n# Example alerting rules for Prometheus\n\ngroups:\n- name: e2e-tests\n  rules:\n  - alert: HighTestFailureRate\n    expr: rate(e2e_test_executions_total{status=\"failed\"}[1h]) / rate(e2e_test_executions_total[1h]) * 100 > 5\n    for: 10m\n    labels:\n      severity: warning\n    annotations:\n      summary: \"High E2E test failure rate\"\n      description: \"E2E test failure rate is above 5% for more than 10 minutes\"\n  \n  - alert: SlowTestPerformance\n    expr: rate(e2e_test_duration_seconds_sum[5m]) / rate(e2e_test_duration_seconds_count[5m]) > 30\n    for: 5m\n    labels:\n      severity: warning\n    annotations:\n      summary: \"Slow E2E test performance\"\n      description: \"Average E2E test duration is above 30 seconds\"\n\n# Example Slack alert notification\n{\n  \"channel\": \"#test-alerts\",\n  \"username\": \"Test Monitor\",\n  \"icon_emoji\": \":rotating_light:\",\n  \"attachments\": [\n    {\n      \"color\": \"danger\",\n      \"title\": \"E2E Test Alert: {{ .CommonLabels.alertname }}\",\n      \"text\": \"{{ .CommonAnnotations.description }}\",\n      \"fields\": [\n        {\n          \"title\": \"Failure Rate\",\n          \"value\": \"{{ printf \"%.2f\" $value }}%\",\n          \"short\": true\n        },\n        {\n          \"title\": \"Time\",\n          \"value\": \"{{ .Alerts.Firing.0.StartsAt }}\",\n          \"short\": true\n        }\n      ]\n    }\n  ]\n}\n*/\n\n// 5. Observability with Logging and Tracing\n// Enhanced logging for debugging\nfunction logTestStep(stepName, details = {}) {\n  const timestamp = new Date().toISOString();\n  const logEntry = {\n    timestamp,\n    test: Cypress.currentTest.title,\n    step: stepName,\n    ...details\n  };\n  \n  cy.task('log', JSON.stringify(logEntry));\n  console.log(`[TEST STEP] ${stepName}:`, details);\n}\n\ndescribe('Observable E2E Tests', () => {\n  it('provides detailed logging for debugging', () => {\n    logTestStep('Starting user registration test');\n    \n    cy.visit('/register').then(() => {\n      logTestStep('Registration page loaded');\n    });\n    \n    cy.get('[data-cy=email]').type('test@example.com').then(() => {\n      logTestStep('Email entered', { email: 'test@example.com' });\n    });\n    \n    cy.get('[data-cy=password]').type('password123').then(() => {\n      logTestStep('Password entered');\n    });\n    \n    cy.get('[data-cy=submit]').click().then(() => {\n      logTestStep('Submit button clicked');\n    });\n    \n    cy.get('[data-cy=success-message]').should('be.visible').then(() => {\n      logTestStep('Registration successful');\n    });\n  });\n});",
      "explanation": "This example demonstrates test monitoring and observability implementation including Prometheus/Grafana monitoring setup, custom Cypress tasks for metrics collection, test implementations with built-in monitoring, alerting configuration, and enhanced logging for debugging.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not collecting meaningful metrics that provide actionable insights",
        "solution": "Focus on collecting metrics that directly relate to test reliability, performance, and business outcomes rather than just technical statistics",
        "severity": "high"
      },
      {
        "mistake": "Overwhelming teams with too many alerts or false positives",
        "solution": "Configure alerting thresholds thoughtfully and implement alert deduplication to ensure teams receive only actionable notifications",
        "severity": "medium"
      },
      {
        "mistake": "Ignoring long-term trends in test performance and reliability",
        "solution": "Establish regular reporting and review processes to identify gradual degradation in test suite health before it becomes critical",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Monitoring for an E-commerce Application",
        "description": "Create a comprehensive monitoring and observability system for an e-commerce application's E2E tests, including metrics collection, dashboard creation, alerting configuration, and detailed logging.",
        "checkpoints": [
          "Implement custom Cypress tasks for metrics collection",
          "Configure Prometheus and Grafana for test monitoring",
          "Create alerting rules for test failures and performance degradation",
          "Implement detailed logging for test debugging",
          "Generate comprehensive test metrics reports"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 50,
    "difficulty": "Advanced",
    "tags": [
      "Test Monitoring",
      "Observability",
      "Metrics",
      "E2E Testing"
    ],
    "lastUpdated": "2025-10-03T16:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "e2e-testing-lesson-10",
    "moduleSlug": "e2e-testing",
    "title": "Advanced Debugging and Troubleshooting",
    "order": 10,
    "objectives": [
      "Master advanced debugging techniques for flaky and failing E2E tests",
      "Utilize browser developer tools and Cypress debugging features effectively",
      "Implement systematic approaches to identify and resolve test issues",
      "Apply troubleshooting strategies for environment-specific test failures"
    ],
    "intro": "Advanced debugging and troubleshooting techniques are essential for maintaining reliable end-to-end test suites. As E2E tests interact with complex systems and dependencies, understanding how to effectively diagnose and resolve issues becomes critical for test suite stability and team productivity.\n\nIn this lesson, you'll learn advanced debugging techniques specifically tailored for E2E tests, including how to use browser developer tools, Cypress debugging features, and custom logging to identify the root causes of test failures. You'll understand how to differentiate between application issues and test issues, and how to approach debugging systematically.\n\nFlaky tests present unique challenges that require specialized troubleshooting approaches. You'll explore techniques for identifying flaky test patterns, understanding their causes, and implementing solutions that improve test reliability without masking real application issues.\n\nEnvironment-specific test failures often stem from differences in configuration, data, or infrastructure between environments. You'll learn strategies for diagnosing these issues, including how to capture and compare environment states, identify configuration discrepancies, and implement environment-aware testing practices.\n\nBy mastering advanced debugging and troubleshooting techniques, you'll be able to maintain healthy, reliable E2E test suites that provide trustworthy feedback and support rapid development cycles.",
    "code": {
      "example": "// Advanced Debugging and Troubleshooting Techniques\n\n// 1. Systematic Debugging Approach\n/*\nDebugging Checklist:\n\n1. Reproduce the Issue\n   - Can you reproduce the failure consistently?\n   - Does it fail in both headless and headed modes?\n   - Does it fail on different machines/environments?\n\n2. Isolate the Problem\n   - Is it an application issue or test issue?\n   - Does it fail at a specific step or randomly?\n   - Are there any error messages or console logs?\n\n3. Gather Information\n   - Check screenshots and videos from failed runs\n   - Examine network requests and responses\n   - Review application and test logs\n\n4. Formulate Hypotheses\n   - Timing issues (race conditions, slow loading)\n   - Data issues (missing, incorrect, or inconsistent data)\n   - Environment issues (configuration, permissions)\n   - External dependency issues (APIs, databases, services)\n\n5. Test Hypotheses\n   - Modify test to validate each hypothesis\n   - Use debugging tools to inspect state\n   - Add logging to trace execution flow\n\n6. Implement Solution\n   - Fix application code if it's a bug\n   - Improve test reliability if it's a test issue\n   - Add proper waits, retries, or error handling\n*/\n\n// 2. Cypress Debugging Features\ndescribe('Debugging Techniques', () => {\n  it('uses Cypress debugging tools effectively', () => {\n    // Pause execution for interactive debugging\n    cy.visit('/dashboard');\n    // cy.pause(); // Uncomment to pause execution\n    \n    // Debug element selection\n    cy.get('[data-cy=widget]').debug().should('be.visible');\n    \n    // Log element properties\n    cy.get('[data-cy=user-name]').then(($el) => {\n      console.log('Element text:', $el.text());\n      console.log('Element attributes:', $el[0].attributes);\n    });\n    \n    // Inspect network requests\n    cy.intercept('/api/user-data').as('userData');\n    cy.wait('@userData').then((interception) => {\n      console.log('Response:', interception.response);\n      console.log('Request:', interception.request);\n    });\n    \n    // Debug timing issues\n    cy.get('[data-cy=loading-spinner]', { timeout: 10000 }).should('not.exist');\n    cy.get('[data-cy=content]').should('be.visible');\n  });\n  \n  it('implements custom debugging utilities', () => {\n    // Custom debugging command\n    Cypress.Commands.add('debugClick', { prevSubject: 'element' }, (subject, options = {}) => {\n      if (options.log !== false) {\n        cy.wrap(subject).then(($el) => {\n          console.log(`Clicking element:`, {\n            selector: $el.selector,\n            text: $el.text(),\n            attributes: Array.from($el[0].attributes).reduce((acc, attr) => {\n              acc[attr.name] = attr.value;\n              return acc;\n            }, {})\n          });\n        });\n      }\n      return cy.wrap(subject).click(options);\n    });\n    \n    // Custom logging utility\n    function logTestState(message, data = {}) {\n      const timestamp = new Date().toISOString();\n      const logEntry = {\n        timestamp,\n        test: Cypress.currentTest.title,\n        message,\n        ...data\n      };\n      \n      cy.task('log', JSON.stringify(logEntry, null, 2));\n      cy.task('table', logEntry);\n    }\n    \n    // Usage in test\n    cy.visit('/profile');\n    logTestState('Profile page loaded', { url: cy.url() });\n    \n    cy.get('[data-cy=edit-button]').debugClick();\n    logTestState('Edit button clicked');\n    \n    cy.get('[data-cy=form]').should('be.visible');\n    logTestState('Edit form is visible');\n  });\n});\n\n// 3. Flaky Test Troubleshooting\ndescribe('Flaky Test Troubleshooting', () => {\n  it('identifies and fixes timing-related flakiness', () => {\n    // Problematic test that fails intermittently\n    /*cy.visit('/search');\n    cy.get('[data-cy=search-input]').type('laptop');\n    cy.get('[data-cy=search-button]').click();\n    cy.get('[data-cy=search-results]').should('have.length.greaterThan', 0);*/\n    \n    // Improved version with proper waits\n    cy.visit('/search');\n    cy.get('[data-cy=search-input]').type('laptop');\n    cy.get('[data-cy=search-button]').click();\n    \n    // Wait for loading indicator to appear and disappear\n    cy.get('[data-cy=loading-spinner]', { timeout: 10000 }).should('be.visible');\n    cy.get('[data-cy=loading-spinner]', { timeout: 10000 }).should('not.exist');\n    \n    // Then check for results\n    cy.get('[data-cy=search-results]').should('be.visible');\n    cy.get('[data-cy=search-result-item]').should('have.length.greaterThan', 0);\n  });\n  \n  it('handles dynamic content loading', () => {\n    cy.visit('/dashboard');\n    \n    // Wait for critical elements to load\n    cy.get('[data-cy=user-widget]', { timeout: 15000 }).should('be.visible');\n    cy.get('[data-cy=analytics-widget]', { timeout: 15000 }).should('be.visible');\n    \n    // Use aliases for complex element chains\n    cy.get('[data-cy=user-widget]').find('[data-cy=user-count]').as('userCount');\n    cy.get('@userCount').should('contain.text', 'Users');\n    \n    // Handle dynamic updates\n    cy.get('[data-cy=refresh-button]').click();\n    cy.get('[data-cy=refresh-indicator]').should('be.visible');\n    cy.get('[data-cy=refresh-indicator]', { timeout: 10000 }).should('not.exist');\n    cy.get('@userCount').should('be.visible');\n  });\n});\n\n// 4. Environment-Specific Issue Debugging\n// Configuration for different environments\nconst envConfig = {\n  development: {\n    baseUrl: 'http://localhost:3000',\n    apiTimeout: 5000,\n    debug: true\n  },\n  \n  staging: {\n    baseUrl: 'https://staging.example.com',\n    apiTimeout: 10000,\n    debug: true\n  },\n  \n  production: {\n    baseUrl: 'https://example.com',\n    apiTimeout: 15000,\n    debug: false\n  }\n};\n\ndescribe('Environment-Specific Debugging', () => {\n  const env = Cypress.env('ENVIRONMENT') || 'development';\n  const config = envConfig[env];\n  \n  it('adapts to environment differences', () => {\n    // Log environment info for debugging\n    cy.log(`Running in ${env} environment`);\n    cy.log(`Base URL: ${config.baseUrl}`);\n    cy.log(`API Timeout: ${config.apiTimeout}ms`);\n    \n    cy.visit(config.baseUrl);\n    \n    // Environment-specific element handling\n    if (env === 'development') {\n      // Development might have debug tools visible\n      cy.get('[data-cy=dev-tools]').should('be.visible');\n    } else {\n      // Production should not have debug tools\n      cy.get('[data-cy=dev-tools]').should('not.exist');\n    }\n    \n    // Adjust timeouts based on environment\n    cy.get('[data-cy=content]', { timeout: config.apiTimeout })\n      .should('be.visible');\n  });\n  \n  it('debugs network issues across environments', () => {\n    // Capture environment-specific network behavior\n    cy.intercept('/api/data').as('apiData');\n    \n    cy.visit(config.baseUrl);\n    cy.wait('@apiData', { timeout: config.apiTimeout }).then((interception) => {\n      // Log response details for debugging\n      cy.log(`Response status: ${interception.response.statusCode}`);\n      cy.log(`Response time: ${interception.response.headers['response-time']}ms`);\n      \n      // Environment-specific assertions\n      if (env === 'production') {\n        expect(interception.response.statusCode).to.eq(200);\n        expect(interception.response.headers).to.have.property('cache-control');\n      }\n    });\n  });\n});\n\n// 5. Post-Failure Analysis Utilities\n// Custom command for detailed failure analysis\nCypress.Commands.add('analyzeFailure', () => {\n  // Capture additional debugging information\n  cy.url().then((url) => {\n    cy.log(`Failure URL: ${url}`);\n  });\n  \n  // Capture page HTML for analysis\n  cy.document().then((doc) => {\n    const html = doc.documentElement.outerHTML;\n    // Save to file or send to logging service\n    cy.task('saveFailureHtml', html);\n  });\n  \n  // Capture browser console logs\n  cy.window().then((win) => {\n    cy.task('log', `Console logs at failure: ${JSON.stringify(win.consoleLogs || [])}`);\n  });\n  \n  // Take detailed screenshot\n  cy.screenshot(`failure-analysis-${Date.now()}`, {\n    capture: 'fullPage',\n    log: true\n  });\n});\n\n// Use in tests\ndescribe('Failure Analysis', () => {\n  afterEach(function() {\n    if (this.currentTest.state === 'failed') {\n      cy.analyzeFailure();\n    }\n  });\n  \n  it('demonstrates failure analysis', () => {\n    cy.visit('/');\n    // Intentional failure for demonstration\n    cy.get('[data-cy=nonexistent-element]').should('exist');\n  });\n});",
      "explanation": "This example demonstrates advanced debugging and troubleshooting techniques including systematic debugging approaches, Cypress debugging features, flaky test troubleshooting, environment-specific issue debugging, and post-failure analysis utilities.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Jumping to conclusions without systematic investigation",
        "solution": "Follow a structured debugging approach that includes reproducing the issue, isolating the problem, gathering information, and testing hypotheses methodically",
        "severity": "high"
      },
      {
        "mistake": "Not utilizing available debugging tools effectively",
        "solution": "Learn and use Cypress debugging features like cy.pause(), cy.debug(), and network interception to gather detailed information about test execution",
        "severity": "medium"
      },
      {
        "mistake": "Ignoring environment differences when troubleshooting",
        "solution": "Consider environment-specific factors like configuration, data, network conditions, and infrastructure when debugging test failures",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Debug Flaky Tests in a Social Media Application",
        "description": "Identify and fix flaky tests in a social media application's E2E test suite, implementing systematic debugging approaches and environment-aware troubleshooting techniques.",
        "checkpoints": [
          "Implement systematic debugging utilities for test analysis",
          "Identify and fix timing-related flakiness in dynamic content tests",
          "Create environment-specific debugging configurations",
          "Implement post-failure analysis tools for detailed diagnostics",
          "Document debugging findings and solutions for team knowledge sharing"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 55,
    "difficulty": "Expert",
    "tags": [
      "Debugging",
      "Troubleshooting",
      "Flaky Tests",
      "E2E Testing"
    ],
    "lastUpdated": "2025-10-03T16:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "e2e-testing-lesson-11",
    "moduleSlug": "e2e-testing",
    "title": "Test Performance Optimization",
    "order": 11,
    "objectives": [
      "Implement strategies to optimize E2E test execution speed and reliability",
      "Apply parallelization techniques to reduce overall test suite runtime",
      "Utilize selective testing and test prioritization to focus on critical functionality",
      "Optimize resource utilization and infrastructure for efficient test execution"
    ],
    "intro": "Test performance optimization is crucial for maintaining efficient development workflows as end-to-end test suites grow in size and complexity. Slow test execution creates bottlenecks in continuous integration pipelines, reduces developer productivity, and can lead to tests being skipped or ignored. Understanding how to optimize test performance while maintaining reliability is essential for scalable testing practices.\n\nIn this lesson, you'll learn strategies to optimize E2E test execution speed, including identifying and eliminating bottlenecks, reducing unnecessary waits, and optimizing test data management. You'll understand how to implement effective parallelization techniques that maximize resource utilization while maintaining test isolation.\n\nSelective testing and test prioritization help focus testing efforts on the most critical functionality and areas most likely to be affected by changes. You'll explore techniques for implementing intelligent test selection, risk-based testing, and smoke testing strategies that provide rapid feedback without sacrificing coverage.\n\nResource utilization and infrastructure optimization ensure that tests run efficiently without consuming excessive computing resources. You'll learn about containerization for consistent test environments, resource allocation strategies, and infrastructure-as-code approaches that support scalable test execution.\n\nBy mastering test performance optimization, you'll be able to maintain fast, reliable E2E test suites that support rapid development cycles while providing comprehensive coverage of critical application functionality.",
    "code": {
      "example": "// Test Performance Optimization Techniques\n\n// 1. Test Execution Speed Optimization\n/*\nPerformance Optimization Checklist:\n\n1. Identify Bottlenecks\n   - Profile test execution times\n   - Analyze network request patterns\n   - Monitor resource utilization\n\n2. Reduce Unnecessary Waits\n   - Replace fixed waits with intelligent waits\n   - Use appropriate timeout values\n   - Implement retry strategies for flaky operations\n\n3. Optimize Test Data Management\n   - Use factories for consistent data\n   - Implement efficient cleanup strategies\n   - Leverage database snapshots where appropriate\n\n4. Minimize Test Dependencies\n   - Reduce external API calls\n   - Mock non-critical services\n   - Use local resources when possible\n*/\n\n// 2. Intelligent Waiting Strategies\ndescribe('Optimized Waiting Strategies', () => {\n  it('uses intelligent waits instead of fixed delays', () => {\n    cy.visit('/dashboard');\n    \n    // BAD: Fixed wait that always delays execution\n    // cy.wait(2000);\n    \n    // GOOD: Wait for specific condition\n    cy.get('[data-cy=loading-spinner]').should('not.exist');\n    cy.get('[data-cy=content]').should('be.visible');\n    \n    // GOOD: Custom wait with timeout\n    cy.get('[data-cy=async-content]', { timeout: 10000 }).should('be.visible');\n    \n    // GOOD: Wait for network request completion\n    cy.intercept('/api/user-data').as('userData');\n    cy.wait('@userData').then((interception) => {\n      // Process response immediately\n      expect(interception.response.statusCode).to.eq(200);\n    });\n  });\n  \n  it('implements retry strategies for flaky operations', () => {\n    // Custom retry command\n    Cypress.Commands.add('retryClick', { prevSubject: 'element' }, (subject, maxRetries = 3) => {\n      let retries = 0;\n      \n      const attemptClick = () => {\n        cy.wrap(subject).click({ force: true }).then({ timeout: 5000 }, () => {\n          // Check if click was successful\n          return cy.get('body').then(($body) => {\n            // Define success condition\n            if ($body.find('[data-cy=modal]').length > 0) {\n              return true; // Success\n            } else if (retries < maxRetries) {\n              retries++;\n              // Retry after short delay\n              cy.wait(500);\n              return attemptClick();\n            } else {\n              throw new Error(`Click failed after ${maxRetries} attempts`);\n            }\n          });\n        });\n      };\n      \n      return attemptClick();\n    });\n    \n    // Usage\n    cy.get('[data-cy=flaky-button]').retryClick();\n    cy.get('[data-cy=modal]').should('be.visible');\n  });\n});\n\n// 3. Parallelization Strategies\n// cypress.config.js\nmodule.exports = {\n  e2e: {\n    // Enable parallelization\n    experimentalParallel: true,\n    \n    // Configure for CI parallelization\n    projectId: 'your-project-id',\n    \n    // Optimize for parallel execution\n    setupNodeEvents(on, config) {\n      // Group tests for optimal parallelization\n      on('before:run', (details) => {\n        console.log('Parallel run details:', details.parallel);\n      });\n      \n      // Balance test distribution\n      on('file:preprocessor', (file) => {\n        // Implement custom logic to balance test files\n        return file;\n      });\n    }\n  }\n};\n\n// Test file organization for parallelization\n/*\nRecommended test file structure:\n\ncypress/e2e/\n├── authentication/\n│   ├── login.cy.js\n│   ├── registration.cy.js\n│   └── password-reset.cy.js\n├── user-management/\n│   ├── profile.cy.js\n│   ├── settings.cy.js\n│   └── permissions.cy.js\n├── core-features/\n│   ├── dashboard.cy.js\n│   ├── navigation.cy.js\n│   └── search.cy.js\n└── smoke-tests/\n    ├── critical-path.cy.js\n    └── health-check.cy.js\n*/\n\n// 4. Selective Testing and Prioritization\n// GitHub Actions workflow with selective testing\n/*\nname: Selective E2E Tests\n\non:\n  pull_request:\n    branches: [main]\n    paths-ignore:\n      - 'docs/**'\n      - 'README.md'\n      - '*.md'\n\njobs:\n  selective-tests:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n      with:\n        fetch-depth: 2\n    \n    - name: Determine changed files\n      id: changes\n      run: |\n        echo \"::set-output name=changed_files::$(git diff --name-only HEAD^ HEAD)\"\n    \n    - name: Run selective tests\n      run: |\n        if echo \"${{ steps.changes.outputs.changed_files }}\" | grep -q 'auth/'; then\n          npm run test:e2e:auth\n        fi\n        \n        if echo \"${{ steps.changes.outputs.changed_files }}\" | grep -q 'user-profile/'; then\n          npm run test:e2e:user-profile\n        fi\n\n    - name: Run smoke tests for all changes\n      run: npm run test:e2e:smoke\n*/\n\n// 5. Resource Utilization Optimization\n// Docker configuration for consistent test environments\n/*\n# docker-compose.test.yml\nversion: '3.8'\n\nservices:\n  cypress:\n    image: cypress/included:10.0.0\n    depends_on:\n      - app\n      - database\n    environment:\n      - CYPRESS_BASE_URL=http://app:3000\n    volumes:\n      - ./cypress:/cypress\n      - ./cypress.config.js:/cypress.config.js\n    # Limit resources to prevent overconsumption\n    deploy:\n      resources:\n        limits:\n          cpus: '1'\n          memory: 2G\n        reservations:\n          cpus: '0.5'\n          memory: 1G\n  \n  app:\n    build: .\n    ports:\n      - \"3000:3000\"\n    environment:\n      - NODE_ENV=test\n    # Optimize app container resources\n    deploy:\n      resources:\n        limits:\n          cpus: '1'\n          memory: 1G\n\n  database:\n    image: postgres:13\n    environment:\n      - POSTGRES_DB=test\n      - POSTGRES_USER=test\n      - POSTGRES_PASSWORD=test\n    # Optimize database resources\n    deploy:\n      resources:\n        limits:\n          cpus: '0.5'\n          memory: 512M\n*/\n\n// Test configuration for resource optimization\nmodule.exports = {\n  e2e: {\n    // Optimize browser resources\n    chromeWebSecurity: false,\n    viewportWidth: 1280,\n    viewportHeight: 720,\n    \n    // Reduce resource-intensive features\n    video: false, // Disable video recording unless needed\n    videoUploadOnPasses: false,\n    screenshotOnRunFailure: true, // Keep screenshots for failures\n    \n    // Optimize timeouts\n    defaultCommandTimeout: 8000,\n    pageLoadTimeout: 30000,\n    requestTimeout: 10000,\n    responseTimeout: 20000,\n    \n    // Configure for efficient execution\n    numTestsKeptInMemory: 0, // Reduce memory usage\n    experimentalMemoryManagement: true,\n    \n    setupNodeEvents(on, config) {\n      // Clean up resources between tests\n      on('after:spec', (spec, results) => {\n        // Implement cleanup logic\n        console.log(`Finished spec: ${spec.name}`);\n      });\n    }\n  }\n};",
      "explanation": "This example demonstrates test performance optimization techniques including intelligent waiting strategies, parallelization configurations, selective testing workflows, and resource utilization optimization through Docker configuration and Cypress settings.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Using fixed waits instead of intelligent waiting strategies",
        "solution": "Replace fixed cy.wait() calls with conditional waits that wait for specific elements or conditions to be met, reducing unnecessary delays",
        "severity": "high"
      },
      {
        "mistake": "Not organizing tests for effective parallelization",
        "solution": "Structure test files and implement test dependencies in a way that maximizes parallel execution opportunities while maintaining test isolation",
        "severity": "high"
      },
      {
        "mistake": "Running all tests for every change regardless of impact",
        "solution": "Implement selective testing strategies that run only the tests relevant to the changes being made, using path-based triggers or other change detection mechanisms",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Optimize Test Performance for a News Website",
        "description": "Implement comprehensive test performance optimization for a news website's E2E test suite, including intelligent waiting strategies, parallelization configuration, selective testing implementation, and resource utilization optimization.",
        "checkpoints": [
          "Replace fixed waits with intelligent waiting strategies",
          "Configure parallelization for optimal test distribution",
          "Implement selective testing based on file changes",
          "Optimize resource utilization through container configuration",
          "Measure and document performance improvements"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Performance Optimization",
      "Parallelization",
      "Selective Testing",
      "E2E Testing"
    ],
    "lastUpdated": "2025-10-03T16:30:00.000Z",
    "version": "1.1.0"
  },
  {
    "id": "e2e-testing-lesson-12",
    "moduleSlug": "e2e-testing",
    "title": "Test Quality Assurance and Standards",
    "order": 12,
    "objectives": [
      "Establish and maintain quality standards for E2E test development",
      "Implement code review processes and static analysis for test code",
      "Apply testing best practices to ensure reliable and maintainable test suites",
      "Create comprehensive test documentation and knowledge sharing practices"
    ],
    "intro": "Test quality assurance and standards are fundamental to building and maintaining reliable, maintainable end-to-end test suites that provide consistent value to development teams. As E2E tests become critical infrastructure for ensuring application quality, establishing rigorous quality standards becomes essential for long-term success.\n\nIn this lesson, you'll learn how to establish and maintain quality standards for E2E test development, including coding standards, architectural patterns, and testing principles that promote reliability and maintainability. You'll understand how to implement effective code review processes specifically tailored for test code, ensuring that tests meet quality criteria before being merged.\n\nStatic analysis and automated quality checks help enforce standards consistently across test suites. You'll explore tools and techniques for implementing static analysis, linting, and formatting checks that catch quality issues early in the development process.\n\nDocumentation and knowledge sharing practices ensure that test suites remain understandable and maintainable as teams grow and evolve. You'll learn strategies for creating comprehensive test documentation, maintaining test inventories, and sharing knowledge across teams to support collaborative test development.\n\nBy mastering test quality assurance and standards, you'll be able to build E2E test suites that not only verify application functionality but also serve as reliable, maintainable assets that support long-term development success.",
    "code": {
      "example": "// Test Quality Assurance and Standards Implementation\n\n// 1. ESLint Configuration for Test Code Quality\n/*\n// .eslintrc.js\nmodule.exports = {\n  extends: [\n    'eslint:recommended',\n    'plugin:cypress/recommended'\n  ],\n  plugins: [\n    'cypress',\n    'jest'\n  ],\n  env: {\n    'cypress/globals': true,\n    'jest/globals': true\n  },\n  rules: {\n    // Test-specific rules\n    'cypress/no-assigning-return-values': 'error',\n    'cypress/no-unnecessary-waiting': 'error',\n    'cypress/assertion-before-screenshot': 'warn',\n    'cypress/no-force': 'warn',\n    'cypress/no-async-tests': 'error',\n    \n    // General quality rules\n    'no-unused-vars': ['error', { 'argsIgnorePattern': '^_' }],\n    'no-console': 'warn',\n    'prefer-const': 'error',\n    'prefer-arrow-callback': 'error',\n    'no-var': 'error',\n    \n    // Test structure rules\n    'jest/expect-expect': 'off', // Not applicable for Cypress\n    'max-lines-per-function': ['warn', 50],\n    'max-nested-callbacks': ['error', 5]\n  }\n};\n\n// .prettierrc\n{\n  \"semi\": true,\n  \"trailingComma\": \"es5\",\n  \"singleQuote\": true,\n  \"printWidth\": 100,\n  \"tabWidth\": 2\n}\n*/\n\n// 2. Test Code Review Checklist\n/*\nTest Code Review Checklist:\n\n□ Test Structure and Organization\n  □ Uses proper describe/it structure with clear naming\n  □ Tests are focused and test single behaviors\n  □ Appropriate use of before/after hooks\n  □ Test file organization follows conventions\n\n□ Page Objects and Abstractions\n  □ Page objects used for UI element management\n  □ Custom commands for repeated actions\n  □ Test data factories for consistent data\n  □ Appropriate abstraction level (not too complex)\n\n□ Reliability and Stability\n  □ Uses intelligent waits instead of fixed delays\n  □ Proper test isolation implemented\n  □ Handles errors and edge cases\n  □ No flaky test patterns\n\n□ Assertions and Validation\n  □ Specific, meaningful assertions\n  □ Verifies business outcomes, not implementation details\n  □ Appropriate use of should/expect\n  □ Covers both positive and negative cases\n\n□ Performance and Efficiency\n  □ Reasonable test execution time\n  □ Minimal external dependencies\n  □ Efficient data setup and cleanup\n  □ No unnecessary operations\n*/\n\n// 3. Automated Quality Checks in CI\n/*\n# GitHub Actions workflow with quality checks\nname: Test Quality Assurance\n\non: [push, pull_request]\n\njobs:\n  quality-checks:\n    runs-on: ubuntu-latest\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Setup Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18'\n        cache: 'npm'\n    \n    - name: Install dependencies\n      run: npm ci\n    \n    - name: Run ESLint\n      run: npm run lint\n    \n    - name: Run Prettier check\n      run: npm run format:check\n    \n    - name: Run type checking\n      run: npm run type-check\n    \n    - name: Run security audit\n      run: npm audit --audit-level high\n    \n    - name: Run custom quality checks\n      run: npm run quality:check\n    \n    - name: Comment on PR with issues\n      if: failure()\n      uses: actions/github-script@v6\n      with:\n        script: |\n          github.rest.issues.createComment({\n            issue_number: context.issue.number,\n            owner: context.repo.owner,\n            repo: context.repo.repo,\n            body: '.quality checks failed. Please review the output and fix the issues.'\n          })\n*/\n\n// 4. Custom Quality Assurance Utilities\n// Custom ESLint plugin for test-specific rules\n/*\n// eslint-plugin-custom-tests/index.js\nmodule.exports = {\n  rules: {\n    'no-direct-selectors': {\n      meta: {\n        type: 'problem',\n        docs: {\n          description: 'Disallow direct CSS selectors in favor of page objects'\n        },\n        messages: {\n          avoidDirectSelector: 'Use page objects instead of direct CSS selectors'\n        }\n      },\n      create(context) {\n        return {\n          CallExpression(node) {\n            if (\n              node.callee.type === 'MemberExpression' &&\n              node.callee.object.name === 'cy' &&\n              node.callee.property.name === 'get' &&\n              node.arguments.length > 0 &&\n              node.arguments[0].type === 'Literal'\n            ) {\n              const selector = node.arguments[0].value;\n              // Allow data-cy attributes, disallow direct CSS selectors\n              if (selector && !selector.startsWith('[data-cy=')) {\n                context.report({\n                  node,\n                  messageId: 'avoidDirectSelector'\n                });\n              }\n            }\n          }\n        };\n      }\n    }\n  }\n};\n*/\n\n// 5. Test Documentation and Knowledge Sharing\n/*\nTest Documentation Template:\n\n# {{Test Suite Name}}\n\n## Overview\nBrief description of what this test suite covers.\n\n## Test Environment\n- Base URL: {{URL}}\n- Supported browsers: {{browsers}}\n- Test data requirements: {{data}}\n\n## Key Test Scenarios\n1. {{Scenario 1}} - {{Brief description}}\n2. {{Scenario 2}} - {{Brief description}}\n3. ...\n\n## Page Objects Used\n- {{PageObjectName}}: {{Purpose}}\n- ...\n\n## Custom Commands\n- {{CommandName}}: {{Purpose}}\n- ...\n\n## Test Data Factories\n- {{FactoryName}}: {{Purpose}}\n- ...\n\n## Known Issues and Limitations\n- {{Issue}}: {{Workaround/Status}}\n- ...\n\n## Maintenance Notes\n- {{Note about maintenance requirements}}\n- ...\n*/\n\n// Example documented test\n/**\n * User Authentication Test Suite\n * \n * Tests the complete user authentication flow including registration,\n * login, logout, and password reset functionality.\n * \n * @test-environment development, staging\n * @test-data UserFactory\n * @page-objects LoginPage, RegistrationPage, DashboardPage\n * @custom-commands cy.login, cy.logout\n */\ndescribe('User Authentication', () => {\n  /**\n   * Tests successful user registration with valid data\n   * \n   * @test-scenario New user can register with valid email and password\n   * @test-data UserFactory.create()\n   * @expected-result User is redirected to dashboard and can access protected resources\n   */\n  it('allows new users to register successfully', () => {\n    const user = UserFactory.create();\n    \n    const registrationPage = new RegistrationPage();\n    registrationPage.visit();\n    registrationPage.fillForm(user);\n    registrationPage.submit();\n    registrationPage.assertSuccess();\n    \n    // Verify user can log in with new credentials\n    const loginPage = new LoginPage();\n    loginPage.visit();\n    loginPage.login(user.email, user.password);\n    loginPage.assertDashboardVisible();\n  });\n});",
      "explanation": "This example demonstrates test quality assurance and standards implementation including ESLint configuration for test code quality, test code review checklists, automated quality checks in CI pipelines, custom quality assurance utilities, and test documentation templates.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not establishing clear quality standards for test code",
        "solution": "Create and document specific quality standards for test code, including coding conventions, architectural patterns, and testing principles that promote reliability and maintainability",
        "severity": "high"
      },
      {
        "mistake": "Skipping code reviews for test implementations",
        "solution": "Implement mandatory code review processes for all test changes, using structured checklists to ensure consistency and quality",
        "severity": "high"
      },
      {
        "mistake": "Neglecting test documentation and knowledge sharing",
        "solution": "Maintain comprehensive test documentation, including test scenarios, page objects, custom commands, and known issues to support team understanding and collaboration",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Quality Standards for an E-commerce Test Suite",
        "description": "Establish comprehensive quality standards for an e-commerce application's E2E test suite, including ESLint configuration, code review processes, automated quality checks, and documentation practices.",
        "checkpoints": [
          "Configure ESLint and Prettier for test code quality",
          "Create a comprehensive test code review checklist",
          "Implement automated quality checks in CI pipeline",
          "Develop custom quality assurance utilities",
          "Establish test documentation and knowledge sharing practices"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 50,
    "difficulty": "Advanced",
    "tags": [
      "Quality Assurance",
      "Code Standards",
      "Code Review",
      "E2E Testing"
    ],
    "lastUpdated": "2025-10-03T16:30:00.000Z",
    "version": "1.1.0"
  }]
}
]