[
  {
    "id": "e2e-testing-lesson-1",
    "moduleSlug": "e2e-testing",
    "title": "Introduction to End-to-End Testing",
    "order": 1,
    "objectives": [
      "Understand the fundamental concepts and importance of end-to-end testing",
      "Learn the differences between unit, integration, and end-to-end testing",
      "Identify when to use end-to-end testing in the testing pyramid",
      "Recognize common E2E testing frameworks and tools"
    ],
    "intro": "End-to-end (E2E) testing is a software testing methodology that validates entire workflows of an application from start to finish, simulating real user scenarios. Unlike unit tests that focus on individual functions or integration tests that verify interactions between specific components, E2E tests ensure that all integrated parts of an application work together as expected.\n\nIn this lesson, you'll learn about the role of E2E testing within the broader testing strategy and how it fits into the testing pyramid. You'll understand why E2E tests are crucial for validating user journeys and business workflows, even though they're typically slower and more complex than other test types.\n\nYou'll explore the key characteristics that make E2E tests both valuable and challenging, including their ability to catch integration issues that other test types might miss, and their tendency to be more brittle due to their broad scope.\n\nThe lesson will also cover the evolution of E2E testing frameworks, from early tools like Selenium to modern solutions like Cypress and Playwright, and how these tools have addressed many of the traditional challenges with E2E testing.\n\nBy mastering these fundamentals, you'll understand when and how to effectively incorporate E2E testing into your overall testing strategy to maximize confidence in your application's functionality.",
    "code": {
      "example": "// Example of a simple user registration workflow that would be tested with E2E testing\n\n// User visits the registration page\n// User fills in registration form with valid data\n// User submits the form\n// Application validates the data\n// Application creates a new user account\n// Application sends a confirmation email\n// User receives confirmation message\n// User can log in with new credentials\n\n// In an E2E test using a framework like Playwright:\nconst { test, expect } = require('@playwright/test');\n\ntest('user can register for an account', async ({ page }) => {\n  // Navigate to registration page\n  await page.goto('/register');\n  \n  // Fill in registration form\n  await page.fill('#email', 'test@example.com');\n  await page.fill('#password', 'securePassword123');\n  await page.fill('#confirmPassword', 'securePassword123');\n  \n  // Submit form\n  await page.click('#register-button');\n  \n  // Verify success message\n  await expect(page.locator('.success-message')).toContainText('Account created successfully');\n  \n  // Verify user is redirected to dashboard\n  await expect(page).toHaveURL('/dashboard');\n});\n\n// This test validates the entire workflow from UI interaction through backend processing\n// to user feedback, which is the essence of end-to-end testing.",
      "explanation": "This example demonstrates a typical E2E test scenario for user registration. The test simulates a real user's journey through the application, interacting with the UI, submitting data, and verifying the results. Unlike unit tests that would test individual functions in isolation, this E2E test validates the complete workflow, ensuring all components work together correctly. The test uses Playwright syntax but illustrates concepts that apply to all E2E testing frameworks.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Writing too many E2E tests, leading to slow test suites and maintenance overhead",
        "solution": "Follow the testing pyramid - focus E2E tests on critical user journeys and supplement with more unit and integration tests",
        "severity": "high"
      },
      {
        "mistake": "Testing implementation details instead of user workflows",
        "solution": "Focus on user-facing behaviors and business workflows rather than specific UI elements or implementation details",
        "severity": "high"
      },
      {
        "mistake": "Creating overly complex E2E tests that are hard to maintain",
        "solution": "Keep E2E tests focused on specific user journeys and break complex workflows into multiple tests",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Identify Critical User Journeys for E2E Testing",
        "description": "Analyze an e-commerce application and identify the most critical user journeys that should be covered by E2E tests.",
        "checkpoints": [
          "List the core business workflows (e.g., product search, add to cart, checkout)",
          "Identify authentication flows (login, registration, password reset)",
          "Consider edge cases in critical workflows",
          "Prioritize workflows based on business impact and user frequency",
          "Map out the steps in each identified journey"
        ]
      }
    ],
    "next": [
      "e2e-testing-lesson-2"
    ],
    "estimatedMinutes": 45,
    "difficulty": "Beginner",
    "tags": [
      "e2e-testing",
      "testing-pyramid",
      "fundamentals",
      "workflows"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-2",
    "moduleSlug": "e2e-testing",
    "title": "Cypress Fundamentals",
    "order": 2,
    "objectives": [
      "Master the core concepts and architecture of Cypress testing framework",
      "Learn to write, run, and debug Cypress tests",
      "Understand Cypress's automatic waiting and retry mechanisms",
      "Implement best practices for reliable Cypress tests"
    ],
    "intro": "Cypress is a next-generation front-end testing tool built for the modern web. Unlike traditional testing frameworks that run tests outside the browser, Cypress runs in the same run loop as your application, providing real-time feedback and eliminating many of the common issues with flaky tests.\n\nIn this lesson, you'll learn about Cypress's unique architecture and how it differs from other E2E testing frameworks. You'll understand the benefits of Cypress's automatic waiting mechanisms, which eliminate the need for arbitrary timeouts and make tests more reliable.\n\nYou'll explore Cypress's powerful debugging capabilities, including time-travel debugging that allows you to see the state of your application at each step of a test. This feature dramatically reduces the time needed to identify and fix test issues.\n\nThe lesson will cover core Cypress commands for interacting with web elements, asserting conditions, and navigating between pages. You'll learn about Cypress's selector strategies and best practices for creating stable, maintainable tests.\n\nYou'll also understand how to structure Cypress tests using patterns like Page Objects and how to handle common testing scenarios like authentication, file uploads, and network requests.\n\nBy mastering Cypress fundamentals, you'll be able to create fast, reliable E2E tests that provide confidence in your application's functionality.",
    "code": {
      "example": "// Basic Cypress test structure\n\ndescribe('Login Feature', () => {\n  beforeEach(() => {\n    // Visit the login page before each test\n    cy.visit('/login');\n  });\n\n  it('successfully logs in with valid credentials', () => {\n    // Arrange - Fill in login form\n    cy.get('[data-cy=\"email\"]').type('user@example.com');\n    cy.get('[data-cy=\"password\"]').type('password123');\n    \n    // Act - Submit the form\n    cy.get('[data-cy=\"login-button\"]').click();\n    \n    // Assert - Verify successful login\n    cy.url().should('include', '/dashboard');\n    cy.get('[data-cy=\"welcome-message\"]').should('contain', 'Welcome');\n    cy.get('[data-cy=\"user-menu\"]').should('be.visible');\n  });\n\n  it('shows error message with invalid credentials', () => {\n    // Arrange - Fill in login form with invalid data\n    cy.get('[data-cy=\"email\"]').type('invalid@example.com');\n    cy.get('[data-cy=\"password\"]').type('wrongpassword');\n    \n    // Act - Submit the form\n    cy.get('[data-cy=\"login-button\"]').click();\n    \n    // Assert - Verify error message\n    cy.get('[data-cy=\"error-message\"]').should('be.visible')\n      .and('contain', 'Invalid credentials');\n    cy.url().should('include', '/login'); // Should stay on login page\n  });\n\n  it('requires email and password fields to be filled', () => {\n    // Act - Try to submit empty form\n    cy.get('[data-cy=\"login-button\"]').click();\n    \n    // Assert - Verify validation messages\n    cy.get('[data-cy=\"email-error\"]').should('be.visible');\n    cy.get('[data-cy=\"password-error\"]').should('be.visible');\n  });\n});\n\n// Key Cypress features demonstrated:\n// 1. Automatic waiting - No need for explicit waits\n// 2. Retry-ability - Commands retry until they pass or timeout\n// 3. Time-travel debugging - Click commands in test runner to see app state\n// 4. Data attributes for stable selectors",
      "explanation": "This example demonstrates core Cypress testing patterns including test structure with describe/it blocks, beforeEach hooks for setup, and the Arrange-Act-Assert pattern. The test uses Cypress's automatic waiting mechanisms - when you use cy.get(), Cypress automatically waits for the element to appear and be interactable. The data-cy attributes provide stable selectors that won't break when CSS classes change. Each assertion demonstrates different aspects of Cypress's capabilities, from URL verification to content checking.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Using cy.wait() with static timeouts instead of automatic waiting",
        "solution": "Rely on Cypress's automatic waiting and retry mechanisms, only using cy.wait() for specific network timing scenarios",
        "severity": "high"
      },
      {
        "mistake": "Using unreliable selectors like CSS classes that may change",
        "solution": "Use data attributes specifically for testing (data-cy) or other stable selectors",
        "severity": "high"
      },
      {
        "mistake": "Writing tests that depend on previous tests (not isolated)",
        "solution": "Ensure each test can run independently by using beforeEach to set up required state",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Create Cypress Tests for a Shopping Cart Feature",
        "description": "Write comprehensive Cypress tests for adding items to a shopping cart and proceeding to checkout.",
        "checkpoints": [
          "Create tests for adding single and multiple items to cart",
          "Test updating item quantities in the cart",
          "Verify cart total calculations are correct",
          "Test removing items from the cart",
          "Implement checkout flow validation"
        ]
      }
    ],
    "next": [
      "e2e-testing-lesson-3"
    ],
    "estimatedMinutes": 75,
    "difficulty": "Intermediate",
    "tags": [
      "cypress",
      "frameworks",
      "automatic-waiting",
      "debugging"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-3",
    "moduleSlug": "e2e-testing",
    "title": "Playwright Essentials",
    "order": 3,
    "objectives": [
      "Understand the core features and architecture of Playwright",
      "Learn to write tests for multiple browsers with a single API",
      "Master Playwright's auto-waiting and retry mechanisms",
      "Implement advanced testing scenarios with Playwright"
    ],
    "intro": "Playwright is a modern end-to-end testing framework that enables reliable testing across all modern browsers with a single API. Developed by Microsoft, Playwright addresses many limitations of earlier testing frameworks and provides powerful features for testing modern web applications.\n\nIn this lesson, you'll learn about Playwright's architecture and how it differs from other E2E testing frameworks. You'll understand the benefits of Playwright's multi-browser support, which allows you to test your application on Chromium, Firefox, and WebKit (Safari) using the same test code.\n\nYou'll explore Playwright's powerful auto-waiting mechanisms that automatically wait for elements to be ready before interacting with them. This eliminates flaky tests caused by timing issues and makes tests more reliable.\n\nThe lesson will cover advanced Playwright features like network interception, which allows you to mock API responses and test different scenarios without modifying your application code. You'll also learn about Playwright's powerful locator strategies and how to create robust selectors.\n\nYou'll understand how to handle complex testing scenarios like file uploads, drag and drop interactions, and testing applications with complex UI components like calendars and rich text editors.\n\nBy mastering Playwright essentials, you'll be able to create fast, reliable tests that work across all major browsers and handle complex testing scenarios.",
    "code": {
      "example": "// Playwright test with multiple browser support\nconst { test, expect } = require('@playwright/test');\n\n// This test will run on Chromium, Firefox, and WebKit\ntest('user can search for products', async ({ page }) => {\n  // Navigate to the homepage\n  await page.goto('/');\n  \n  // Search for a product\n  await page.fill('[data-testid=\"search-input\"]', 'laptop');\n  await page.click('[data-testid=\"search-button\"]');\n  \n  // Wait for search results and verify\n  await expect(page.locator('[data-testid=\"search-results\"]'))\n    .toBeVisible();\n  \n  // Verify at least one result is shown\n  const resultsCount = await page\n    .locator('[data-testid=\"product-card\"]')\n    .count();\n  expect(resultsCount).toBeGreaterThan(0);\n  \n  // Verify first product has expected elements\n  const firstProduct = page.locator('[data-testid=\"product-card\"]').first();\n  await expect(firstProduct.locator('[data-testid=\"product-title\"]'))\n    .toBeVisible();\n  await expect(firstProduct.locator('[data-testid=\"product-price\"]'))\n    .toBeVisible();\n});\n\n// Advanced Playwright features\n\ntest('handle API mocking for error scenarios', async ({ page }) => {\n  // Mock API response to simulate error\n  await page.route('**/api/products/**', route => {\n    route.fulfill({\n      status: 500,\n      contentType: 'application/json',\n      body: JSON.stringify({ error: 'Server error' })\n    });\n  });\n  \n  // Navigate to products page\n  await page.goto('/products');\n  \n  // Verify error message is displayed\n  await expect(page.locator('[data-testid=\"error-message\"]'))\n    .toBeVisible()\n    .and\n    .toContainText('Server error');\n  \n  // Verify retry button is available\n  await expect(page.locator('[data-testid=\"retry-button\"]'))\n    .toBeVisible();\n});\n\n// Key Playwright features demonstrated:\n// 1. Cross-browser testing with single API\n// 2. Auto-waiting for elements\n// 3. Network interception and mocking\n// 4. Chained locators for complex element selection",
      "explanation": "This example demonstrates key Playwright features including cross-browser testing capabilities and API mocking. The first test shows how Playwright's auto-waiting works - when you use await expect().toBeVisible(), Playwright automatically waits for the element to appear. The second test demonstrates network interception, where we mock an API response to test error handling scenarios without needing to modify the actual application. Playwright's locator chaining allows for precise element selection even in complex UIs.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Not leveraging Playwright's network interception capabilities",
        "solution": "Use page.route() to mock API responses and test various scenarios including error conditions",
        "severity": "high"
      },
      {
        "mistake": "Using brittle selectors that break with UI changes",
        "solution": "Use data-testid attributes or other stable selectors, and leverage Playwright's robust locator strategies",
        "severity": "high"
      },
      {
        "mistake": "Writing tests that don't take advantage of cross-browser testing",
        "solution": "Configure tests to run on multiple browsers to catch browser-specific issues early",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Playwright Tests for a File Upload Feature",
        "description": "Create comprehensive Playwright tests for a file upload feature with validation and error handling.",
        "checkpoints": [
          "Test uploading valid file types and sizes",
          "Verify upload progress indicators work correctly",
          "Test error handling for invalid file types",
          "Implement tests for large file upload scenarios",
          "Verify uploaded files are properly processed and displayed"
        ]
      }
    ],
    "next": [
      "e2e-testing-lesson-4"
    ],
    "estimatedMinutes": 75,
    "difficulty": "Intermediate",
    "tags": [
      "playwright",
      "cross-browser",
      "network-interception",
      "locators"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-4",
    "moduleSlug": "e2e-testing",
    "title": "Test Organization and Page Objects",
    "order": 4,
    "objectives": [
      "Learn to organize E2E tests using the Page Object Model pattern",
      "Implement reusable components and utilities for test code",
      "Structure test suites for maintainability and scalability",
      "Apply best practices for test data management"
    ],
    "intro": "As your E2E test suite grows, proper organization becomes crucial for maintainability and scalability. The Page Object Model (POM) is a design pattern that creates an object repository for web UI elements, reducing code duplication and making tests more readable and maintainable.\n\nIn this lesson, you'll learn how to implement the Page Object Model pattern with modern E2E testing frameworks. You'll understand how to structure your test code to maximize reusability and minimize maintenance overhead.\n\nYou'll explore strategies for managing test data effectively, including using factories for generating consistent test data and implementing cleanup mechanisms to ensure test isolation.\n\nThe lesson will cover advanced organizational patterns like component objects for reusable UI components and service objects for encapsulating business logic. You'll learn how to structure your test directories and files for optimal navigation and maintenance.\n\nYou'll also understand how to implement configuration management for different environments (development, staging, production) and how to handle secrets and sensitive data in test environments.\n\nBy mastering test organization, you'll create E2E test suites that scale effectively with your application and remain maintainable over time.",
    "code": {
      "example": "// Page Object Model implementation for a login page\n\n// LoginPage.js\nexport class LoginPage {\n  constructor(page) {\n    this.page = page;\n    this.emailInput = page.locator('[data-testid=\"email-input\"]');\n    this.passwordInput = page.locator('[data-testid=\"password-input\"]');\n    this.loginButton = page.locator('[data-testid=\"login-button\"]');\n    this.errorMessage = page.locator('[data-testid=\"error-message\"]');\n  }\n\n  async navigate() {\n    await this.page.goto('/login');\n  }\n\n  async login(email, password) {\n    await this.emailInput.fill(email);\n    await this.passwordInput.fill(password);\n    await this.loginButton.click();\n  }\n\n  async loginWithRedirect(email, password) {\n    await this.login(email, password);\n    // Wait for redirect to complete\n    await this.page.waitForURL('**/dashboard');\n    // Return new page object for the next page\n    return new DashboardPage(this.page);\n  }\n}\n\n// DashboardPage.js\nexport class DashboardPage {\n  constructor(page) {\n    this.page = page;\n    this.welcomeMessage = page.locator('[data-testid=\"welcome-message\"]');\n    this.userMenu = page.locator('[data-testid=\"user-menu\"]');\n  }\n\n  async getWelcomeText() {\n    return await this.welcomeMessage.textContent();\n  }\n\n  async isUserMenuVisible() {\n    return await this.userMenu.isVisible();\n  }\n}\n\n// login.test.js\nimport { test, expect } from '@playwright/test';\nimport { LoginPage } from '../pages/LoginPage';\nimport { DashboardPage } from '../pages/DashboardPage';\n\ntest('successful login redirects to dashboard', async ({ page }) => {\n  const loginPage = new LoginPage(page);\n  await loginPage.navigate();\n  \n  // Using page object methods\n  const dashboardPage = await loginPage.loginWithRedirect(\n    'user@example.com', \n    'password123'\n  );\n  \n  // Assertions using page object\n  expect(await dashboardPage.getWelcomeText()).toContain('Welcome');\n  expect(await dashboardPage.isUserMenuVisible()).toBe(true);\n});\n\n// Key benefits of Page Object Model:\n// 1. Centralized element locators - change in one place\n// 2. Reusable methods - loginWithRedirect can be used in multiple tests\n// 3. Improved readability - test logic is clear and focused\n// 4. Easier maintenance - UI changes only require page object updates",
      "explanation": "This example demonstrates the Page Object Model pattern with Playwright. The LoginPage and DashboardPage classes encapsulate the UI elements and interactions for each page, making the test code more readable and maintainable. When UI elements change, you only need to update the page objects rather than every test that uses those elements. The loginWithRedirect method shows how page objects can return other page objects, creating a fluent API for navigating through the application.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Creating page objects that are too large or try to do too much",
        "solution": "Keep page objects focused on specific pages or components, and break complex pages into multiple objects",
        "severity": "high"
      },
      {
        "mistake": "Hard-coding test data in page objects",
        "solution": "Use parameters for test data and implement data factories for generating consistent test data",
        "severity": "high"
      },
      {
        "mistake": "Not organizing test files logically",
        "solution": "Use a clear directory structure (pages, tests, utils, data) and consistent naming conventions",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Page Objects for an E-commerce Application",
        "description": "Create page objects for a complete e-commerce flow including product browsing, cart management, and checkout.",
        "checkpoints": [
          "Create page objects for homepage, product listing, product detail, cart, and checkout pages",
          "Implement reusable methods for common actions like adding to cart",
          "Design component objects for shared UI elements like headers and footers",
          "Structure the page object files in a logical directory hierarchy",
          "Write tests that use the page objects to verify the complete purchase flow"
        ]
      }
    ],
    "next": [
      "e2e-testing-lesson-5"
    ],
    "estimatedMinutes": 90,
    "difficulty": "Intermediate",
    "tags": [
      "page-object-model",
      "test-organization",
      "reusability",
      "maintainability"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-5",
    "moduleSlug": "e2e-testing",
    "title": "Handling Authentication and Sessions",
    "order": 5,
    "objectives": [
      "Learn strategies for handling authentication in E2E tests",
      "Implement session management to avoid repeated logins",
      "Master token-based authentication testing",
      "Handle complex authentication flows like OAuth and SSO"
    ],
    "intro": "Authentication is a critical aspect of most web applications, and properly testing authentication flows is essential for ensuring application security and user experience. However, authentication can significantly slow down E2E tests if not handled correctly.\n\nIn this lesson, you'll learn various strategies for handling authentication in E2E tests, from simple username/password flows to complex OAuth and SSO implementations. You'll understand how to balance test realism with execution speed.\n\nYou'll explore session management techniques that allow tests to reuse authenticated sessions, dramatically reducing test execution time while maintaining test isolation. You'll learn about browser storage mechanisms and how to properly manage authentication tokens.\n\nThe lesson will cover advanced authentication scenarios including multi-factor authentication, social login integrations, and token refresh mechanisms. You'll understand how to test error conditions and edge cases in authentication flows.\n\nYou'll also learn about security considerations in E2E testing, including how to handle sensitive credentials and how to test authentication without exposing real user accounts or production systems.\n\nBy mastering authentication handling, you'll create efficient, secure E2E tests that properly validate your application's authentication mechanisms.",
    "code": {
      "example": "// Authentication strategies in Playwright\n\nimport { test, expect } from '@playwright/test';\n\n// Strategy 1: Direct login for each test (slower but more realistic)\ntest('user can access protected page after login', async ({ page }) => {\n  // Navigate to login page\n  await page.goto('/login');\n  \n  // Perform login\n  await page.fill('[data-testid=\"email\"]', 'user@example.com');\n  await page.fill('[data-testid=\"password\"]', 'password123');\n  await page.click('[data-testid=\"login-button\"]');\n  \n  // Verify successful login\n  await expect(page).toHaveURL('/dashboard');\n  \n  // Perform actions that require authentication\n  await page.click('[data-testid=\"profile-link\"]');\n  await expect(page.locator('[data-testid=\"profile-page\"]')).toBeVisible();\n});\n\n// Strategy 2: Session storage reuse (faster)\nconst authFile = 'auth.json';\n\ntest('setup authenticated session', async ({ page }) => {\n  // Perform login\n  await page.goto('/login');\n  await page.fill('[data-testid=\"email\"]', 'user@example.com');\n  await page.fill('[data-testid=\"password\"]', 'password123');\n  await page.click('[data-testid=\"login-button\"]');\n  \n  // Wait for login to complete\n  await page.waitForURL('/dashboard');\n  \n  // Save storage state\n  await page.context().storageState({ path: authFile });\n});\n\n// Reuse authenticated state in other tests\ntest.use({ storageState: authFile });\n\ntest('access profile page with saved session', async ({ page }) => {\n  // Start already authenticated\n  await page.goto('/profile');\n  \n  // Perform actions that require authentication\n  await expect(page.locator('[data-testid=\"profile-page\"]')).toBeVisible();\n});\n\n// Strategy 3: API-based authentication (fastest for token-based auth)\ntest('API-based login for token authentication', async ({ request }) => {\n  // Get authentication token via API\n  const loginResponse = await request.post('/api/login', {\n    data: {\n      email: 'user@example.com',\n      password: 'password123'\n    }\n  });\n  \n  expect(loginResponse.ok()).toBeTruthy();\n  \n  const { token } = await loginResponse.json();\n  \n  // Use token in subsequent API requests\n  const profileResponse = await request.get('/api/profile', {\n    headers: {\n      'Authorization': `Bearer ${token}`\n    }\n  });\n  \n  expect(profileResponse.ok()).toBeTruthy();\n});\n\n// Key authentication strategies:\n// 1. Full UI login - Most realistic but slowest\n// 2. Session reuse - Good balance of speed and realism\n// 3. API authentication - Fastest for token-based systems",
      "explanation": "This example demonstrates three different authentication strategies with increasing levels of efficiency. The first approach performs a full UI login for each test, which is the most realistic but slowest. The second approach logs in once and saves the session state, then reuses it in subsequent tests - a good balance of speed and realism. The third approach bypasses the UI entirely and authenticates via API, which is fastest for token-based authentication but doesn't test the login UI itself. Each strategy has its place depending on what you're trying to test.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Performing full login for every test, causing unnecessarily slow test execution",
        "solution": "Use session reuse or API-based authentication for tests that don't specifically need to test the login flow",
        "severity": "high"
      },
      {
        "mistake": "Hard-coding credentials in test code",
        "solution": "Use environment variables or secure credential management systems for authentication data",
        "severity": "high"
      },
      {
        "mistake": "Not properly cleaning up authentication state between tests",
        "solution": "Implement proper test isolation with beforeEach/afterEach hooks to ensure tests don't interfere with each other",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Authentication Strategies for a Social Media App",
        "description": "Create E2E tests for an application with email/password login, Google OAuth, and session management.",
        "checkpoints": [
          "Implement UI-based login tests for the main login flow",
          "Create session reuse setup for faster authenticated tests",
          "Test OAuth integration with Google login",
          "Implement tests for session timeout and token refresh",
          "Verify proper logout functionality and session cleanup"
        ]
      }
    ],
    "next": [
      "e2e-testing-lesson-6"
    ],
    "estimatedMinutes": 90,
    "difficulty": "Intermediate",
    "tags": [
      "authentication",
      "session-management",
      "oauth",
      "security"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-6",
    "moduleSlug": "e2e-testing",
    "title": "Network Interception and API Mocking",
    "order": 6,
    "objectives": [
      "Master network interception techniques for E2E testing",
      "Learn to mock API responses for reliable testing",
      "Implement stubbing for external services and dependencies",
      "Handle complex network scenarios and error conditions"
    ],
    "intro": "Modern web applications heavily rely on APIs and external services, making network interception and API mocking essential skills for effective E2E testing. These techniques allow you to test various scenarios without depending on actual backend services or external systems.\n\nIn this lesson, you'll learn how to intercept network requests and mock responses using modern E2E testing frameworks. You'll understand how to create reliable tests that aren't affected by backend issues or network latency.\n\nYou'll explore advanced mocking scenarios including simulating different API response times, error conditions, and edge cases that are difficult to reproduce in real environments. You'll learn how to mock external services like payment gateways, social media APIs, and third-party integrations.\n\nThe lesson will cover strategies for handling authentication tokens in mocked requests and how to maintain consistency between mocked data and UI expectations. You'll understand how to create realistic mock data that matches your application's actual API contracts.\n\nYou'll also learn about the limitations of API mocking and when it's better to test against real services. You'll understand how to balance test reliability with test realism.\n\nBy mastering network interception and API mocking, you'll create faster, more reliable E2E tests that can validate complex application behavior under various conditions.",
    "code": {
      "example": "// Network interception and API mocking in Playwright\n\nimport { test, expect } from '@playwright/test';\n\n// Mock successful API response\ntest('display user profile with mocked API data', async ({ page }) => {\n  // Intercept API request and mock response\n  await page.route('**/api/user/profile', route => {\n    route.fulfill({\n      status: 200,\n      contentType: 'application/json',\n      body: JSON.stringify({\n        id: 123,\n        name: 'John Doe',\n        email: 'john@example.com',\n        avatar: '/images/avatar.jpg',\n        membershipLevel: 'premium'\n      })\n    });\n  });\n  \n  // Navigate to profile page\n  await page.goto('/profile');\n  \n  // Verify UI displays mocked data\n  await expect(page.locator('[data-testid=\"user-name\"]'))\n    .toHaveText('John Doe');\n  await expect(page.locator('[data-testid=\"user-email\"]'))\n    .toHaveText('john@example.com');\n  await expect(page.locator('[data-testid=\"membership-badge\"]'))\n    .toHaveText('premium');\n});\n\n// Mock API error response\ntest('handle API error gracefully', async ({ page }) => {\n  // Mock 500 error response\n  await page.route('**/api/user/profile', route => {\n    route.fulfill({\n      status: 500,\n      contentType: 'application/json',\n      body: JSON.stringify({\n        error: 'Internal server error'\n      })\n    });\n  });\n  \n  // Navigate to profile page\n  await page.goto('/profile');\n  \n  // Verify error handling\n  await expect(page.locator('[data-testid=\"error-message\"]'))\n    .toBeVisible()\n    .and\n    .toContainText('Unable to load profile');\n  await expect(page.locator('[data-testid=\"retry-button\"]'))\n    .toBeVisible();\n});\n\n// Mock slow API response\ntest('handle loading states properly', async ({ page }) => {\n  // Mock slow API response (3 seconds)\n  await page.route('**/api/user/profile', async route => {\n    await page.waitForTimeout(3000);\n    route.fulfill({\n      status: 200,\n      contentType: 'application/json',\n      body: JSON.stringify({\n        name: 'John Doe',\n        email: 'john@example.com'\n      })\n    });\n  });\n  \n  // Navigate to profile page\n  await page.goto('/profile');\n  \n  // Verify loading state is displayed\n  await expect(page.locator('[data-testid=\"loading-spinner\"]'))\n    .toBeVisible();\n  \n  // Verify content appears after loading\n  await expect(page.locator('[data-testid=\"user-name\"]'))\n    .toBeVisible();\n});\n\n// Inspect and modify real requests\ntest('add authentication header to API requests', async ({ page }) => {\n  // Intercept and modify requests\n  await page.route('**/api/**', route => {\n    const headers = {\n      ...route.request().headers(),\n      'Authorization': 'Bearer mock-token-123'\n    };\n    route.continue({ headers });\n  });\n  \n  // Perform actions that trigger API calls\n  await page.goto('/dashboard');\n  // API calls will now include the mock authorization header\n});",
      "explanation": "This example demonstrates various network interception and mocking techniques. The first test shows how to mock a successful API response with specific data, allowing you to test the UI without depending on a real backend. The second test demonstrates error handling by mocking a 500 server error response. The third test shows how to simulate slow network conditions to verify loading states. The fourth example demonstrates how to intercept and modify real requests, such as adding authentication headers. These techniques make tests more reliable and allow you to test scenarios that would be difficult to reproduce in a real environment.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Mocking API responses that don't match real API contracts",
        "solution": "Ensure mocked responses match the actual API structure and data types to avoid false positives",
        "severity": "high"
      },
      {
        "mistake": "Over-mocking and not testing against real services when appropriate",
        "solution": "Use mocking for specific scenarios but also have tests that run against real services for integration validation",
        "severity": "high"
      },
      {
        "mistake": "Not handling all possible API response scenarios",
        "solution": "Mock success, error, timeout, and edge case scenarios to ensure comprehensive test coverage",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement API Mocking for a Weather Application",
        "description": "Create E2E tests for a weather app that displays current conditions and forecasts using API mocking.",
        "checkpoints": [
          "Mock successful weather API responses with realistic data",
          "Test error handling for API failures and network issues",
          "Implement mocking for different weather conditions (sunny, rainy, stormy)",
          "Test loading states and UI transitions",
          "Verify proper display of temperature units and formatting"
        ]
      }
    ],
    "next": [
      "e2e-testing-lesson-7"
    ],
    "estimatedMinutes": 90,
    "difficulty": "Intermediate",
    "tags": [
      "network-interception",
      "api-mocking",
      "error-handling",
      "performance"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-7",
    "moduleSlug": "e2e-testing",
    "title": "Cross-Browser and Visual Testing",
    "order": 7,
    "objectives": [
      "Learn cross-browser testing strategies and implementation",
      "Master visual regression testing techniques",
      "Implement responsive design testing across devices",
      "Handle browser-specific issues and compatibility"
    ],
    "intro": "Modern web applications must work consistently across different browsers, devices, and screen sizes. Cross-browser testing and visual regression testing are essential for ensuring a consistent user experience regardless of how users access your application.\n\nIn this lesson, you'll learn how to implement effective cross-browser testing strategies using modern E2E testing frameworks. You'll understand the differences between various browsers and how to handle browser-specific quirks and compatibility issues.\n\nYou'll explore visual regression testing techniques that automatically detect unintended visual changes in your application. You'll learn how to set up visual testing workflows and handle false positives that can occur with visual comparisons.\n\nThe lesson will cover responsive design testing across different screen sizes and devices. You'll understand how to simulate various viewport sizes and device characteristics to ensure your application works well on mobile, tablet, and desktop.\n\nYou'll also learn about performance considerations in cross-browser testing and how to optimize test execution across multiple browser environments. You'll understand when to test on real browsers versus when emulators are sufficient.\n\nBy mastering cross-browser and visual testing, you'll ensure your application provides a consistent, high-quality experience for all users regardless of their browser or device preferences.",
    "code": {
      "example": "// Cross-browser testing with Playwright\n\nimport { test, expect } from '@playwright/test';\n\n// This test will automatically run on Chromium, Firefox, and WebKit\ntest('navigation works correctly across browsers', async ({ page }) => {\n  await page.goto('/');\n  \n  // Click navigation link\n  await page.click('[data-testid=\"products-link\"]');\n  \n  // Verify navigation worked\n  await expect(page).toHaveURL('/products');\n  await expect(page.locator('[data-testid=\"products-page\"]')).toBeVisible();\n});\n\n// Test specific browser\ntest('check browser-specific feature support', async ({ page, browserName }) => {\n  await page.goto('/');\n  \n  // Different behavior based on browser\n  if (browserName === 'chromium') {\n    // Chromium-specific test\n    await expect(page.locator('[data-testid=\"web-share-button\"]')).toBeVisible();\n  } else {\n    // Other browsers might not support this feature\n    await expect(page.locator('[data-testid=\"web-share-button\"]')).toBeHidden();\n  }\n});\n\n// Visual regression testing\nimport { test, expect } from '@playwright/test';\n\ntest('homepage visual regression', async ({ page }) => {\n  await page.goto('/');\n  \n  // Take screenshot and compare with baseline\n  await expect(page).toHaveScreenshot('homepage.png', {\n    maxDiffPixelRatio: 0.01\n  });\n});\n\n// Responsive design testing\ntest('mobile navigation works correctly', async ({ page }) => {\n  // Set viewport to mobile size\n  await page.setViewportSize({ width: 375, height: 667 });\n  \n  await page.goto('/');\n  \n  // Mobile-specific elements should be visible\n  await expect(page.locator('[data-testid=\"mobile-menu-button\"]')).toBeVisible();\n  \n  // Desktop elements should be hidden\n  await expect(page.locator('[data-testid=\"desktop-nav\"]')).toBeHidden();\n  \n  // Test mobile menu interaction\n  await page.click('[data-testid=\"mobile-menu-button\"]');\n  await expect(page.locator('[data-testid=\"mobile-menu\"]')).toBeVisible();\n});\n\n// Test across multiple viewports\ntest('hero section responsive behavior', async ({ page }) => {\n  const viewports = [\n    { name: 'mobile', width: 375, height: 667 },\n    { name: 'tablet', width: 768, height: 1024 },\n    { name: 'desktop', width: 1280, height: 800 }\n  ];\n  \n  for (const viewport of viewports) {\n    await page.setViewportSize({ \n      width: viewport.width, \n      height: viewport.height \n    });\n    \n    await page.goto('/');\n    \n    // Take viewport-specific screenshot\n    await expect(page).toHaveScreenshot(`hero-${viewport.name}.png`, {\n      maxDiffPixelRatio: 0.01\n    });\n  }\n});",
      "explanation": "This example demonstrates cross-browser and visual testing techniques. The first test will automatically run on all supported browsers (Chromium, Firefox, WebKit) ensuring consistent behavior. The second test shows how to write browser-specific tests when needed. The third test demonstrates visual regression testing by comparing screenshots with baselines. The fourth test shows responsive design testing by setting different viewport sizes. The final test demonstrates testing across multiple viewports in a single test, which is useful for ensuring responsive behavior across different device sizes.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Testing on too many browser combinations, causing slow test execution",
        "solution": "Focus on browsers that represent your user base and use risk-based testing to prioritize combinations",
        "severity": "high"
      },
      {
        "mistake": "Ignoring visual regression testing false positives",
        "solution": "Configure appropriate thresholds and review visual diffs carefully to distinguish real issues from acceptable changes",
        "severity": "high"
      },
      {
        "mistake": "Not testing on actual mobile devices when targeting mobile users",
        "solution": "Use device emulators for development but test on real devices for critical user flows",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Cross-Browser Testing for a Dashboard Application",
        "description": "Create comprehensive cross-browser and visual tests for a data dashboard with charts and graphs.",
        "checkpoints": [
          "Test dashboard functionality across Chromium, Firefox, and WebKit",
          "Implement visual regression tests for chart rendering",
          "Test responsive behavior on mobile, tablet, and desktop viewports",
          "Verify data visualization consistency across browsers",
          "Handle browser-specific issues in chart libraries"
        ]
      }
    ],
    "next": [
      "e2e-testing-lesson-8"
    ],
    "estimatedMinutes": 90,
    "difficulty": "Intermediate",
    "tags": [
      "cross-browser",
      "visual-testing",
      "responsive-design",
      "compatibility"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-8",
    "moduleSlug": "e2e-testing",
    "title": "Performance and Reliability Optimization",
    "order": 8,
    "objectives": [
      "Learn techniques for optimizing E2E test performance",
      "Master strategies for creating reliable, non-flaky tests",
      "Implement parallel test execution and resource management",
      "Handle test data and environment setup efficiently"
    ],
    "intro": "As E2E test suites grow, performance and reliability become critical concerns. Slow tests can bottleneck development workflows, while flaky tests can erode confidence in the entire testing process. Optimizing both performance and reliability is essential for maintaining effective E2E testing practices.\n\nIn this lesson, you'll learn techniques for identifying and addressing performance bottlenecks in your E2E tests. You'll understand how to profile test execution and optimize resource usage to reduce test run times.\n\nYou'll explore strategies for creating reliable tests that consistently pass or fail based on actual application behavior rather than timing issues or environmental factors. You'll learn about common causes of test flakiness and how to address them.\n\nThe lesson will cover parallel test execution strategies that maximize resource utilization while maintaining test isolation. You'll understand how to configure test runners for optimal parallelization and how to handle resource contention.\n\nYou'll also learn about advanced reliability techniques including automatic retries, test quarantine patterns, and monitoring for flaky tests. You'll understand how to balance test speed with test reliability.\n\nBy mastering performance and reliability optimization, you'll create E2E test suites that provide fast feedback while maintaining the confidence needed for continuous deployment.",
    "code": {
      "example": "// Performance and reliability optimization techniques\n\nimport { test, expect } from '@playwright/test';\n\n// Reliable element interaction with proper waits\ntest('reliable form submission', async ({ page }) => {\n  await page.goto('/contact');\n  \n  // Instead of arbitrary waits, use auto-waiting\n  await page.fill('[data-testid=\"name\"]', 'John Doe');\n  await page.fill('[data-testid=\"email\"]', 'john@example.com');\n  await page.fill('[data-testid=\"message\"]', 'Test message');\n  \n  // Wait for button to be enabled before clicking\n  const submitButton = page.locator('[data-testid=\"submit-button\"]');\n  await expect(submitButton).toBeEnabled();\n  await submitButton.click();\n  \n  // Wait for success message\n  await expect(page.locator('[data-testid=\"success-message\"]'))\n    .toBeVisible({ timeout: 10000 }); // Extended timeout for network operations\n});\n\n// Test data management with factories\nclass UserFactory {\n  static create(userData = {}) {\n    return {\n      id: Date.now(), // Unique ID\n      name: userData.name || `User ${Date.now()}`,\n      email: userData.email || `user${Date.now()}@example.com`,\n      ...userData\n    };\n  }\n}\n\ntest('create user with factory data', async ({ page }) => {\n  const testUser = UserFactory.create({\n    name: 'Test User',\n    email: 'test@example.com'\n  });\n  \n  // Use factory data in test\n  await page.goto('/register');\n  await page.fill('[data-testid=\"name\"]', testUser.name);\n  await page.fill('[data-testid=\"email\"]', testUser.email);\n  // ... rest of test\n});\n\n// Parallel execution configuration (playwright.config.js)\n/*\nconst config = {\n  // Run tests in parallel\n  workers: process.env.CI ? 2 : undefined, // Fewer workers in CI\n  \n  // Use sharding for large test suites\n  shard: process.env.SHARD ? {\n    total: parseInt(process.env.SHARD_TOTAL || '1'),\n    current: parseInt(process.env.SHARD_INDEX || '1')\n  } : undefined,\n  \n  // Retry failed tests\n  retries: process.env.CI ? 2 : 0,\n  \n  // Timeout configuration\n  timeout: 30000, // 30 seconds per test\n  expect: {\n    timeout: 10000 // 10 seconds for assertions\n  },\n  \n  use: {\n    // Headless in CI, headed locally for debugging\n    headless: !!process.env.CI,\n    \n    // Screenshot on failure\n    screenshot: 'only-on-failure',\n    \n    // Video recording\n    video: 'retain-on-failure'\n  }\n};\n\nexport default config;\n*/\n\n// Test isolation with beforeEach\ntest.beforeEach(async ({ page }) => {\n  // Clear browser storage\n  await page.context().clearCookies();\n  await page.evaluate(() => localStorage.clear());\n  \n  // Reset database or use test-specific data\n  // This ensures tests don't interfere with each other\n});\n\n// Handling flaky tests with proper waits\ntest('handle dynamic content loading', async ({ page }) => {\n  await page.goto('/dashboard');\n  \n  // Wait for specific content to load rather than arbitrary timeouts\n  await page.waitForSelector('[data-testid=\"dashboard-content\"]', {\n    state: 'visible'\n  });\n  \n  // Or use expect with timeout\n  await expect(page.locator('[data-testid=\"welcome-message\"]'))\n    .toBeVisible({ timeout: 15000 });\n});",
      "explanation": "This example demonstrates several performance and reliability optimization techniques. The first test shows how to use Playwright's auto-waiting features instead of arbitrary timeouts. The UserFactory class demonstrates proper test data management. The configuration example shows how to optimize parallel execution and handle retries. The beforeEach hook shows how to ensure test isolation. The final test demonstrates proper waiting strategies for dynamic content. These techniques help create fast, reliable tests that provide consistent results.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Using arbitrary timeouts (cy.wait(1000)) instead of smart waiting",
        "solution": "Use framework auto-waiting and explicit waits for specific conditions",
        "severity": "high"
      },
      {
        "mistake": "Not properly isolating tests, causing interference between test runs",
        "solution": "Implement proper beforeEach/afterEach hooks to reset state between tests",
        "severity": "high"
      },
      {
        "mistake": "Running too many tests in parallel without considering resource constraints",
        "solution": "Configure appropriate worker counts based on system resources and test characteristics",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Optimize a Slow E2E Test Suite",
        "description": "Identify and fix performance and reliability issues in an existing E2E test suite.",
        "checkpoints": [
          "Profile test execution to identify bottlenecks",
          "Replace arbitrary waits with smart waiting strategies",
          "Implement proper test data management with factories",
          "Configure parallel execution for optimal resource usage",
          "Fix flaky tests by improving reliability techniques"
        ]
      }
    ],
    "next": [
      "e2e-testing-lesson-9"
    ],
    "estimatedMinutes": 90,
    "difficulty": "Intermediate",
    "tags": [
      "performance",
      "reliability",
      "parallel-execution",
      "test-optimization"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-9",
    "moduleSlug": "e2e-testing",
    "title": "CI/CD Integration and Reporting",
    "order": 9,
    "objectives": [
      "Learn to integrate E2E tests into CI/CD pipelines",
      "Master test reporting and result analysis techniques",
      "Implement quality gates and deployment controls",
      "Handle test failures and debugging in CI environments"
    ],
    "intro": "Integrating E2E tests into continuous integration and continuous deployment (CI/CD) pipelines is crucial for maintaining software quality while enabling rapid delivery. Proper CI/CD integration ensures that tests provide fast feedback and that failures are properly identified and addressed.\n\nIn this lesson, you'll learn how to configure E2E tests to run effectively in CI/CD environments. You'll understand the differences between running tests locally versus in CI and how to optimize for each environment.\n\nYou'll explore various reporting mechanisms that provide actionable insights into test results and application quality. You'll learn how to configure detailed reporting that helps teams quickly identify and resolve issues.\n\nThe lesson will cover quality gate implementation that prevents problematic code from reaching production. You'll understand how to set appropriate thresholds for test pass rates, performance metrics, and other quality indicators.\n\nYou'll also learn about debugging strategies for CI environments where direct access to test execution is limited. You'll understand how to capture relevant information for troubleshooting test failures.\n\nBy mastering CI/CD integration and reporting, you'll ensure that your E2E tests provide maximum value in automated deployment workflows while maintaining high software quality standards.",
    "code": {
      "example": "// CI/CD integration and reporting examples\n\n// GitHub Actions workflow for E2E testing\n/*\nname: E2E Tests\n\non:\n  push:\n    branches: [ main ]\n  pull_request:\n    branches: [ main ]\n\njobs:\n  e2e-tests:\n    runs-on: ubuntu-latest\n    \n    # Services needed for testing\n    services:\n      postgres:\n        image: postgres:13\n        env:\n          POSTGRES_PASSWORD: postgres\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n    \n    steps:\n    - uses: actions/checkout@v3\n    \n    - name: Setup Node.js\n      uses: actions/setup-node@v3\n      with:\n        node-version: '18'\n        cache: 'npm'\n    \n    - name: Install dependencies\n      run: npm ci\n    \n    - name: Install Playwright browsers\n      run: npx playwright install --with-deps\n    \n    - name: Start application\n      run: npm run start:test &\n      env:\n        DATABASE_URL: postgresql://postgres:postgres@localhost:5432/test\n    \n    - name: Wait for application\n      run: npx wait-on http://localhost:3000\n    \n    - name: Run E2E tests\n      run: npm run test:e2e\n      env:\n        CI: true\n    \n    - name: Upload test results\n      uses: actions/upload-artifact@v3\n      if: always()\n      with:\n        name: test-results\n        path: |\n          test-results/\n          screenshots/\n          videos/\n    \n    - name: Report test coverage\n      if: github.ref == 'refs/heads/main'\n      run: npm run report-coverage\n*/\n\n// Playwright configuration for CI/CD\n/*\n// playwright.config.js\nimport { defineConfig } from '@playwright/test';\n\nexport default defineConfig({\n  // CI-specific settings\n  workers: process.env.CI ? 2 : undefined,\n  retries: process.env.CI ? 2 : 0,\n  \n  // Reporting\n  reporter: [\n    ['list'], // Simple output for CI logs\n    ['html', { open: 'never' }], // HTML report for detailed analysis\n    ['json', { outputFile: 'test-results/results.json' }], // JSON for CI integration\n    ['junit', { outputFile: 'test-results/results.xml' }] // JUnit for CI systems\n  ],\n  \n  use: {\n    // Headless in CI\n    headless: !!process.env.CI,\n    \n    // Capture artifacts on failure\n    screenshot: 'only-on-failure',\n    video: 'retain-on-failure',\n    trace: 'retain-on-failure',\n    \n    // Base URL for tests\n    baseURL: process.env.BASE_URL || 'http://localhost:3000',\n    \n    // Timeout settings\n    actionTimeout: 10000,\n    navigationTimeout: 15000\n  },\n  \n  // Projects for different browsers\n  projects: [\n    {\n      name: 'chromium',\n      use: { browserName: 'chromium' }\n    },\n    {\n      name: 'firefox',\n      use: { browserName: 'firefox' }\n    },\n    {\n      name: 'webkit',\n      use: { browserName: 'webkit' }\n    }\n  ]\n});\n*/\n\n// Quality gate implementation\n/*\n// Script to check test results before deployment\nconst fs = require('fs');\n\nfunction checkTestResults() {\n  const results = JSON.parse(fs.readFileSync('test-results/results.json', 'utf8'));\n  \n  const totalTests = results.suites.reduce((total, suite) => \n    total + suite.specs.length, 0);\n  \n  const failedTests = results.suites.reduce((failed, suite) => \n    failed + suite.specs.filter(spec => spec.ok === false).length, 0);\n  \n  const passRate = ((totalTests - failedTests) / totalTests) * 100;\n  \n  console.log(`Test Results: ${totalTests} total, ${failedTests} failed, ${passRate.toFixed(2)}% pass rate`);\n  \n  // Quality gate - fail if pass rate is below threshold\n  if (passRate < 95) {\n    console.error('Quality gate failed: Test pass rate below 95%');\n    process.exit(1);\n  }\n  \n  console.log('Quality gate passed');\n}\n\ncheckTestResults();\n*/",
      "explanation": "This example demonstrates CI/CD integration for E2E testing. The GitHub Actions workflow shows how to set up a complete testing environment with necessary services, install dependencies, start the application, and run tests. The Playwright configuration shows CI-specific settings like reduced workers, retries, and artifact capture. The quality gate script demonstrates how to programmatically check test results and prevent deployment if quality thresholds aren't met. These configurations ensure that E2E tests provide reliable feedback in automated workflows.",
      "language": "yaml"
    },
    "pitfalls": [
      {
        "mistake": "Not capturing enough debugging information in CI environments",
        "solution": "Configure screenshots, videos, and traces to be captured on test failures for troubleshooting",
        "severity": "high"
      },
      {
        "mistake": "Setting unrealistic quality gates that block all deployments",
        "solution": "Set appropriate thresholds based on historical data and allow for temporary overrides when needed",
        "severity": "high"
      },
      {
        "mistake": "Running E2E tests on every commit without considering resource costs",
        "solution": "Use selective test execution and run full suites on specific triggers like pull requests to main branch",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement CI/CD Pipeline for E2E Testing",
        "description": "Create a complete CI/CD pipeline that runs E2E tests and implements quality gates for deployment.",
        "checkpoints": [
          "Configure GitHub Actions or GitLab CI workflow for E2E testing",
          "Set up proper reporting with multiple output formats",
          "Implement quality gates based on test results",
          "Configure artifact capture for debugging failed tests",
          "Optimize pipeline for fast feedback and resource usage"
        ]
      }
    ],
    "next": [
      "e2e-testing-lesson-10"
    ],
    "estimatedMinutes": 90,
    "difficulty": "Intermediate",
    "tags": [
      "ci-cd",
      "reporting",
      "quality-gates",
      "pipeline-integration"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "e2e-testing-lesson-10",
    "moduleSlug": "e2e-testing",
    "title": "Advanced Testing Patterns and Best Practices",
    "order": 10,
    "objectives": [
      "Master advanced E2E testing patterns and techniques",
      "Learn industry best practices for scalable test suites",
      "Implement testing strategies for complex applications",
      "Understand when and how to evolve testing approaches"
    ],
    "intro": "As you gain experience with E2E testing, advanced patterns and best practices become essential for maintaining effective, scalable test suites. These techniques help you handle complex testing scenarios while keeping your tests maintainable and reliable.\n\nIn this lesson, you'll learn advanced testing patterns like the Screenplay Pattern, which provides a more maintainable alternative to traditional Page Objects for complex applications. You'll understand how to structure tests for maximum reusability and minimal maintenance overhead.\n\nYou'll explore best practices for testing complex application features like real-time updates, file handling, and third-party integrations. You'll learn how to create robust tests for challenging scenarios while maintaining test performance.\n\nThe lesson will cover strategies for evolving your testing approach as your application grows and changes. You'll understand how to refactor test suites, update testing strategies, and adapt to new requirements without starting from scratch.\n\nYou'll also learn about emerging trends in E2E testing including AI-assisted testing, self-healing tests, and component-based testing approaches. You'll understand how to evaluate and adopt new techniques that provide genuine value.\n\nBy mastering advanced testing patterns and best practices, you'll create E2E test suites that scale with your application and continue to provide value as your software evolves.",
    "code": {
      "example": "// Advanced testing patterns and best practices\n\nimport { test, expect } from '@playwright/test';\n\n// Screenplay Pattern implementation\n// Instead of Page Objects, use Tasks and Questions\n\nclass LoginTask {\n  constructor(email, password) {\n    this.email = email;\n    this.password = password;\n  }\n  \n  async performAs(actor) {\n    await actor.page.goto('/login');\n    await actor.page.fill('[data-testid=\"email\"]', this.email);\n    await actor.page.fill('[data-testid=\"password\"]', this.password);\n    await actor.page.click('[data-testid=\"login-button\"]');\n    await actor.page.waitForURL('**/dashboard');\n  }\n}\n\nclass CurrentUserQuestion {\n  static async answeredBy(actor) {\n    return await actor.page.locator('[data-testid=\"user-menu\"]').textContent();\n  }\n}\n\nclass Actor {\n  constructor(page) {\n    this.page = page;\n  }\n  \n  async attemptsTo(task) {\n    await task.performAs(this);\n  }\n  \n  async asks(question) {\n    return await question.answeredBy(this);\n  }\n}\n\n// Using the Screenplay Pattern\ntest('user can login using Screenplay Pattern', async ({ page }) => {\n  const actor = new Actor(page);\n  \n  await actor.attemptsTo(new LoginTask('user@example.com', 'password123'));\n  \n  const userName = await actor.asks(CurrentUserQuestion);\n  expect(userName).toContain('User Name');\n});\n\n// Component-based testing for reusable UI components\ntest('date picker component works correctly', async ({ page }) => {\n  // Test the date picker component in isolation\n  await page.goto('/components/date-picker');\n  \n  // Select a date\n  await page.click('[data-testid=\"date-input\"]');\n  await page.click('[data-testid=\"calendar-day-15\"]');\n  \n  // Verify date is selected\n  const selectedDate = await page.inputValue('[data-testid=\"date-input\"]');\n  expect(selectedDate).toMatch(/\\d{4}-\\d{2}-15/);\n  \n  // Verify calendar closes\n  await expect(page.locator('[data-testid=\"calendar\"]')).toBeHidden();\n});\n\n// Testing real-time updates\n// playwright.config.js configuration for real-time testing\n/*\n{\n  use: {\n    // Increase timeout for real-time operations\n    actionTimeout: 30000,\n    navigationTimeout: 45000,\n    \n    // Use fewer workers for real-time tests to reduce server load\n    launchOptions: {\n      slowMo: process.env.CI ? 50 : 0 // Slow down in CI for stability\n    }\n  }\n}\n*/\n\ntest('real-time chat updates correctly', async ({ page }) => {\n  // Join chat room\n  await page.goto('/chat/room1');\n  \n  // Send a message\n  await page.fill('[data-testid=\"message-input\"]', 'Hello, world!');\n  await page.click('[data-testid=\"send-button\"]');\n  \n  // Wait for message to appear (real-time)\n  await expect(page.locator('[data-testid=\"message\"]'))\n    .toContainText('Hello, world!', { timeout: 10000 });\n  \n  // Verify message timestamp is recent\n  const timestamp = await page.locator('[data-testid=\"message-timestamp\"]').textContent();\n  const messageTime = new Date(timestamp);\n  const now = new Date();\n  const timeDiff = Math.abs(now - messageTime);\n  expect(timeDiff).toBeLessThan(60000); // Within last minute\n});\n\n// Best practice: Test data cleanup\ntest.afterEach(async ({ page }) => {\n  // Clean up test data\n  await page.evaluate(() => {\n    // Clear any test-specific data from localStorage\n    Object.keys(localStorage).forEach(key => {\n      if (key.startsWith('test-')) {\n        localStorage.removeItem(key);\n      }\n    });\n  });\n  \n  // Clear cookies\n  await page.context().clearCookies();\n});",
      "explanation": "This example demonstrates advanced testing patterns and best practices. The Screenplay Pattern implementation shows an alternative to traditional Page Objects that can be more maintainable for complex applications. The component-based testing example shows how to test reusable UI components in isolation. The real-time chat test demonstrates handling of real-time updates with appropriate timeouts. The afterEach hook shows proper test data cleanup to ensure test isolation. These patterns help create more maintainable and reliable test suites for complex applications.",
      "language": "javascript"
    },
    "pitfalls": [
      {
        "mistake": "Over-engineering test solutions with complex patterns that aren't needed",
        "solution": "Start with simple approaches and only add complexity when it provides clear benefits for maintainability",
        "severity": "high"
      },
      {
        "mistake": "Not regularly refactoring and updating test suites as applications evolve",
        "solution": "Treat test code with the same care as production code, regularly reviewing and improving test architecture",
        "severity": "high"
      },
      {
        "mistake": "Ignoring emerging testing trends and techniques that could improve efficiency",
        "solution": "Stay informed about new testing approaches and evaluate them for applicability to your specific context",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Refactor an Existing E2E Test Suite Using Advanced Patterns",
        "description": "Take an existing E2E test suite and refactor it using advanced patterns and best practices.",
        "checkpoints": [
          "Identify areas of the existing test suite that could benefit from refactoring",
          "Implement the Screenplay Pattern or other advanced patterns where appropriate",
          "Improve test data management and cleanup strategies",
          "Optimize test structure for better maintainability",
          "Document the improvements and their benefits"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 90,
    "difficulty": "Advanced",
    "tags": [
      "advanced-patterns",
      "best-practices",
      "screenplay-pattern",
      "maintainability"
    ],
    "lastUpdated": "2025-10-09T10:00:00.000Z",
    "version": "1.0.0"
  }
]