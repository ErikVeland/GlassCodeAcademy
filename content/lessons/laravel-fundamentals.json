[
  {
    "id": "1",
    "moduleSlug": "laravel-fundamentals",
    "title": "Basic Routing in Laravel",
    "order": 1,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to the foundational world of Laravel routing - the cornerstone of web application navigation and request handling in one of PHP's most elegant frameworks. Laravel's routing system provides an intuitive, expressive syntax that transforms complex URL patterns into clean, maintainable code structures that power modern web applications.\n\nRouting in Laravel serves as the traffic control system for your application, determining how incoming HTTP requests are directed to the appropriate controllers, closures, or resources. Understanding Laravel's routing capabilities is essential for building scalable web applications, as it provides the foundation for RESTful APIs, resource controllers, and complex application architectures.\n\nIn this comprehensive introduction, you'll master the fundamental concepts of route definition, from basic GET and POST routes to more advanced patterns involving route parameters, middleware integration, and route model binding. Laravel's routing system supports HTTP verbs, route groups, and subdomain routing, providing flexibility for everything from simple websites to complex enterprise applications.\n\nThe knowledge you gain here forms the backbone of Laravel development, enabling you to create intuitive URL structures, implement proper separation of concerns, and build applications that follow web standards and best practices. Every subsequent Laravel concept builds upon these routing fundamentals.\n\nBy the end of this lesson, you'll confidently navigate Laravel's routing landscape, understanding how to structure URLs that are both user-friendly and SEO-optimized while maintaining clean, readable code that scales with your application's growth.",
    "code": {
      "example": "<?php\n// routes/web.php\n\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('/', function () {\n    return view('welcome');\n});\n\nRoute::get('/users', function () {\n    return 'All users';\n});",
      "explanation": "This example produces: Route definitions registered successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Basic Routing in Laravel",
        "description": "Apply the concepts from this lesson on Routing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Beginner",
    "tags": [
      "Routing",
      "laravel"
    ],
    "legacy": {
      "originalId": 1,
      "originalTopic": "Routing",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "2",
    "moduleSlug": "laravel-fundamentals",
    "title": "Route Parameters",
    "order": 2,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Routing.\n\nLearn how to capture segments of the URI in Laravel routes.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<?php\n// routes/web.php\n\nuse Illuminate\\Support\\Facades\\Route;\n\nRoute::get('/user/{id}', function ($id) {\n    return 'User '.$id;\n});\n\nRoute::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) {\n    //\n});",
      "explanation": "This example produces: Route with parameters registered successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Route Parameters",
        "description": "Apply the concepts from this lesson on Routing",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Routing",
      "laravel"
    ],
    "legacy": {
      "originalId": 2,
      "originalTopic": "Routing",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "3",
    "moduleSlug": "laravel-fundamentals",
    "title": "Introduction to Eloquent",
    "order": 3,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Eloquent ORM.\n\nLearn how to work with database records using Eloquent ORM.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<?php\n// app/Models/User.php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass User extends Model\n{\n    use HasFactory;\n\n    protected $fillable = [\n        'name',\n        'email',\n        'password',\n    ];\n}",
      "explanation": "This example produces: Eloquent model created successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Introduction to Eloquent",
        "description": "Apply the concepts from this lesson on Eloquent ORM",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Beginner",
    "tags": [
      "Eloquent ORM",
      "laravel"
    ],
    "legacy": {
      "originalId": 3,
      "originalTopic": "Eloquent ORM",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "4",
    "moduleSlug": "laravel-fundamentals",
    "title": "Querying Models",
    "order": 4,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Eloquent ORM.\n\nLearn how to retrieve records from the database using Eloquent.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<?php\n// Retrieving models\n\nuse App\\Models\\User;\n\n$users = User::all();\n\n$user = User::find(1);\n\n$users = User::where('active', 1)->orderBy('name')->get();",
      "explanation": "This example produces: Users retrieved successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Querying Models",
        "description": "Apply the concepts from this lesson on Eloquent ORM",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Eloquent ORM",
      "laravel"
    ],
    "legacy": {
      "originalId": 4,
      "originalTopic": "Eloquent ORM",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "5",
    "moduleSlug": "laravel-fundamentals",
    "title": "Blade Basics",
    "order": 5,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Blade Templates.\n\nLearn how to create dynamic views using Blade templating engine.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<!-- resources/views/welcome.blade.php -->\n\n<!DOCTYPE html>\n<html>\n<head>\n    <title>App Name - @yield('title')</title>\n</head>\n<body>\n    @section('sidebar')\n        This is the master sidebar.\n    @show\n\n    <div class=\"container\">\n        @yield('content')\n    </div>\n</body>\n</html>",
      "explanation": "This example produces: Blade template rendered successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Blade Basics",
        "description": "Apply the concepts from this lesson on Blade Templates",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Beginner",
    "tags": [
      "Blade Templates",
      "laravel"
    ],
    "legacy": {
      "originalId": 5,
      "originalTopic": "Blade Templates",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "6",
    "moduleSlug": "laravel-fundamentals",
    "title": "Blade Control Structures",
    "order": 6,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Blade Templates.\n\nLearn how to use control structures in Blade templates.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "@if (count($records) === 1)\n    I have one record!\n@elseif (count($records) > 1)\n    I have multiple records!\n@else\n    I don't have any records!\n@endif\n\n@foreach ($users as $user)\n    <p>This is user {{ $user->id }}</p>\n@endforeach",
      "explanation": "This example produces: Blade control structures executed successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Blade Control Structures",
        "description": "Apply the concepts from this lesson on Blade Templates",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Blade Templates",
      "laravel"
    ],
    "legacy": {
      "originalId": 6,
      "originalTopic": "Blade Templates",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "7",
    "moduleSlug": "laravel-fundamentals",
    "title": "Creating Middleware",
    "order": 7,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Middleware.\n\nLearn how to create and register custom middleware in Laravel.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<?php\n// app/Http/Middleware/EnsureTokenIsValid.php\n\nnamespace App\\Http\\Middleware;\n\nuse Closure;\n\nclass EnsureTokenIsValid\n{\n    public function handle($request, Closure $next)\n    {\n        if ($request->input('token') !== 'my-secret-token') {\n            return redirect('home');\n        }\n\n        return $next($request);\n    }\n}",
      "explanation": "This example produces: Middleware created successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Creating Middleware",
        "description": "Apply the concepts from this lesson on Middleware",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Advanced",
    "tags": [
      "Middleware",
      "laravel"
    ],
    "legacy": {
      "originalId": 7,
      "originalTopic": "Middleware",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "8",
    "moduleSlug": "laravel-fundamentals",
    "title": "Registering Middleware",
    "order": 8,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Middleware.\n\nLearn how to register middleware in Laravel applications.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<?php\n// app/Http/Kernel.php\n\nprotected $routeMiddleware = [\n    // ...\n    'token' => \\App\\Http\\Middleware\\EnsureTokenIsValid::class,\n];\n\n// In routes\nRoute::get('/profile', function () {\n    //\n})->middleware('token');",
      "explanation": "This example produces: Middleware registered successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Registering Middleware",
        "description": "Apply the concepts from this lesson on Middleware",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Middleware",
      "laravel"
    ],
    "legacy": {
      "originalId": 8,
      "originalTopic": "Middleware",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "9",
    "moduleSlug": "laravel-fundamentals",
    "title": "Migrations",
    "order": 9,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Database.\n\nLearn how to create and run database migrations in Laravel.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<?php\n// Creating a migration\nphp artisan make:migration create_flights_table\n\n// Migration file\nSchema::create('flights', function (Blueprint $table) {\n    $table->id();\n    $table->string('name');\n    $table->text('description');\n    $table->timestamps();\n});",
      "explanation": "This example produces: Migration created and executed successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Migrations",
        "description": "Apply the concepts from this lesson on Database",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Database",
      "laravel"
    ],
    "legacy": {
      "originalId": 9,
      "originalTopic": "Database",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "10",
    "moduleSlug": "laravel-fundamentals",
    "title": "Seeding Data",
    "order": 10,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Database.\n\nLearn how to seed your database with test data in Laravel.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<?php\n// Creating a seeder\nphp artisan make:seeder UsersTableSeeder\n\n// In the seeder\npublic function run()\n{\n    DB::table('users')->insert([\n        'name' => Str::random(10),\n        'email' => Str::random(10).'@gmail.com',\n        'password' => Hash::make('password'),\n    ]);\n}",
      "explanation": "This example produces: Database seeded successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Seeding Data",
        "description": "Apply the concepts from this lesson on Database",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Database",
      "laravel"
    ],
    "legacy": {
      "originalId": 10,
      "originalTopic": "Database",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "11",
    "moduleSlug": "laravel-fundamentals",
    "title": "Laravel Breeze",
    "order": 11,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Authentication.\n\nLearn how to implement authentication using Laravel Breeze.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "// Install Laravel Breeze\ncomposer require laravel/breeze --dev\n\n// Install Breeze scaffolding\nphp artisan breeze:install\n\n// Run migrations\nphp artisan migrate",
      "explanation": "This example produces: Authentication scaffolding installed successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: Laravel Breeze",
        "description": "Apply the concepts from this lesson on Authentication",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Authentication",
      "laravel"
    ],
    "legacy": {
      "originalId": 11,
      "originalTopic": "Authentication",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "12",
    "moduleSlug": "laravel-fundamentals",
    "title": "API Authentication",
    "order": 12,
    "objectives": [
      "Implement practical solutions",
      "Build foundational understanding"
    ],
    "intro": "Welcome to this comprehensive lesson on Authentication.\n\nLearn how to authenticate API requests in Laravel.\n\nThroughout this lesson, you'll gain hands-on experience with practical implementations and real-world scenarios. We'll explore both the theoretical foundations and practical applications, ensuring you can immediately apply what you learn.\n\nThis lesson is designed to build upon previous concepts while introducing new techniques that will enhance your development skills. By the end, you'll have a solid understanding of the key principles and be ready to tackle more advanced topics.\n\nThe knowledge gained here will serve as a foundation for subsequent lessons and real-world projects.",
    "code": {
      "example": "<?php\n// In routes/api.php\n\nRoute::middleware('auth:sanctum')->get('/user', function (Request $request) {\n    return $request->user();\n});\n\n// In controller\npublic function index(Request $request)\n{\n    return $request->user();\n}",
      "explanation": "This example produces: API authentication configured successfully\n\nThe code demonstrates practical implementation techniques and shows how the concepts work in real scenarios. Pay attention to the structure and patterns used, as these represent industry best practices.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not following best practices",
        "solution": "Review documentation and community guidelines",
        "severity": "medium"
      },
      {
        "mistake": "Skipping error handling",
        "solution": "Implement proper error boundaries and validation",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Practice: API Authentication",
        "description": "Apply the concepts from this lesson on Authentication",
        "checkpoints": [
          "Understand the core concept",
          "Implement the example code",
          "Experiment with variations"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 25,
    "difficulty": "Intermediate",
    "tags": [
      "Authentication",
      "laravel"
    ],
    "legacy": {
      "originalId": 12,
      "originalTopic": "Authentication",
      "migrated": "2025-10-01T06:41:13.484Z"
    },
    "lastUpdated": "2025-10-01T06:41:13.484Z",
    "version": "1.0.0"
  },
  {
    "id": "13",
    "moduleSlug": "laravel-fundamentals",
    "title": "Form Validation",
    "order": 13,
    "objectives": [
      "Implement comprehensive form validation in Laravel applications",
      "Create custom validation rules and error handling",
      "Understand validation request classes and their benefits"
    ],
    "intro": "Form validation is a critical aspect of web application security and user experience in Laravel development. This comprehensive lesson will teach you how to implement robust validation systems that protect your application from malicious input while providing clear feedback to users.\n\nYou'll learn to use Laravel's powerful validation features, including built-in rules, custom validation logic, and validation request classes. We'll explore both server-side and client-side validation techniques, ensuring your applications maintain data integrity and security.\n\nBy mastering Laravel's validation system, you'll be able to create forms that handle edge cases gracefully, provide meaningful error messages, and maintain excellent user experience. This knowledge is essential for building production-ready applications that users can trust.\n\nThe validation techniques covered here will serve as the foundation for secure data handling in all your Laravel projects, from simple contact forms to complex multi-step registration processes.",
    "code": {
      "example": "<?php\n// In Controller\npublic function store(Request $request)\n{\n    $validated = $request->validate([\n        'name' => 'required|string|max:255',\n        'email' => 'required|email|unique:users',\n        'password' => 'required|min:8|confirmed',\n        'age' => 'required|integer|min:18|max:120',\n        'terms' => 'accepted'\n    ]);\n\n    User::create($validated);\n    return redirect()->route('users.index')->with('success', 'User created successfully');\n}\n\n// Form Request Class\nclass StoreUserRequest extends FormRequest\n{\n    public function rules()\n    {\n        return [\n            'name' => 'required|string|max:255',\n            'email' => 'required|email|unique:users,email',\n            'password' => 'required|min:8|regex:/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)/',\n        ];\n    }\n\n    public function messages()\n    {\n        return [\n            'password.regex' => 'Password must contain uppercase, lowercase, and numbers',\n        ];\n    }\n}",
      "explanation": "This example demonstrates comprehensive form validation including required fields, email validation, password confirmation, and custom validation rules. The FormRequest class provides organized validation logic with custom error messages, making the code more maintainable and reusable across different controllers.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not validating file uploads properly",
        "solution": "Always validate file types, sizes, and use secure upload handling",
        "severity": "high"
      },
      {
        "mistake": "Trusting client-side validation only",
        "solution": "Always implement server-side validation as the primary security measure",
        "severity": "high"
      },
      {
        "mistake": "Not providing clear error messages",
        "solution": "Create user-friendly validation messages that guide users to correct inputs",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build a User Registration Form",
        "description": "Create a complete user registration form with comprehensive validation including password strength, email uniqueness, and profile image upload validation",
        "checkpoints": [
          "Implement FormRequest class with all validation rules",
          "Add custom validation for password strength",
          "Create user-friendly error messages",
          "Test validation with various input scenarios"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 35,
    "difficulty": "Intermediate",
    "tags": [
      "Validation",
      "Forms",
      "Security",
      "Laravel"
    ],
    "legacy": {
      "originalId": 13,
      "originalTopic": "Form Validation",
      "migrated": "2025-01-27T10:15:00.000Z"
    },
    "lastUpdated": "2025-01-27T10:15:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "14",
    "moduleSlug": "laravel-fundamentals",
    "title": "Eloquent Relationships",
    "order": 14,
    "objectives": [
      "Master one-to-many and many-to-many relationships in Eloquent",
      "Implement efficient relationship queries with eager loading",
      "Understand pivot tables and relationship constraints"
    ],
    "intro": "Eloquent relationships are the backbone of database interactions in Laravel, enabling you to define and work with complex data structures efficiently. This lesson provides comprehensive coverage of Laravel's relationship system, from basic one-to-one connections to complex many-to-many associations.\n\nYou'll learn to design database schemas that reflect real-world relationships, implement efficient queries that avoid the N+1 problem, and leverage Laravel's powerful relationship features for clean, maintainable code. Understanding relationships is crucial for building scalable applications that handle complex data interactions.\n\nWe'll explore practical scenarios like user-post relationships, role-based permissions, and tagging systems. You'll discover how to optimize relationship queries, handle pivot table data, and implement relationship constraints that maintain data integrity.\n\nMastering Eloquent relationships will dramatically improve your ability to build sophisticated applications with clean, expressive code that accurately models complex business logic and data structures.",
    "code": {
      "example": "<?php\n// User Model (One-to-Many)\nclass User extends Model\n{\n    public function posts()\n    {\n        return $this->hasMany(Post::class);\n    }\n\n    public function roles()\n    {\n        return $this->belongsToMany(Role::class)->withPivot('assigned_at');\n    }\n}\n\n// Post Model\nclass Post extends Model\n{\n    public function user()\n    {\n        return $this->belongsTo(User::class);\n    }\n\n    public function tags()\n    {\n        return $this->belongsToMany(Tag::class);\n    }\n}\n\n// Efficient Relationship Queries\n$users = User::with(['posts', 'roles'])->get(); // Eager loading\n\n$userPosts = User::find(1)->posts()->where('published', true)->get();\n\n// Many-to-Many with Pivot Data\n$user->roles()->attach($roleId, ['assigned_at' => now()]);\n$user->roles()->wherePivot('assigned_at', '>', Carbon::yesterday())->get();",
      "explanation": "This example demonstrates the three main relationship types in Laravel: one-to-many (User-Posts), many-to-many (User-Roles), and many-to-many with pivot data (Posts-Tags). Eager loading prevents N+1 query problems, while pivot table methods enable complex relationship management.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "N+1 query problem when accessing relationships",
        "solution": "Use eager loading with with() method or lazy eager loading with load()",
        "severity": "high"
      },
      {
        "mistake": "Not defining inverse relationships",
        "solution": "Always define both sides of relationships for proper Eloquent functionality",
        "severity": "medium"
      },
      {
        "mistake": "Incorrectly naming foreign keys",
        "solution": "Follow Laravel conventions or explicitly specify `foreign key` names",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build a Blog System with Relationships",
        "description": "Create a complete blog system with Users, Posts, Categories, and Tags, implementing all relationship types and optimized queries",
        "checkpoints": [
          "Define all model relationships correctly",
          "Implement efficient queries with eager loading",
          "Create pivot table for post-tag relationships",
          "Build controllers that demonstrate relationship usage"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 40,
    "difficulty": "Intermediate",
    "tags": [
      "Eloquent",
      "Relationships",
      "Database",
      "ORM",
      "Laravel"
    ],
    "legacy": {
      "originalId": 14,
      "originalTopic": "Eloquent Relationships",
      "migrated": "2025-01-27T10:15:00.000Z"
    },
    "lastUpdated": "2025-01-27T10:15:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "15",
    "moduleSlug": "laravel-fundamentals",
    "title": "File Storage and Uploads",
    "order": 15,
    "objectives": [
      "Implement secure file upload handling in Laravel applications",
      "Configure and use different storage drivers (local, S3, etc.)",
      "Handle file validation, processing, and storage organization"
    ],
    "intro": "File storage and uploads are essential features in modern web applications, from user profile pictures to document management systems. This comprehensive lesson covers Laravel's powerful filesystem abstraction, enabling you to handle files securely and efficiently across different storage environments.\n\nYou'll learn to implement robust file upload systems that validate file types and sizes, process images, and organize files in logical directory structures. We'll explore Laravel's unified API for different storage drivers, making it easy to switch between local storage, cloud services like Amazon S3, and CDN integration.\n\nSecurity is paramount when handling user uploads, so we'll cover best practices for preventing malicious file uploads, implementing proper access controls, and sanitizing file names. You'll also learn to optimize file storage for performance and scalability.\n\nBy the end of this lesson, you'll be confident in building file management features that scale from simple personal projects to enterprise applications handling thousands of uploads daily.",
    "code": {
      "example": "<?php\n// File Upload Controller\nclass FileUploadController extends Controller\n{\n    public function store(Request $request)\n    {\n        $request->validate([\n            'avatar' => 'required|image|mimes:jpeg,png,jpg|max:2048',\n            'document' => 'required|file|mimes:pdf,doc,docx|max:10240'\n        ]);\n\n        // Store avatar with custom name\n        $avatarPath = $request->file('avatar')->store('avatars', 'public');\n        \n        // Store document on S3\n        $documentPath = $request->file('document')->store('documents', 's3');\n\n        // Save file info to database\n        UserFile::create([\n            'user_id' => auth()->id(),\n            'avatar_path' => $avatarPath,\n            'document_path' => $documentPath,\n            'original_name' => $request->file('document')->getClientOriginalName()\n        ]);\n\n        return back()->with('success', 'Files uploaded successfully');\n    }\n\n    public function download($fileId)\n    {\n        $file = UserFile::findOrFail($fileId);\n        \n        // Check permissions\n        $this->authorize('download', $file);\n        \n        return Storage::disk('s3')->download($file->document_path, $file->original_name);\n    }\n}\n\n// In config/filesystems.php\n'disks' => [\n    's3' => [\n        'driver' => 's3',\n        'key' => env('AWS_ACCESS_KEY_ID'),\n        'secret' => env('AWS_SECRET_ACCESS_KEY'),\n        'region' => env('AWS_DEFAULT_REGION'),\n        'bucket' => env('AWS_BUCKET'),\n    ],\n];",
      "explanation": "This example shows comprehensive file handling including validation, multiple storage drivers, organized directory structure, and secure download functionality. The code demonstrates both local and cloud storage integration with proper security measures.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not validating file types and sizes",
        "solution": "Always implement strict file validation to prevent security vulnerabilities",
        "severity": "high"
      },
      {
        "mistake": "Storing files in publicly accessible directories without access control",
        "solution": "Use Laravel's storage system with proper disk configuration and authorization",
        "severity": "high"
      },
      {
        "mistake": "Not handling file upload errors gracefully",
        "solution": "Implement proper error handling and user feedback for upload failures",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build a Document Management System",
        "description": "Create a secure document upload and management system with different file types, access controls, and cloud storage integration",
        "checkpoints": [
          "Implement file upload with comprehensive validation",
          "Configure multiple storage drivers (local and cloud)",
          "Create access control for file downloads",
          "Build file organization and search functionality"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 45,
    "difficulty": "Intermediate",
    "tags": [
      "File Storage",
      "Uploads",
      "Security",
      "Cloud Storage",
      "Laravel"
    ],
    "legacy": {
      "originalId": 15,
      "originalTopic": "File Storage",
      "migrated": "2025-01-27T10:15:00.000Z"
    },
    "lastUpdated": "2025-01-27T10:15:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "16",
    "moduleSlug": "laravel-fundamentals",
    "title": "Laravel Artisan Commands",
    "order": 16,
    "objectives": [
      "Create custom Artisan commands for application automation",
      "Understand command scheduling and background task execution",
      "Implement command-line interfaces for administrative tasks"
    ],
    "intro": "Laravel's Artisan command-line interface is a powerful tool for automating tasks, managing your application, and creating custom administrative utilities. This lesson teaches you to harness Artisan's full potential by creating custom commands that streamline your development workflow and application maintenance.\n\nYou'll learn to build sophisticated command-line tools that can process data, generate reports, perform maintenance tasks, and integrate with external systems. We'll explore command arguments, options, interactive prompts, and progress indicators that create professional command-line experiences.\n\nCommand scheduling is another crucial aspect we'll cover, enabling you to automate repetitive tasks like data backups, email notifications, and system cleanups. You'll discover how to create robust, error-resistant commands that handle edge cases and provide detailed logging.\n\nMastering Artisan commands will significantly improve your productivity and enable you to build applications with powerful administrative capabilities that can be automated and scheduled for optimal performance.",
    "code": {
      "example": "<?php\n// Creating a custom command\nphp artisan make:command ProcessUserData\n\n// In app/Console/Commands/ProcessUserData.php\nclass ProcessUserData extends Command\n{\n    protected $signature = 'users:process {--inactive : Process only inactive users} {--limit=100 : Limit number of users}';\n    protected $description = 'Process user data and generate reports';\n\n    public function handle()\n    {\n        $limit = $this->option('limit');\n        $onlyInactive = $this->option('inactive');\n        \n        $query = User::query();\n        if ($onlyInactive) {\n            $query->where('last_login_at', '<', now()->subDays(30));\n        }\n        \n        $users = $query->limit($limit)->get();\n        \n        $this->info(\"Processing {$users->count()} users...\");\n        \n        $bar = $this->output->createProgressBar($users->count());\n        $bar->start();\n        \n        foreach ($users as $user) {\n            // Process user data\n            $this->processUserData($user);\n            $bar->advance();\n        }\n        \n        $bar->finish();\n        $this->newLine();\n        $this->info('User processing completed successfully!');\n        \n        return Command::SUCCESS;\n    }\n    \n    private function processUserData(User $user)\n    {\n        // Simulate data processing\n        sleep(1);\n        \n        // Log processing\n        $this->line(\"Processed user: {$user->email}\");\n    }\n}\n\n// In app/Console/Kernel.php - Scheduling\nprotected function schedule(Schedule $schedule)\n{\n    $schedule->command('users:process --inactive')\n             ->daily()\n             ->at('02:00')\n             ->emailOutputTo('admin@example.com');\n             \n    $schedule->command('backup:run')\n             ->weekly()\n             ->sundays()\n             ->at('01:00');\n}",
      "explanation": "This example demonstrates a comprehensive custom Artisan command with options, arguments, progress bars, and interactive output. The command includes scheduling configuration for automated execution, showing how to build professional command-line tools for application management.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not handling command failures gracefully",
        "solution": "Implement proper error handling and return appropriate exit codes",
        "severity": "medium"
      },
      {
        "mistake": "Creating commands that consume too much memory",
        "solution": "Use chunking and proper memory management for large data processing",
        "severity": "medium"
      },
      {
        "mistake": "Not providing clear command documentation",
        "solution": "Write descriptive command descriptions and use meaningful argument names",
        "severity": "low"
      }
    ],
    "exercises": [
      {
        "title": "Build a Data Export Command",
        "description": "Create a comprehensive data export command that can export different data types with various format options and scheduling capabilities",
        "checkpoints": [
          "Create command with multiple options and arguments",
          "Implement progress tracking and user feedback",
          "Add error handling and logging",
          "Configure command scheduling for automated exports"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 35,
    "difficulty": "Intermediate",
    "tags": [
      "Artisan",
      "Commands",
      "Automation",
      "CLI",
      "Laravel"
    ],
    "legacy": {
      "originalId": 16,
      "originalTopic": "Artisan Commands",
      "migrated": "2025-01-27T10:15:00.000Z"
    },
    "lastUpdated": "2025-01-27T10:15:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "17",
    "moduleSlug": "laravel-fundamentals",
    "title": "Advanced Eloquent Relationships",
    "order": 17,
    "objectives": [
      "Master polymorphic relationships in Eloquent ORM",
      "Implement relationship constraints and custom relationship methods",
      "Utilize relationship existence and absence queries effectively",
      "Optimize complex relationship queries with advanced eager loading"
    ],
    "intro": "Advanced Eloquent relationships in Laravel provide powerful mechanisms for modeling complex data associations that go beyond basic one-to-many and many-to-many relationships. This comprehensive lesson explores sophisticated relationship patterns including polymorphic relationships, custom relationship methods, and advanced querying techniques that enable you to build highly flexible and efficient data models.\n\nYou'll learn to implement polymorphic relationships that allow a model to belong to more than one other model on a single association, creating versatile data structures for scenarios like media attachments, comments systems, and activity logs. We'll also explore custom relationship methods that extend Laravel's built-in relationships with domain-specific logic.\n\nAdvanced querying techniques covered include relationship existence and absence queries that enable complex filtering based on related model conditions, and sophisticated eager loading strategies that optimize performance for deeply nested relationships. These techniques are essential for building high-performance applications with complex data requirements.\n\nBy mastering advanced Eloquent relationships, you'll be able to create data models that accurately represent complex business domains while maintaining optimal performance and code maintainability. This knowledge is crucial for senior Laravel developers working on enterprise applications with intricate data relationships.",
    "code": {
      "example": "<?php\n// Polymorphic Relationships\n// Models\n\nclass Photo extends Model\n{\n    public function imageable()\n    {\n        return $this->morphTo();\n    }\n}\n\nclass User extends Model\n{\n    public function photos()\n    {\n        return $this->morphMany(Photo::class, 'imageable');\n    }\n}\n\nclass Post extends Model\n{\n    public function photos()\n    {\n        return $this->morphMany(Photo::class, 'imageable');\n    }\n}\n\n// Usage\n$user = User::find(1);\n$user->photos()->create(['path' => 'user-avatar.jpg']);\n\n$post = Post::find(1);\n$post->photos()->create(['path' => 'post-image.jpg']);\n\n// Querying Polymorphic Relationships\n$photos = Photo::with('imageable')->get();\n\n// Custom Relationship Methods\nclass User extends Model\n{\n    public function posts()\n    {\n        return $this->hasMany(Post::class);\n    }\n    \n    public function publishedPosts()\n    {\n        return $this->posts()->where('status', 'published');\n    }\n    \n    public function recentPosts($limit = 5)\n    {\n        return $this->posts()->latest()->limit($limit);\n    }\n}\n\n// Relationship Existence Queries\n$users = User::has('posts')->get();\n$users = User::has('posts', '>=', 3)->get();\n$users = User::whereHas('posts', function ($query) {\n    $query->where('status', 'published');\n})->get();\n\n// Advanced Eager Loading\n$users = User::with([\n    'posts' => function ($query) {\n        $query->where('status', 'published')\n              ->withCount('comments')\n              ->orderBy('created_at', 'desc');\n    }\n])->get();",
      "explanation": "This example demonstrates advanced Eloquent relationship patterns including polymorphic relationships that allow a single model to belong to multiple types of parent models, custom relationship methods that add domain-specific constraints, relationship existence queries for complex filtering, and advanced eager loading techniques for performance optimization. These patterns enable sophisticated data modeling while maintaining clean, expressive code.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Overusing polymorphic relationships when simpler relationships would suffice",
        "solution": "Use polymorphic relationships only when you truly need a model to belong to multiple types of parent models",
        "severity": "medium"
      },
      {
        "mistake": "Not properly constraining eager loaded relationships leading to N+1 query problems",
        "solution": "Always apply appropriate constraints in eager loading callbacks and use relationship existence queries when filtering",
        "severity": "high"
      },
      {
        "mistake": "Creating overly complex custom relationship methods that are difficult to maintain",
        "solution": "Keep custom relationship methods focused and well-documented, following the single responsibility principle",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build a Content Management System with Polymorphic Relationships",
        "description": "Create a flexible CMS that supports comments on multiple content types (posts, pages, media) using polymorphic relationships, implement custom relationship methods for content filtering, and optimize queries with advanced eager loading",
        "checkpoints": [
          "Implement polymorphic comments system for posts, pages, and media",
          "Create custom relationship methods for content status filtering",
          "Optimize content queries with constrained eager loading",
          "Add relationship existence queries for content statistics"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 45,
    "difficulty": "Advanced",
    "tags": [
      "Eloquent",
      "Relationships",
      "Polymorphic",
      "Database",
      "ORM",
      "Laravel"
    ],
    "lastUpdated": "2025-10-03T00:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "18",
    "moduleSlug": "laravel-fundamentals",
    "title": "API Development with Sanctum and Passport",
    "order": 18,
    "objectives": [
      "Implement RESTful API authentication with Laravel Sanctum",
      "Create secure API endpoints with token-based authentication",
      "Build comprehensive API resource controllers and request validation",
      "Implement API rate limiting and CORS configuration"
    ],
    "intro": "API development is a cornerstone of modern web applications, enabling seamless integration between frontend applications, mobile apps, and third-party services. This comprehensive lesson covers Laravel's powerful tools for building secure, scalable APIs including Sanctum for simple token-based authentication and Passport for full OAuth2 implementation.\n\nYou'll learn to implement RESTful API design principles with proper HTTP status codes, resource representations, and error handling. We'll explore both Sanctum for first-party API authentication and Passport for complex OAuth2 scenarios, helping you choose the right tool for your specific use case.\n\nSecurity is paramount in API development, so we'll cover best practices for token management, rate limiting to prevent abuse, CORS configuration for cross-origin requests, and request validation to ensure data integrity. You'll also learn to implement comprehensive API documentation and testing strategies.\n\nBy mastering API development with Laravel, you'll be able to build robust backend services that power modern applications while maintaining security, performance, and scalability. This knowledge is essential for full-stack developers and backend specialists working on distributed systems.",
    "code": {
      "example": "<?php\n// Sanctum API Authentication\n\n// In config/sanctum.php\n'stateful' => explode(',', env('SANCTUM_STATEFUL_DOMAINS', sprintf(\n    '%s%s',\n    'localhost,localhost:3000,127.0.0.1,127.0.0.1:8000,::1',\n    env('APP_URL') ? ','.parse_url(env('APP_URL'), PHP_URL_HOST) : ''\n))),\n\n// In routes/api.php\nuse App\\Http\\Controllers\\Api\\PostController;\n\nRoute::middleware('auth:sanctum')->group(function () {\n    Route::apiResource('posts', PostController::class);\n    Route::post('/posts/{post}/publish', [PostController::class, 'publish']);\n});\n\n// In App\\Http\\Controllers\\Api\\PostController.php\nclass PostController extends Controller\n{\n    public function index(Request $request)\n    {\n        $posts = $request->user()->posts()\n            ->with('tags')\n            ->paginate(15);\n        \n        return PostResource::collection($posts);\n    }\n    \n    public function store(StorePostRequest $request)\n    {\n        $post = $request->user()->posts()->create($request->validated());\n        \n        return new PostResource($post);\n    }\n    \n    public function show(Post $post)\n    {\n        $this->authorize('view', $post);\n        \n        return new PostResource($post->load('tags', 'comments'));\n    }\n}\n\n// In App\\Http\\Requests\\StorePostRequest.php\nclass StorePostRequest extends FormRequest\n{\n    public function authorize()\n    {\n        return true; // Sanctum handles authentication\n    }\n    \n    public function rules()\n    {\n        return [\n            'title' => 'required|string|max:255',\n            'content' => 'required|string',\n            'status' => 'required|in:draft,published,archived',\n            'tags' => 'array',\n            'tags.*' => 'exists:tags,id',\n        ];\n    }\n}\n\n// In App\\Http\\Resources\\PostResource.php\nclass PostResource extends JsonResource\n{\n    public function toArray($request)\n    {\n        return [\n            'id' => $this->id,\n            'title' => $this->title,\n            'content' => $this->content,\n            'status' => $this->status,\n            'created_at' => $this->created_at->toIso8601String(),\n            'updated_at' => $this->updated_at->toIso8601String(),\n            'tags' => TagResource::collection($this->whenLoaded('tags')),\n            'comments_count' => $this->whenCounted('comments'),\n        ];\n    }\n}\n\n// In App\\Models\\User.php\nclass User extends Authenticatable\n{\n    use HasApiTokens;\n    \n    public function posts()\n    {\n        return $this->hasMany(Post::class);\n    }\n}\n\n// Client-side usage with JavaScript\n/*\n// Login and get CSRF cookie\nawait fetch('/sanctum/csrf-cookie');\n\n// Login\nconst loginResponse = await fetch('/login', {\n    method: 'POST',\n    headers: {\n        'Content-Type': 'application/json',\n        'X-Requested-With': 'XMLHttpRequest',\n    },\n    body: JSON.stringify({\n        email: 'user@example.com',\n        password: 'password',\n    }),\n});\n\n// Make authenticated API request\nconst postsResponse = await fetch('/api/posts', {\n    headers: {\n        'Authorization': `Bearer ${token}`,\n        'Content-Type': 'application/json',\n    },\n});\n*/",
      "explanation": "This example demonstrates comprehensive API development with Laravel Sanctum including token-based authentication, RESTful resource controllers, form request validation, and API resource responses. The code shows proper API structure with authentication middleware, resource collections, and client-side usage patterns for JavaScript applications.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Not properly configuring CORS for API requests from frontend applications",
        "solution": "Configure CORS middleware correctly in config/cors.php and ensure frontend and backend domains are properly configured",
        "severity": "high"
      },
      {
        "mistake": "Exposing sensitive user information in API responses",
        "solution": "Use API resources to carefully control which attributes are exposed and implement proper authorization checks",
        "severity": "high"
      },
      {
        "mistake": "Not implementing proper rate limiting for API endpoints",
        "solution": "Configure rate limiting in RouteServiceProvider and apply appropriate middleware to API routes",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Build a Complete Blogging API with Authentication",
        "description": "Create a full-featured blogging API with user authentication using Sanctum, implement CRUD operations for posts with proper validation, add API resource responses, configure rate limiting and CORS, and test API endpoints with a frontend client",
        "checkpoints": [
          "Implement Sanctum authentication with token management",
          "Create RESTful API controllers with proper request validation",
          "Build API resources for consistent JSON responses",
          "Configure rate limiting and CORS for API security",
          "Test API with a JavaScript frontend client"
        ]
      }
    ],
    "next": [],
    "estimatedMinutes": 50,
    "difficulty": "Advanced",
    "tags": [
      "API",
      "Sanctum",
      "Passport",
      "Authentication",
      "REST",
      "Laravel"
    ],
    "lastUpdated": "2025-10-03T00:00:00.000Z",
    "version": "1.0.0"
  },
  {
    "id": "19",
    "moduleSlug": "laravel-fundamentals",
    "title": "Advanced Testing Strategies with Pest and PHPUnit",
    "order": 19,
    "objectives": [
      "Master advanced testing patterns with Pest and PHPUnit",
      "Implement comprehensive test coverage for Laravel applications",
      "Create effective mocking strategies for complex dependencies",
      "Optimize test performance and maintainability"
    ],
    "intro": "Advanced testing strategies in Laravel applications go beyond basic unit testing to encompass comprehensive coverage of complex application logic, database interactions, and integration scenarios. This comprehensive lesson explores sophisticated testing techniques that ensure application reliability and maintainability at scale.\n\nYou'll learn to implement advanced testing patterns with both Pest and PHPUnit, create effective mocking strategies for complex dependencies like external APIs and services, and optimize test performance and maintainability through proper organization and database management. We'll explore advanced patterns for testing Eloquent models, HTTP controllers, console commands, and event broadcasting.\n\nThe lesson covers practical implementation strategies for organizing large test suites, implementing proper test data management with factories and seeders, and creating tests that provide meaningful coverage while remaining maintainable. You'll discover how to balance test coverage with development velocity, implement proper continuous integration testing, and optimize tests for performance.\n\nBy mastering advanced testing strategies, you'll be able to create Laravel applications with high confidence in their correctness and reliability, enabling faster development cycles and reduced bug rates.",
    "code": {
      "example": "<?php\n// Advanced Testing Strategies with Pest and PHPUnit\n\n// Pest test examples\n// tests/Feature/UserRegistrationTest.php\n\nuse App\\Models\\User;\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse Illuminate\\Support\\Facades\\Event;\nuse Illuminate\\Support\\Facades\\Http;\nuse Illuminate\\Support\\Facades\\Mail;\nuse Illuminate\\Support\\Facades\\Notification;\nuse function Pest\\Laravel\\postJson;\nuse function Pest\\Laravel\\assertDatabaseHas;\nuse function Pest\\Laravel\\assertDatabaseMissing;\nuse Tests\\TestCase;\n\ndescribe('User Registration', function () {\n    uses(RefreshDatabase::class);\n    \n    beforeEach(function () {\n        // Mock external service\n        Http::fake([\n            'api.payment-provider.com/*' => Http::response(['status' => 'success'], 200),\n        ]);\n        \n        // Prevent actual emails\n        Mail::fake();\n        Notification::fake();\n        Event::fake();\n    });\n    \n    it('registers a new user successfully', function () {\n        $response = postJson('/api/register', [\n            'name' => 'John Doe',\n            'email' => 'john@example.com',\n            'password' => 'password123',\n            'password_confirmation' => 'password123',\n        ]);\n        \n        $response->assertStatus(201)\n                 ->assertJsonStructure([\n                     'user' => ['id', 'name', 'email'],\n                     'token'\n                 ]);\n        \n        assertDatabaseHas('users', [\n            'name' => 'John Doe',\n            'email' => 'john@example.com'\n        ]);\n        \n        // Assert emails were sent\n        Mail::assertSent(\\App\\Mail\\WelcomeEmail::class);\n        \n        // Assert notifications were sent\n        Notification::assertSentTo(\n            User::where('email', 'john@example.com')->first(),\n            \\App\\Notifications\\WelcomeNotification::class\n        );\n    });\n    \n    it('prevents duplicate email registration', function () {\n        // Create existing user\n        User::factory()->create([\n            'email' => 'john@example.com'\n        ]);\n        \n        $response = postJson('/api/register', [\n            'name' => 'Jane Doe',\n            'email' => 'john@example.com',\n            'password' => 'password123',\n            'password_confirmation' => 'password123',\n        ]);\n        \n        $response->assertStatus(422)\n                 ->assertJsonValidationErrors(['email']);\n        \n        // Assert only one user exists\n        expect(User::where('email', 'john@example.com')->count())->toBe(1);\n    });\n    \n    it('validates required fields', function (string $field) {\n        $data = [\n            'name' => 'John Doe',\n            'email' => 'john@example.com',\n            'password' => 'password123',\n            'password_confirmation' => 'password123',\n        ];\n        \n        unset($data[$field]);\n        \n        $response = postJson('/api/register', $data);\n        \n        $response->assertStatus(422)\n                 ->assertJsonValidationErrors([$field]);\n    })->with([\n        'name',\n        'email',\n        'password',\n    ]);\n    \n    it('validates password confirmation', function () {\n        $response = postJson('/api/register', [\n            'name' => 'John Doe',\n            'email' => 'john@example.com',\n            'password' => 'password123',\n            'password_confirmation' => 'different123',\n        ]);\n        \n        $response->assertStatus(422)\n                 ->assertJsonValidationErrors(['password']);\n    });\n    \n    it('handles external service failures gracefully', function () {\n        // Mock external service failure\n        Http::fake([\n            'api.payment-provider.com/*' => Http::response(['error' => 'Service unavailable'], 503),\n        ]);\n        \n        $response = postJson('/api/register', [\n            'name' => 'John Doe',\n            'email' => 'john@example.com',\n            'password' => 'password123',\n            'password_confirmation' => 'password123',\n        ]);\n        \n        $response->assertStatus(503);\n        \n        // Assert user was not created due to external service failure\n        assertDatabaseMissing('users', [\n            'email' => 'john@example.com'\n        ]);\n    });\n});\n\n// Advanced Unit Testing with PHPUnit\n// tests/Unit/Services/UserServiceTest.php\n\nuse App\\Models\\User;\nuse App\\Services\\UserService;\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse Illuminate\\Support\\Facades\\Http;\nuse Mockery;\nuse Tests\\TestCase;\n\nclass UserServiceTest extends TestCase\n{\n    use RefreshDatabase;\n    \n    protected UserService $userService;\n    protected $mockPaymentService;\n    \n    protected function setUp(): void\n    {\n        parent::setUp();\n        \n        // Create mock for external service\n        $this->mockPaymentService = Mockery::mock('App\\Services\\PaymentService');\n        $this->app->instance('App\\Services\\PaymentService', $this->mockPaymentService);\n        \n        $this->userService = new UserService();\n    }\n    \n    protected function tearDown(): void\n    {\n        Mockery::close();\n        parent::tearDown();\n    }\n    \n    /**\n     * @test\n     */\n    public function it_creates_user_with_subscription()\n    {\n        // Arrange\n        $userData = [\n            'name' => 'John Doe',\n            'email' => 'john@example.com',\n            'password' => 'password123',\n        ];\n        \n        $this->mockPaymentService\n             ->shouldReceive('createSubscription')\n             ->once()\n             ->with(Mockery::type(User::class), 'premium')\n             ->andReturn(['subscription_id' => 'sub_123']);\n        \n        // Act\n        $user = $this->userService->createUserWithSubscription($userData, 'premium');\n        \n        // Assert\n        $this->assertInstanceOf(User::class, $user);\n        $this->assertEquals('john@example.com', $user->email);\n        $this->assertDatabaseHas('users', [\n            'email' => 'john@example.com',\n            'subscription_id' => 'sub_123'\n        ]);\n    }\n    \n    /**\n     * @test\n     */\n    public function it_handles_payment_service_exceptions()\n    {\n        // Arrange\n        $userData = [\n            'name' => 'John Doe',\n            'email' => 'john@example.com',\n            'password' => 'password123',\n        ];\n        \n        $this->mockPaymentService\n             ->shouldReceive('createSubscription')\n             ->once()\n             ->with(Mockery::type(User::class), 'premium')\n             ->andThrow(new \\Exception('Payment service unavailable'));\n        \n        // Act & Assert\n        $this->expectException(\\Exception::class);\n        $this->expectExceptionMessage('Payment service unavailable');\n        \n        $this->userService->createUserWithSubscription($userData, 'premium');\n        \n        // Assert user was not created due to exception\n        $this->assertDatabaseMissing('users', [\n            'email' => 'john@example.com'\n        ]);\n    }\n    \n    /**\n     * @test\n     * @dataProvider userRoleDataProvider\n     */\n    public function it_assigns_correct_permissions_based_on_role($role, $expectedPermissions)\n    {\n        // Arrange\n        $user = User::factory()->create(['role' => $role]);\n        \n        // Act\n        $permissions = $this->userService->getUserPermissions($user);\n        \n        // Assert\n        $this->assertEquals($expectedPermissions, $permissions);\n    }\n    \n    public function userRoleDataProvider()\n    {\n        return [\n            ['admin', ['create', 'read', 'update', 'delete']],\n            ['editor', ['create', 'read', 'update']],\n            ['user', ['read']],\n        ];\n    }\n}\n\n// Database Testing with Factories and Seeders\n// tests/Feature/PostManagementTest.php\n\nuse App\\Models\\Post;\nuse App\\Models\\User;\nuse Illuminate\\Foundation\\Testing\\RefreshDatabase;\nuse function Pest\\Laravel\\get;\nuse function Pest\\Laravel\\post;\nuse function Pest\\Laravel\\put;\nuse function Pest\\Laravel\\delete;\nuse Tests\\TestCase;\n\ndescribe('Post Management', function () {\n    uses(RefreshDatabase::class, TestCase::class);\n    \n    let('author', fn() => User::factory()->create());\n    let('admin', fn() => User::factory()->admin()->create());\n    \n    beforeEach(function () {\n        // Create posts using factories\n        Post::factory()\n            ->count(10)\n            ->sequence(\n                ['status' => 'draft'],\n                ['status' => 'published'],\n            )\n            ->create();\n    });\n    \n    it('lists published posts for guests', function () {\n        $response = get('/api/posts');\n        \n        $response->assertStatus(200)\n                 ->assertJsonCount(5, 'data') // Only published posts\n                 ->assertJsonStructure([\n                     'data' => [\n                         '*' => ['id', 'title', 'excerpt', 'published_at']\n                     ]\n                 ]);\n    });\n    \n    it('lists all posts for admin', function () {\n        $response = get('/api/posts')\n            ->actingAs($this->admin);\n        \n        $response->assertStatus(200)\n                 ->assertJsonCount(10, 'data') // All posts\n                 ->assertJsonStructure([\n                     'data' => [\n                         '*' => ['id', 'title', 'status', 'created_at']\n                     ]\n                 ]);\n    });\n    \n    it('allows author to update their own post', function () {\n        $post = Post::factory()->for($this->author)->create();\n        \n        $response = put(\"/api/posts/{$post->id}\", [\n            'title' => 'Updated Title',\n            'content' => 'Updated content',\n        ])->actingAs($this->author);\n        \n        $response->assertStatus(200);\n        $this->assertDatabaseHas('posts', [\n            'id' => $post->id,\n            'title' => 'Updated Title',\n        ]);\n    });\n    \n    it('prevents user from updating others posts', function () {\n        $otherUser = User::factory()->create();\n        $post = Post::factory()->for($this->author)->create();\n        \n        $response = put(\"/api/posts/{$post->id}\", [\n            'title' => 'Hacked Title',\n        ])->actingAs($otherUser);\n        \n        $response->assertStatus(403);\n        $this->assertDatabaseMissing('posts', [\n            'id' => $post->id,\n            'title' => 'Hacked Title',\n        ]);\n    });\n});",
      "explanation": "This example demonstrates advanced Laravel testing strategies including:\n\n1. Comprehensive feature testing with Pest for API endpoints\n2. Advanced unit testing with PHPUnit and Mockery\n3. Database testing with factories and proper data setup\n4. Mocking external services and dependencies\n5. Testing validation and error conditions\n6. Testing authorization and permission systems\n7. Data provider patterns for testing multiple scenarios\n8. Proper test organization and setup/teardown patterns\n\nThese patterns enable developers to create comprehensive test suites that provide high confidence in application correctness while remaining maintainable and performant.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Creating tests that depend on database state from other tests",
        "solution": "Use database transactions and proper test isolation with RefreshDatabase trait",
        "severity": "high"
      },
      {
        "mistake": "Not testing edge cases and error conditions thoroughly",
        "solution": "Test validation errors, authorization failures, and external service failures",
        "severity": "high"
      },
      {
        "mistake": "Ignoring test performance which slows down development",
        "solution": "Use proper database seeding, mock external services, and optimize test data",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Comprehensive Laravel Testing",
        "description": "Create a complete testing suite with advanced patterns for feature, unit, and database tests",
        "checkpoints": [
          "Implement feature tests for API endpoints with proper validation",
          "Create unit tests with mocking for service classes",
          "Build database tests with factories and proper data setup",
          "Add tests for authorization and permission systems",
          "Implement proper error handling and edge case tests"
        ]
      }
    ],
    "next": [
      "laravel-lesson-20-queue-workers"
    ],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Testing",
      "Pest",
      "PHPUnit",
      "Database Testing",
      "Mocking",
      "Laravel"
    ],
    "lastUpdated": "2025-10-03T10:00:00Z",
    "version": "1.0.0"
  },
  {
    "id": "20",
    "moduleSlug": "laravel-fundamentals",
    "title": "Queue Workers and Job Processing",
    "order": 20,
    "objectives": [
      "Master Laravel's queue system for background job processing",
      "Implement reliable job handling with proper error management",
      "Create efficient queue workers with monitoring and optimization",
      "Design scalable job architectures for high-volume applications"
    ],
    "intro": "Queue workers and job processing in Laravel provide a robust foundation for handling time-intensive operations without blocking user requests, enabling applications to maintain responsiveness while processing complex tasks in the background. This comprehensive lesson explores advanced techniques for implementing reliable, scalable queue systems that can handle high volumes of jobs while maintaining system stability.\n\nYou'll learn to implement sophisticated job patterns that handle complex business logic, create reliable error handling and retry mechanisms, and optimize queue workers for performance and resource utilization. We'll explore advanced patterns for job chaining, batching, and rate limiting that enable sophisticated background processing workflows.\n\nThe lesson covers practical implementation strategies for monitoring queue performance, handling failed jobs effectively, and designing queue architectures that scale with application growth. You'll discover how to balance queue throughput with system resources, implement proper logging and alerting, and optimize jobs for different processing requirements.\n\nBy mastering queue workers and job processing, you'll be able to create Laravel applications that efficiently handle complex background operations while maintaining excellent user experience and system reliability.",
    "code": {
      "example": "<?php\n// Advanced Queue Workers and Job Processing\n\n// Complex Job Implementation\n// app/Jobs/ProcessUserReport.php\n\nnamespace App\\Jobs;\n\nuse App\\Models\\User;\nuse App\\Models\\Report;\nuse App\\Services\\ReportGenerator;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\Storage;\nuse Throwable;\n\nclass ProcessUserReport implements ShouldQueue\n{\n    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n    \n    public $tries = 3;\n    public $backoff = [1, 5, 10]; // Exponential backoff\n    public $timeout = 300; // 5 minutes\n    public $maxExceptions = 3;\n    \n    protected $userId;\n    protected $reportType;\n    protected $parameters;\n    \n    public function __construct($userId, $reportType, array $parameters = [])\n    {\n        $this->userId = $userId;\n        $this->reportType = $reportType;\n        $this->parameters = $parameters;\n        \n        // Set queue based on priority\n        $this->onQueue($this->determineQueue($reportType));\n        \n        // Set connection for critical reports\n        if ($this->isCriticalReport($reportType)) {\n            $this->onConnection('redis');\n        }\n    }\n    \n    public function handle(ReportGenerator $reportGenerator)\n    {\n        try {\n            Log::info('Starting report generation', [\n                'user_id' => $this->userId,\n                'report_type' => $this->reportType,\n                'job_id' => $this->job->getJobId()\n            ]);\n            \n            // Check if job should be cancelled\n            if ($this->job->isDeletedOrReleased()) {\n                return;\n            }\n            \n            // Get user\n            $user = User::find($this->userId);\n            if (!$user) {\n                $this->fail('User not found');\n                return;\n            }\n            \n            // Create report record\n            $report = Report::create([\n                'user_id' => $this->userId,\n                'type' => $this->reportType,\n                'status' => 'processing',\n                'parameters' => $this->parameters\n            ]);\n            \n            // Update progress\n            $this->updateProgress($report, 10);\n            \n            // Generate report data\n            $data = $reportGenerator->generate($this->reportType, $this->parameters);\n            \n            // Update progress\n            $this->updateProgress($report, 70);\n            \n            // Save report file\n            $filePath = $this->saveReportFile($report, $data);\n            \n            // Update progress\n            $this->updateProgress($report, 90);\n            \n            // Finalize report\n            $report->update([\n                'status' => 'completed',\n                'file_path' => $filePath,\n                'completed_at' => now()\n            ]);\n            \n            // Notify user\n            $user->notify(new \\App\\Notifications\\ReportCompleted($report));\n            \n            Log::info('Report generation completed', [\n                'report_id' => $report->id,\n                'user_id' => $this->userId\n            ]);\n            \n        } catch (Throwable $e) {\n            Log::error('Report generation failed', [\n                'user_id' => $this->userId,\n                'report_type' => $this->reportType,\n                'error' => $e->getMessage(),\n                'trace' => $e->getTraceAsString()\n            ]);\n            \n            // Update report status\n            if (isset($report)) {\n                $report->update([\n                    'status' => 'failed',\n                    'error_message' => $e->getMessage(),\n                    'failed_at' => now()\n                ]);\n            }\n            \n            // Re-throw to trigger retry mechanism\n            throw $e;\n        }\n    }\n    \n    public function updateProgress(Report $report, int $percentage)\n    {\n        $report->update(['progress' => $percentage]);\n        \n        // Broadcast progress update\n        broadcast(new \\App\\Events\\ReportProgressUpdated($report));\n    }\n    \n    public function saveReportFile(Report $report, array $data): string\n    {\n        $fileName = \"reports/{$report->id}_\" . time() . '.json';\n        Storage::put($fileName, json_encode($data, JSON_PRETTY_PRINT));\n        return $fileName;\n    }\n    \n    public function failed(Throwable $exception)\n    {\n        Log::error('Report job failed permanently', [\n            'user_id' => $this->userId,\n            'report_type' => $this->reportType,\n            'error' => $exception->getMessage()\n        ]);\n        \n        // Update report status\n        Report::where('user_id', $this->userId)\n              ->where('type', $this->reportType)\n              ->where('status', 'processing')\n              ->update([\n                  'status' => 'failed',\n                  'error_message' => $exception->getMessage(),\n                  'failed_at' => now()\n              ]);\n        \n        // Notify user of failure\n        $user = User::find($this->userId);\n        if ($user) {\n            $user->notify(new \\App\\Notifications\\ReportFailed($this->reportType));\n        }\n    }\n    \n    protected function determineQueue(string $reportType): string\n    {\n        return match($reportType) {\n            'financial', 'compliance' => 'high-priority',\n            'analytics', 'statistics' => 'low-priority',\n            default => 'default'\n        };\n    }\n    \n    protected function isCriticalReport(string $reportType): bool\n    {\n        return in_array($reportType, ['financial', 'compliance']);\n    }\n}\n\n// Job Chaining Example\n// app/Jobs/ProcessOrder.php\n\nnamespace App\\Jobs;\n\nuse App\\Models\\Order;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass ProcessOrder implements ShouldQueue\n{\n    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n    \n    protected $orderId;\n    \n    public function __construct($orderId)\n    {\n        $this->orderId = $orderId;\n    }\n    \n    public function handle()\n    {\n        $order = Order::find($this->orderId);\n        if (!$order) {\n            $this->fail('Order not found');\n            return;\n        }\n        \n        // Process payment\n        ProcessPayment::withChain([\n            new UpdateInventory($order->id),\n            new SendConfirmationEmail($order->id),\n            new UpdateAnalytics($order->id)\n        ])->dispatch($order->id);\n        \n        Log::info('Order processing chain initiated', ['order_id' => $order->id]);\n    }\n}\n\n// Batch Job Processing\n// app/Jobs/ImportUsers.php\n\nnamespace App\\Jobs;\n\nuse App\\Models\\User;\nuse Illuminate\\Bus\\Batchable;\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Support\\Collection;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass ImportUsers implements ShouldQueue\n{\n    use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n    \n    protected Collection $users;\n    \n    public function __construct(Collection $users)\n    {\n        $this->users = $users;\n    }\n    \n    public function handle()\n    {\n        if ($this->batch()->cancelled()) {\n            return;\n        }\n        \n        foreach ($this->users as $userData) {\n            if ($this->batch()->cancelled()) {\n                return;\n            }\n            \n            try {\n                User::create($userData);\n                $this->batch()->incrementProgress();\n            } catch (\\Exception $e) {\n                Log::error('User import failed', [\n                    'data' => $userData,\n                    'error' => $e->getMessage()\n                ]);\n                \n                $this->batch()->recordFailedJob($this->job->getJobId(), $e);\n            }\n        }\n    }\n    \n    public function failed(\\Throwable $e)\n    {\n        Log::error('Batch job failed', [\n            'error' => $e->getMessage(),\n            'batch_id' => $this->batch()->id\n        ]);\n    }\n}\n\n// Controller to dispatch jobs\n// app/Http/Controllers/ReportController.php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Jobs\\ProcessUserReport;\nuse App\\Models\\Report;\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\Bus;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass ReportController extends Controller\n{\n    public function generate(Request $request)\n    {\n        $request->validate([\n            'type' => 'required|string',\n            'parameters' => 'array'\n        ]);\n        \n        // Dispatch job\n        $job = new ProcessUserReport(\n            auth()->id(),\n            $request->type,\n            $request->parameters ?? []\n        );\n        \n        // Add delay for non-critical reports\n        if (!in_array($request->type, ['financial', 'compliance'])) {\n            $job->delay(now()->addMinutes(5));\n        }\n        \n        dispatch($job);\n        \n        // Create initial report record for tracking\n        $report = Report::create([\n            'user_id' => auth()->id(),\n            'type' => $request->type,\n            'status' => 'queued',\n            'parameters' => $request->parameters\n        ]);\n        \n        return response()->json([\n            'message' => 'Report generation started',\n            'report_id' => $report->id\n        ], 202);\n    }\n    \n    public function batchImport(Request $request)\n    {\n        $request->validate([\n            'users' => 'required|array',\n            'users.*.email' => 'required|email',\n            'users.*.name' => 'required|string'\n        ]);\n        \n        $userChunks = collect($request->users)->chunk(100);\n        \n        $batch = Bus::batch([])->dispatch();\n        \n        foreach ($userChunks as $chunk) {\n            $batch->add(new \\App\\Jobs\\ImportUsers($chunk));\n        }\n        \n        return response()->json([\n            'message' => 'Batch import started',\n            'batch_id' => $batch->id\n        ], 202);\n    }\n}\n\n// Queue monitoring and optimization\n// app/Console/Commands/MonitorQueues.php\n\nnamespace App\\Console\\Commands;\n\nuse Illuminate\\Console\\Command;\nuse Illuminate\\Support\\Facades\\Redis;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass MonitorQueues extends Command\n{\n    protected $signature = 'queue:monitor';\n    protected $description = 'Monitor queue performance and alert on issues';\n    \n    public function handle()\n    {\n        $queues = ['default', 'high-priority', 'low-priority'];\n        \n        foreach ($queues as $queue) {\n            $pendingJobs = Redis::llen(\"queues:{$queue}\");\n            $failedJobs = \\App\\Models\\FailedJob::where('queue', $queue)\n                                              ->where('failed_at', '>', now()->subHour())\n                                              ->count();\n            \n            // Alert if queue is backing up\n            if ($pendingJobs > 1000) {\n                Log::warning(\"Queue {$queue} has {$pendingJobs} pending jobs\");\n                // Send alert to monitoring system\n            }\n            \n            // Alert on high failure rate\n            if ($failedJobs > 50) {\n                Log::critical(\"High failure rate in queue {$queue}: {$failedJobs} failures in last hour\");\n                // Send critical alert\n            }\n            \n            $this->info(\"Queue {$queue}: {$pendingJobs} pending, {$failedJobs} failed (last hour)\");\n        }\n    }\n}",
      "explanation": "This example demonstrates advanced Laravel queue worker patterns including:\n\n1. Complex job implementation with proper error handling and retry mechanisms\n2. Job chaining for sequential processing workflows\n3. Batch job processing for handling large datasets\n4. Queue prioritization and connection management\n5. Progress tracking and real-time updates\n6. Comprehensive logging and monitoring\n7. Graceful failure handling and cleanup\n8. Performance optimization techniques\n\nThese patterns enable developers to create robust, scalable queue systems that can handle complex background processing requirements while maintaining system reliability and performance.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Creating jobs that are too large and take too long to process",
        "solution": "Break large jobs into smaller chunks, implement proper progress tracking, and use batch processing for large datasets",
        "severity": "high"
      },
      {
        "mistake": "Not implementing proper error handling and cleanup in jobs",
        "solution": "Use try-catch blocks, implement failed() method for cleanup, and ensure jobs can be safely retried",
        "severity": "high"
      },
      {
        "mistake": "Ignoring queue monitoring and performance optimization",
        "solution": "Implement queue monitoring, set appropriate timeouts, and optimize job processing for resource utilization",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Advanced Queue Processing System",
        "description": "Create a comprehensive queue system with job chaining, batching, and proper monitoring",
        "checkpoints": [
          "Implement complex jobs with proper error handling and retry mechanisms",
          "Create job chaining for sequential workflows",
          "Build batch processing for large datasets",
          "Add queue monitoring and alerting",
          "Implement progress tracking and real-time updates"
        ]
      }
    ],
    "next": [
      "laravel-lesson-21-event-broadcasting"
    ],
    "estimatedMinutes": 55,
    "difficulty": "Advanced",
    "tags": [
      "Queue",
      "Jobs",
      "Workers",
      "Background Processing",
      "Laravel"
    ],
    "lastUpdated": "2025-10-03T10:00:00Z",
    "version": "1.0.0"
  },
  {
    "id": "21",
    "moduleSlug": "laravel-fundamentals",
    "title": "Event Broadcasting and Real-Time Features",
    "order": 21,
    "objectives": [
      "Master Laravel's event broadcasting system for real-time applications",
      "Implement WebSocket connections with Laravel Echo and Pusher",
      "Create efficient event handling with proper serialization",
      "Design scalable real-time architectures for high-concurrency applications"
    ],
    "intro": "Event broadcasting and real-time features in Laravel provide powerful tools for creating dynamic, interactive applications that can instantly respond to server-side events and deliver real-time updates to users. This comprehensive lesson explores advanced techniques for implementing robust real-time systems that can handle high concurrency while maintaining excellent performance and reliability.\n\nYou'll learn to implement sophisticated event broadcasting patterns that efficiently deliver real-time updates to connected clients, create WebSocket connections with proper authentication and channel management, and optimize event handling for performance and resource utilization. We'll explore advanced patterns for presence channels, private channels, and event broadcasting to specific users or groups.\n\nThe lesson covers practical implementation strategies for monitoring real-time performance, handling connection failures gracefully, and designing event architectures that scale with application growth. You'll discover how to balance real-time functionality with system resources, implement proper logging and debugging, and optimize events for different use cases.\n\nBy mastering event broadcasting and real-time features, you'll be able to create Laravel applications that provide engaging, interactive user experiences with instant updates and real-time collaboration capabilities.",
    "code": {
      "example": "<?php\n// Advanced Event Broadcasting and Real-Time Features\n\n// Event Implementation with Broadcasting\n// app/Events/UserStatusChanged.php\n\nnamespace App\\Events;\n\nuse App\\Models\\User;\nuse Illuminate\\Broadcasting\\Channel;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Broadcasting\\PresenceChannel;\nuse Illuminate\\Broadcasting\\PrivateChannel;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass UserStatusChanged implements ShouldBroadcast\n{\n    use Dispatchable, InteractsWithSockets, SerializesModels;\n    \n    public $user;\n    public $status;\n    public $timestamp;\n    \n    public function __construct(User $user, string $status)\n    {\n        $this->user = $user;\n        $this->status = $status;\n        $this->timestamp = now();\n        \n        // Broadcast immediately without queueing\n        $this->connection = 'redis';\n        $this->queue = 'broadcasts';\n    }\n    \n    public function broadcastOn()\n    {\n        return new PrivateChannel('user.' . $this->user->id);\n    }\n    \n    public function broadcastWith()\n    {\n        return [\n            'user' => [\n                'id' => $this->user->id,\n                'name' => $this->user->name,\n                'avatar' => $this->user->avatar_url,\n            ],\n            'status' => $this->status,\n            'timestamp' => $this->timestamp->toIso8601String(),\n        ];\n    }\n    \n    public function broadcastAs()\n    {\n        return 'user.status.changed';\n    }\n}\n\n// Real-time Notification Event\n// app/Events/NotificationCreated.php\n\nnamespace App\\Events;\n\nuse App\\Models\\Notification;\nuse App\\Models\\User;\nuse Illuminate\\Broadcasting\\Channel;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Broadcasting\\PrivateChannel;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass NotificationCreated implements ShouldBroadcast\n{\n    use Dispatchable, InteractsWithSockets, SerializesModels;\n    \n    public $notification;\n    public $user;\n    \n    public function __construct(Notification $notification, User $user)\n    {\n        $this->notification = $notification;\n        $this->user = $user;\n    }\n    \n    public function broadcastOn()\n    {\n        return new PrivateChannel('App.Models.User.' . $this->user->id);\n    }\n    \n    public function broadcastWith()\n    {\n        return [\n            'id' => $this->notification->id,\n            'type' => $this->notification->type,\n            'data' => $this->notification->data,\n            'read_at' => $this->notification->read_at,\n            'created_at' => $this->notification->created_at->toIso8601String(),\n        ];\n    }\n    \n    public function broadcastAs()\n    {\n        return 'notification.created';\n    }\n}\n\n// Presence Channel Event\n// app/Events/UserJoinedRoom.php\n\nnamespace App\\Events;\n\nuse App\\Models\\User;\nuse App\\Models\\ChatRoom;\nuse Illuminate\\Broadcasting\\Channel;\nuse Illuminate\\Broadcasting\\InteractsWithSockets;\nuse Illuminate\\Broadcasting\\PresenceChannel;\nuse Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\nuse Illuminate\\Foundation\\Events\\Dispatchable;\nuse Illuminate\\Queue\\SerializesModels;\n\nclass UserJoinedRoom implements ShouldBroadcast\n{\n    use Dispatchable, InteractsWithSockets, SerializesModels;\n    \n    public $user;\n    public $room;\n    \n    public function __construct(User $user, ChatRoom $room)\n    {\n        $this->user = $user;\n        $this->room = $room;\n    }\n    \n    public function broadcastOn()\n    {\n        return new PresenceChannel('chat.room.' . $this->room->id);\n    }\n    \n    public function broadcastWith()\n    {\n        return [\n            'user' => [\n                'id' => $this->user->id,\n                'name' => $this->user->name,\n                'avatar' => $this->user->avatar_url,\n            ]\n        ];\n    }\n    \n    public function broadcastAs()\n    {\n        return 'user.joined';\n    }\n}\n\n// Event Listener with Real-Time Processing\n// app/Listeners/SendRealTimeNotification.php\n\nnamespace App\\Listeners;\n\nuse App\\Events\\OrderShipped;\nuse App\\Events\\NotificationCreated;\nuse App\\Models\\User;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Queue\\InteractsWithQueue;\n\nclass SendRealTimeNotification implements ShouldQueue\n{\n    use InteractsWithQueue;\n    \n    public $connection = 'redis';\n    public $queue = 'listeners';\n    public $delay = 0;\n    \n    public function handle(OrderShipped $event)\n    {\n        $user = $event->order->user;\n        \n        // Create database notification\n        $notification = $user->notifications()->create([\n            'type' => 'order_shipped',\n            'data' => [\n                'order_id' => $event->order->id,\n                'tracking_number' => $event->trackingNumber,\n            ],\n        ]);\n        \n        // Broadcast real-time notification\n        broadcast(new NotificationCreated($notification, $user));\n        \n        // Send push notification (if configured)\n        if ($user->push_notifications_enabled) {\n            // Send push notification via external service\n        }\n    }\n}\n\n// Controller for Real-Time Features\n// app/Http/Controllers/RealTimeController.php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Events\\UserStatusChanged;\nuse App\\Models\\User;\nuse Illuminate\\Http\\Request;\n\nclass RealTimeController extends Controller\n{\n    public function updateStatus(Request $request)\n    {\n        $request->validate([\n            'status' => 'required|string|in:online,away,busy,offline'\n        ]);\n        \n        $user = $request->user();\n        $user->update(['status' => $request->status]);\n        \n        // Broadcast status change\n        broadcast(new UserStatusChanged($user, $request->status));\n        \n        return response()->json([\n            'message' => 'Status updated',\n            'status' => $request->status\n        ]);\n    }\n    \n    public function joinRoom(Request $request, $roomId)\n    {\n        $user = $request->user();\n        $room = \\App\\Models\\ChatRoom::findOrFail($roomId);\n        \n        // Add user to room\n        $room->users()->attach($user->id, [\n            'joined_at' => now()\n        ]);\n        \n        // Broadcast user joined\n        broadcast(new \\App\\Events\\UserJoinedRoom($user, $room));\n        \n        return response()->json([\n            'message' => 'Joined room successfully',\n            'room' => $room\n        ]);\n    }\n}\n\n// Frontend JavaScript with Laravel Echo\n// resources/js/echo.js\n\nimport Echo from 'laravel-echo';\nimport Pusher from 'pusher-js';\n\nwindow.Pusher = Pusher;\n\nconst echo = new Echo({\n    broadcaster: 'pusher',\n    key: process.env.MIX_PUSHER_APP_KEY,\n    cluster: process.env.MIX_PUSHER_APP_CLUSTER,\n    forceTLS: true,\n    auth: {\n        headers: {\n            'Authorization': `Bearer ${localStorage.getItem('authToken')}`,\n            'X-CSRF-TOKEN': document.querySelector('meta[name=\"csrf-token\"]').getAttribute('content')\n        }\n    }\n});\n\n// Listen for user status changes\necho.private(`user.${userId}`)\n    .listen('UserStatusChanged', (e) => {\n        console.log('User status changed:', e.status);\n        // Update UI with new status\n        document.getElementById('user-status').textContent = e.status;\n    });\n\n// Listen for notifications\necho.private(`App.Models.User.${userId}`)\n    .listen('NotificationCreated', (e) => {\n        console.log('New notification:', e);\n        // Show notification in UI\n        showNotification(e.data.title, e.data.message);\n        \n        // Update notification count\n        const countElement = document.getElementById('notification-count');\n        countElement.textContent = parseInt(countElement.textContent) + 1;\n    });\n\n// Presence channel for chat rooms\necho.join(`chat.room.${roomId}`)\n    .here((users) => {\n        // Initial list of users in room\n        console.log('Users in room:', users);\n        updateOnlineUsersList(users);\n    })\n    .joining((user) => {\n        // User joined room\n        console.log('User joined:', user);\n        addUserToList(user);\n        showSystemMessage(`${user.name} joined the room`);\n    })\n    .leaving((user) => {\n        // User left room\n        console.log('User left:', user);\n        removeUserFromList(user);\n        showSystemMessage(`${user.name} left the room`);\n    })\n    .listen('MessageSent', (e) => {\n        // New message in room\n        console.log('New message:', e.message);\n        displayMessage(e.message);\n    });\n\n// Real-time dashboard updates\necho.channel('dashboard')\n    .listen('MetricsUpdated', (e) => {\n        console.log('Dashboard metrics updated:', e.metrics);\n        updateDashboardMetrics(e.metrics);\n    });\n\n// Error handling\necho.connector.pusher.connection.bind('error', (error) => {\n    console.error('Pusher connection error:', error);\n    // Handle connection error\n    showConnectionError();\n});\n\n// Reconnection handling\necho.connector.pusher.connection.bind('state_change', (states) => {\n    console.log('Connection state changed:', states);\n    if (states.current === 'connected') {\n        hideConnectionError();\n    }\n});\n\n// Broadcasting from server-side\n// In a service class or controller\n\\App\\Events\\UserStatusChanged::dispatch($user, 'online');\n\n// Broadcasting to specific channels\nbroadcast(new \\App\\Events\\NotificationCreated($notification, $user));\n\n// Broadcasting to presence channels\nbroadcast(new \\App\\Events\\UserJoinedRoom($user, $room));",
      "explanation": "This example demonstrates advanced Laravel event broadcasting patterns including:\n\n1. Event implementation with proper broadcasting configuration\n2. Private and presence channel usage for secure real-time communication\n3. Event serialization and custom payload formatting\n4. Event listeners with queue integration\n5. Frontend JavaScript with Laravel Echo for real-time updates\n6. Presence channels for user presence tracking\n7. Authentication and security for real-time connections\n8. Error handling and reconnection management\n\nThese patterns enable developers to create robust, scalable real-time applications that provide engaging user experiences with instant updates and interactive features.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Broadcasting sensitive data in events without proper authorization",
        "solution": "Implement proper channel authorization, sanitize event data, and use private channels for sensitive information",
        "severity": "high"
      },
      {
        "mistake": "Creating events that are too large or broadcast too frequently",
        "solution": "Optimize event payload size, implement rate limiting, and batch updates when appropriate",
        "severity": "medium"
      },
      {
        "mistake": "Not handling connection failures and reconnection scenarios",
        "solution": "Implement proper error handling, reconnection logic, and user feedback for connection issues",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Comprehensive Real-Time Features",
        "description": "Create a complete real-time system with private channels, presence channels, and proper error handling",
        "checkpoints": [
          "Implement events with proper broadcasting configuration",
          "Create private and presence channels for secure communication",
          "Build frontend integration with Laravel Echo",
          "Add proper authentication and authorization",
          "Implement error handling and reconnection management"
        ]
      }
    ],
    "next": [
      "laravel-lesson-22-caching-strategies"
    ],
    "estimatedMinutes": 55,
    "difficulty": "Advanced",
    "tags": [
      "Event Broadcasting",
      "Real-Time",
      "WebSocket",
      "Laravel Echo",
      "Pusher",
      "Laravel"
    ],
    "lastUpdated": "2025-10-03T10:00:00Z",
    "version": "1.0.0"
  },
  {
    "id": "22",
    "moduleSlug": "laravel-fundamentals",
    "title": "Caching Strategies and Optimization",
    "order": 22,
    "objectives": [
      "Master Laravel's caching system with multiple drivers and strategies",
      "Implement efficient cache invalidation and expiration patterns",
      "Create scalable caching architectures for high-performance applications",
      "Optimize cache usage for different data access patterns"
    ],
    "intro": "Caching strategies and optimization in Laravel provide essential tools for creating high-performance applications that can efficiently serve content while minimizing database load and response times. This comprehensive lesson explores advanced techniques for implementing robust caching systems that can handle complex data access patterns while maintaining data consistency and optimal performance.\n\nYou'll learn to implement sophisticated caching patterns that efficiently store and retrieve frequently accessed data, create cache invalidation strategies that maintain data consistency, and optimize cache usage for different types of data and access patterns. We'll explore advanced patterns for cache tagging, cache warming, and distributed caching that enable scalable, high-performance applications.\n\nThe lesson covers practical implementation strategies for monitoring cache performance, handling cache failures gracefully, and designing caching architectures that scale with application growth. You'll discover how to balance cache hit rates with memory usage, implement proper cache key naming conventions, and optimize caching for different storage drivers.\n\nBy mastering caching strategies and optimization, you'll be able to create Laravel applications that deliver exceptional performance and can handle high traffic loads while maintaining excellent user experience.",
    "code": {
      "example": "<?php\n// Advanced Caching Strategies and Optimization\n\n// Repository Pattern with Caching\n// app/Repositories/UserRepository.php\n\nnamespace App\\Repositories;\n\nuse App\\Models\\User;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass UserRepository\n{\n    protected const CACHE_TTL = 3600; // 1 hour\n    protected const TAG_PREFIX = 'users';\n    \n    public function findById(int $id)\n    {\n        $key = \"user:{$id}\";\n        \n        return Cache::tags([self::TAG_PREFIX])->remember($key, self::CACHE_TTL, function () use ($id) {\n            Log::info('Cache miss: User ' . $id);\n            return User::find($id);\n        });\n    }\n    \n    public function findByEmail(string $email)\n    {\n        $key = \"user:email:{$email}\";\n        \n        return Cache::tags([self::TAG_PREFIX, 'user_emails'])->remember($key, self::CACHE_TTL, function () use ($email) {\n            return User::where('email', $email)->first();\n        });\n    }\n    \n    public function getActiveUsers(int $limit = 50)\n    {\n        $key = \"users:active:limit:{$limit}\";\n        \n        return Cache::tags([self::TAG_PREFIX, 'user_lists'])->remember($key, 1800, function () use ($limit) {\n            return User::where('status', 'active')\n                      ->orderBy('last_login_at', 'desc')\n                      ->limit($limit)\n                      ->get();\n        });\n    }\n    \n    public function getUserStats(int $userId)\n    {\n        $key = \"user:{$userId}:stats\";\n        \n        return Cache::tags([self::TAG_PREFIX, 'user_stats'])->remember($key, 300, function () use ($userId) {\n            return [\n                'total_posts' => DB::table('posts')->where('user_id', $userId)->count(),\n                'total_comments' => DB::table('comments')->where('user_id', $userId)->count(),\n                'total_likes' => DB::table('likes')->where('user_id', $userId)->count(),\n                'last_activity' => DB::table('activities')\n                                    ->where('user_id', $userId)\n                                    ->latest('created_at')\n                                    ->value('created_at'),\n            ];\n        });\n    }\n    \n    public function searchUsers(array $filters = [])\n    {\n        // Create cache key from filters\n        $key = 'users:search:' . md5(serialize($filters));\n        \n        return Cache::tags([self::TAG_PREFIX, 'user_searches'])->remember($key, 600, function () use ($filters) {\n            $query = User::query();\n            \n            if (!empty($filters['name'])) {\n                $query->where('name', 'like', \"%{$filters['name']}%\");\n            }\n            \n            if (!empty($filters['status'])) {\n                $query->where('status', $filters['status']);\n            }\n            \n            if (!empty($filters['role'])) {\n                $query->where('role', $filters['role']);\n            }\n            \n            return $query->paginate($filters['per_page'] ?? 15);\n        });\n    }\n    \n    public function createUser(array $data)\n    {\n        $user = User::create($data);\n        \n        // Clear relevant caches\n        Cache::tags([self::TAG_PREFIX, 'user_lists'])->flush();\n        \n        return $user;\n    }\n    \n    public function updateUser(int $id, array $data)\n    {\n        $user = User::findOrFail($id);\n        $user->update($data);\n        \n        // Clear user-specific cache\n        Cache::tags([self::TAG_PREFIX])->forget(\"user:{$id}\");\n        Cache::tags([self::TAG_PREFIX])->forget(\"user:email:{$user->email}\");\n        \n        // Clear related caches\n        Cache::tags([self::TAG_PREFIX, 'user_stats'])->flush();\n        Cache::tags([self::TAG_PREFIX, 'user_lists'])->flush();\n        \n        return $user;\n    }\n    \n    public function deleteUser(int $id)\n    {\n        $user = User::findOrFail($id);\n        $user->delete();\n        \n        // Clear all user-related caches\n        Cache::tags([self::TAG_PREFIX])->flush();\n        \n        return true;\n    }\n    \n    public function clearUserCache(int $userId)\n    {\n        Cache::tags([self::TAG_PREFIX])->forget(\"user:{$userId}\");\n        Cache::tags([self::TAG_PREFIX, 'user_stats'])->forget(\"user:{$userId}:stats\");\n    }\n}\n\n// Advanced Cache Management Service\n// app/Services/CacheManager.php\n\nnamespace App\\Services;\n\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\Redis;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass CacheManager\n{\n    public function warmCache()\n    {\n        // Warm frequently accessed caches\n        $this->warmUserStats();\n        $this->warmActiveUsers();\n        $this->warmSystemSettings();\n        \n        Log::info('Cache warming completed');\n    }\n    \n    protected function warmUserStats()\n    {\n        $activeUsers = \\App\\Models\\User::where('status', 'active')\n                                      ->limit(1000)\n                                      ->pluck('id');\n        \n        foreach ($activeUsers as $userId) {\n            // Preload user stats\n            app('App\\Repositories\\UserRepository')->getUserStats($userId);\n        }\n    }\n    \n    protected function warmActiveUsers()\n    {\n        // Preload active users list\n        app('App\\Repositories\\UserRepository')->getActiveUsers(100);\n    }\n    \n    protected function warmSystemSettings()\n    {\n        // Preload system settings\n        \\App\\Models\\Setting::all()->keyBy('key');\n    }\n    \n    public function getCacheStats()\n    {\n        $driver = config('cache.default');\n        \n        switch ($driver) {\n            case 'redis':\n                return $this->getRedisStats();\n            case 'memcached':\n                return $this->getMemcachedStats();\n            default:\n                return [\n                    'driver' => $driver,\n                    'info' => 'Detailed stats not available for this driver'\n                ];\n        }\n    }\n    \n    protected function getRedisStats()\n    {\n        try {\n            $info = Redis::info();\n            $stats = [\n                'driver' => 'redis',\n                'used_memory' => $info['used_memory_human'] ?? 'N/A',\n                'connected_clients' => $info['connected_clients'] ?? 'N/A',\n                'total_commands_processed' => $info['total_commands_processed'] ?? 'N/A',\n                'keyspace_hits' => $info['keyspace_hits'] ?? 'N/A',\n                'keyspace_misses' => $info['keyspace_misses'] ?? 'N/A',\n                'hit_rate' => $this->calculateHitRate(\n                    $info['keyspace_hits'] ?? 0,\n                    $info['keyspace_misses'] ?? 0\n                )\n            ];\n            \n            return $stats;\n        } catch (\\Exception $e) {\n            Log::error('Failed to get Redis stats: ' . $e->getMessage());\n            return ['error' => 'Failed to retrieve Redis stats'];\n        }\n    }\n    \n    protected function calculateHitRate($hits, $misses)\n    {\n        $total = $hits + $misses;\n        return $total > 0 ? round(($hits / $total) * 100, 2) . '%' : '0%';\n    }\n    \n    public function clearTag($tag)\n    {\n        try {\n            Cache::tags([$tag])->flush();\n            Log::info(\"Cache tag '{$tag}' cleared\");\n            return true;\n        } catch (\\Exception $e) {\n            Log::error(\"Failed to clear cache tag '{$tag}': \" . $e->getMessage());\n            return false;\n        }\n    }\n    \n    public function clearPattern($pattern)\n    {\n        // Implementation depends on cache driver\n        // For Redis, you might use KEYS pattern and DEL\n        if (config('cache.default') === 'redis') {\n            $keys = Redis::keys($pattern);\n            if (!empty($keys)) {\n                Redis::del($keys);\n            }\n        }\n    }\n}\n\n// Model with Caching\n// app/Models/User.php\n\nnamespace App\\Models;\n\nuse Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\nuse Illuminate\\Foundation\\Auth\\User as Authenticatable;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\DB;\n\nclass User extends Authenticatable\n{\n    use HasFactory;\n    \n    protected $fillable = [\n        'name', 'email', 'password', 'status', 'role'\n    ];\n    \n    protected $hidden = [\n        'password', 'remember_token',\n    ];\n    \n    protected $casts = [\n        'email_verified_at' => 'datetime',\n        'last_login_at' => 'datetime',\n    ];\n    \n    // Cached relationships\n    public function posts()\n    {\n        return $this->hasMany(Post::class);\n    }\n    \n    public function getPostCountAttribute()\n    {\n        return Cache::remember(\"user:{$this->id}:post_count\", 3600, function () {\n            return $this->posts()->count();\n        });\n    }\n    \n    // Cached computed properties\n    public function getFullNameAttribute()\n    {\n        return Cache::remember(\"user:{$this->id}:full_name\", 86400, function () {\n            return trim($this->first_name . ' ' . $this->last_name);\n        });\n    }\n    \n    // Cache invalidation on model events\n    protected static function booted()\n    {\n        static::saved(function ($user) {\n            // Clear user-specific caches\n            Cache::forget(\"user:{$user->id}\");\n            Cache::forget(\"user:{$user->id}:full_name\");\n            Cache::forget(\"user:{$user->id}:post_count\");\n            \n            // Clear user lists if status changed\n            if ($user->wasChanged('status')) {\n                Cache::tags(['users', 'user_lists'])->flush();\n            }\n        });\n        \n        static::deleted(function ($user) {\n            // Clear all user-related caches\n            Cache::tags(['users'])->flush();\n        });\n    }\n}\n\n// Controller with Cache Optimization\n// app/Http/Controllers/DashboardController.php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Repositories\\UserRepository;\nuse Illuminate\\Support\\Facades\\Cache;\nuse Illuminate\\Support\\Facades\\DB;\n\nclass DashboardController extends Controller\n{\n    protected $userRepository;\n    \n    public function __construct(UserRepository $userRepository)\n    {\n        $this->userRepository = $userRepository;\n    }\n    \n    public function index()\n    {\n        // Use cache tags for easy invalidation\n        $dashboardData = Cache::tags(['dashboard', 'analytics'])->remember('dashboard:data', 300, function () {\n            return [\n                'total_users' => $this->userRepository->getActiveUsers()->count(),\n                'recent_users' => $this->userRepository->getActiveUsers(10),\n                'system_stats' => $this->getSystemStats(),\n                'cache_stats' => app('App\\Services\\CacheManager')->getCacheStats(),\n            ];\n        });\n        \n        return response()->json($dashboardData);\n    }\n    \n    protected function getSystemStats()\n    {\n        return Cache::remember('system:stats', 600, function () {\n            return [\n                'database_size' => DB::select('SELECT pg_size_pretty(pg_database_size(current_database())) as size')[0]->size ?? 'N/A',\n                'active_sessions' => DB::table('sessions')->count(),\n                'server_load' => sys_getloadavg()[0] ?? 0,\n            ];\n        });\n    }\n    \n    public function clearCache(Request $request)\n    {\n        $tag = $request->get('tag', 'dashboard');\n        \n        $success = app('App\\Services\\CacheManager')->clearTag($tag);\n        \n        return response()->json([\n            'message' => $success ? 'Cache cleared successfully' : 'Failed to clear cache',\n            'tag' => $tag\n        ]);\n    }\n}\n\n// Cache Configuration\n// config/cache.php\n\nreturn [\n    'default' => env('CACHE_DRIVER', 'redis'),\n    \n    'stores' => [\n        'redis' => [\n            'driver' => 'redis',\n            'connection' => 'cache',\n            'lock_connection' => 'default',\n            'options' => [\n                'compression' => true, // Enable compression for large values\n                'serializer' => 'igbinary', // Use igbinary for better performance\n            ],\n        ],\n        \n        'memcached' => [\n            'driver' => 'memcached',\n            'persistent_id' => env('MEMCACHED_PERSISTENT_ID'),\n            'sasl' => [\n                env('MEMCACHED_USERNAME'),\n                env('MEMCACHED_PASSWORD'),\n            ],\n            'options' => [\n                // Memcached::OPT_CONNECT_TIMEOUT => 2000,\n            ],\n            'servers' => [\n                [\n                    'host' => env('MEMCACHED_HOST', '127.0.0.1'),\n                    'port' => env('MEMCACHED_PORT', 11211),\n                    'weight' => 100,\n                ],\n            ],\n        ],\n    ],\n    \n    'prefix' => env('CACHE_PREFIX', 'laravel'),\n    \n    // Cache warming configuration\n    'warm_on_deploy' => env('CACHE_WARM_ON_DEPLOY', true),\n    \n    // Cache monitoring\n    'monitor_hits' => env('CACHE_MONITOR_HITS', false),\n];",
      "explanation": "This example demonstrates advanced Laravel caching strategies including:\n\n1. Repository pattern with comprehensive caching\n2. Cache tagging for organized invalidation\n3. Advanced cache management service\n4. Model-level caching with automatic invalidation\n5. Cache warming strategies for improved performance\n6. Cache statistics and monitoring\n7. Multiple cache driver configuration\n8. Proper cache key naming conventions\n\nThese patterns enable developers to create robust, scalable caching systems that significantly improve application performance while maintaining data consistency.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Caching data that changes frequently without proper invalidation",
        "solution": "Implement proper cache invalidation strategies, use appropriate TTL values, and leverage cache tags for organized clearing",
        "severity": "high"
      },
      {
        "mistake": "Creating cache keys that are too generic or collide",
        "solution": "Use consistent naming conventions, include relevant identifiers, and consider using cache key hashing for complex keys",
        "severity": "medium"
      },
      {
        "mistake": "Not monitoring cache performance and hit rates",
        "solution": "Implement cache statistics tracking, monitor hit rates, and regularly review cache effectiveness",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Comprehensive Caching System",
        "description": "Create a complete caching system with proper invalidation, monitoring, and optimization",
        "checkpoints": [
          "Implement repository pattern with caching",
          "Create cache tagging for organized invalidation",
          "Build cache warming strategies",
          "Add cache monitoring and statistics",
          "Implement proper cache key naming conventions"
        ]
      }
    ],
    "next": [
      "laravel-lesson-23-deployment-practices"
    ],
    "estimatedMinutes": 55,
    "difficulty": "Advanced",
    "tags": [
      "Caching",
      "Optimization",
      "Redis",
      "Performance",
      "Laravel"
    ],
    "lastUpdated": "2025-10-03T10:00:00Z",
    "version": "1.0.0"
  },
  {
    "id": "23",
    "moduleSlug": "laravel-fundamentals",
    "title": "Deployment and DevOps Practices",
    "order": 23,
    "objectives": [
      "Master Laravel application deployment strategies for different environments",
      "Implement CI/CD pipelines with automated testing and deployment",
      "Create robust deployment configurations with environment management",
      "Design scalable infrastructure architectures for Laravel applications"
    ],
    "intro": "Deployment and DevOps practices in Laravel provide essential tools and techniques for reliably delivering applications to production environments while maintaining security, performance, and scalability. This comprehensive lesson explores advanced deployment strategies that ensure smooth, consistent deployments across different environments with minimal downtime and maximum reliability.\n\nYou'll learn to implement sophisticated deployment pipelines that automate testing, building, and deployment processes while maintaining strict quality controls and security measures. We'll explore advanced patterns for environment configuration management, zero-downtime deployments, and rollback strategies that enable confident, frequent releases.\n\nThe lesson covers practical implementation strategies for containerization with Docker, infrastructure as code with configuration management tools, and monitoring and alerting systems that provide visibility into application health and performance. You'll discover how to balance deployment automation with security requirements, implement proper secrets management, and design deployment architectures that scale with application growth.\n\nBy mastering deployment and DevOps practices, you'll be able to create Laravel applications that can be reliably deployed and maintained in production environments with confidence and efficiency.",
    "code": {
      "example": "<?php\n// Advanced Deployment and DevOps Practices\n\n// Environment Configuration Management\n// config/deployment.php\n\nreturn [\n    'environments' => [\n        'local' => [\n            'debug' => true,\n            'log_level' => 'debug',\n            'cache_driver' => 'array',\n            'session_driver' => 'file',\n        ],\n        \n        'staging' => [\n            'debug' => false,\n            'log_level' => 'info',\n            'cache_driver' => 'redis',\n            'session_driver' => 'redis',\n        ],\n        \n        'production' => [\n            'debug' => false,\n            'log_level' => 'error',\n            'cache_driver' => 'redis',\n            'session_driver' => 'redis',\n        ],\n    ],\n    \n    'deployment' => [\n        'strategy' => env('DEPLOYMENT_STRATEGY', 'rolling'),\n        'max_concurrent' => env('DEPLOYMENT_MAX_CONCURRENT', 2),\n        'health_check_url' => env('DEPLOYMENT_HEALTH_CHECK_URL', '/health'),\n        'health_check_timeout' => env('DEPLOYMENT_HEALTH_CHECK_TIMEOUT', 30),\n    ],\n    \n    'monitoring' => [\n        'enabled' => env('MONITORING_ENABLED', true),\n        'providers' => [\n            'sentry' => [\n                'dsn' => env('SENTRY_LARAVEL_DSN'),\n                'traces_sample_rate' => env('SENTRY_TRACES_SAMPLE_RATE', 0.1),\n            ],\n            'newrelic' => [\n                'enabled' => env('NEW_RELIC_ENABLED', false),\n                'license_key' => env('NEW_RELIC_LICENSE_KEY'),\n            ],\n        ],\n    ],\n];\n\n// Deployment Health Check Controller\n// app/Http/Controllers/HealthCheckController.php\n\nnamespace App\\Http\\Controllers;\n\nuse Illuminate\\Http\\Request;\nuse Illuminate\\Support\\Facades\\DB;\nuse Illuminate\\Support\\Facades\\Redis;\nuse Illuminate\\Support\\Facades\\Storage;\n\nclass HealthCheckController extends Controller\n{\n    public function index()\n    {\n        $checks = [\n            'database' => $this->checkDatabase(),\n            'cache' => $this->checkCache(),\n            'storage' => $this->checkStorage(),\n            'queue' => $this->checkQueue(),\n        ];\n        \n        $status = collect($checks)->every(fn($check) => $check['status'] === 'healthy') ? 'healthy' : 'degraded';\n        \n        return response()->json([\n            'status' => $status,\n            'timestamp' => now()->toISOString(),\n            'checks' => $checks,\n        ], $status === 'healthy' ? 200 : 503);\n    }\n    \n    protected function checkDatabase()\n    {\n        try {\n            DB::connection()->getPdo();\n            DB::select('SELECT 1');\n            return ['status' => 'healthy', 'message' => 'Database connection successful'];\n        } catch (\\Exception $e) {\n            return ['status' => 'unhealthy', 'message' => $e->getMessage()];\n        }\n    }\n    \n    protected function checkCache()\n    {\n        try {\n            $key = 'health_check_' . time();\n            $value = 'test_value';\n            \n            Redis::setex($key, 10, $value);\n            $result = Redis::get($key);\n            \n            if ($result === $value) {\n                return ['status' => 'healthy', 'message' => 'Cache connection successful'];\n            }\n            \n            return ['status' => 'unhealthy', 'message' => 'Cache value mismatch'];\n        } catch (\\Exception $e) {\n            return ['status' => 'unhealthy', 'message' => $e->getMessage()];\n        }\n    }\n    \n    protected function checkStorage()\n    {\n        try {\n            $testFile = 'health_check_' . time() . '.txt';\n            Storage::put($testFile, 'test');\n            $exists = Storage::exists($testFile);\n            Storage::delete($testFile);\n            \n            return $exists \n                ? ['status' => 'healthy', 'message' => 'Storage accessible']\n                : ['status' => 'unhealthy', 'message' => 'Storage test failed'];\n        } catch (\\Exception $e) {\n            return ['status' => 'unhealthy', 'message' => $e->getMessage()];\n        }\n    }\n    \n    protected function checkQueue()\n    {\n        try {\n            // Dispatch a test job\n            $jobId = uniqid();\n            dispatch(new \\App\\Jobs\\HealthCheckJob($jobId));\n            \n            return ['status' => 'healthy', 'message' => 'Queue system operational'];\n        } catch (\\Exception $e) {\n            return ['status' => 'unhealthy', 'message' => $e->getMessage()];\n        }\n    }\n}\n\n// Health Check Job\n// app/Jobs/HealthCheckJob.php\n\nnamespace App\\Jobs;\n\nuse Illuminate\\Bus\\Queueable;\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\nuse Illuminate\\Queue\\InteractsWithQueue;\nuse Illuminate\\Queue\\SerializesModels;\nuse Illuminate\\Support\\Facades\\Log;\n\nclass HealthCheckJob implements ShouldQueue\n{\n    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n    \n    protected $jobId;\n    \n    public function __construct($jobId)\n    {\n        $this->jobId = $jobId;\n    }\n    \n    public function handle()\n    {\n        Log::info('Health check job processed successfully', ['job_id' => $this->jobId]);\n        // This job is just for testing queue functionality\n    }\n}\n\n// Deployment Configuration Service\n// app/Services/DeploymentService.php\n\nnamespace App\\Services;\n\nuse Illuminate\\Support\\Facades\\Artisan;\nuse Illuminate\\Support\\Facades\\Log;\nuse Illuminate\\Support\\Facades\\File;\n\nclass DeploymentService\n{\n    public function preDeploy()\n    {\n        Log::info('Starting pre-deployment tasks');\n        \n        // Run tests\n        $this->runTests();\n        \n        // Backup database (in non-production environments)\n        if (app()->environment('staging')) {\n            $this->backupDatabase();\n        }\n        \n        // Clear caches\n        $this->clearCaches();\n        \n        Log::info('Pre-deployment tasks completed');\n    }\n    \n    public function postDeploy()\n    {\n        Log::info('Starting post-deployment tasks');\n        \n        // Run migrations\n        $this->runMigrations();\n        \n        // Clear and rebuild caches\n        $this->rebuildCaches();\n        \n        // Warm caches\n        $this->warmCaches();\n        \n        // Restart queue workers\n        $this->restartQueueWorkers();\n        \n        Log::info('Post-deployment tasks completed');\n    }\n    \n    protected function runTests()\n    {\n        Log::info('Running tests');\n        // In a real deployment, this would be handled by CI/CD\n        // For demonstration, we're just logging\n    }\n    \n    protected function backupDatabase()\n    {\n        Log::info('Backing up database');\n        // Implementation would depend on database type\n        // For MySQL: mysqldump\n        // For PostgreSQL: pg_dump\n    }\n    \n    protected function clearCaches()\n    {\n        Log::info('Clearing caches');\n        Artisan::call('cache:clear');\n        Artisan::call('config:clear');\n        Artisan::call('route:clear');\n        Artisan::call('view:clear');\n    }\n    \n    protected function runMigrations()\n    {\n        Log::info('Running migrations');\n        Artisan::call('migrate', ['--force' => true]);\n    }\n    \n    protected function rebuildCaches()\n    {\n        Log::info('Rebuilding caches');\n        Artisan::call('config:cache');\n        Artisan::call('route:cache');\n        Artisan::call('view:cache');\n    }\n    \n    protected function warmCaches()\n    {\n        Log::info('Warming caches');\n        // Warm frequently accessed caches\n        app('App\\Services\\CacheManager')->warmCache();\n    }\n    \n    protected function restartQueueWorkers()\n    {\n        Log::info('Restarting queue workers');\n        // This would typically be handled by the process manager\n        // In production, you might use: php artisan queue:restart\n        Artisan::call('queue:restart');\n    }\n    \n    public function rollback($steps = 1)\n    {\n        Log::info('Rolling back migrations', ['steps' => $steps]);\n        Artisan::call('migrate:rollback', ['--step' => $steps]);\n        \n        // Clear and rebuild caches after rollback\n        $this->clearCaches();\n        $this->rebuildCaches();\n    }\n}\n\n// Docker Configuration for Laravel\n// Dockerfile\n\nFROM php:8.1-fpm\n\n# Install system dependencies\nRUN apt-get update && apt-get install -y \\\n    git \\\n    curl \\\n    libpng-dev \\\n    libonig-dev \\\n    libxml2-dev \\\n    zip \\\n    unzip\n\n# Clear cache\nRUN apt-get clean && rm -rf /var/lib/apt/lists/*\n\n# Install PHP extensions\nRUN docker-php-ext-install pdo_mysql mbstring exif pcntl bcmath gd\n\n# Get latest Composer\nCOPY --from=composer:latest /usr/bin/composer /usr/bin/composer\n\n# Set working directory\nWORKDIR /var/www\n\n# Copy existing application directory contents\nCOPY . /var/www\n\n# Install dependencies\nRUN composer install --optimize-autoloader --no-dev\n\n# Set permissions\nRUN chown -R www-data:www-data \\\n    /var/www/vendor \\\n    /var/www/storage \\\n    /var/www/bootstrap/cache\n\n# Expose port 9000 and start PHP-FPM server\nEXPOSE 9000\nCMD [\"php-fpm\"]\n\n// Nginx Configuration\n// nginx.conf\n\nserver {\n    listen 80;\n    server_name example.com;\n    root /var/www/public;\n    \n    add_header X-Frame-Options \"SAMEORIGIN\";\n    add_header X-Content-Type-Options \"nosniff\";\n    \n    index index.php;\n    \n    charset utf-8;\n    \n    location / {\n        try_files $uri $uri/ /index.php?$query_string;\n    }\n    \n    location = /favicon.ico { access_log off; log_not_found off; }\n    location = /robots.txt  { access_log off; log_not_found off; }\n    \n    error_page 404 /index.php;\n    \n    location ~ \\.php$ {\n        fastcgi_pass app:9000;\n        fastcgi_param SCRIPT_FILENAME $realpath_root$fastcgi_script_name;\n        include fastcgi_params;\n    }\n    \n    location ~ /\\.(?!well-known).* {\n        deny all;\n    }\n}\n\n// Docker Compose Configuration\n// docker-compose.yml\n\nversion: '3.8'\n\nservices:\n    app:\n        build:\n            context: .\n            dockerfile: Dockerfile\n        image: laravel-app\n        container_name: laravel-app\n        restart: unless-stopped\n        working_dir: /var/www/\n        volumes:\n            - ./:/var/www\n            - ./storage/logs:/var/www/storage/logs\n        networks:\n            - laravel\n    \n    webserver:\n        image: nginx:alpine\n        container_name: laravel-nginx\n        restart: unless-stopped\n        ports:\n            - \"80:80\"\n            - \"443:443\"\n        volumes:\n            - ./:/var/www\n            - ./nginx.conf:/etc/nginx/conf.d/default.conf\n            - ./ssl:/etc/nginx/ssl\n        networks:\n            - laravel\n    \n    db:\n        image: mysql:8.0\n        container_name: laravel-mysql\n        restart: unless-stopped\n        environment:\n            MYSQL_DATABASE: laravel\n            MYSQL_ROOT_PASSWORD: secret\n            MYSQL_PASSWORD: secret\n            MYSQL_USER: laraveluser\n        volumes:\n            - dbdata:/var/lib/mysql\n            - ./mysql/my.cnf:/etc/mysql/my.cnf\n        ports:\n            - \"3306:3306\"\n        networks:\n            - laravel\n    \n    redis:\n        image: redis:alpine\n        container_name: laravel-redis\n        restart: unless-stopped\n        ports:\n            - \"6379:6379\"\n        networks:\n            - laravel\n    \n    queue:\n        build:\n            context: .\n            dockerfile: Dockerfile\n        image: laravel-app\n        container_name: laravel-queue\n        restart: unless-stopped\n        command: 'php artisan queue:work --tries=3'\n        volumes:\n            - ./:/var/www\n        networks:\n            - laravel\n        depends_on:\n            - app\n            - db\n            - redis\n\nnetworks:\n    laravel:\n        driver: bridge\n\nvolumes:\n    dbdata:\n        driver: local\n\n// CI/CD Pipeline Configuration\n// .github/workflows/deploy.yml\n\nname: Deploy Laravel Application\n\non:\n  push:\n    branches: [ main ]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    \n    services:\n      mysql:\n        image: mysql:8.0\n        env:\n          MYSQL_ROOT_PASSWORD: password\n          MYSQL_DATABASE: test\n        ports:\n          - 3306:3306\n        options: --health-cmd=\"mysqladmin ping\" --health-interval=10s --health-timeout=5s --health-retries=3\n    \n    steps:\n    - uses: actions/checkout@v2\n    \n    - name: Setup PHP\n      uses: shivammathur/setup-php@v2\n      with:\n        php-version: '8.1'\n        extensions: mbstring, pdo, pdo_mysql\n        coverage: none\n    \n    - name: Copy .env\n      run: php -r \"file_exists('.env') || copy('.env.example', '.env');\"\n    \n    - name: Install Dependencies\n      run: composer install -q --no-ansi --no-interaction --no-scripts --no-progress --prefer-dist\n    \n    - name: Generate key\n      run: php artisan key:generate\n    \n    - name: Directory Permissions\n      run: chmod -R 777 storage bootstrap/cache\n    \n    - name: Create Database\n      run: |\n        mkdir -p database\n        touch database/database.sqlite\n    \n    - name: Execute tests (Unit and Feature tests) via PHPUnit\n      env:\n        DB_CONNECTION: sqlite\n        DB_DATABASE: database/database.sqlite\n      run: vendor/bin/phpunit\n  \n  deploy:\n    needs: test\n    runs-on: ubuntu-latest\n    \n    steps:\n    - name: Deploy to production\n      uses: appleboy/ssh-action@v0.1.5\n      with:\n        host: ${{ secrets.HOST }}\n        username: ${{ secrets.USERNAME }}\n        key: ${{ secrets.KEY }}\n        script: |\n          cd /var/www/html\n          git pull origin main\n          composer install --no-dev --optimize-autoloader\n          php artisan migrate --force\n          php artisan config:cache\n          php artisan route:cache\n          php artisan view:cache\n          php artisan queue:restart\n          sudo systemctl reload php8.1-fpm\n          sudo systemctl reload nginx",
      "explanation": "This example demonstrates advanced Laravel deployment and DevOps practices including:\n\n1. Environment configuration management for different deployment stages\n2. Comprehensive health check implementation for deployment validation\n3. Deployment service with pre and post-deployment tasks\n4. Docker configuration for containerized Laravel applications\n5. Nginx configuration for optimal performance\n6. Docker Compose setup for multi-container applications\n7. CI/CD pipeline configuration with GitHub Actions\n8. Database backup and rollback strategies\n\nThese patterns enable developers to create robust, automated deployment processes that ensure reliable, consistent application delivery with minimal downtime and maximum reliability.",
      "language": "php"
    },
    "pitfalls": [
      {
        "mistake": "Deploying without proper testing and validation checks",
        "solution": "Implement comprehensive CI/CD pipelines with automated testing, health checks, and rollback capabilities",
        "severity": "high"
      },
      {
        "mistake": "Not managing environment-specific configurations properly",
        "solution": "Use proper environment variable management, configuration caching, and environment-specific settings",
        "severity": "high"
      },
      {
        "mistake": "Deploying with downtime or without proper rollback strategies",
        "solution": "Implement zero-downtime deployment strategies, blue-green deployments, and comprehensive rollback procedures",
        "severity": "medium"
      }
    ],
    "exercises": [
      {
        "title": "Implement Complete Deployment Pipeline",
        "description": "Create a comprehensive deployment system with health checks, CI/CD integration, and proper environment management",
        "checkpoints": [
          "Implement environment configuration management",
          "Create comprehensive health check system",
          "Build deployment service with pre/post tasks",
          "Configure Docker for containerized deployment",
          "Set up CI/CD pipeline with automated testing"
        ]
      }
    ],
    "next": [
      "laravel-interview-questions"
    ],
    "estimatedMinutes": 60,
    "difficulty": "Advanced",
    "tags": [
      "Deployment",
      "DevOps",
      "Docker",
      "CI/CD",
      "Laravel"
    ],
    "lastUpdated": "2025-10-03T10:00:00Z",
    "version": "1.0.0"
  }
]