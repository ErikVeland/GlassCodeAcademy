{
  "moduleSlug": "graphql-advanced",
  "title": "GraphQL Advanced Assessment",
  "description": "Comprehensive assessment covering key concepts from the graphql-advanced module",
  "totalQuestions": 33,
  "passingScore": 70,
  "timeLimit": 30,
  "questions": [
    {
      "id": 1,
      "question": "What is `GraphQL`?",
      "topic": "GraphQL Fundamentals",
      "difficulty": "Beginner",
      "choices": [
        "A `query` language for APIs and a runtime for executing queries",
        "A database management system",
        "A REST API framework",
        "A JavaScript library for building user interfaces"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL` is a `query` language for APIs and a runtime for executing those queries by using a type system you define for your data. It provides a more efficient, powerful and flexible alternative to REST.",
      "industryContext": "GraphQL is widely adopted by companies like Facebook, GitHub, and Shopify for building efficient APIs that reduce over-fetching and under-fetching of data.",
      "tags": [
        "GraphQL Fundamentals",
        "beginner",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 60,
      "correctAnswer": 0
    },
    {
      "id": 2,
      "question": "Which of the following is NOT a core operation type in `GraphQL`?",
      "topic": "GraphQL Fundamentals",
      "difficulty": "Intermediate",
      "choices": [
        "Query",
        "Mutation",
        "Subscription",
        "Transaction"
      ],
      "correctIndex": 3,
      "explanation": "`GraphQL` has three core operation types: Query (for reading data), Mutation (for modifying data), and Subscription (for real-time data). Transaction is not a `GraphQL` operation type.",
      "industryContext": "Understanding GraphQL operation types is essential for building robust APIs that support various client requirements including real-time data updates.",
      "tags": [
        "GraphQL Fundamentals",
        "intermediate",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 60,
      "correctAnswer": 3
    },
    {
      "id": 4,
      "question": "What are the main advantages of `GraphQL` over REST APIs?",
      "topic": "GraphQL Fundamentals",
      "difficulty": "Intermediate",
      "choices": [
        "Clients can request exactly the data they need, avoiding over-fetching and under-fetching",
        "`GraphQL` uses multiple endpoints while REST uses a single endpoint",
        "REST provides better type safety than `GraphQL`",
        "`GraphQL` is only suitable for mobile applications"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL`'s main advantages over REST include: 1) Clients can request exactly the data they need, avoiding over-fetching and under-fetching, 2) Single endpoint for all operations instead of multiple URLs, 3) Strong type system provides better tooling and validation, 4) Real-time subscriptions built-in, 5) Introspection allows for automatic documentation and tooling.",
      "industryContext": "Companies migrating from REST to GraphQL often see significant performance improvements and reduced network overhead, especially in mobile applications where bandwidth is limited.",
      "tags": [
        "GraphQL Fundamentals",
        "intermediate",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "correctAnswer": 0
    },
    {
      "id": 5,
      "question": "In `GraphQL` `schema` definition, what does the exclamation mark (!) indicate?",
      "topic": "Schema Design",
      "difficulty": "Intermediate",
      "choices": [
        "The field is required and cannot be null",
        "The field is deprecated",
        "The field is an array",
        "The field is a custom scalar"
      ],
      "correctIndex": 0,
      "explanation": "The exclamation mark (!) in `GraphQL` `schema` definition indicates that a field is non-nullable, meaning it must always return a value and cannot be null.",
      "industryContext": "Proper use of nullability in GraphQL schemas is crucial for building reliable client applications that can handle data validation and error states effectively.",
      "tags": [
        "Schema Design",
        "intermediate",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 60,
      "correctAnswer": 0
    },
    {
      "id": 6,
      "question": "What is the purpose of resolvers in `GraphQL`?",
      "topic": "Schema Design",
      "difficulty": "Beginner",
      "choices": [
        "To fetch data for each field in a `query`",
        "To define the `schema` structure",
        "To validate user input",
        "To handle authentication"
      ],
      "correctIndex": 0,
      "explanation": "Resolvers are functions that fetch the actual data for each field in a `GraphQL` `query`. They define how to retrieve data from databases, APIs, or other sources for each field in the `schema`.",
      "industryContext": "Resolver design is critical for GraphQL performance optimization, as inefficient resolvers can lead to the N+1 problem and slow query execution.",
      "tags": [
        "Schema Design",
        "beginner",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 60,
      "correctAnswer": 0
    },
    {
      "id": 7,
      "question": "What is the difference between a `GraphQL` `query` and a `mutation`?",
      "topic": "GraphQL Operations",
      "difficulty": "Beginner",
      "choices": [
        "Queries are used for reading data while mutations are used for modifying data",
        "Queries are executed sequentially while mutations are executed in parallel",
        "Mutations are used for reading data while queries are used for modifying data",
        "There is no difference, they are interchangeable"
      ],
      "correctIndex": 0,
      "explanation": "Queries are used for reading/fetching data and should be side-effect free, while mutations are used for modifying data (create, update, delete operations). Queries can be executed in parallel, but mutations are executed sequentially to ensure data consistency.",
      "industryContext": "Understanding the distinction between queries and mutations is fundamental for building GraphQL APIs that follow best practices and maintain data integrity.",
      "tags": [
        "GraphQL Operations",
        "beginner",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 75,
      "correctAnswer": 0
    },
    {
      "id": 8,
      "question": "How do you pass variables to a `GraphQL` `query`?",
      "topic": "GraphQL Operations",
      "difficulty": "Beginner",
      "choices": [
        "Using the variables object alongside the `query`",
        "Directly interpolating values in the `query` string",
        "Using `query` parameters in the URL",
        "Variables cannot be used in `GraphQL`"
      ],
      "correctIndex": 0,
      "explanation": "Variables are passed to `GraphQL` queries using a variables object that is sent alongside the `query`. The `query` defines variable types and names using $ syntax, and values are provided in the variables object.",
      "industryContext": "Using variables in GraphQL queries is essential for security (preventing injection attacks) and reusability of query templates in client applications.",
      "tags": [
        "GraphQL Operations",
        "beginner",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 60,
      "correctAnswer": 0
    },
    {
      "id": 21,
      "question": "What are `GraphQL` subscriptions used for?",
      "topic": "Real-time Data",
      "difficulty": "Intermediate",
      "choices": [
        "Real-time data updates from the server to clients",
        "Batch processing of multiple queries",
        "Caching `query` results",
        "Authentication and authorization"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL` subscriptions provide a way to stream real-time data from the server to clients when specific events occur. They use the WebSocket protocol to maintain a persistent connection between client and server.",
      "industryContext": "Real-time features like live notifications, chat applications, and collaborative tools rely heavily on GraphQL subscriptions for efficient data delivery.",
      "tags": [
        "Real-time Data",
        "intermediate",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 75,
      "correctAnswer": 0
    },
    {
      "id": 22,
      "question": "What is the N+1 problem in `GraphQL` and how can it be solved?",
      "topic": "Performance Optimization",
      "difficulty": "Advanced",
      "choices": [
        "Multiple database queries for related data; solved with DataLoader pattern",
        "Network latency issues; solved with CDN caching",
        "Memory leaks in resolvers; solved with garbage collection",
        "Schema validation errors; solved with stricter type definitions"
      ],
      "correctIndex": 0,
      "explanation": "The N+1 problem occurs when resolving nested fields results in multiple database queries - one for the parent records and N additional queries for related data. It can be solved using the DataLoader pattern, which batches and caches database requests to minimize the number of round trips to the database.",
      "industryContext": "Performance optimization is critical for production GraphQL APIs serving thousands of requests per second, where the N+1 problem can severely impact response times and database load.",
      "tags": [
        "Performance Optimization",
        "advanced",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 120,
      "correctAnswer": 0
    },
    {
      "id": 23,
      "question": "What is `schema` stitching in `GraphQL`?",
      "topic": "Advanced Concepts",
      "difficulty": "Advanced",
      "choices": [
        "Combining multiple `GraphQL` schemas into a single unified `schema`",
        "Breaking a large `schema` into smaller pieces",
        "Validating `schema` against business rules",
        "Optimizing `schema` for better performance"
      ],
      "correctIndex": 0,
      "explanation": "Schema stitching is a technique for combining multiple `GraphQL` schemas into a single unified `schema`. This allows you to create a single `GraphQL` endpoint that can delegate parts of queries to different underlying services, enabling microservices architecture with `GraphQL`.",
      "industryContext": "Schema stitching is commonly used in large organizations with multiple teams owning different services, allowing them to maintain independent GraphQL APIs while providing a unified experience to clients.",
      "tags": [
        "Advanced Concepts",
        "advanced",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "correctAnswer": 0
    },
    {
      "id": 24,
      "question": "Which directive is used to mark a field as deprecated in `GraphQL`?",
      "topic": "Schema Design",
      "difficulty": "Intermediate",
      "choices": [
        "@deprecated",
        "@obsolete",
        "@remove",
        "@legacy"
      ],
      "correctIndex": 0,
      "explanation": "The @deprecated directive is used to mark `GraphQL` fields, arguments, or enum values as deprecated. It can include a reason string to explain why the element is deprecated and what should be used instead.",
      "industryContext": "Proper API versioning and deprecation strategies are essential for maintaining backward compatibility while evolving GraphQL APIs in production environments.",
      "tags": [
        "Schema Design",
        "intermediate",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 60,
      "correctAnswer": 0
    },
    {
      "id": 25,
      "question": "What is the purpose of `GraphQL` fragments?",
      "topic": "Client Usage",
      "difficulty": "Beginner",
      "choices": [
        "To reuse parts of queries and avoid duplication",
        "To encrypt sensitive data in queries",
        "To compress `query` payloads",
        "To cache `query` results on the server"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL` fragments allow you to define reusable parts of queries that can be shared across multiple queries or nested within other queries. This helps avoid duplication and makes client code more maintainable.",
      "industryContext": "Fragments are extensively used in real-world GraphQL applications to create reusable components that can compose complex queries from smaller, well-defined pieces.",
      "tags": [
        "Client Usage",
        "beginner",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 60,
      "correctAnswer": 0
    },
    {
      "id": 26,
      "question": "What is `GraphQL` introspection?",
      "topic": "Development Tools",
      "difficulty": "Intermediate",
      "choices": [
        "The ability to `query` a `GraphQL` `schema` for information about itself",
        "A tool for testing `GraphQL` APIs",
        "A method for optimizing `query` performance",
        "A technique for securing `GraphQL` endpoints"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL` introspection allows clients to `query` the `schema` for information about what queries, mutations, and types are available. This enables powerful development tools like GraphiQL and `GraphQL` Playground, as well as automatic documentation generation.",
      "industryContext": "Introspection is a key feature that enables the rich ecosystem of GraphQL development tools and provides the foundation for automatic client code generation and type safety.",
      "tags": [
        "Development Tools",
        "intermediate",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 75,
      "correctAnswer": 0
    },
    {
      "id": 27,
      "question": "Which of the following is a built-in scalar type in `GraphQL`?",
      "topic": "Schema Design",
      "difficulty": "Beginner",
      "choices": [
        "ID",
        "Date",
        "Timestamp",
        "UUID"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL` has five built-in scalar types: Int, Float, String, Boolean, and ID. While Date, Timestamp, and UUID are commonly used, they are custom scalar types that need to be defined in the `schema`.",
      "industryContext": "Understanding GraphQL's type system is fundamental for designing robust APIs that provide appropriate data types for client applications to consume effectively.",
      "tags": [
        "Schema Design",
        "beginner",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 45,
      "correctAnswer": 0
    },
    {
      "id": 28,
      "question": "What is the purpose of `GraphQL` interfaces?",
      "topic": "Schema Design",
      "difficulty": "Intermediate",
      "choices": [
        "To define common fields that multiple types can implement",
        "To create private fields that are not visible in the `schema`",
        "To optimize `query` execution performance",
        "To handle authentication and authorization"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL` interfaces define a common set of fields that multiple object types can implement. This allows you to define fields that can return different types as long as they conform to the same interface, enabling polymorphic queries.",
      "industryContext": "Interfaces are essential for modeling complex domain relationships in GraphQL schemas and enabling flexible query patterns that can work with multiple related types.",
      "tags": [
        "Schema Design",
        "intermediate",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 75,
      "correctAnswer": 0
    },
    {
      "id": 29,
      "question": "How does `GraphQL` handle error handling?",
      "topic": "Error Handling",
      "difficulty": "Intermediate",
      "choices": [
        "Errors are returned alongside successful data in the response",
        "Errors cause the entire `query` to fail",
        "Errors are logged server-side but not sent to clients",
        "`GraphQL` does not have built-in error handling"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL` includes errors in a dedicated 'errors' array in the response alongside successful data. This allows partial results to be returned even when some fields fail, providing better user experience and more granular error information.",
      "industryContext": "Proper error handling in GraphQL APIs is crucial for building resilient client applications that can gracefully handle partial failures and provide meaningful feedback to users.",
      "tags": [
        "Error Handling",
        "intermediate",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 75,
      "correctAnswer": 0
    },
    {
      "id": 30,
      "question": "What is the purpose of `GraphQL` unions?",
      "topic": "Schema Design",
      "difficulty": "Advanced",
      "choices": [
        "To define a field that can return one of several object types",
        "To combine multiple fields into a single field",
        "To create a hierarchy of types",
        "To optimize memory usage in resolvers"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL` unions allow you to define a field that can return one of several different object types. Unlike interfaces, unions don't require the types to share common fields, making them suitable for representing truly disparate types in a single field.",
      "industryContext": "Unions are particularly useful for search results, notification systems, and other scenarios where a field might return completely different types of objects based on runtime conditions.",
      "tags": [
        "Schema Design",
        "advanced",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "correctAnswer": 0
    },
    {
      "id": 31,
      "question": "What is `GraphQL` caching typically implemented at?",
      "topic": "Performance",
      "difficulty": "Intermediate",
      "choices": [
        "Client-side and CDN level, not at the `GraphQL` server level",
        "Server-side resolvers",
        "Database level",
        "Network level"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL` caching is typically implemented at the client-side and CDN level because `GraphQL` uses a single endpoint with POST requests, making HTTP-level caching challenging. Client libraries like Apollo Client provide sophisticated caching mechanisms, and CDNs can cache based on `query` structure and variables.",
      "industryContext": "Caching strategy is critical for GraphQL performance, especially since the flexibility of GraphQL queries makes traditional HTTP caching less effective than in REST APIs.",
      "tags": [
        "Performance",
        "intermediate",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 90,
      "correctAnswer": 0
    },
    {
      "id": 32,
      "question": "What is the purpose of `GraphQL`'s 'selection set'?",
      "topic": "Query Structure",
      "difficulty": "Intermediate",
      "choices": [
        "To specify which fields to include in the `query` response",
        "To define the order of field execution",
        "To validate `query` syntax",
        "To optimize database queries"
      ],
      "correctIndex": 0,
      "explanation": "The selection set in `GraphQL` specifies which fields to include in the `query` response. It's the set of fields enclosed in curly braces {} that follows a field name, allowing clients to request exactly the data they need.",
      "industryContext": "Selection sets are the core mechanism that enables GraphQL's key advantage of preventing over-fetching and under-fetching of data compared to traditional REST APIs.",
      "tags": [
        "Query Structure",
        "intermediate",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 60,
      "correctAnswer": 0
    },
    {
      "id": 33,
      "question": "Which company originally developed `GraphQL`?",
      "topic": "History",
      "difficulty": "Beginner",
      "choices": [
        "Facebook",
        "Google",
        "Microsoft",
        "Amazon"
      ],
      "correctIndex": 0,
      "explanation": "`GraphQL` was originally developed by Facebook (now Meta) in 2012 to address the challenges of fetching data for their mobile applications. It was open-sourced in 2015 and has since become a widely adopted standard for API development.",
      "industryContext": "Understanding GraphQL's origins at Facebook provides context for its design philosophy focused on mobile-first development and efficient data fetching in bandwidth-constrained environments.",
      "tags": [
        "History",
        "beginner",
        "graphql"
      ],
      "questionType": "multiple-choice",
      "estimatedTime": 45,
      "correctAnswer": 0
    },
    {
      "id": 3,
      "topic": "GraphQL Fundamentals",
      "type": "open-ended",
      "question": "Explain the main advantages of `GraphQL` over REST APIs.",
      "choices": null,
      "explanation": "`GraphQL` offers several advantages over REST: 1) Clients can request exactly the data they need, avoiding over-fetching and under-fetching, 2) Single endpoint for all operations instead of multiple URLs, 3) Strong type system provides better tooling and validation, 4) Real-time subscriptions built-in, 5) Introspection allows for automatic documentation and tooling.",
      "difficulty": "Beginner"
    },
    {
      "id": 9,
      "topic": "Performance Optimization",
      "type": "open-ended",
      "question": "What is the N+1 `query` problem in `GraphQL` and how can it be solved?",
      "choices": null,
      "explanation": "The N+1 `query` problem occurs when fetching a list of N items requires N+1 database queries (1 for the list + N queries for related data). It can be solved using DataLoader, which batches and caches database requests, or by using more efficient database queries with joins.",
      "difficulty": "Beginner"
    },
    {
      "id": 10,
      "topic": "Performance Optimization",
      "type": "multiple-choice",
      "question": "What is DataLoader used for in `GraphQL`?",
      "choices": [
        "Batching and caching data requests to solve N+1 queries",
        "Loading `GraphQL` `schema` definitions",
        "Validating incoming queries",
        "Handling user authentication"
      ],
      "correctAnswer": 0,
      "explanation": "DataLoader is a utility for batching and caching data fetching operations. It helps solve the N+1 `query` problem by collecting individual loads and batching them into single requests.",
      "correctIndex": 0,
      "difficulty": "Beginner"
    },
    {
      "id": 11,
      "topic": "Schema Design",
      "type": "multiple-choice",
      "question": "What is a `GraphQL` interface?",
      "choices": [
        "A way to define common fields that multiple types can implement",
        "A method for connecting to external APIs",
        "A type of scalar value",
        "A security mechanism"
      ],
      "correctAnswer": 0,
      "explanation": "A `GraphQL` interface defines a set of common fields that multiple object types can implement, similar to interfaces in programming languages. It allows for polymorphic queries and better `schema` organization.",
      "correctIndex": 0,
      "difficulty": "Beginner"
    },
    {
      "id": 12,
      "topic": "Schema Design",
      "type": "open-ended",
      "question": "When would you use a union type in `GraphQL`?",
      "choices": null,
      "explanation": "Union types are used when a field can return one of several different types. Common use cases include search results that can return different types of objects, polymorphic relationships, or error handling where a field might return either a success object or an error object.",
      "difficulty": "Beginner"
    },
    {
      "id": 13,
      "topic": "Performance Optimization",
      "type": "multiple-choice",
      "question": "What is `query` depth limiting in `GraphQL`?",
      "choices": [
        "A security measure to prevent deeply nested queries that could cause performance issues",
        "A way to limit the number of fields in a `query`",
        "A method for caching `query` results",
        "A technique for optimizing `resolver` performance"
      ],
      "correctAnswer": 0,
      "explanation": "Query depth limiting is a security measure that prevents clients from sending deeply nested queries that could consume excessive server resources. It sets a maximum depth for `query` nesting.",
      "correctIndex": 0,
      "difficulty": "Beginner"
    },
    {
      "id": 14,
      "topic": "Testing and Tools",
      "type": "multiple-choice",
      "question": "What is `GraphQL` Playground?",
      "choices": [
        "An in-browser IDE for exploring `GraphQL` APIs",
        "A testing framework for `GraphQL`",
        "A `GraphQL` `schema` validation tool",
        "A performance monitoring tool"
      ],
      "correctAnswer": 0,
      "explanation": "`GraphQL` Playground is an in-browser IDE for exploring `GraphQL` APIs. It provides features like `query` execution, `schema` exploration, documentation browsing, and `query` history.",
      "correctIndex": 0,
      "difficulty": "Beginner"
    },
    {
      "id": 15,
      "topic": "Testing and Tools",
      "type": "open-ended",
      "question": "How would you test a `GraphQL` API effectively?",
      "choices": null,
      "explanation": "`GraphQL` APIs should be tested at multiple levels: 1) Unit tests for individual resolvers, 2) Integration tests for complete queries/mutations, 3) Schema validation tests, 4) Performance tests for complex queries, 5) Security tests for rate limiting and authentication. Tools like Jest, Apollo Server Testing, and `GraphQL` testing utilities help automate these tests.",
      "difficulty": "Beginner"
    },
    {
      "id": 16,
      "topic": "Production Deployment",
      "type": "multiple-choice",
      "question": "Which of the following is a security best practice for `GraphQL` APIs?",
      "choices": [
        "All of the above",
        "Implement `query` depth limiting",
        "Use authentication and authorization",
        "Disable introspection in production"
      ],
      "correctAnswer": 0,
      "explanation": "All mentioned practices are important for `GraphQL` security: `query` depth limiting prevents expensive queries, authentication/authorization controls access, and disabling introspection in production prevents `schema` discovery by unauthorized users.",
      "correctIndex": 0,
      "difficulty": "Beginner"
    },
    {
      "id": 17,
      "topic": "Production Deployment",
      "type": "open-ended",
      "question": "What considerations should you make when deploying `GraphQL` to production?",
      "choices": null,
      "explanation": "Production `GraphQL` deployment requires: 1) Security measures (authentication, authorization, rate limiting, `query` complexity analysis), 2) Performance optimization (DataLoader, caching, `query` analysis), 3) Monitoring and logging, 4) Error handling and reporting, 5) Schema versioning strategy, 6) Disabling development features like introspection and playground.",
      "difficulty": "Beginner"
    },
    {
      "id": 18,
      "topic": "GraphQL Operations",
      "type": "multiple-choice",
      "question": "What are fragments in `GraphQL`?",
      "choices": [
        "Reusable units of `query` logic that can be included in multiple queries",
        "Broken `query` parts that cause errors",
        "A type of `mutation` operation",
        "Database transaction components"
      ],
      "correctAnswer": 0,
      "explanation": "Fragments are reusable units of `query` logic that allow you to define a set of fields once and include them in multiple queries. They help reduce duplication and improve `query` maintainability.",
      "correctIndex": 0,
      "difficulty": "Beginner"
    },
    {
      "id": 19,
      "topic": "Schema Design",
      "type": "multiple-choice",
      "question": "What is the purpose of input types in `GraphQL`?",
      "choices": [
        "To define the structure of data passed as arguments to mutations and queries",
        "To handle user authentication",
        "To define database schemas",
        "To validate `query` syntax"
      ],
      "correctAnswer": 0,
      "explanation": "Input types define the structure of complex data that can be passed as arguments to `GraphQL` mutations and queries. They ensure type safety for input validation and provide clear documentation for required data structures.",
      "correctIndex": 0,
      "difficulty": "Beginner"
    },
    {
      "id": 20,
      "topic": "Performance Optimization",
      "type": "open-ended",
      "question": "Explain `query` complexity analysis in `GraphQL` and why it's important.",
      "choices": null,
      "explanation": "Query complexity analysis assigns complexity scores to `GraphQL` operations based on the fields requested and their relationships. It's important because it helps prevent expensive queries from overwhelming the server, provides a standardized way to rate-limit based on resource usage rather than just request count, and helps identify potentially problematic queries before they impact performance.",
      "difficulty": "Beginner"
    }
  ],
  "metadata": {
    "migrated": true,
    "originalQuestionCount": 15,
    "migrationDate": "2025-10-01T06:41:13.486Z",
    "lastUpdated": "2025-10-02T10:00:00.000Z",
    "version": "1.1.0"
  }
}