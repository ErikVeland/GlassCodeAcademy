{
  "id": "node-fundamentals-lesson-13",
  "moduleSlug": "node-fundamentals",
  "title": "Microservices Architecture Patterns",
  "order": 13,
  "objectives": [
    "Design scalable microservices architectures with proper service boundaries",
    "Implement service communication patterns including REST APIs and message queues",
    "Create resilient microservices with circuit breakers and retry mechanisms",
    "Build distributed tracing and monitoring systems for microservices"
  ],
  "intro": "Microservices architecture patterns provide a foundational approach to building scalable, maintainable applications by decomposing monolithic systems into smaller, independently deployable services. This comprehensive lesson explores advanced architectural patterns that enable teams to develop, deploy, and scale services independently while maintaining system coherence and reliability.\n\nYou'll learn to identify appropriate service boundaries based on business domains and data models, implementing communication patterns that balance consistency requirements with system performance. We'll explore both synchronous and asynchronous communication mechanisms, including REST APIs, message queues, and event-driven architectures that enable loose coupling between services.\n\nResilience patterns are crucial for maintaining system stability when individual services fail. We'll cover circuit breakers, bulkheads, and retry mechanisms that prevent cascading failures and maintain graceful degradation when parts of the system are unavailable. You'll also learn to implement health checks, load balancing, and service discovery mechanisms that enable robust service orchestration.\n\nMonitoring and observability are essential for understanding system behavior in distributed environments. We'll explore distributed tracing, centralized logging, and metrics collection that provide visibility into service interactions and performance bottlenecks. By mastering microservices architecture patterns, you'll be able to design systems that scale effectively, maintain high availability, and support rapid innovation.",
  "code": {
    "example": "// Microservices Architecture Implementation\n\n// Service Registry and Discovery\nconst express = require('express');\nconst axios = require('axios');\nconst Redis = require('redis');\n\n// Service Registry Client\nclass ServiceRegistry {\n  constructor(redisUrl) {\n    this.redis = Redis.createClient({ url: redisUrl });\n    this.redis.connect();\n  }\n  \n  async registerService(serviceName, host, port, healthCheckPath = '/health') {\n    const serviceInfo = {\n      name: serviceName,\n      host,\n      port,\n      healthCheckPath,\n      registeredAt: new Date().toISOString(),\n      status: 'healthy'\n    };\n    \n    const key = `service:${serviceName}:${host}:${port}`;\n    await this.redis.set(key, JSON.stringify(serviceInfo), {\n      EX: 300 // Expire after 5 minutes\n    });\n    \n    // Add to service list\n    await this.redis.sadd(`services:${serviceName}`, key);\n  }\n  \n  async discoverService(serviceName) {\n    const serviceKeys = await this.redis.smembers(`services:${serviceName}`);\n    \n    for (const key of serviceKeys) {\n      const serviceInfo = JSON.parse(await this.redis.get(key));\n      \n      // Check if service is healthy\n      try {\n        const healthUrl = `http://${serviceInfo.host}:${serviceInfo.port}${serviceInfo.healthCheckPath}`;\n        await axios.get(healthUrl, { timeout: 2000 });\n        \n        return {\n          host: serviceInfo.host,\n          port: serviceInfo.port\n        };\n      } catch (error) {\n        // Mark service as unhealthy\n        serviceInfo.status = 'unhealthy';\n        await this.redis.set(key, JSON.stringify(serviceInfo));\n      }\n    }\n    \n    throw new Error(`No healthy instances of ${serviceName} found`);\n  }\n  \n  async deregisterService(serviceName, host, port) {\n    const key = `service:${serviceName}:${host}:${port}`;\n    await this.redis.del(key);\n    await this.redis.srem(`services:${serviceName}`, key);\n  }\n}\n\n// API Gateway Implementation\nconst express = require('express');\nconst { createProxyMiddleware } = require('http-proxy-middleware');\n\nconst app = express();\nconst serviceRegistry = new ServiceRegistry('redis://localhost:6379');\n\n// Circuit Breaker Pattern\nclass CircuitBreaker {\n  constructor(options = {}) {\n    this.failureThreshold = options.failureThreshold || 5;\n    this.timeout = options.timeout || 60000; // 1 minute\n    this.resetTimeout = options.resetTimeout || 30000; // 30 seconds\n    \n    this.failureCount = 0;\n    this.lastFailureTime = null;\n    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN\n  }\n  \n  async execute(asyncFunction) {\n    if (this.state === 'OPEN') {\n      if (Date.now() - this.lastFailureTime > this.timeout) {\n        this.state = 'HALF_OPEN';\n      } else {\n        throw new Error('Circuit breaker is OPEN');\n      }\n    }\n    \n    try {\n      const result = await asyncFunction();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure();\n      throw error;\n    }\n  }\n  \n  onSuccess() {\n    this.failureCount = 0;\n    this.state = 'CLOSED';\n  }\n  \n  onFailure() {\n    this.failureCount++;\n    this.lastFailureTime = Date.now();\n    \n    if (this.failureCount >= this.failureThreshold) {\n      this.state = 'OPEN';\n    }\n  }\n  \n  getState() {\n    return this.state;\n  }\n}\n\n// Service Communication with Circuit Breaker\nconst userServiceCircuitBreaker = new CircuitBreaker({\n  failureThreshold: 3,\n  timeout: 60000\n});\n\napp.get('/api/users/:id', async (req, res) => {\n  try {\n    // Discover user service\n    const userService = await serviceRegistry.discoverService('user-service');\n    \n    // Call user service with circuit breaker\n    const response = await userServiceCircuitBreaker.execute(async () => {\n      return await axios.get(`http://${userService.host}:${userService.port}/users/${req.params.id}`);\n    });\n    \n    res.json(response.data);\n  } catch (error) {\n    console.error('User service error:', error.message);\n    res.status(503).json({ error: 'User service unavailable' });\n  }\n});\n\n// Event-Driven Communication with Message Queue\nconst amqp = require('amqplib');\n\nclass EventPublisher {\n  constructor(rabbitMQUrl) {\n    this.rabbitMQUrl = rabbitMQUrl;\n    this.connection = null;\n    this.channel = null;\n  }\n  \n  async connect() {\n    this.connection = await amqp.connect(this.rabbitMQUrl);\n    this.channel = await this.connection.createChannel();\n  }\n  \n  async publish(eventType, eventData) {\n    if (!this.channel) {\n      await this.connect();\n    }\n    \n    const exchange = 'service_events';\n    await this.channel.assertExchange(exchange, 'topic', { durable: true });\n    \n    const message = {\n      type: eventType,\n      data: eventData,\n      timestamp: new Date().toISOString()\n    };\n    \n    this.channel.publish(\n      exchange,\n      eventType,\n      Buffer.from(JSON.stringify(message))\n    );\n  }\n  \n  async close() {\n    if (this.channel) await this.channel.close();\n    if (this.connection) await this.connection.close();\n  }\n}\n\n// Publish user created event\nconst eventPublisher = new EventPublisher('amqp://localhost');\n\napp.post('/api/users', async (req, res) => {\n  try {\n    // Create user logic here\n    const user = {\n      id: Date.now(),\n      ...req.body,\n      createdAt: new Date().toISOString()\n    };\n    \n    // Save user to database\n    \n    // Publish event\n    await eventPublisher.publish('user.created', user);\n    \n    res.status(201).json(user);\n  } catch (error) {\n    console.error('Error creating user:', error);\n    res.status(500).json({ error: 'Failed to create user' });\n  }\n});\n\n// Health Check Endpoint\napp.get('/health', (req, res) => {\n  res.json({\n    status: 'healthy',\n    timestamp: new Date().toISOString(),\n    service: 'api-gateway'\n  });\n});\n\n// Distributed Tracing Middleware\nconst tracing = require('@opentelemetry/api');\n\napp.use((req, res, next) => {\n  const tracer = tracing.trace.getTracer('api-gateway');\n  const span = tracer.startSpan(`HTTP ${req.method} ${req.path}`);\n  \n  // Add request context to span\n  span.setAttribute('http.method', req.method);\n  span.setAttribute('http.url', req.url);\n  span.setAttribute('http.user_agent', req.get('user-agent') || '');\n  \n  // Add span to request context\n  req.span = span;\n  \n  // End span when response is finished\n  res.on('finish', () => {\n    span.setAttribute('http.status_code', res.statusCode);\n    span.end();\n  });\n  \n  next();\n});\n\napp.listen(3000, () => {\n  console.log('API Gateway listening on port 3000');\n});\n\n// User Service Implementation\nconst userServiceApp = express();\nuserServiceApp.use(express.json());\n\n// Register with service registry on startup\nconst serviceRegistryClient = new ServiceRegistry('redis://localhost:6379');\n\nuserServiceApp.listen(3001, async () => {\n  console.log('User Service listening on port 3001');\n  \n  try {\n    await serviceRegistryClient.registerService('user-service', 'localhost', 3001);\n    console.log('User Service registered with service registry');\n  } catch (error) {\n    console.error('Failed to register service:', error);\n  }\n});\n\n// Event Consumer for Order Service\nclass EventConsumer {\n  constructor(rabbitMQUrl) {\n    this.rabbitMQUrl = rabbitMQUrl;\n  }\n  \n  async consume(eventType, handler) {\n    const connection = await amqp.connect(this.rabbitMQUrl);\n    const channel = await connection.createChannel();\n    \n    const exchange = 'service_events';\n    await channel.assertExchange(exchange, 'topic', { durable: true });\n    \n    const queue = await channel.assertQueue('', { exclusive: true });\n    await channel.bindQueue(queue.queue, exchange, eventType);\n    \n    channel.consume(queue.queue, async (msg) => {\n      if (msg !== null) {\n        try {\n          const event = JSON.parse(msg.content.toString());\n          await handler(event);\n          channel.ack(msg);\n        } catch (error) {\n          console.error('Error processing event:', error);\n          channel.nack(msg);\n        }\n      }\n    });\n  }\n}\n\n// Order Service consuming user events\nconst eventConsumer = new EventConsumer('amqp://localhost');\n\n// Handle user created events\neventConsumer.consume('user.created', async (event) => {\n  console.log('User created event received:', event.data);\n  \n  // Create default order for new user\n  // Save to order database\n  \n  console.log(`Created default order for user ${event.data.id}`);\n});",
    "explanation": "This example demonstrates key microservices architecture patterns including:\n\n1. Service registry and discovery for dynamic service location\n2. Circuit breaker pattern for resilient service communication\n3. Event-driven communication using message queues\n4. API gateway for centralized request routing\n5. Health checks for service monitoring\n6. Distributed tracing for observability\n\nThese patterns work together to create a robust, scalable microservices architecture that can handle service failures gracefully while maintaining system performance and reliability.",
    "language": "javascript"
  },
  "pitfalls": [
    {
      "mistake": "Creating services with poorly defined boundaries that lead to tight coupling",
      "solution": "Define services based on business capabilities and data ownership, ensuring each service has a single responsibility and clear interface",
      "severity": "high"
    },
    {
      "mistake": "Not implementing proper error handling and resilience patterns",
      "solution": "Use circuit breakers, retries, and timeouts to prevent cascading failures, and implement graceful degradation when services are unavailable",
      "severity": "high"
    },
    {
      "mistake": "Neglecting distributed system monitoring and debugging challenges",
      "solution": "Implement distributed tracing, centralized logging, and comprehensive metrics collection to maintain visibility into system behavior",
      "severity": "medium"
    }
  ],
  "exercises": [
    {
      "title": "Implement a Microservices Architecture with Resilience Patterns",
      "description": "Create a complete microservices system with service discovery, circuit breakers, event-driven communication, and monitoring capabilities",
      "checkpoints": [
        "Implement service registry and discovery mechanism",
        "Create circuit breaker for service communication",
        "Build event-driven communication with message queues",
        "Add health checks and distributed tracing",
        "Implement API gateway with request routing"
      ]
    }
  ],
  "next": ["node-fundamentals-lesson-14"],
  "estimatedMinutes": 60,
  "difficulty": "Advanced",
  "tags": [
    "Microservices",
    "Architecture",
    "Service Discovery",
    "Circuit Breaker",
    "Event-Driven",
    "Node.js"
  ],
  "lastUpdated": "2025-10-03T00:00:00.000Z",
  "version": "1.0.0"
}